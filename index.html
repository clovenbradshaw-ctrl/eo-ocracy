<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holonic Org Knowledge Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #F5F2ED;
            color: #3D2E1F;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        /* Workspace Selector Styles */
        .workspace-selector {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .workspace-dropdown-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            padding: 0.4rem 0.75rem;
            color: white;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            max-width: 200px;
        }

        .workspace-dropdown-toggle:hover {
            background: rgba(255,255,255,0.25);
            border-color: rgba(255,255,255,0.5);
        }

        .workspace-dropdown-toggle .workspace-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .workspace-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            min-width: 250px;
            max-width: 300px;
            z-index: 1000;
            display: none;
            overflow: hidden;
        }

        .workspace-dropdown.open {
            display: block;
        }

        .workspace-dropdown-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #E5DDD1;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .workspace-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .workspace-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.15s;
            color: #3D2E1F;
        }

        .workspace-item:hover {
            background: #FAF7F5;
        }

        .workspace-item.active {
            background: #F5EFE6;
        }

        .workspace-item-name {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            overflow: hidden;
        }

        .workspace-item-name span {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .workspace-item-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .workspace-item:hover .workspace-item-actions {
            opacity: 1;
        }

        .workspace-action-btn {
            background: none;
            border: none;
            padding: 0.25rem;
            cursor: pointer;
            color: #8B6F47;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .workspace-action-btn:hover {
            background: rgba(0,0,0,0.05);
            color: #C88F4A;
        }

        .workspace-action-btn.delete:hover {
            color: #d32f2f;
        }

        .workspace-dropdown-footer {
            border-top: 1px solid #E5DDD1;
            padding: 0.5rem;
        }

        .workspace-new-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.75rem 1rem;
            background: none;
            border: none;
            cursor: pointer;
            color: #C88F4A;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .workspace-new-btn:hover {
            background: #FAF7F5;
        }

        /* Workspace Modal Styles */
        .workspace-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .workspace-modal-overlay.open {
            display: flex;
        }

        .workspace-modal {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .workspace-modal h3 {
            margin-bottom: 1rem;
            color: #3D2E1F;
            font-size: 1.125rem;
        }

        .workspace-modal-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            font-size: 1rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s;
        }

        .workspace-modal-input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .workspace-modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .workspace-modal-btn {
            padding: 0.6rem 1.25rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .workspace-modal-btn.cancel {
            background: #f5f5f5;
            border: 1px solid #E5DDD1;
            color: #6B5642;
        }

        .workspace-modal-btn.cancel:hover {
            background: #eee;
        }

        .workspace-modal-btn.primary {
            background: #D4A54A;
            border: none;
            color: white;
        }

        .workspace-modal-btn.primary:hover {
            background: #E5B555;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .view-toggle {
            display: flex;
            gap: 0.5rem;
            background: rgba(255,255,255,0.2);
            padding: 0.25rem;
            border-radius: 6px;
        }

        .view-toggle-btn {
            background: transparent;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: background 0.2s;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .view-toggle-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .view-toggle-btn.active {
            background: white;
            color: #C88F4A;
            text-shadow: none;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            height: calc(100vh - 65px);
        }

        .panel {
            background: white;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .panel-left {
            border-right: 1px solid #E5DDD1;
        }

        .panel-right {
            border-left: 1px solid #E5DDD1;
        }

        /* Collapsible Sidebar Styles */
        .panel-left,
        .panel-right {
            position: relative;
            transition: width 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
        }

        .panel-collapse-btn {
            position: absolute;
            top: 12px;
            width: 28px;
            height: 28px;
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8B6F47;
            transition: all 0.2s;
            z-index: 10;
        }

        .panel-collapse-btn:hover {
            background: #F5EFE6;
            color: #C88F4A;
            border-color: #C88F4A;
        }

        .panel-left .panel-collapse-btn {
            right: 12px;
        }

        .panel-right .panel-collapse-btn {
            left: 12px;
        }

        .panel-collapse-btn i {
            font-size: 1rem;
            transition: transform 0.3s ease;
        }

        /* Collapsed state for panels */
        .panel-left.collapsed,
        .panel-right.collapsed {
            width: 48px !important;
            min-width: 48px;
            padding: 1rem 0.5rem;
            overflow: hidden;
        }

        .panel-left.collapsed .panel-collapse-btn,
        .panel-right.collapsed .panel-collapse-btn {
            right: 50%;
            left: 50%;
            transform: translateX(-50%);
        }

        .panel-left.collapsed .panel-collapse-btn i {
            transform: rotate(180deg);
        }

        .panel-right.collapsed .panel-collapse-btn i {
            transform: rotate(180deg);
        }

        .panel-left.collapsed > *:not(.panel-collapse-btn),
        .panel-right.collapsed > *:not(.panel-collapse-btn) {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* Container grid adjustments for collapsed panels */
        .container {
            transition: grid-template-columns 0.3s ease;
        }

        .container.left-collapsed {
            grid-template-columns: 48px 1fr 320px;
        }

        .container.right-collapsed {
            grid-template-columns: 300px 1fr 48px;
        }

        .container.left-collapsed.right-collapsed {
            grid-template-columns: 48px 1fr 48px;
        }

        .panel-title {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-bottom: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.7;
        }

        .btn {
            background: #D4A54A;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            transition: background 0.2s;
            display: inline-block;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .btn:hover {
            background: #E5B555;
        }

        .btn-small {
            padding: 0.35rem 0.75rem;
            font-size: 0.75rem;
        }

        .btn-secondary {
            background: #8B6F47;
        }

        .btn-secondary:hover {
            background: #6B5642;
        }

        .btn-outline {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.9);
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn-outline:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
            color: white;
        }

        .entity-type-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .entity-type-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #E5DDD1;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .entity-type-btn:hover {
            border-color: #C88F4A;
        }

        .filter-pill {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 0.75rem;
            border: 2px solid #E5DDD1;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            color: #8B6F47;
            transition: all 0.2s;
            position: relative;
        }

        .filter-pill input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
        }

        .filter-pill:hover {
            border-color: #C88F4A;
            background: #FAF7F5;
        }

        .filter-pill:has(input:checked) {
            border-color: #C88F4A;
            background: #C88F4A;
            color: white;
        }

        .filter-pill span {
            pointer-events: none;
        }

        .entity-type-btn.active {
            background: #C88F4A;
            color: white;
            border-color: #C88F4A;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #6B5642;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 0.625rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .entity-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .entity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.625rem;
            background: transparent;
            border-radius: 8px;
            border: none;
            transition: all 0.15s ease;
        }

        .entity-item:hover {
            background: rgba(139, 111, 71, 0.06);
        }

        .entity-item .btn-icon {
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .entity-item:hover .btn-icon {
            opacity: 0.6;
        }

        .entity-item:hover .btn-icon:hover {
            opacity: 1;
        }

        .entity-item.team {
            color: #5A4736;
        }

        .entity-item.role {
            color: #6B5642;
        }

        .entity-item.person {
            color: #5A4736;
        }

        .entity-item.object {
            color: #8B6F47;
        }

        .entity-name {
            font-size: 0.875rem;
            color: inherit;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .entity-type {
            font-size: 0.7rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
        }

        .entity-section-header {
            font-size: 0.7rem;
            color: #8B6F47;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.375rem;
            padding: 0.25rem 0.625rem;
            opacity: 0.7;
        }

        .entity-section {
            margin-top: 1.25rem;
        }

        .btn-icon {
            background: none;
            border: none;
            color: #8B6F47;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 6px;
            transition: all 0.15s ease;
            font-size: 0.875rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            opacity: 0.6;
        }

        .btn-icon:hover {
            background: rgba(139, 111, 71, 0.12);
            color: #5A4736;
            opacity: 1;
        }

        .btn-icon.add {
            background: rgba(200, 143, 74, 0.15);
            color: #C88F4A;
            opacity: 0.8;
        }

        .btn-icon.add:hover {
            background: #C88F4A;
            color: white;
            opacity: 1;
        }

        .tree-node-item.unit .btn-icon {
            color: rgba(255, 255, 255, 0.8);
            opacity: 0.7;
        }

        .tree-node-item.unit .btn-icon:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            opacity: 1;
        }

        .tree-node-item.unit .btn-icon.add {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .tree-node-item.unit .btn-icon.add:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #graph {
            width: 100%;
            height: calc(100% - 48px);
            background: #FAFAF8;
            background-image:
                radial-gradient(circle, #E5DDD1 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .graph-toolbar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: white;
            border-bottom: 1px solid #E5DDD1;
            height: 48px;
            box-sizing: border-box;
        }

        .graph-tool-btn {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.5rem 0.75rem;
            border: 1px solid #E5DDD1;
            background: white;
            color: #6B5642;
            font-size: 0.8rem;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .graph-tool-btn:hover {
            background: #FAF7F5;
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .graph-tool-btn.small {
            padding: 0.375rem 0.5rem;
        }

        .graph-zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            padding-left: 1rem;
            border-left: 1px solid #E5DDD1;
        }

        .graph-zoom-controls span {
            font-size: 0.8rem;
            color: #8B6F47;
            min-width: 40px;
            text-align: center;
        }

        /* n8n-style node styling */
        .graph-node {
            cursor: grab;
        }

        .graph-node:active {
            cursor: grabbing;
        }

        .graph-node-body {
            fill: white;
            stroke: #E5DDD1;
            stroke-width: 2;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.08));
            transition: stroke 0.2s, filter 0.2s;
        }

        .graph-node:hover .graph-node-body {
            stroke: #C88F4A;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.12));
        }

        .graph-node.selected .graph-node-body {
            stroke: #C88F4A;
            stroke-width: 3;
        }

        .graph-node-accent {
            pointer-events: none;
        }

        .graph-node-icon {
            pointer-events: none;
        }

        .graph-node-label {
            font-size: 12px;
            font-weight: 500;
            fill: #3D2E1F;
            pointer-events: none;
        }

        .graph-node-type {
            font-size: 10px;
            fill: #8B6F47;
            text-transform: uppercase;
            pointer-events: none;
        }

        .graph-port {
            fill: white;
            stroke: #C88F4A;
            stroke-width: 2;
            cursor: crosshair;
            transition: fill 0.2s, r 0.2s;
        }

        .graph-port:hover {
            fill: #C88F4A;
            r: 7;
        }

        .graph-port.active {
            fill: #C88F4A;
        }

        /* Edge styling */
        .graph-edge {
            fill: none;
            stroke-width: 2;
            cursor: pointer;
            transition: stroke-width 0.2s;
        }

        .graph-edge:hover {
            stroke-width: 4;
        }

        .graph-edge-hitbox {
            fill: none;
            stroke: transparent;
            stroke-width: 20;
            cursor: pointer;
        }

        .graph-edge-label {
            font-size: 10px;
            fill: #6B5642;
            pointer-events: none;
        }

        .graph-edge-label-bg {
            fill: white;
            opacity: 0.9;
        }

        /* Drag preview line */
        .graph-drag-line {
            fill: none;
            stroke: #C88F4A;
            stroke-width: 2;
            stroke-dasharray: 8, 4;
            pointer-events: none;
        }

        .layer-bg {
            pointer-events: none;
        }

        .layer-label {
            pointer-events: none;
            user-select: none;
        }

        .graph-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 0.75rem;
            max-width: 200px;
        }

        .legend-title {
            font-weight: 600;
            color: #6B5642;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.25rem 0;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            background: #8B6F47;
        }

        .legend-line.bold {
            height: 3px;
        }

        .legend-line.dashed {
            background: repeating-linear-gradient(
                to right,
                #8B6F47 0,
                #8B6F47 4px,
                transparent 4px,
                transparent 8px
            );
        }

        .legend-line.dotted {
            background: repeating-linear-gradient(
                to right,
                #8B6F47 0,
                #8B6F47 2px,
                transparent 2px,
                transparent 6px
            );
        }

        .triple-form {
            background: #FAF7F5;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .triple-preview {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
            background: white;
            border-radius: 6px;
            margin-top: 1rem;
            border-left: 3px solid #C88F4A;
        }

        .triple-part {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .triple-label {
            font-weight: 600;
            color: #8B6F47;
            min-width: 80px;
        }

        .triple-value {
            color: #3D2E1F;
        }

        .predicate-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .predicate-btn {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid #E5DDD1;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.2s;
            text-align: center;
        }

        .predicate-btn:hover {
            border-color: #C88F4A;
        }

        .predicate-btn.active {
            border-color: #C88F4A;
            background: #FFF9F0;
            color: #C88F4A;
        }

        /* EO Operator specific colors */
        .predicate-btn.NUL.active { border-color: #6B5642; background: #F5F2ED; color: #6B5642; }
        .predicate-btn.DES.active { border-color: #C88F4A; background: #FFF9F0; color: #C88F4A; }
        .predicate-btn.INS.active { border-color: #8B6F47; background: #F5F0E8; color: #8B6F47; }
        .predicate-btn.SEG.active { border-color: #A89984; background: #FAFAF8; color: #A89984; }
        .predicate-btn.CON.active { border-color: #7B95A3; background: #F0F4F7; color: #7B95A3; }
        .predicate-btn.ALT.active { border-color: #B87B5B; background: #FFF5EB; color: #B87B5B; }
        .predicate-btn.SYN.active { border-color: #D4A574; background: #FFFAF3; color: #D4A574; }
        .predicate-btn.SUP.active { border-color: #9B6F47; background: #F7F3EF; color: #9B6F47; }
        .predicate-btn.REC.active { border-color: #C8997F; background: #FFF8F4; color: #C8997F; }

        .relationship-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .relationship-item {
            padding: 0.75rem;
            background: #FAF7F5;
            border-radius: 6px;
            border-left: 3px solid;
            font-size: 0.85rem;
        }

        .relationship-item.NUL { border-left-color: #6B5642; }
        .relationship-item.DES { border-left-color: #C88F4A; }
        .relationship-item.INS { border-left-color: #8B6F47; }
        .relationship-item.SEG { border-left-color: #A89984; }
        .relationship-item.CON { border-left-color: #7B95A3; }
        .relationship-item.ALT { border-left-color: #B87B5B; }
        .relationship-item.SYN { border-left-color: #D4A574; }
        .relationship-item.SUP { border-left-color: #9B6F47; }
        .relationship-item.REC { border-left-color: #C8997F; }

        .relationship-text {
            color: #3D2E1F;
            margin-bottom: 0.25rem;
        }

        .relationship-meta {
            font-size: 0.75rem;
            color: #8B6F47;
        }

        .graph-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            background: white;
            padding: 0.5rem;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .tooltip {
            position: absolute;
            background: rgba(61, 46, 31, 0.95);
            color: white;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.875rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
            z-index: 1000;
        }

        .section {
            margin-bottom: 2rem;
        }

        .divider {
            height: 1px;
            background: #E5DDD1;
            margin: 1.5rem 0;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-dialog {
            background: white;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .modal-header-section {
            padding: 2rem;
            border-bottom: 2px solid #F5E6D3;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
        }

        .modal-title-text {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-section {
            margin-bottom: 2rem;
        }

        .modal-section-title {
            font-size: 1rem;
            color: #8B6F47;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .related-entity {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: #FAF7F5;
            border-radius: 6px;
            margin: 0.25rem;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid #C88F4A;
        }

        .related-entity:hover {
            background: #F5E6D3;
        }

        .card-view {
            display: none;
            padding: 2rem;
            overflow-y: auto;
            max-height: 100vh;
            background: white;
        }

        .card-view.active {
            display: block;
        }

        .card-row {
            margin-bottom: 2.5rem;
        }

        .card-row-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #E5DDD1;
        }

        .card-row-title {
            font-size: 1.25rem;
            color: #3D2E1F;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-row-count {
            font-size: 0.85rem;
            color: #6B5642;
            font-weight: 500;
            background: #F5F0E8;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
        }

        .grouped-by-label {
            font-size: 0.85rem;
            color: #8B7355;
            font-weight: 400;
            font-style: italic;
        }

        /* Entity Group Styles (for grouped view) */
        .entity-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #FDFCFA;
            border-radius: 12px;
            border: 1px solid #E5DDD1;
        }

        .entity-group.ungrouped {
            background: #F8F5F0;
            border-style: dashed;
        }

        .entity-group-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #E5DDD1;
        }

        .entity-group-icon {
            font-size: 1.1rem;
        }

        .entity-group-name {
            font-size: 1rem;
            font-weight: 600;
            color: #3D2E1F;
        }

        .entity-group-count {
            font-size: 0.8rem;
            color: #6B5642;
            background: #EAE4DA;
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            margin-left: auto;
        }

        .grouped-section {
            margin-bottom: 2.5rem;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.25rem;
        }

        .entity-card {
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 12px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 140px;
        }

        .entity-card:hover {
            border-color: #C88F4A;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.2);
        }

        .entity-card.unit { background: linear-gradient(135deg, #FFF9F0 0%, white 100%); }
        .entity-card.team { background: linear-gradient(135deg, #FAF7F5 0%, white 100%); }
        .entity-card.role { background: linear-gradient(135deg, #F5F3F0 0%, white 100%); }
        .entity-card.person { background: linear-gradient(135deg, #F0EDE8 0%, white 100%); }
        .entity-card.object { background: linear-gradient(135deg, #FFFBF5 0%, white 100%); }
        .entity-card.activity { background: linear-gradient(135deg, #F5F8FA 0%, white 100%); }

        /* Nested/Hierarchical Cards Styles */
        .hierarchy-card-container {
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 16px;
            padding: 1.25rem;
            margin-bottom: 1.25rem;
            transition: all 0.2s;
        }

        .hierarchy-card-container:hover {
            border-color: #C88F4A;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.15);
        }

        .hierarchy-card-container.unit {
            background: linear-gradient(135deg, #FFF9F0 0%, #FFFBF7 100%);
            border-color: #D4A574;
        }

        .hierarchy-card-container.team {
            background: linear-gradient(135deg, #FAF7F5 0%, #FEFCFA 100%);
            border-color: #E5DDD1;
        }

        /* Nested unit cards within parent units */
        .hierarchy-card-container.nested-unit-card {
            background: linear-gradient(135deg, #FDF8F2 0%, #FFFBF7 100%);
            border-color: #C9A77A;
            margin-bottom: 0;
            padding: 1rem;
        }

        .hierarchy-card-container.nested-unit-card .hierarchy-card-header {
            margin-bottom: 0.5rem;
        }

        .hierarchy-card-container.nested-unit-card .hierarchy-card-title {
            font-size: 1rem;
        }

        .hierarchy-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
        }

        .hierarchy-card-header:hover .hierarchy-card-title {
            color: #C88F4A;
        }

        .hierarchy-card-icon {
            font-size: 2rem;
            line-height: 1;
        }

        .hierarchy-card-title {
            font-size: 1.15rem;
            font-weight: 600;
            color: #3D2E1F;
            transition: color 0.2s;
        }

        .hierarchy-card-description {
            font-size: 0.85rem;
            color: #8B6F47;
            line-height: 1.5;
            font-style: italic;
            margin-bottom: 0.75rem;
            padding-left: 2.75rem;
        }

        .hierarchy-card-activities {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            padding-left: 2.75rem;
            margin-bottom: 1rem;
        }

        .nested-cards-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px dashed #E5DDD1;
        }

        .nested-cards-label {
            font-size: 0.75rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nested-cards-label::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #E5DDD1;
        }

        .nested-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 1rem;
        }

        .nested-entity-card {
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 10px;
            padding: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .nested-entity-card:hover {
            border-color: #C88F4A;
            box-shadow: 0 2px 6px rgba(200, 143, 74, 0.2);
        }

        .nested-entity-card.team { background: linear-gradient(135deg, #FAF7F5 0%, white 100%); }
        .nested-entity-card.role { background: linear-gradient(135deg, #F5F3F0 0%, white 100%); }
        .nested-entity-card.person { background: linear-gradient(135deg, #F0EDE8 0%, white 100%); }

        .nested-card-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nested-card-icon {
            font-size: 1.25rem;
            line-height: 1;
        }

        .nested-card-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: #3D2E1F;
        }

        .nested-card-description {
            font-size: 0.8rem;
            color: #8B6F47;
            line-height: 1.4;
            font-style: italic;
        }

        .nested-card-connections {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: auto;
        }

        .nested-card-connections .connection-badge {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
        }

        /* Deep nesting - roles/people inside teams */
        .deep-nested-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px dotted #E5DDD1;
        }

        .deep-nested-label {
            font-size: 0.7rem;
            color: #A89B8C;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .deep-nested-items {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .deep-nested-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.625rem;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #3D2E1F;
            cursor: pointer;
            transition: all 0.2s;
        }

        .deep-nested-item:hover {
            background: white;
            border-color: #C88F4A;
        }

        .deep-nested-item .item-icon {
            font-size: 1rem;
        }

        .deep-nested-item .item-name {
            font-weight: 500;
        }

        /* View mode toggle button */
        .view-mode-toggle {
            display: flex;
            background: #E5DDD1;
            border-radius: 8px;
            padding: 3px;
            gap: 2px;
        }

        .view-mode-btn {
            padding: 0.5rem 0.875rem;
            border: none;
            background: transparent;
            color: #6B5642;
            font-size: 0.85rem;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .view-mode-btn:hover {
            color: #3D2E1F;
        }

        .view-mode-btn.active {
            background: white;
            color: #3D2E1F;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Hierarchy row styling */
        .hierarchy-grid {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        /* Orphan entities section */
        .orphan-entities-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 2px solid #E5DDD1;
        }

        .orphan-section-title {
            font-size: 1rem;
            color: #6B5642;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-icon {
            font-size: 2rem;
            line-height: 1;
        }

        .card-title {
            font-size: 1.05rem;
            font-weight: 600;
            color: #3D2E1F;
            line-height: 1.3;
        }

        .card-meta {
            font-size: 0.875rem;
            color: #6B5642;
            line-height: 1.5;
        }

        .card-description {
            font-size: 0.85rem;
            color: #8B6F47;
            line-height: 1.5;
            font-style: italic;
        }

        .card-connections {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            margin-top: auto;
        }

        .connection-badge {
            font-size: 0.75rem;
            padding: 0.375rem 0.625rem;
            background: #F5E6D3;
            color: #6B5642;
            border-radius: 16px;
            font-weight: 500;
            border: 1px solid #E5DDD1;
        }

        .card-nested-under {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            align-items: center;
        }

        .card-nested-under .nested-label {
            font-size: 0.7rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 0.25rem;
        }

        .nested-parent-badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            background: linear-gradient(135deg, #C88F4A 0%, #D4A574 100%);
            color: white;
            border-radius: 12px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }

        .nested-parent-badge .parent-icon {
            font-size: 0.85rem;
        }

        /* Nested chips container for parent display in modal */
        .nested-chips-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .nested-chips-container .entity-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.6rem;
            border-radius: 16px;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .nested-chips-container .entity-chip.unit {
            background: linear-gradient(135deg, #C88F4A 0%, #D4A574 100%);
            color: white;
        }

        .nested-chips-container .entity-chip.team {
            background: linear-gradient(135deg, #5B8C5A 0%, #7CB37B 100%);
            color: white;
        }

        .nested-chips-container .entity-chip:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .chip-remove-btn {
            background: rgba(255,255,255,0.3);
            border: none;
            color: inherit;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            margin-left: 0.15rem;
            transition: all 0.2s;
            padding: 0;
        }

        .chip-remove-btn:hover {
            background: rgba(255,255,255,0.5);
        }

        /* Card View Filter/Sort Controls */
        .card-view-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1rem 1.5rem;
            background: #FAF7F5;
            border-bottom: 2px solid #E5DDD1;
            position: sticky;
            top: 0;
            z-index: 10;
            align-items: center;
        }

        .card-search-container {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
            position: relative;
        }

        .card-search-input {
            width: 100%;
            padding: 0.625rem 1rem 0.625rem 2.5rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #3D2E1F;
            background: white;
            transition: all 0.2s;
        }

        .card-search-input:focus {
            outline: none;
            border-color: #C88F4A;
            box-shadow: 0 0 0 3px rgba(200, 143, 74, 0.15);
        }

        .card-search-input::placeholder {
            color: #A89B8C;
        }

        .card-search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: #8B6F47;
            font-size: 1rem;
            pointer-events: none;
        }

        .card-sort-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-sort-label {
            font-size: 0.85rem;
            color: #6B5642;
            font-weight: 500;
        }

        .card-sort-select {
            padding: 0.5rem 2rem 0.5rem 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #3D2E1F;
            background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236B5642' d='M6 8L2 4h8z'/%3E%3C/svg%3E") no-repeat right 0.75rem center;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            transition: all 0.2s;
        }

        .card-sort-select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .card-sort-select:hover {
            border-color: #C88F4A;
        }

        .card-filter-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .card-filter-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.5rem 0.875rem;
            border: 2px solid #E5DDD1;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            color: #6B5642;
        }

        .card-filter-btn:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .card-filter-btn.active {
            background: linear-gradient(135deg, #C88F4A 0%, #D4A574 100%);
            color: white;
            border-color: #C88F4A;
        }

        .card-filter-btn .filter-icon {
            font-size: 1rem;
        }

        .card-filter-btn .filter-count {
            background: rgba(0, 0, 0, 0.1);
            padding: 0.125rem 0.375rem;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .card-filter-btn.active .filter-count {
            background: rgba(255, 255, 255, 0.25);
        }

        .card-view-content {
            padding: 2rem;
        }

        .card-no-results {
            text-align: center;
            padding: 3rem;
            color: #8B6F47;
        }

        .card-no-results i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .card-no-results p {
            font-size: 1rem;
            margin: 0;
        }

        .sentence-preview {
            padding: 1rem;
            background: #FAF7F5;
            border-radius: 6px;
            border-left: 3px solid #C88F4A;
            margin-top: 1rem;
            font-size: 0.95rem;
            color: #3D2E1F;
            line-height: 1.5;
        }

        .sentence-preview strong {
            color: #C88F4A;
        }

        .inline-add-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.35rem 0.75rem;
            background: transparent;
            border: 1px dashed #C88F4A;
            color: #C88F4A;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin: 0.5rem 0;
            transition: all 0.2s;
        }

        .inline-add-btn:hover {
            background: #FFF9F0;
            border-style: solid;
        }

        .tree-view {
            display: none;
            padding: 2rem;
            overflow-y: auto;
            height: 100%;
            background: white;
        }

        .tree-view.active {
            display: block;
        }

        .graph-view {
            display: none;
            position: relative;
            height: 100%;
        }

        .graph-view.active {
            display: block;
        }

        /* Venn View Styles */
        .venn-view {
            display: none;
            position: relative;
            height: 100%;
            background: white;
            overflow: hidden;
        }

        .venn-view.active {
            display: block;
        }

        .venn-controls {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .venn-level-nav {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #E5DDD1;
        }

        .venn-level-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid #E5DDD1;
            background: white;
            color: #6B5642;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .venn-level-btn:hover:not(:disabled) {
            background: #C88F4A;
            color: white;
            border-color: #C88F4A;
        }

        .venn-level-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .venn-level-label {
            font-weight: 600;
            color: #3D2E1F;
            min-width: 80px;
            text-align: center;
            font-size: 0.95rem;
        }

        .venn-breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: #8B6F47;
        }

        .venn-breadcrumb-item {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.15s;
        }

        .venn-breadcrumb-item:hover {
            background: rgba(200, 143, 74, 0.15);
            color: #C88F4A;
        }

        .venn-breadcrumb-separator {
            color: #C8B9A0;
        }

        #vennDiagram {
            width: 100%;
            height: 100%;
        }

        .venn-circle {
            cursor: pointer;
            transition: all 0.2s;
        }

        .venn-circle:hover {
            filter: brightness(1.05);
        }

        .venn-circle-label {
            pointer-events: none;
            font-weight: 600;
            font-size: 14px;
            fill: #3D2E1F;
        }

        .venn-circle-count {
            pointer-events: none;
            font-size: 11px;
            fill: #6B5642;
        }

        .venn-overlap {
            cursor: pointer;
            transition: all 0.2s;
        }

        .venn-overlap:hover {
            filter: brightness(0.95);
        }

        .venn-overlap-indicator {
            pointer-events: none;
        }

        .venn-tooltip {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 0.75rem 1rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 100;
            max-width: 250px;
            border: 1px solid #E5DDD1;
        }

        .venn-tooltip.visible {
            opacity: 1;
        }

        .venn-tooltip-title {
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.25rem;
        }

        .venn-tooltip-desc {
            font-size: 0.85rem;
            color: #6B5642;
        }

        .venn-overlap-panel {
            position: absolute;
            right: 1rem;
            top: 1rem;
            width: 300px;
            max-height: calc(100% - 2rem);
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid #E5DDD1;
            z-index: 50;
            display: none;
            overflow: hidden;
        }

        .venn-overlap-panel.visible {
            display: block;
        }

        .venn-overlap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.875rem 1rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            font-weight: 600;
        }

        .venn-close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .venn-close-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .venn-overlap-content {
            padding: 1rem;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }

        .venn-connection-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.625rem 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            cursor: pointer;
            transition: all 0.15s;
        }

        .venn-connection-item:hover {
            border-color: #C88F4A;
            background: white;
        }

        .venn-connection-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .venn-connection-info {
            flex: 1;
            min-width: 0;
        }

        .venn-connection-name {
            font-weight: 500;
            color: #3D2E1F;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .venn-connection-type {
            font-size: 0.75rem;
            color: #8B6F47;
            text-transform: uppercase;
        }

        .venn-shared-label {
            font-size: 0.85rem;
            color: #6B5642;
            font-weight: 600;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .venn-shared-count {
            background: #C88F4A;
            color: white;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
        }

        .venn-entity-section {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #E5DDD1;
        }

        .venn-entity-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .venn-entity-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.5rem;
        }

        .venn-zoom-hint {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(59, 46, 31, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .venn-zoom-hint.visible {
            opacity: 1;
        }

        .tree-node-container {
            margin-bottom: 0.25rem;
            position: relative;
        }

        .tree-node-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.625rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            gap: 0.5rem;
            background: transparent;
            border: none;
            margin-bottom: 0.125rem;
            position: relative;
        }

        .tree-node-item:hover {
            background: rgba(200, 143, 74, 0.08);
        }

        .tree-node-item .tree-node-actions {
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .tree-node-item:hover .tree-node-actions {
            opacity: 1;
        }

        .tree-node-item.unit {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            font-weight: 500;
            padding: 0.625rem 0.75rem;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.25);
            margin-bottom: 0.375rem;
        }

        .tree-node-item.unit:hover {
            background: linear-gradient(135deg, #D9A05B 0%, #C98C6C 100%);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.35);
            transform: translateY(-1px);
        }

        .tree-node-item.unit .tree-node-actions {
            opacity: 0.7;
        }

        .tree-node-item.unit:hover .tree-node-actions {
            opacity: 1;
        }

        .tree-node-item.team {
            background: rgba(184, 123, 91, 0.06);
            font-weight: 500;
            color: #5A4736;
        }

        .tree-node-item.team:hover {
            background: rgba(184, 123, 91, 0.12);
        }

        .tree-node-item.role {
            background: transparent;
            color: #6B5642;
        }

        .tree-node-item.role:hover {
            background: rgba(139, 111, 71, 0.08);
        }

        .tree-node-item.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }

        .tree-node-item.drag-over {
            outline: 2px dashed #C88F4A;
            outline-offset: 2px;
            background: rgba(255, 248, 231, 0.8) !important;
        }

        .tree-node-item.drag-over.unit {
            background: rgba(232, 213, 192, 0.8) !important;
        }

        .tree-expand-icon {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.5;
            border-radius: 4px;
        }

        .tree-expand-icon:hover {
            background: rgba(0, 0, 0, 0.05);
            opacity: 0.8;
        }

        .tree-node-item.unit .tree-expand-icon:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .tree-expand-icon.expanded {
            transform: rotate(90deg);
        }

        .tree-node-content {
            flex: 1;
            min-width: 0;
        }

        .tree-node-name {
            font-size: 0.875rem;
            line-height: 1.4;
            font-weight: inherit;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tree-node-meta {
            font-size: 0.7rem;
            opacity: 0.6;
            margin-top: 0.125rem;
        }

        .tree-node-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .tree-node-item.unit .tree-node-icon {
            opacity: 0.9;
        }

        .tree-node-actions {
            display: flex;
            align-items: center;
            gap: 0.125rem;
        }

        .tree-children {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding-left: 1.25rem;
            margin-left: 0.5rem;
            border-left: 1px solid rgba(139, 111, 71, 0.15);
        }

        .tree-children.expanded {
            max-height: 5000px;
        }

        .tree-people-assigned {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .tree-person-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: #6B5642;
            color: white;
            border-radius: 12px;
            font-size: 0.75rem;
            transition: background 0.2s, transform 0.1s;
        }

        .tree-person-badge:hover {
            background: #5A4736;
            transform: scale(1.05);
        }

        .tree-relationships-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            margin-left: 3rem;
            margin-top: 0.5rem;
            background: #FAF7F5;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #6B5642;
            font-weight: 500;
            transition: background 0.2s;
        }

        .tree-relationships-header:hover {
            background: #F5E6D3;
        }

        .tree-relationships {
            margin-left: 3rem;
            margin-top: 0.25rem;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            border: 1px solid #E5DDD1;
            font-size: 0.85rem;
        }

        .tree-relationship-item {
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.375rem;
            border-radius: 6px;
            background: #FAF7F5;
            border-left: 3px solid #C88F4A;
            line-height: 1.5;
        }

        .tree-relationship-item:last-child {
            margin-bottom: 0;
        }

        .tree-relationship-item.shares {
            background: #F0F4F7;
            color: #7B95A3;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Simplified UX Styles */
        .welcome-banner {
            background: linear-gradient(135deg, #FFF9F0 0%, #FAF7F5 100%);
            border: 2px solid #C88F4A;
            border-radius: 8px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
        }

        .welcome-banner h3 {
            color: #C88F4A;
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .welcome-banner ol {
            margin-left: 1.25rem;
            margin-bottom: 1rem;
            color: #6B5642;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        .welcome-banner .actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .collapsible-section {
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .collapsible-header {
            background: #FAF7F5;
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            color: #6B5642;
            transition: background 0.2s;
        }

        .collapsible-header:hover {
            background: #F5E6D3;
        }

        .collapsible-header .collapse-icon {
            transition: transform 0.2s;
        }

        .collapsible-section.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            padding: 1rem;
            max-height: 2000px;
            transition: max-height 0.3s ease-out, padding 0.3s;
            overflow: hidden;
        }

        .collapsible-section.collapsed .collapsible-content {
            max-height: 0;
            padding: 0 1rem;
        }

        .show-more-btn {
            width: 100%;
            padding: 0.5rem;
            background: transparent;
            border: 1px dashed #C88F4A;
            color: #C88F4A;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.375rem;
        }

        .show-more-btn:hover {
            background: #FFF9F0;
        }

        .show-more-btn.expanded {
            border-style: solid;
            background: #FFF9F0;
        }

        .filter-dropdown {
            flex: 1;
            padding: 0.625rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
            cursor: pointer;
            font-family: inherit;
        }

        .filter-simplified {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tooltip-hint {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: #E5DDD1;
            color: #6B5642;
            border-radius: 50%;
            font-size: 0.7rem;
            cursor: help;
            margin-left: 0.25rem;
        }

        .help-text {
            font-size: 0.75rem;
            color: #8B6F47;
            font-style: italic;
            margin-top: 0.25rem;
        }

        .quick-operator-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .operator-btn {
            flex: 1;
            padding: 0.75rem 0.5rem;
            border: 2px solid #E5DDD1;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.2s;
            text-align: center;
        }

        .operator-btn:hover {
            border-color: #C88F4A;
        }

        .operator-btn.active {
            border-color: #C88F4A;
            background: #FFF9F0;
            color: #C88F4A;
        }

        .operator-btn.active.link-type {
            border-color: #7B95A3;
            background: #F0F4F7;
            color: #7B95A3;
        }

        .operator-btn.active.start-type {
            border-color: #8B6F47;
            background: #F5F0E8;
            color: #8B6F47;
        }

        .operator-btn-subtitle {
            font-size: 0.7rem;
            opacity: 0.8;
            font-weight: 400;
            margin-top: 0.125rem;
        }

        .advanced-operators {
            display: none;
            margin-top: 0.75rem;
        }

        .advanced-operators.visible {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .advanced-filters-content {
            display: none;
            padding-top: 1rem;
        }

        .advanced-filters-content.visible {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: #FFF9F0;
            color: #C88F4A;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        /* Hide technical labels by default */
        .technical-label {
            display: none;
        }

        body.technical-mode .technical-label {
            display: inline;
        }

        body.technical-mode .friendly-label {
            display: none;
        }

        /* ========================================== */
        /* Enhanced Entity Modal Styles */
        /* ========================================== */

        .modal-dialog {
            background: white;
            border-radius: 16px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.25);
        }

        .modal-header-section {
            padding: 1.75rem 2rem;
            border-bottom: none;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            position: relative;
            flex-shrink: 0;
        }

        .modal-header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .modal-header-icon {
            font-size: 2.5rem;
            opacity: 0.9;
            margin-right: 1rem;
        }

        .modal-header-content {
            flex: 1;
        }

        .modal-title-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .modal-title-text {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0;
            letter-spacing: -0.02em;
        }

        .modal-title-edit-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.4rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
        }

        .modal-title-edit-btn:hover {
            background: rgba(255,255,255,0.3);
            opacity: 1;
        }

        .modal-type-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            background: rgba(255,255,255,0.2);
            padding: 0.35rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.5rem;
        }

        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 1.25rem;
        }

        .modal-close-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .modal-body {
            padding: 0;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .modal-section {
            padding: 1.5rem 2rem;
            margin-bottom: 0;
            border-bottom: 1px solid #F0EBE4;
        }

        .modal-section:last-of-type {
            border-bottom: none;
        }

        .modal-section-title {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-bottom: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .modal-section-title i {
            font-size: 1rem;
        }

        .connection-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1rem;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            margin: 0.25rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            font-weight: 500;
            color: #3D2E1F;
        }

        .connection-badge:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
            transform: translateY(-1px);
        }

        .connection-badge i {
            color: #8B6F47;
        }

        /* Orbital Connections Visualization */
        .orbital-container {
            position: relative;
            width: 100%;
            height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
        }

        /* Mobile modal optimizations */
        @media (max-width: 640px) {
            .modal-dialog {
                width: 100%;
                max-width: 100%;
                height: 100%;
                max-height: 100%;
                border-radius: 0;
                margin: 0;
            }

            .modal-header-section {
                padding: 1rem 1.25rem;
            }

            .modal-header-icon {
                font-size: 2rem;
                margin-right: 0.75rem;
            }

            .modal-title-text {
                font-size: 1.35rem;
            }

            .modal-section {
                padding: 1rem 1.25rem;
            }

            .modal-actions {
                padding: 1rem 1.25rem;
            }

            /* Hide orbital view on mobile - always use list */
            .orbital-container {
                display: none !important;
            }

            /* Hide view toggle on mobile since we only show list */
            .view-toggle {
                display: none;
            }

            /* Compact empty states */
            .modal-empty-state {
                padding: 0.75rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .modal-empty-state i {
                font-size: 1rem;
                margin-bottom: 0;
            }

            /* Compact description empty state */
            .modal-description-empty {
                padding: 0.75rem;
                font-size: 0.85rem;
            }

            /* Stack connection badges vertically for easier tapping */
            .connection-group-items {
                flex-direction: column;
                gap: 0.5rem;
            }

            .connection-badge {
                width: 100%;
                padding: 0.75rem 1rem;
                margin: 0;
                justify-content: space-between;
            }

            /* Add action sections more compact */
            .modal-add-connection {
                padding: 0.75rem;
            }

            .modal-add-connection-row {
                flex-direction: column;
                gap: 0.5rem;
            }

            .modal-add-connection-row select {
                width: 100%;
            }

            .modal-add-connection-btn {
                width: 100%;
                justify-content: center;
            }

            /* Hide separate add sections on mobile - use inline buttons instead */
            #modalAddNested,
            #modalAddActivity {
                display: none !important;
            }

            /* Hide delete from footer on mobile */
            #modalDeleteButton {
                display: none !important;
            }

            /* Make footer simpler on mobile */
            .modal-actions {
                justify-content: space-between;
            }

            .modal-action-spacer {
                display: none;
            }
        }

        /* Inline add button for section headers */
        .section-add-btn {
            background: rgba(200, 143, 74, 0.15);
            border: none;
            color: #C88F4A;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .section-add-btn:hover {
            background: rgba(200, 143, 74, 0.25);
        }

        /* Inline add form that expands in section */
        .inline-add-form {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: #FAF7F5;
            border-radius: 8px;
            border: 1px dashed #E5DDD1;
        }

        .inline-add-form.hidden {
            display: none;
        }

        .inline-add-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .inline-add-row select {
            flex: 1;
            min-width: 100px;
            padding: 0.5rem;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
        }

        .inline-add-row select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .inline-add-btn {
            padding: 0.5rem 0.75rem;
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .inline-add-btn:hover {
            background: #B87B5B;
        }

        /* Hide mobile-only delete button on desktop */
        .mobile-only-delete {
            display: none;
        }

        @media (max-width: 640px) {
            .mobile-only-delete {
                display: flex;
            }
        }

        .orbital-svg {
            width: 100%;
            height: 100%;
        }

        .orbital-center {
            cursor: default;
        }

        .orbital-center-circle {
            fill: #C88F4A;
            stroke: #B87B5B;
            stroke-width: 3;
        }

        .orbital-center-icon {
            fill: white;
            font-size: 24px;
        }

        .orbital-center-label {
            fill: #3D2E1F;
            font-size: 11px;
            font-weight: 600;
            text-anchor: middle;
        }

        .orbital-ring {
            fill: none;
            stroke: #E5DDD1;
            stroke-width: 1;
            stroke-dasharray: 4,4;
        }

        .orbital-node {
            cursor: pointer;
            transition: transform 0.2s;
        }

        .orbital-node:hover {
            transform: scale(1.1);
        }

        .orbital-node-circle {
            stroke-width: 2;
            stroke: white;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .orbital-node-icon {
            fill: white;
            font-size: 14px;
            pointer-events: none;
        }

        .orbital-node-label {
            font-size: 11px;
            font-weight: 500;
            fill: #3D2E1F;
            pointer-events: none;
        }

        .orbital-link {
            stroke: #E5DDD1;
            stroke-width: 1.5;
            fill: none;
        }

        .orbital-link.has-children {
            stroke: #C88F4A;
            stroke-width: 2;
            stroke-dasharray: none;
        }

        /* Grouped connections fallback */
        .connections-grouped {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .connection-group {
            background: #FAF7F5;
            border-radius: 8px;
            padding: 0.75rem;
        }

        .connection-group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .connection-group-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        /* Nested indicator */
        .connection-badge.has-nested {
            border-color: #C88F4A;
            position: relative;
        }

        .connection-badge.has-nested::after {
            content: '';
            position: absolute;
            top: -4px;
            right: -4px;
            width: 12px;
            height: 12px;
            background: #C88F4A;
            border-radius: 50%;
            border: 2px solid white;
        }

        .nested-count {
            position: absolute;
            top: -4px;
            right: -4px;
            min-width: 18px;
            height: 18px;
            background: #C88F4A;
            border-radius: 9px;
            border: 2px solid white;
            color: white;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
        }

        /* View toggle for connections */
        .connections-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .view-toggle {
            display: flex;
            gap: 0.25rem;
            background: #F5F2ED;
            border-radius: 6px;
            padding: 2px;
        }

        .view-toggle-btn {
            padding: 0.35rem 0.5rem;
            border: none;
            background: transparent;
            color: #8B6F47;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .view-toggle-btn:hover {
            background: #E5DDD1;
        }

        .view-toggle-btn.active {
            background: white;
            color: #C88F4A;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .activity-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            border-left: 3px solid #C88F4A;
        }

        .activity-item:last-child {
            margin-bottom: 0;
        }

        .activity-operator {
            font-weight: 700;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .modal-actions {
            display: flex;
            gap: 0.75rem;
            padding: 1.5rem 2rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
            flex-shrink: 0;
        }

        .modal-action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .modal-action-btn.primary {
            background: #D4A54A;
            color: white;
            border-color: #D4A54A;
        }

        .modal-action-btn.primary:hover {
            background: #E5B555;
            border-color: #E5B555;
        }

        .modal-action-btn.secondary {
            background: white;
            color: #6B5642;
            border-color: #E5DDD1;
        }

        .modal-action-btn.secondary:hover {
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .modal-action-btn.danger {
            background: white;
            color: #d32f2f;
            border-color: #E5DDD1;
        }

        .modal-action-btn.danger:hover {
            border-color: #d32f2f;
            background: #fff5f5;
        }

        .modal-action-spacer {
            flex: 1;
        }

        /* Entity Edit Modal */
        .entity-edit-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }

        .entity-edit-modal-overlay.open {
            display: flex;
        }

        .entity-edit-modal {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 450px;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.25);
            overflow: hidden;
        }

        .entity-edit-modal-header {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            padding: 1.5rem;
            color: white;
        }

        .entity-edit-modal-header h3 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .entity-edit-modal-body {
            padding: 1.5rem;
        }

        .entity-edit-field {
            margin-bottom: 1.25rem;
        }

        .entity-edit-field:last-child {
            margin-bottom: 0;
        }

        .entity-edit-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            color: #6B5642;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .entity-edit-input {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s;
            color: #3D2E1F;
        }

        .entity-edit-input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .entity-edit-textarea {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
            color: #3D2E1F;
            resize: vertical;
            min-height: 80px;
            max-height: 160px;
            font-family: inherit;
            line-height: 1.5;
        }

        .entity-edit-textarea:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .entity-edit-label .char-limit {
            font-weight: 400;
            color: #8B6F47;
            font-size: 0.75rem;
        }

        /* Modal description display */
        .modal-description-text {
            color: #6B5642;
            font-size: 0.95rem;
            line-height: 1.6;
            padding: 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            border-left: 3px solid #C88F4A;
        }

        .modal-description-empty {
            color: #8B6F47;
            font-style: italic;
            font-size: 0.9rem;
            padding: 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            text-align: center;
        }

        /* Add connection in modal */
        .modal-add-connection {
            background: #FAF7F5;
            border-radius: 8px;
            padding: 1rem;
            border: 1px dashed #E5DDD1;
        }

        .modal-add-connection-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .modal-add-connection-row select {
            flex: 1;
            min-width: 120px;
            padding: 0.625rem 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
            color: #3D2E1F;
            cursor: pointer;
        }

        .modal-add-connection-row select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .modal-add-connection-btn {
            padding: 0.625rem 1rem;
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.375rem;
            transition: background 0.2s;
        }

        .modal-add-connection-btn:hover {
            background: #B87B5B;
        }

        .modal-add-connection-btn:disabled {
            background: #E5DDD1;
            cursor: not-allowed;
        }

        /* Work Product Selector Modal */
        .work-product-selector-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .work-product-selector-overlay.active {
            display: flex;
        }

        .work-product-selector-modal {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 70vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        }

        .work-product-selector-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 2px solid #F5E6D3;
            background: linear-gradient(135deg, #D4A574 0%, #C88F4A 100%);
            color: white;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .work-product-selector-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .work-product-selector-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: background 0.2s;
        }

        .work-product-selector-close:hover {
            background: rgba(255, 255, 255, 0.35);
        }

        .work-product-selector-search {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #E5DDD1;
            background: #FAF7F5;
        }

        .work-product-selector-search input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.9rem;
            background: white;
        }

        .work-product-selector-search input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .work-product-selector-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
        }

        .work-product-category {
            margin-bottom: 0.5rem;
        }

        .work-product-category-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: #F5F0E8;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #6B5642;
            transition: background 0.2s;
        }

        .work-product-category-header:hover {
            background: #EDE5D8;
        }

        .work-product-category-header .category-toggle {
            transition: transform 0.2s;
        }

        .work-product-category-header.collapsed .category-toggle {
            transform: rotate(-90deg);
        }

        .work-product-category-items {
            padding-left: 0.5rem;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .work-product-category-items.collapsed {
            max-height: 0;
        }

        .work-product-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.875rem 1rem;
            margin: 0.25rem 0;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .work-product-item:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .work-product-item.selected {
            border-color: #C88F4A;
            background: #FFF9F0;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.2);
        }

        .work-product-item-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: linear-gradient(135deg, #D4A574 0%, #C88F4A 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.1rem;
        }

        .work-product-item-content {
            flex: 1;
        }

        .work-product-item-name {
            font-weight: 600;
            color: #3D2E1F;
            font-size: 0.95rem;
        }

        .work-product-item-desc {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-top: 0.125rem;
        }

        .work-product-selector-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid #E5DDD1;
            background: #FAF7F5;
            border-radius: 0 0 12px 12px;
            display: flex;
            gap: 0.75rem;
            justify-content: space-between;
            align-items: center;
        }

        .work-product-create-new {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex: 1;
        }

        .work-product-create-new input {
            flex: 1;
            padding: 0.625rem 0.875rem;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .work-product-create-new input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .work-product-create-btn {
            padding: 0.625rem 1rem;
            background: #8B6F47;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.375rem;
            transition: background 0.2s;
        }

        .work-product-create-btn:hover {
            background: #6B5642;
        }

        .work-product-select-btn {
            padding: 0.625rem 1.25rem;
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .work-product-select-btn:hover {
            background: #B87B5B;
        }

        .work-product-select-btn:disabled {
            background: #E5DDD1;
            cursor: not-allowed;
        }

        /* Work product selector button in modal */
        .modal-work-product-selector-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.625rem 0.875rem;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            color: #6B5642;
            transition: all 0.2s;
            flex: 1;
            min-width: 150px;
        }

        .modal-work-product-selector-btn:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .modal-work-product-selector-btn.has-selection {
            border-color: #C88F4A;
            background: #FFF9F0;
            color: #3D2E1F;
            font-weight: 600;
        }

        .modal-work-product-selector-btn .btn-icon {
            color: #C88F4A;
        }

        .entity-edit-modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            padding: 1.25rem 1.5rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
        }

        /* Empty state styles */
        .modal-empty-state {
            text-align: center;
            padding: 1.5rem;
            color: #8B6F47;
            font-size: 0.9rem;
        }

        .modal-empty-state i {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }

        /* Delete confirmation */
        .delete-confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .delete-confirm-overlay.open {
            display: flex;
        }

        .delete-confirm-modal {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.3);
            overflow: hidden;
            text-align: center;
        }

        .delete-confirm-icon {
            padding: 2rem 2rem 1rem;
            font-size: 3rem;
            color: #d32f2f;
        }

        .delete-confirm-content {
            padding: 0 2rem 1.5rem;
        }

        .delete-confirm-content h3 {
            margin: 0 0 0.5rem;
            color: #3D2E1F;
            font-size: 1.25rem;
        }

        .delete-confirm-content p {
            margin: 0;
            color: #6B5642;
            font-size: 0.9rem;
        }

        .delete-confirm-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            padding: 1.25rem 1.5rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
        }

        /* ========================================== */
        /* Bulk Import Modal Styles */
        /* ========================================== */

        .bulk-import-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .bulk-import-overlay.open {
            display: flex;
        }

        .bulk-import-modal {
            background: white;
            border-radius: 16px;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.25);
            display: flex;
            flex-direction: column;
        }

        .bulk-import-header {
            padding: 1.5rem 2rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bulk-import-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            transition: all 0.2s;
        }

        .bulk-import-close:hover {
            background: rgba(255,255,255,0.3);
        }

        .bulk-import-body {
            padding: 1.5rem 2rem;
            overflow-y: auto;
            flex: 1;
        }

        .bulk-import-steps {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .bulk-import-step {
            flex: 1;
            padding: 0.75rem 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            text-align: center;
            font-size: 0.875rem;
            color: #8B6F47;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .bulk-import-step.active {
            background: #FFF9F0;
            border-color: #C88F4A;
            color: #C88F4A;
            font-weight: 600;
        }

        .bulk-import-step.completed {
            background: #E8F5E9;
            color: #4CAF50;
        }

        .bulk-import-step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #E5DDD1;
            border-radius: 50%;
            margin-right: 0.5rem;
            font-weight: 700;
            font-size: 0.75rem;
        }

        .bulk-import-step.active .bulk-import-step-number {
            background: #C88F4A;
            color: white;
        }

        .bulk-import-step.completed .bulk-import-step-number {
            background: #4CAF50;
            color: white;
        }

        .bulk-import-section {
            margin-bottom: 1.5rem;
        }

        .bulk-import-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #6B5642;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-entity-type {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .bulk-import-entity-btn {
            padding: 0.6rem 1rem;
            border: 2px solid #E5DDD1;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-entity-btn:hover {
            border-color: #C88F4A;
        }

        .bulk-import-entity-btn.active {
            background: #C88F4A;
            color: white;
            border-color: #C88F4A;
        }

        .bulk-import-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #E5DDD1;
            padding-bottom: 0.5rem;
        }

        .bulk-import-tab {
            padding: 0.5rem 1rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.875rem;
            color: #8B6F47;
            border-radius: 6px 6px 0 0;
            transition: all 0.2s;
        }

        .bulk-import-tab:hover {
            background: #FAF7F5;
        }

        .bulk-import-tab.active {
            background: #C88F4A;
            color: white;
            font-weight: 600;
        }

        .bulk-import-textarea {
            width: 100%;
            min-height: 150px;
            padding: 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
            resize: vertical;
            transition: border-color 0.2s;
        }

        .bulk-import-textarea:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .bulk-import-textarea::placeholder {
            color: #B0A090;
        }

        .bulk-import-hint {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .bulk-import-file-upload {
            border: 2px dashed #E5DDD1;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bulk-import-file-upload:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .bulk-import-file-upload i {
            font-size: 2.5rem;
            color: #C88F4A;
            margin-bottom: 0.75rem;
        }

        .bulk-import-file-upload input {
            display: none;
        }

        .bulk-import-mapping {
            background: #FAF7F5;
            border-radius: 8px;
            padding: 1rem;
        }

        .bulk-import-mapping-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr auto;
            gap: 0.75rem;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border: 1px solid #E5DDD1;
        }

        .bulk-import-mapping-row:last-child {
            margin-bottom: 0;
        }

        .bulk-import-mapping-col {
            padding: 0.5rem 0.75rem;
            background: #F5E6D3;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            color: #6B5642;
        }

        .bulk-import-mapping-arrow {
            color: #C88F4A;
            font-size: 1.25rem;
        }

        .bulk-import-mapping-select {
            padding: 0.5rem 0.75rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
            cursor: pointer;
            min-width: 150px;
        }

        .bulk-import-mapping-select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .bulk-import-set-all {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-set-all-btn {
            padding: 0.4rem 0.6rem;
            background: #E5DDD1;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            color: #6B5642;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .bulk-import-set-all-btn:hover {
            background: #C88F4A;
            color: white;
        }

        .bulk-import-set-all-btn.active {
            background: #C88F4A;
            color: white;
        }

        .bulk-import-set-all-input {
            padding: 0.4rem 0.6rem;
            border: 1px solid #E5DDD1;
            border-radius: 4px;
            font-size: 0.8rem;
            width: 120px;
        }

        .bulk-import-set-all-input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .bulk-import-preview {
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 1rem;
        }

        .bulk-import-preview-header {
            background: #FAF7F5;
            padding: 0.75rem 1rem;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #E5DDD1;
        }

        .bulk-import-preview-count {
            background: #C88F4A;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .bulk-import-preview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        .bulk-import-preview-table th {
            background: #F5F2ED;
            padding: 0.6rem 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #6B5642;
            border-bottom: 1px solid #E5DDD1;
        }

        .bulk-import-preview-table td {
            padding: 0.6rem 0.75rem;
            border-bottom: 1px solid #F0EBE4;
        }

        .bulk-import-preview-table tr:hover {
            background: #FFF9F0;
        }

        .bulk-import-preview-table tr.error {
            background: #FFF5F5;
        }

        .bulk-import-preview-table .preview-error {
            color: #d32f2f;
            font-size: 0.75rem;
        }

        .bulk-import-preview-table .preview-set-all {
            color: #C88F4A;
            font-style: italic;
        }

        .bulk-import-footer {
            padding: 1rem 2rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bulk-import-footer-info {
            font-size: 0.875rem;
            color: #8B6F47;
        }

        .bulk-import-footer-actions {
            display: flex;
            gap: 0.75rem;
        }

        .bulk-import-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-btn.secondary {
            background: white;
            border: 2px solid #E5DDD1;
            color: #6B5642;
        }

        .bulk-import-btn.secondary:hover {
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .bulk-import-btn.primary {
            background: #C88F4A;
            border: 2px solid #C88F4A;
            color: white;
        }

        .bulk-import-btn.primary:hover {
            background: #B87B5B;
            border-color: #B87B5B;
        }

        .bulk-import-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bulk-import-success {
            text-align: center;
            padding: 2rem;
        }

        .bulk-import-success i {
            font-size: 4rem;
            color: #4CAF50;
            margin-bottom: 1rem;
        }

        .bulk-import-success h3 {
            font-size: 1.25rem;
            color: #3D2E1F;
            margin-bottom: 0.5rem;
        }

        .bulk-import-success p {
            color: #8B6F47;
        }

        /* Undo Button Styles */
        .undo-btn {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            padding: 0.4rem 0.75rem;
            color: white;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .undo-btn:hover:not(:disabled) {
            background: rgba(255,255,255,0.25);
            border-color: rgba(255,255,255,0.5);
        }

        .undo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .undo-btn .undo-count {
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 0 0.4rem;
            font-size: 0.75rem;
            min-width: 1.25rem;
            text-align: center;
        }

        /* Undo Notification Styles */
        .undo-notification {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #3D2E1F;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            font-size: 0.9rem;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .undo-notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Recycle Bin Section Styles */
        .recycle-bin-section {
            margin-top: 1rem;
            border-top: 1px solid #E5DDD1;
            padding-top: 1rem;
        }

        .recycle-bin-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .recycle-bin-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.9rem;
        }

        .recycle-bin-count {
            background: #E5DDD1;
            color: #6B5642;
            border-radius: 10px;
            padding: 0.1rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .recycle-bin-empty-btn {
            background: none;
            border: none;
            color: #8B6F47;
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.15s;
        }

        .recycle-bin-empty-btn:hover {
            background: #FAF7F5;
            color: #d32f2f;
        }

        .recycle-bin-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .recycle-bin-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            color: #A89984;
            text-align: center;
        }

        .recycle-bin-empty i {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }

        .recycle-bin-empty p {
            margin: 0;
            font-size: 0.85rem;
        }

        .recycle-bin-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: #FAF7F5;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            transition: all 0.15s;
        }

        .recycle-bin-item:hover {
            background: #F5EFE6;
        }

        .recycle-bin-item-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            min-width: 0;
        }

        .recycle-bin-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.5rem;
            color: #8B6F47;
        }

        .recycle-bin-details {
            flex: 1;
            min-width: 0;
        }

        .recycle-bin-name {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: #3D2E1F;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .recycle-bin-meta {
            display: block;
            font-size: 0.7rem;
            color: #A89984;
        }

        .recycle-bin-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .recycle-bin-item:hover .recycle-bin-actions {
            opacity: 1;
        }

        .recycle-bin-actions .btn-icon {
            padding: 0.25rem;
            border-radius: 4px;
            color: #8B6F47;
        }

        .recycle-bin-actions .btn-icon:hover {
            background: rgba(0,0,0,0.05);
            color: #C88F4A;
        }

        .recycle-bin-actions .btn-icon.delete:hover {
            color: #d32f2f;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            <i class="ph ph-buildings"></i>
            <div class="workspace-selector">
                <button class="workspace-dropdown-toggle" onclick="toggleWorkspaceDropdown(event)">
                    <span class="workspace-name" id="workspaceNameText">My Organization</span>
                    <i class="ph ph-caret-down"></i>
                </button>
                <div class="workspace-dropdown" id="workspaceDropdown">
                    <div class="workspace-dropdown-header">Workspaces</div>
                    <div class="workspace-list" id="workspaceList">
                        <!-- Workspace items populated by JS -->
                    </div>
                    <div class="workspace-dropdown-footer">
                        <button class="workspace-new-btn" onclick="openNewWorkspaceModal()">
                            <i class="ph ph-plus-circle"></i> New Workspace
                        </button>
                    </div>
                </div>
            </div>
        </h1>
        <div class="header-controls">
            <div id="loadingStatus" style="color: rgba(255,255,255,0.9); font-size: 0.875rem; margin-right: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(0,0,0,0.2); border-radius: 4px;">
                <i class="ph ph-spinner" style="animation: spin 1s linear infinite;"></i> Loading...
            </div>
            <div id="filterStatus" style="color: rgba(255,255,255,0.9); font-size: 0.875rem; margin-right: 0.5rem;"></div>
            <div class="view-toggle">
                <button class="view-toggle-btn" data-view="tree" onclick="switchView('tree')">
                    <i class="ph ph-tree-structure"></i> Tree
                </button>
                <button class="view-toggle-btn active" data-view="card" onclick="switchView('card')">
                    <i class="ph ph-squares-four"></i> Cards
                </button>
                <button class="view-toggle-btn" data-view="graph" onclick="switchView('graph')">
                    <i class="ph ph-graph"></i> Graph
                </button>
                <button class="view-toggle-btn" data-view="venn" onclick="switchView('venn')">
                    <i class="ph ph-circles-three"></i> Venn
                </button>
            </div>
            <button class="undo-btn" id="undoBtn" onclick="undo()" disabled title="Nothing to undo">
                <i class="ph ph-arrow-counter-clockwise"></i>
                Undo
                <span class="undo-count" id="undoCount" style="display: none;">0</span>
            </button>
            <button class="btn btn-small btn-outline" onclick="toggleSampleData()" id="sampleDataBtn">
                <i class="ph ph-database"></i> <span id="sampleDataText">Clear Sample Data</span>
            </button>
            <button class="btn btn-small btn-outline" onclick="clearAllData()">
                <i class="ph ph-trash"></i> Clear All
            </button>
            <button class="btn btn-small btn-outline" onclick="resetGraph()">Reset View</button>
            <button class="btn btn-small btn-outline" onclick="openBulkImportModal()"><i class="ph ph-upload-simple"></i> Import</button>
            <button class="btn btn-small" onclick="exportData()">Export Data</button>
        </div>
    </div>

    <div class="container" id="mainContainer">
        <!-- Left Panel: Entities -->
        <div class="panel panel-left" id="panelLeft">
            <button class="panel-collapse-btn" onclick="togglePanel('left')" title="Collapse sidebar">
                <i class="ph ph-caret-left"></i>
            </button>
            <!-- Welcome Banner (dismissible) -->
            <div id="welcomeBanner" class="welcome-banner">
                <h3><i class="ph ph-hand-waving"></i> Getting Started</h3>
                <ol>
                    <li>Add your first unit (like a department)</li>
                    <li>Add teams within it</li>
                    <li>Define roles</li>
                    <li>Create connections between them</li>
                </ol>
                <div class="actions">
                    <button class="btn btn-small" onclick="loadSampleData()">Load Sample</button>
                    <button class="btn btn-small btn-secondary" onclick="dismissWelcomeBanner()">Got it!</button>
                </div>
            </div>

            <div class="panel-title"><i class="ph ph-buildings"></i> Your Organization</div>

            <div class="input-group">
                <input type="text" id="entitySearch" placeholder="Search entities..." oninput="filterEntities()">
            </div>

            <!-- Collapsible Add Entity Section -->
            <div class="collapsible-section" id="addEntitySection">
                <div class="collapsible-header" onclick="toggleCollapsible('addEntitySection')">
                    <span><i class="ph ph-plus-circle"></i> Add New Entity</span>
                    <i class="ph ph-caret-down collapse-icon"></i>
                </div>
                <div class="collapsible-content">
                    <div class="entity-type-selector">
                        <button class="entity-type-btn active" data-type="unit" onclick="selectEntityType('unit')" title="Organizational unit or department">
                            <i class="ph ph-buildings"></i> Unit
                        </button>
                        <button class="entity-type-btn" data-type="team" onclick="selectEntityType('team')" title="Working team or group">
                            <i class="ph ph-users-three"></i> Team
                        </button>
                        <button class="entity-type-btn" data-type="role" onclick="selectEntityType('role')" title="Position or function">
                            <i class="ph ph-briefcase"></i> Role
                        </button>
                        <button class="entity-type-btn" data-type="person" onclick="selectEntityType('person')" title="Individual person">
                            <i class="ph ph-user"></i> Person
                        </button>
                    </div>

                    <div class="input-group">
                        <label>Name</label>
                        <input type="text" id="entityName" placeholder="Enter name..." onkeypress="if(event.key==='Enter') addEntity()">
                    </div>

                    <button class="btn" onclick="addEntity()" id="addEntityBtn" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <i class="ph ph-plus-circle" style="color: white; font-size: 1.25rem;"></i> Add Unit
                    </button>

                    <!-- Advanced Options (collapsed by default) -->
                    <button class="show-more-btn" onclick="toggleAdvancedEntityOptions()" id="advancedEntityToggle">
                        <i class="ph ph-plus"></i>
                        Advanced options
                    </button>
                    <div id="advancedEntityOptions" style="display: none; margin-top: 0.75rem;">
                        <div class="input-group" id="parentSelectGroup">
                            <label>Parent Entity</label>
                            <select id="parentEntitySelect">
                                <option value="">None - Top Level</option>
                            </select>
                            <div class="help-text">Place this entity under another one</div>
                        </div>
                        <div class="entity-type-selector" style="margin-top: 0.75rem;">
                            <button class="entity-type-btn" data-type="object" onclick="selectEntityType('object')" title="Work product or deliverable">
                                <i class="ph ph-package"></i> Object
                            </button>
                        </div>
                        <div class="help-text">Objects are work products or deliverables</div>
                    </div>
                </div>
            </div>

            <div class="panel-title" style="font-size: 1rem;">All Entities</div>
            <div id="entityList" class="entity-list"></div>

            <!-- Recycle Bin Section -->
            <div class="recycle-bin-section">
                <div class="recycle-bin-header">
                    <div class="recycle-bin-title">
                        <i class="ph ph-trash"></i>
                        Recycle Bin
                        <span class="recycle-bin-count" id="recycleBinCount" style="display: none;">0</span>
                    </div>
                    <button class="recycle-bin-empty-btn" onclick="emptyRecycleBin()" title="Empty recycle bin">
                        Empty
                    </button>
                </div>
                <div class="recycle-bin-list" id="recycleBinList">
                    <div class="recycle-bin-empty">
                        <i class="ph ph-trash"></i>
                        <p>Recycle bin is empty</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Center Panel: Multiple Views -->
        <div>
            <!-- Tree View -->
            <div id="treeView" class="tree-view"></div>
            
            <!-- Card View -->
            <div id="cardView" class="card-view"></div>
            
            <!-- Graph View -->
            <div id="graphView" class="graph-view active">
                <div class="graph-toolbar">
                    <button class="graph-tool-btn" onclick="cleanGraphLayout()" title="Auto-arrange nodes">
                        <i class="ph ph-magic-wand"></i> Clean Layout
                    </button>
                    <button class="graph-tool-btn" onclick="fitGraphToView()" title="Fit to view">
                        <i class="ph ph-arrows-out"></i> Fit
                    </button>
                    <div class="graph-zoom-controls">
                        <button class="graph-tool-btn small" onclick="zoomGraph(0.8)" title="Zoom out">
                            <i class="ph ph-minus"></i>
                        </button>
                        <span id="graphZoomLevel">100%</span>
                        <button class="graph-tool-btn small" onclick="zoomGraph(1.25)" title="Zoom in">
                            <i class="ph ph-plus"></i>
                        </button>
                    </div>
                </div>
                <svg id="graph"></svg>
                <div class="tooltip" id="tooltip"></div>
            </div>

            <!-- Venn View -->
            <div id="vennView" class="venn-view">
                <div class="venn-controls">
                    <div class="venn-level-nav">
                        <button class="venn-level-btn" onclick="changeVennLevel(-1)" id="vennLevelUp" disabled>
                            <i class="ph ph-arrow-up"></i>
                        </button>
                        <span class="venn-level-label" id="vennLevelLabel">Units</span>
                        <button class="venn-level-btn" onclick="changeVennLevel(1)" id="vennLevelDown">
                            <i class="ph ph-arrow-down"></i>
                        </button>
                    </div>
                    <div class="venn-breadcrumb" id="vennBreadcrumb"></div>
                </div>
                <svg id="vennDiagram"></svg>
                <div class="venn-tooltip" id="vennTooltip"></div>
                <div class="venn-overlap-panel" id="vennOverlapPanel">
                    <div class="venn-overlap-header">
                        <span id="vennOverlapTitle">Shared Connections</span>
                        <button class="venn-close-btn" onclick="closeOverlapPanel()">
                            <i class="ph ph-x"></i>
                        </button>
                    </div>
                    <div class="venn-overlap-content" id="vennOverlapContent"></div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Relationships -->
        <div class="panel panel-right" id="panelRight">
            <button class="panel-collapse-btn" onclick="togglePanel('right')" title="Collapse sidebar">
                <i class="ph ph-caret-right"></i>
            </button>
            <!-- Simplified Filters -->
            <div class="panel-title" style="display: flex; align-items: center; gap: 0.5rem;">
                <i class="ph ph-funnel"></i>
                View Options
            </div>

            <div class="filter-simplified">
                <select class="filter-dropdown" id="connectionFilterDropdown" onchange="applySimplifiedFilters()">
                    <option value="all">All</option>
                    <option value="nesting">Nesting only</option>
                    <option value="activities">Activities only</option>
                </select>
                <select class="filter-dropdown" id="entityFilterDropdown" onchange="applySimplifiedFilters()">
                    <option value="all">All Entities</option>
                    <option value="structure">Units & Teams</option>
                    <option value="roles">Roles only</option>
                    <option value="people">People only</option>
                </select>
            </div>

            <!-- Advanced Filters (Collapsed) -->
            <div class="collapsible-section collapsed" id="advancedFiltersSection">
                <div class="collapsible-header" onclick="toggleCollapsible('advancedFiltersSection')">
                    <span>Advanced Filters <span class="badge">9 operators</span></span>
                    <i class="ph ph-caret-down collapse-icon"></i>
                </div>
                <div class="collapsible-content">
                    <p class="help-text">Filter by specific activity operators</p>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-top: 0.75rem;">
                        <label class="filter-pill" title="Recognize absence, remove, delete">
                            <input type="checkbox" id="filterNUL" checked onchange="applyFilters()">
                            <span>Notice</span>
                        </label>
                        <label class="filter-pill" title="Designate, describe, assign">
                            <input type="checkbox" id="filterDES" checked onchange="applyFilters()">
                            <span>Define</span>
                        </label>
                        <label class="filter-pill" title="Instantiate, create, initiate">
                            <input type="checkbox" id="filterINS" checked onchange="applyFilters()">
                            <span>Start</span>
                        </label>
                        <label class="filter-pill" title="Divide, segment, break down">
                            <input type="checkbox" id="filterSEG" checked onchange="applyFilters()">
                            <span>Divide</span>
                        </label>
                        <label class="filter-pill" title="Connect, associate, relate">
                            <input type="checkbox" id="filterCON" checked onchange="applyFilters()">
                            <span>Link</span>
                        </label>
                        <label class="filter-pill" title="Alternate, modify, switch">
                            <input type="checkbox" id="filterALT" checked onchange="applyFilters()">
                            <span>Shift</span>
                        </label>
                        <label class="filter-pill" title="Synthesize, combine, bring together">
                            <input type="checkbox" id="filterSYN" checked onchange="applyFilters()">
                            <span>Merge</span>
                        </label>
                        <label class="filter-pill" title="Superpose, balance multiple frames, oversee">
                            <input type="checkbox" id="filterSUP" checked onchange="applyFilters()">
                            <span>Balance</span>
                        </label>
                        <label class="filter-pill" title="Recurse, restructure, iterate">
                            <input type="checkbox" id="filterREC" checked onchange="applyFilters()">
                            <span>Loop</span>
                        </label>
                    </div>
                    <div style="margin-top: 1rem;">
                        <label style="font-size: 0.85rem; color: #6B5642; font-weight: 600; margin-bottom: 0.5rem; display: block;">Entity Types</label>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <label class="filter-pill" style="flex: 0 0 auto;">
                                <input type="checkbox" id="filterUnit" checked onchange="applyFilters()">
                                <span>Units</span>
                            </label>
                            <label class="filter-pill" style="flex: 0 0 auto;">
                                <input type="checkbox" id="filterTeam" checked onchange="applyFilters()">
                                <span>Teams</span>
                            </label>
                            <label class="filter-pill" style="flex: 0 0 auto;">
                                <input type="checkbox" id="filterRole" checked onchange="applyFilters()">
                                <span>Roles</span>
                            </label>
                            <label class="filter-pill" style="flex: 0 0 auto;">
                                <input type="checkbox" id="filterPerson" checked onchange="applyFilters()">
                                <span>People</span>
                            </label>
                            <label class="filter-pill" style="flex: 0 0 auto;">
                                <input type="checkbox" id="filterObject" checked onchange="applyFilters()">
                                <span>Objects</span>
                            </label>
                        </div>
                    </div>
                    <button class="btn btn-small btn-secondary" onclick="toggleAllFilters()" style="margin-top: 1rem; width: 100%;">Toggle All</button>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Simplified Connection Creation -->
            <div class="panel-title" style="display: flex; align-items: center; gap: 0.5rem;">
                <i class="ph ph-link"></i>
                <span class="friendly-label">Create Connection</span>
                <span class="technical-label">Create Activity</span>
            </div>

            <div style="background: #FAF7F5; padding: 1rem; border-radius: 6px;">
                <div class="input-group">
                    <label>
                        <span class="friendly-label">From</span>
                        <span class="technical-label">Subject</span>
                        <span class="help-text" style="margin-left: 0.25rem;">(who/what)</span>
                    </label>
                    <select id="subjectSelect" onchange="updateSentencePreview()">
                        <option value="">Select entity...</option>
                    </select>
                </div>

                <!-- Quick Operator Selector (3 main operators) -->
                <div class="quick-operator-selector">
                    <button class="operator-btn active" data-predicate="DES" onclick="selectSimplifiedPredicate('DES', this)" title="Creates a hierarchical relationship">
                        <div>Define</div>
                        <div class="operator-btn-subtitle">hierarchy</div>
                    </button>
                    <button class="operator-btn link-type" data-predicate="CON" onclick="selectSimplifiedPredicate('CON', this)" title="Connects work or responsibilities">
                        <div>Link</div>
                        <div class="operator-btn-subtitle">connect work</div>
                    </button>
                    <button class="operator-btn start-type" data-predicate="INS" onclick="selectSimplifiedPredicate('INS', this)" title="Assigns a person to a role">
                        <div>Start</div>
                        <div class="operator-btn-subtitle">assign</div>
                    </button>
                </div>

                <!-- More Operators Button -->
                <button class="show-more-btn" onclick="toggleAdvancedOperators()" id="moreOperatorsBtn">
                    <i class="ph ph-plus"></i>
                    More operators (6)
                </button>

                <!-- Advanced Operators (hidden by default) -->
                <div class="advanced-operators" id="advancedOperators">
                    <button class="predicate-btn NUL" onclick="selectPredicate('NUL')" title="Recognize absence, remove, delete">Notice</button>
                    <button class="predicate-btn SEG" onclick="selectPredicate('SEG')" title="Divide, segment, break down">Divide</button>
                    <button class="predicate-btn ALT" onclick="selectPredicate('ALT')" title="Alternate, modify, switch">Shift</button>
                    <button class="predicate-btn SYN" onclick="selectPredicate('SYN')" title="Synthesize, combine, bring together">Merge</button>
                    <button class="predicate-btn SUP" onclick="selectPredicate('SUP')" title="Superpose, balance multiple frames, oversee">Balance</button>
                    <button class="predicate-btn REC" onclick="selectPredicate('REC')" title="Recurse, restructure, iterate">Loop</button>
                </div>

                <div class="input-group" style="margin-top: 0.75rem;">
                    <label>
                        <span class="friendly-label">To</span>
                        <span class="technical-label">Object</span>
                        <span class="help-text" style="margin-left: 0.25rem;">(who/what)</span>
                    </label>
                    <select id="orgEntitySelect" onchange="handleOrgEntityChange()">
                        <option value="">Select entity...</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>
                        <span class="friendly-label">Or to Work Product</span>
                        <span class="technical-label">To Object (Work Product)</span>
                    </label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <select id="objectSelect" onchange="handleWorkObjectChange()" style="flex: 1;">
                            <option value="">Select work product...</option>
                        </select>
                        <button class="btn btn-small" onclick="toggleQuickCreateObject()" title="Quick create new work product" style="padding: 0.5rem; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;"><i class="ph ph-plus-circle" style="font-size: 1.25rem;"></i></button>
                    </div>
                    <div id="quickCreateObject" style="display: none; margin-top: 0.5rem; padding: 0.75rem; background: white; border-radius: 6px; border: 1px solid #E5DDD1;">
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <input type="text" id="quickObjectName" placeholder="Work product name..." onkeypress="if(event.key==='Enter') createQuickObject()" style="flex: 1; padding: 0.5rem; border: 1px solid #E5DDD1; border-radius: 4px; font-size: 0.875rem;">
                        </div>
                        <button class="btn btn-small" onclick="createQuickObject()" style="width: 100%;">Create Work Product</button>
                    </div>
                </div>

                <div class="sentence-preview" id="sentencePreview">
                    <em style="color: #8B6F47;">Select entities to preview connection...</em>
                </div>

                <button class="btn" onclick="addActivity()" style="width: 100%; margin-top: 0.75rem;">
                    <i class="ph ph-plus-circle" style="margin-right: 0.25rem;"></i>
                    <span class="friendly-label">Create Connection</span>
                    <span class="technical-label">Create Activity</span>
                </button>

                <!-- Add notes/details (collapsed) -->
                <button class="show-more-btn" onclick="toggleActivityDetails()" id="activityDetailsToggle">
                    <i class="ph ph-plus"></i>
                    Add notes or details
                </button>
                <div id="activityDetailsSection" style="display: none; margin-top: 0.75rem;">
                    <div class="input-group">
                        <label>Description</label>
                        <textarea id="activityDescription" placeholder="Add details about this connection..." maxlength="240" rows="2" style="width: 100%; padding: 0.5rem; border: 1px solid #E5DDD1; border-radius: 6px; font-family: inherit; font-size: 0.875rem; resize: vertical;"></textarea>
                        <div style="font-size: 0.75rem; color: #8B6F47; text-align: right; margin-top: 0.25rem;">
                            <span id="charCount">0</span>/240
                        </div>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="panel-title" style="font-size: 1rem;">
                <span class="friendly-label">Recent Activity</span>
                <span class="technical-label">All Relationships</span>
            </div>
            <div class="input-group" style="margin-bottom: 1rem;">
                <input type="text" id="activitySearch" placeholder="Search..." oninput="renderActivityList()">
            </div>
            <div id="activityList" class="relationship-list"></div>
        </div>
    </div>

    <!-- Entity Detail Modal -->
    <div id="entityModal" class="modal-overlay" onclick="if(event.target === this) closeEntityModal()">
        <div class="modal-dialog">
            <div class="modal-header-section">
                <button class="modal-close-btn" onclick="closeEntityModal()">
                    <i class="ph ph-x"></i>
                </button>
                <div class="modal-header-top">
                    <span class="modal-header-icon" id="modalEntityIcon"></span>
                    <div class="modal-header-content">
                        <div class="modal-title-wrapper">
                            <div class="modal-title-text" id="modalEntityName"></div>
                            <button class="modal-title-edit-btn" id="modalTitleEditBtn" onclick="openEntityEditModal()" title="Rename">
                                <i class="ph ph-pencil-simple"></i>
                            </button>
                        </div>
                        <div class="modal-type-badge" id="modalEntityType"></div>
                    </div>
                </div>
            </div>
            <div class="modal-body">
                <div class="modal-section" id="modalDescription"></div>
                <div class="modal-section" id="modalNested"></div>
                <div class="modal-section" id="modalAddNested"></div>
                <div class="modal-section" id="modalNestUnder"></div>
                <div class="modal-section" id="modalActivities"></div>
                <div class="modal-section" id="modalAddActivity"></div>
            </div>
            <div class="modal-actions" id="modalFooterButtons">
                <button class="modal-action-btn danger" id="modalDeleteButton" onclick="openDeleteConfirmModal()">
                    <i class="ph ph-trash"></i>
                    Delete
                </button>
                <div class="modal-action-spacer"></div>
                <button class="modal-action-btn secondary" onclick="closeEntityModal()">
                    Close
                </button>
                <button class="modal-action-btn primary" id="modalEditButton" onclick="openEntityEditModal()">
                    <i class="ph ph-pencil-simple"></i>
                    Edit
                </button>
            </div>
        </div>
    </div>

    <!-- Entity Edit Modal -->
    <div id="entityEditModal" class="entity-edit-modal-overlay" onclick="if(event.target === this) closeEntityEditModal()">
        <div class="entity-edit-modal">
            <div class="entity-edit-modal-header">
                <h3>
                    <i class="ph ph-pencil-simple"></i>
                    Edit Entity
                </h3>
            </div>
            <div class="entity-edit-modal-body">
                <div class="entity-edit-field">
                    <label class="entity-edit-label">Name</label>
                    <input type="text" class="entity-edit-input" id="entityEditNameInput" placeholder="Enter name...">
                </div>
                <div class="entity-edit-field">
                    <label class="entity-edit-label">Description <span class="char-limit">(<span id="editDescCharCount">0</span>/240)</span></label>
                    <textarea class="entity-edit-textarea" id="entityEditDescInput" placeholder="Add a description..." maxlength="240" oninput="updateEditDescCharCount()"></textarea>
                </div>
            </div>
            <div class="entity-edit-modal-actions">
                <button class="modal-action-btn danger mobile-only-delete" onclick="openDeleteConfirmModal()">
                    <i class="ph ph-trash"></i> Delete
                </button>
                <div style="flex: 1;"></div>
                <button class="modal-action-btn secondary" onclick="closeEntityEditModal()">Cancel</button>
                <button class="modal-action-btn primary" onclick="saveEntityEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="deleteConfirmModal" class="delete-confirm-overlay" onclick="if(event.target === this) closeDeleteConfirmModal()">
        <div class="delete-confirm-modal">
            <div class="delete-confirm-icon">
                <i class="ph ph-warning-circle"></i>
            </div>
            <div class="delete-confirm-content">
                <h3 id="deleteConfirmTitle">Delete Entity?</h3>
                <p id="deleteConfirmText">This will permanently remove this entity and all its nested items and activities.</p>
            </div>
            <div class="delete-confirm-actions">
                <button class="modal-action-btn secondary" onclick="closeDeleteConfirmModal()">Cancel</button>
                <button class="modal-action-btn danger" onclick="confirmDelete()">
                    <i class="ph ph-trash"></i>
                    Delete
                </button>
            </div>
        </div>
    </div>

    <!-- Work Product Selector Modal -->
    <div id="workProductSelectorModal" class="work-product-selector-overlay" onclick="if(event.target === this) closeWorkProductSelectorModal()">
        <div class="work-product-selector-modal">
            <div class="work-product-selector-header">
                <h3><i class="ph ph-package"></i> Select Work Product</h3>
                <button class="work-product-selector-close" onclick="closeWorkProductSelectorModal()">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="work-product-selector-search">
                <input type="text" id="workProductSearchInput" placeholder="Search work products..." oninput="filterWorkProducts()">
            </div>
            <div class="work-product-selector-content" id="workProductSelectorContent">
                <!-- Work products will be populated here dynamically -->
            </div>
            <div class="work-product-selector-footer">
                <div class="work-product-create-new">
                    <input type="text" id="newWorkProductName" placeholder="New work product name..." onkeypress="if(event.key==='Enter') createWorkProductFromModal()">
                    <button class="work-product-create-btn" onclick="createWorkProductFromModal()">
                        <i class="ph ph-plus"></i> Create
                    </button>
                </div>
                <button class="work-product-select-btn" id="confirmWorkProductSelection" onclick="confirmWorkProductSelection()" disabled>
                    Select
                </button>
            </div>
        </div>
    </div>

    <!-- Workspace Modal (Create/Rename) -->
    <div id="workspaceModal" class="workspace-modal-overlay" onclick="if(event.target === this) closeWorkspaceModal()">
        <div class="workspace-modal">
            <h3 id="workspaceModalTitle">New Workspace</h3>
            <input type="text" class="workspace-modal-input" id="workspaceModalInput" placeholder="Workspace name..." onkeypress="if(event.key==='Enter') saveWorkspaceFromModal()">
            <div class="workspace-modal-actions">
                <button class="workspace-modal-btn cancel" onclick="closeWorkspaceModal()">Cancel</button>
                <button class="workspace-modal-btn primary" onclick="saveWorkspaceFromModal()">Save</button>
            </div>
        </div>
    </div>

    <!-- Bulk Import Modal -->
    <div id="bulkImportModal" class="bulk-import-overlay" onclick="if(event.target === this) closeBulkImportModal()">
        <div class="bulk-import-modal">
            <div class="bulk-import-header">
                <h2><i class="ph ph-upload-simple"></i> Bulk Import</h2>
                <button class="bulk-import-close" onclick="closeBulkImportModal()">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="bulk-import-body">
                <!-- Step Indicator -->
                <div class="bulk-import-steps">
                    <div class="bulk-import-step active" id="bulkImportStep1">
                        <span class="bulk-import-step-number">1</span>
                        Select Type & Input Data
                    </div>
                    <div class="bulk-import-step" id="bulkImportStep2">
                        <span class="bulk-import-step-number">2</span>
                        Map Fields
                    </div>
                    <div class="bulk-import-step" id="bulkImportStep3">
                        <span class="bulk-import-step-number">3</span>
                        Review & Import
                    </div>
                </div>

                <!-- Step 1: Select Entity Type & Input Data -->
                <div id="bulkImportStepContent1">
                    <div class="bulk-import-section">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-tag"></i> What type of entity are you importing?
                        </div>
                        <div class="bulk-import-entity-type">
                            <button class="bulk-import-entity-btn" data-type="unit" onclick="selectBulkImportType('unit')">
                                <i class="ph ph-buildings"></i> Units
                            </button>
                            <button class="bulk-import-entity-btn" data-type="team" onclick="selectBulkImportType('team')">
                                <i class="ph ph-users-three"></i> Teams
                            </button>
                            <button class="bulk-import-entity-btn" data-type="role" onclick="selectBulkImportType('role')">
                                <i class="ph ph-briefcase"></i> Roles
                            </button>
                            <button class="bulk-import-entity-btn active" data-type="person" onclick="selectBulkImportType('person')">
                                <i class="ph ph-user"></i> People
                            </button>
                            <button class="bulk-import-entity-btn" data-type="object" onclick="selectBulkImportType('object')">
                                <i class="ph ph-package"></i> Objects
                            </button>
                        </div>
                    </div>

                    <div class="bulk-import-section">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-clipboard-text"></i> How would you like to input data?
                        </div>
                        <div class="bulk-import-tabs">
                            <button class="bulk-import-tab active" onclick="switchBulkImportTab('paste')">
                                <i class="ph ph-clipboard"></i> Paste from Spreadsheet
                            </button>
                            <button class="bulk-import-tab" onclick="switchBulkImportTab('file')">
                                <i class="ph ph-file-csv"></i> Upload CSV File
                            </button>
                        </div>

                        <!-- Paste Tab -->
                        <div id="bulkImportPasteTab">
                            <textarea
                                id="bulkImportPasteArea"
                                class="bulk-import-textarea"
                                placeholder="Paste rows from your spreadsheet here...

Example (tab-separated):
Name    Team    Email
John Doe    Engineering    john@example.com
Jane Smith    Design    jane@example.com

Or comma-separated:
Name,Team,Email
John Doe,Engineering,john@example.com"
                                oninput="parseBulkImportData()"></textarea>
                            <div class="bulk-import-hint">
                                <i class="ph ph-info"></i>
                                Supports tab-separated (copy from Excel/Sheets) or comma-separated values. First row should be headers.
                            </div>
                        </div>

                        <!-- File Upload Tab -->
                        <div id="bulkImportFileTab" style="display: none;">
                            <div class="bulk-import-file-upload" onclick="document.getElementById('bulkImportFileInput').click()">
                                <i class="ph ph-file-arrow-up"></i>
                                <div><strong>Click to upload</strong> or drag and drop</div>
                                <div style="font-size: 0.8rem; color: #8B6F47; margin-top: 0.5rem;">CSV files supported</div>
                                <input type="file" id="bulkImportFileInput" accept=".csv,.tsv,.txt" onchange="handleBulkImportFile(event)">
                            </div>
                            <div id="bulkImportFileName" style="margin-top: 0.75rem; font-size: 0.875rem; color: #6B5642;"></div>
                        </div>
                    </div>

                    <div id="bulkImportDataPreview" style="display: none;">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-eye"></i> Data Preview
                        </div>
                        <div class="bulk-import-preview">
                            <div class="bulk-import-preview-header">
                                <span>Detected Data</span>
                                <span class="bulk-import-preview-count" id="bulkImportRowCount">0 rows</span>
                            </div>
                            <div style="overflow-x: auto; max-height: 200px;">
                                <table class="bulk-import-preview-table" id="bulkImportPreviewTable">
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Field Mapping -->
                <div id="bulkImportStepContent2" style="display: none;">
                    <div class="bulk-import-section">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-arrows-left-right"></i> Map your columns to entity fields
                        </div>
                        <p style="font-size: 0.875rem; color: #8B6F47; margin-bottom: 1rem;">
                            Match your spreadsheet columns to the appropriate fields. Use "Set for All" to apply a default value to all imported items.
                        </p>
                        <div class="bulk-import-mapping" id="bulkImportMappingContainer">
                            <!-- Mapping rows will be dynamically generated -->
                        </div>
                    </div>

                    <div id="bulkImportMappedPreview" style="margin-top: 1.5rem;">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-eye"></i> Preview with Mapping Applied
                        </div>
                        <div class="bulk-import-preview">
                            <div class="bulk-import-preview-header">
                                <span>Mapped Data Preview</span>
                                <span class="bulk-import-preview-count" id="bulkImportMappedCount">0 items</span>
                            </div>
                            <div style="overflow-x: auto; max-height: 250px;">
                                <table class="bulk-import-preview-table" id="bulkImportMappedTable">
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 3: Review & Import -->
                <div id="bulkImportStepContent3" style="display: none;">
                    <div id="bulkImportReviewContent">
                        <div class="bulk-import-section">
                            <div class="bulk-import-section-title">
                                <i class="ph ph-check-square"></i> Review Import
                            </div>
                            <div style="background: #FAF7F5; padding: 1.25rem; border-radius: 8px; margin-bottom: 1rem;">
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
                                    <div>
                                        <div style="font-size: 2rem; font-weight: 700; color: #C88F4A;" id="bulkImportTotalCount">0</div>
                                        <div style="font-size: 0.875rem; color: #6B5642;">Total Items</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 2rem; font-weight: 700; color: #4CAF50;" id="bulkImportValidCount">0</div>
                                        <div style="font-size: 0.875rem; color: #6B5642;">Valid</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 2rem; font-weight: 700; color: #d32f2f;" id="bulkImportErrorCount">0</div>
                                        <div style="font-size: 0.875rem; color: #6B5642;">Errors</div>
                                    </div>
                                </div>
                            </div>
                            <div style="font-size: 0.875rem; color: #6B5642; margin-bottom: 1rem;" id="bulkImportEntityTypeLabel">
                                Importing as: <strong>People</strong>
                            </div>
                        </div>

                        <div class="bulk-import-preview">
                            <div class="bulk-import-preview-header">
                                <span>Final Preview</span>
                                <span class="bulk-import-preview-count" id="bulkImportFinalCount">0 items</span>
                            </div>
                            <div style="overflow-x: auto; max-height: 300px;">
                                <table class="bulk-import-preview-table" id="bulkImportFinalTable">
                                </table>
                            </div>
                        </div>
                    </div>

                    <div id="bulkImportSuccessContent" style="display: none;">
                        <div class="bulk-import-success">
                            <i class="ph ph-check-circle"></i>
                            <h3>Import Successful!</h3>
                            <p id="bulkImportSuccessMessage">Successfully imported 0 items.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="bulk-import-footer">
                <div class="bulk-import-footer-info" id="bulkImportFooterInfo">
                    Select an entity type and paste or upload your data to continue.
                </div>
                <div class="bulk-import-footer-actions">
                    <button class="bulk-import-btn secondary" id="bulkImportBackBtn" onclick="bulkImportBack()" style="display: none;">
                        <i class="ph ph-arrow-left"></i> Back
                    </button>
                    <button class="bulk-import-btn primary" id="bulkImportNextBtn" onclick="bulkImportNext()" disabled>
                        <i class="ph ph-arrow-right"></i> Next
                    </button>
                    <button class="bulk-import-btn primary" id="bulkImportImportBtn" onclick="executeBulkImport()" style="display: none;">
                        <i class="ph ph-check"></i> Import
                    </button>
                    <button class="bulk-import-btn primary" id="bulkImportDoneBtn" onclick="closeBulkImportModal()" style="display: none;">
                        <i class="ph ph-check"></i> Done
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // WORKSPACE MANAGEMENT
        // ==========================================

        // Workspace manager - stores all workspaces
        let workspaces = {};  // { workspaceId: { id, name, entities, relationships, hasSampleData, createdAt, updatedAt } }
        let currentWorkspaceId = null;
        let workspaceModalMode = 'create';  // 'create' or 'rename'
        let workspaceToRename = null;

        function generateWorkspaceId() {
            return 'ws_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function loadWorkspaces() {
            try {
                const saved = localStorage.getItem('holonicWorkspaces');
                if (saved) {
                    const data = JSON.parse(saved);
                    workspaces = data.workspaces || {};
                    currentWorkspaceId = data.currentWorkspaceId || null;

                    // Validate current workspace exists
                    if (currentWorkspaceId && !workspaces[currentWorkspaceId]) {
                        currentWorkspaceId = Object.keys(workspaces)[0] || null;
                    }

                    return Object.keys(workspaces).length > 0;
                }

                // Migration: Check for old single-workspace format
                const oldData = localStorage.getItem('holonicOrgData');
                if (oldData) {
                    const parsed = JSON.parse(oldData);
                    const wsId = generateWorkspaceId();
                    workspaces[wsId] = {
                        id: wsId,
                        name: parsed.workspaceName || 'My Organization',
                        entities: parsed.entities || { unit: [], team: [], role: [], person: [], object: [] },
                        relationships: parsed.relationships || [],
                        hasSampleData: parsed.hasSampleData || false,
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };
                    currentWorkspaceId = wsId;
                    saveWorkspaces();
                    // Remove old format
                    localStorage.removeItem('holonicOrgData');
                    localStorage.removeItem('workspaceName');
                    return true;
                }
            } catch (e) {
                console.error('Failed to load workspaces:', e);
            }
            return false;
        }

        function saveWorkspaces() {
            try {
                // Update current workspace data before saving
                if (currentWorkspaceId && workspaces[currentWorkspaceId]) {
                    workspaces[currentWorkspaceId].entities = JSON.parse(JSON.stringify(entities));
                    workspaces[currentWorkspaceId].relationships = JSON.parse(JSON.stringify(relationships));
                    workspaces[currentWorkspaceId].hasSampleData = hasSampleData;
                    workspaces[currentWorkspaceId].updatedAt = Date.now();
                }

                const data = {
                    workspaces,
                    currentWorkspaceId
                };
                localStorage.setItem('holonicWorkspaces', JSON.stringify(data));
            } catch (e) {
                console.error('Failed to save workspaces:', e);
            }
        }

        function switchWorkspace(workspaceId) {
            if (!workspaces[workspaceId]) return;

            // Save current workspace first
            saveWorkspaces();

            // Switch to new workspace
            currentWorkspaceId = workspaceId;
            const ws = workspaces[workspaceId];

            // Load workspace data
            entities = JSON.parse(JSON.stringify(ws.entities || { unit: [], team: [], role: [], person: [], object: [] }));
            relationships = JSON.parse(JSON.stringify(ws.relationships || []));
            hasSampleData = ws.hasSampleData || false;

            // Update UI
            document.getElementById('workspaceNameText').textContent = ws.name;

            // Update sample data button
            const btnText = document.getElementById('sampleDataText');
            if (btnText) {
                btnText.textContent = hasSampleData ? 'Clear Sample Data' : 'Load Sample Data';
            }

            // Load undo history for this workspace
            loadUndoHistory();

            // Re-render everything
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            // Save the switch
            saveWorkspaces();

            // Close dropdown
            closeWorkspaceDropdown();

            console.log('Switched to workspace:', ws.name);
        }

        function createWorkspace(name) {
            const wsId = generateWorkspaceId();
            workspaces[wsId] = {
                id: wsId,
                name: name.trim() || 'New Workspace',
                entities: { unit: [], team: [], role: [], person: [], object: [] },
                relationships: [],
                hasSampleData: false,
                createdAt: Date.now(),
                updatedAt: Date.now()
            };
            saveWorkspaces();
            switchWorkspace(wsId);
            renderWorkspaceList();
            return wsId;
        }

        function renameWorkspace(workspaceId, newName) {
            if (!workspaces[workspaceId]) return;
            workspaces[workspaceId].name = newName.trim() || workspaces[workspaceId].name;
            workspaces[workspaceId].updatedAt = Date.now();

            // Update display if it's the current workspace
            if (workspaceId === currentWorkspaceId) {
                document.getElementById('workspaceNameText').textContent = workspaces[workspaceId].name;
            }

            saveWorkspaces();
            renderWorkspaceList();
        }

        function deleteWorkspace(workspaceId) {
            if (!workspaces[workspaceId]) return;

            const wsName = workspaces[workspaceId].name;
            const wsCount = Object.keys(workspaces).length;

            if (wsCount <= 1) {
                alert('Cannot delete the last workspace. Create a new workspace first.');
                return;
            }

            if (!confirm(`Delete workspace "${wsName}"? This cannot be undone.`)) return;

            delete workspaces[workspaceId];

            // If we deleted the current workspace, switch to another
            if (workspaceId === currentWorkspaceId) {
                const remainingIds = Object.keys(workspaces);
                if (remainingIds.length > 0) {
                    switchWorkspace(remainingIds[0]);
                }
            }

            saveWorkspaces();
            renderWorkspaceList();
        }

        // ==========================================
        // UNDO HISTORY FUNCTIONS
        // ==========================================

        function pushToUndoHistory(action) {
            // Add timestamp if not present
            if (!action.timestamp) {
                action.timestamp = Date.now();
            }

            undoHistory.push(action);

            // Trim history if it exceeds max size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory = undoHistory.slice(-MAX_UNDO_HISTORY);
            }

            // Save history to localStorage
            saveUndoHistory();
            updateUndoButton();
        }

        function undo() {
            if (undoHistory.length === 0) {
                showUndoNotification('Nothing to undo');
                return;
            }

            const action = undoHistory.pop();

            switch (action.type) {
                case 'create_entity':
                    // Undo entity creation - delete it (but don't add to recycle bin)
                    const entityType = action.entityType;
                    entities[entityType] = entities[entityType].filter(e => e.id !== action.data.id);
                    // Also remove any relationships created with it
                    relationships = relationships.filter(r => r.subject !== action.data.id && r.object !== action.data.id);
                    break;

                case 'delete_entity':
                    // Undo entity deletion - restore it
                    entities[action.entityType].push(action.data);
                    // Restore relationships that were deleted with it
                    if (action.deletedRelationships) {
                        relationships.push(...action.deletedRelationships);
                    }
                    // Remove from recycle bin if present
                    recycleBin = recycleBin.filter(item =>
                        !(item.itemType === 'entity' && item.item.id === action.data.id)
                    );
                    break;

                case 'update_entity':
                    // Undo entity update - restore old values
                    const entity = findEntity(action.data.id);
                    if (entity) {
                        entity.name = action.oldData.name;
                        entity.description = action.oldData.description;
                    }
                    break;

                case 'create_relationship':
                    // Undo relationship creation - delete it
                    relationships = relationships.filter(r => r.id !== action.data.id);
                    break;

                case 'delete_relationship':
                    // Undo relationship deletion - restore it
                    relationships.push(action.data);
                    // Remove from recycle bin if present
                    recycleBin = recycleBin.filter(item =>
                        !(item.itemType === 'relationship' && item.item.id === action.data.id)
                    );
                    break;
            }

            saveToLocalStorage();
            saveUndoHistory();
            updateUndoButton();
            refreshAllViews();

            showUndoNotification(`Undone: ${action.description}`);
        }

        function saveUndoHistory() {
            try {
                if (currentWorkspaceId) {
                    localStorage.setItem(`undoHistory_${currentWorkspaceId}`, JSON.stringify(undoHistory));
                    localStorage.setItem(`recycleBin_${currentWorkspaceId}`, JSON.stringify(recycleBin));
                }
            } catch (e) {
                console.error('Failed to save undo history:', e);
            }
        }

        function loadUndoHistory() {
            try {
                if (currentWorkspaceId) {
                    const savedHistory = localStorage.getItem(`undoHistory_${currentWorkspaceId}`);
                    const savedRecycleBin = localStorage.getItem(`recycleBin_${currentWorkspaceId}`);
                    undoHistory = savedHistory ? JSON.parse(savedHistory) : [];
                    recycleBin = savedRecycleBin ? JSON.parse(savedRecycleBin) : [];
                } else {
                    undoHistory = [];
                    recycleBin = [];
                }
            } catch (e) {
                console.error('Failed to load undo history:', e);
                undoHistory = [];
                recycleBin = [];
            }
            updateUndoButton();
            renderRecycleBin();
        }

        function clearUndoHistory() {
            undoHistory = [];
            saveUndoHistory();
            updateUndoButton();
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            const undoCount = document.getElementById('undoCount');
            if (undoBtn) {
                undoBtn.disabled = undoHistory.length === 0;
                undoBtn.title = undoHistory.length > 0
                    ? `Undo: ${undoHistory[undoHistory.length - 1]?.description || 'last action'} (Ctrl+Z)`
                    : 'Nothing to undo';
            }
            if (undoCount) {
                undoCount.textContent = undoHistory.length;
                undoCount.style.display = undoHistory.length > 0 ? 'inline' : 'none';
            }
        }

        function showUndoNotification(message) {
            // Create or update notification element
            let notification = document.getElementById('undoNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'undoNotification';
                notification.className = 'undo-notification';
                document.body.appendChild(notification);
            }

            notification.textContent = message;
            notification.classList.add('show');

            // Hide after 2 seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        // ==========================================
        // RECYCLE BIN FUNCTIONS
        // ==========================================

        function addToRecycleBin(item, itemType, entityType, deletedRelationships = []) {
            recycleBin.push({
                item: JSON.parse(JSON.stringify(item)),
                itemType,
                entityType,
                deletedAt: Date.now(),
                deletedRelationships: deletedRelationships.map(r => JSON.parse(JSON.stringify(r)))
            });
            saveUndoHistory();
            renderRecycleBin();
        }

        function restoreFromRecycleBin(index) {
            if (index < 0 || index >= recycleBin.length) return;

            const entry = recycleBin[index];

            if (entry.itemType === 'entity') {
                // Restore entity
                entities[entry.entityType].push(entry.item);
                // Restore associated relationships
                if (entry.deletedRelationships) {
                    relationships.push(...entry.deletedRelationships);
                }
            } else if (entry.itemType === 'relationship') {
                // Restore relationship
                relationships.push(entry.item);
            }

            // Remove from recycle bin
            recycleBin.splice(index, 1);

            saveToLocalStorage();
            saveUndoHistory();
            refreshAllViews();
            renderRecycleBin();

            showUndoNotification(`Restored: ${entry.item.name || 'item'}`);
        }

        function permanentlyDelete(index) {
            if (index < 0 || index >= recycleBin.length) return;

            const entry = recycleBin[index];
            const itemName = entry.item.name || 'item';

            if (!confirm(`Permanently delete "${itemName}"? This cannot be undone.`)) return;

            recycleBin.splice(index, 1);
            saveUndoHistory();
            renderRecycleBin();

            showUndoNotification(`Permanently deleted: ${itemName}`);
        }

        function emptyRecycleBin() {
            if (recycleBin.length === 0) {
                showUndoNotification('Recycle bin is empty');
                return;
            }

            if (!confirm(`Permanently delete all ${recycleBin.length} item(s) in recycle bin? This cannot be undone.`)) return;

            recycleBin = [];
            saveUndoHistory();
            renderRecycleBin();

            showUndoNotification('Recycle bin emptied');
        }

        function renderRecycleBin() {
            const container = document.getElementById('recycleBinList');
            if (!container) return;

            const countEl = document.getElementById('recycleBinCount');
            if (countEl) {
                countEl.textContent = recycleBin.length;
                countEl.style.display = recycleBin.length > 0 ? 'inline' : 'none';
            }

            if (recycleBin.length === 0) {
                container.innerHTML = '<div class="recycle-bin-empty"><i class="ph ph-trash"></i><p>Recycle bin is empty</p></div>';
                return;
            }

            container.innerHTML = recycleBin.map((entry, index) => {
                const icon = entry.itemType === 'entity' ? getIcon(entry.entityType) : '<i class="ph ph-link"></i>';
                const name = entry.item.name || `${entry.item.subject}  ${entry.item.object}`;
                const typeLabel = entry.itemType === 'entity' ? entry.entityType : 'connection';
                const timeAgo = getTimeAgo(entry.deletedAt);

                return `
                    <div class="recycle-bin-item">
                        <div class="recycle-bin-item-info">
                            <span class="recycle-bin-icon">${icon}</span>
                            <div class="recycle-bin-details">
                                <span class="recycle-bin-name">${name}</span>
                                <span class="recycle-bin-meta">${typeLabel}  ${timeAgo}</span>
                            </div>
                        </div>
                        <div class="recycle-bin-actions">
                            <button class="btn-icon" onclick="restoreFromRecycleBin(${index})" title="Restore">
                                <i class="ph ph-arrow-counter-clockwise"></i>
                            </button>
                            <button class="btn-icon delete" onclick="permanentlyDelete(${index})" title="Delete permanently">
                                <i class="ph ph-x"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);

            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function refreshAllViews() {
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();
            renderRecycleBin();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            } else if (currentView === 'venn') {
                renderVennView();
            }
        }

        function toggleWorkspaceDropdown(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('workspaceDropdown');
            const isOpen = dropdown.classList.contains('open');

            if (isOpen) {
                closeWorkspaceDropdown();
            } else {
                dropdown.classList.add('open');
                renderWorkspaceList();

                // Close dropdown when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeWorkspaceDropdownOnOutsideClick);
                }, 0);
            }
        }

        function closeWorkspaceDropdown() {
            const dropdown = document.getElementById('workspaceDropdown');
            dropdown.classList.remove('open');
            document.removeEventListener('click', closeWorkspaceDropdownOnOutsideClick);
        }

        function closeWorkspaceDropdownOnOutsideClick(event) {
            const dropdown = document.getElementById('workspaceDropdown');
            const toggle = document.querySelector('.workspace-dropdown-toggle');

            if (!dropdown.contains(event.target) && !toggle.contains(event.target)) {
                closeWorkspaceDropdown();
            }
        }

        function renderWorkspaceList() {
            const listEl = document.getElementById('workspaceList');
            if (!listEl) return;

            const sortedWorkspaces = Object.values(workspaces).sort((a, b) => b.updatedAt - a.updatedAt);

            listEl.innerHTML = sortedWorkspaces.map(ws => `
                <div class="workspace-item ${ws.id === currentWorkspaceId ? 'active' : ''}" onclick="switchWorkspace('${ws.id}')">
                    <div class="workspace-item-name">
                        <i class="ph ${ws.id === currentWorkspaceId ? 'ph-check-circle' : 'ph-folder'}"></i>
                        <span>${escapeHtml(ws.name)}</span>
                    </div>
                    <div class="workspace-item-actions">
                        <button class="workspace-action-btn" onclick="event.stopPropagation(); openRenameWorkspaceModal('${ws.id}')" title="Rename">
                            <i class="ph ph-pencil-simple"></i>
                        </button>
                        <button class="workspace-action-btn delete" onclick="event.stopPropagation(); deleteWorkspace('${ws.id}')" title="Delete">
                            <i class="ph ph-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function openNewWorkspaceModal() {
            workspaceModalMode = 'create';
            workspaceToRename = null;
            document.getElementById('workspaceModalTitle').textContent = 'New Workspace';
            document.getElementById('workspaceModalInput').value = '';
            document.getElementById('workspaceModalInput').placeholder = 'Workspace name...';
            document.getElementById('workspaceModal').classList.add('open');
            setTimeout(() => document.getElementById('workspaceModalInput').focus(), 100);
            closeWorkspaceDropdown();
        }

        function openRenameWorkspaceModal(workspaceId) {
            if (!workspaces[workspaceId]) return;
            workspaceModalMode = 'rename';
            workspaceToRename = workspaceId;
            document.getElementById('workspaceModalTitle').textContent = 'Rename Workspace';
            document.getElementById('workspaceModalInput').value = workspaces[workspaceId].name;
            document.getElementById('workspaceModalInput').placeholder = 'Workspace name...';
            document.getElementById('workspaceModal').classList.add('open');
            setTimeout(() => {
                const input = document.getElementById('workspaceModalInput');
                input.focus();
                input.select();
            }, 100);
            closeWorkspaceDropdown();
        }

        function closeWorkspaceModal() {
            document.getElementById('workspaceModal').classList.remove('open');
            workspaceModalMode = 'create';
            workspaceToRename = null;
        }

        function saveWorkspaceFromModal() {
            const name = document.getElementById('workspaceModalInput').value.trim();
            if (!name) {
                alert('Please enter a workspace name.');
                return;
            }

            if (workspaceModalMode === 'create') {
                createWorkspace(name);
            } else if (workspaceModalMode === 'rename' && workspaceToRename) {
                renameWorkspace(workspaceToRename, name);
            }

            closeWorkspaceModal();
        }

        // ==========================================
        // ENTITY DATA STRUCTURE
        // ==========================================

        // Data structure
        let entities = {
            unit: [],
            team: [],
            role: [],
            person: [],
            object: []
        };

        let relationships = [];

        // Modal state - stores current entity being viewed
        let currentModalEntity = null;
        let currentModalEntityType = null;

        // EO Operators - Emergence Operators for activity modeling
        // Internal codes used for data store, friendly labels for UI
        // 
        // APPEND-ONLY ACTIVITY TRACKING:
        // Every action creates a new record in Xano activity_store
        // - Creates: INS (Start)
        // - Updates: ALT (Shift) 
        // - Deletes: NUL (Notice)
        // - Nesting: DES (Define) for hierarchical parent-child relationships
        // - Activities: CON (Link), INS (Start), etc. for connections between roles
        // - Structural: SEG (Break), REC (Loop), SYN (Merge)
        // - Oversight: SUP (Hold)
        //
        // External (UI)  Internal (Data Store)
        // Notice  NUL | Define  DES | Start  INS
        // Divide  SEG | Link  CON | Shift  ALT
        // Merge  SYN | Balance  SUP | Loop  REC
        const eoOperators = {
            NUL: { 
                code: 'NUL', 
                label: 'Notice', 
                fullLabel: 'NULLIFY',
                color: '#6B5642', 
                description: 'Recognize absence, remove, delete', 
                style: 'solid', 
                weight: 3 
            },
            DES: { 
                code: 'DES', 
                label: 'Define', 
                fullLabel: 'DESIGNATE',
                color: '#C88F4A', 
                description: 'Designate, describe, assign', 
                style: 'solid', 
                weight: 2 
            },
            INS: { 
                code: 'INS', 
                label: 'Start', 
                fullLabel: 'INSERT',
                color: '#8B6F47', 
                description: 'Instantiate, create, initiate', 
                style: 'solid', 
                weight: 2 
            },
            SEG: { 
                code: 'SEG', 
                label: 'Divide', 
                fullLabel: 'SEGMENT',
                color: '#A89984', 
                description: 'Divide, segment, break down', 
                style: 'dashed', 
                weight: 1 
            },
            CON: { 
                code: 'CON', 
                label: 'Link', 
                fullLabel: 'CONNECT',
                color: '#7B95A3', 
                description: 'Connect, associate, relate', 
                style: 'solid', 
                weight: 1 
            },
            ALT: { 
                code: 'ALT', 
                label: 'Shift', 
                fullLabel: 'ALTER',
                color: '#B87B5B', 
                description: 'Alternate, modify, switch', 
                style: 'solid', 
                weight: 2 
            },
            SYN: { 
                code: 'SYN', 
                label: 'Merge', 
                fullLabel: 'SYNTHESIZE',
                color: '#D4A574', 
                description: 'Synthesize, combine, bring together', 
                style: 'solid', 
                weight: 2 
            },
            SUP: { 
                code: 'SUP', 
                label: 'Balance', 
                fullLabel: 'SUPERSEDE',
                color: '#9B6F47', 
                description: 'Superpose, balance multiple frames, oversee', 
                style: 'solid', 
                weight: 3 
            },
            REC: { 
                code: 'REC', 
                label: 'Loop', 
                fullLabel: 'RECONFIGURE',
                color: '#C8997F', 
                description: 'Recurse, restructure, iterate', 
                style: 'dashed', 
                weight: 2 
            }
        };
        
        // Xano configuration
        const XANO_BASE_URL = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:nrIL-Oi-';
        const APP_ID = 'holonic-org-graph'; // Your app identifier
        
        let selectedEntityType = 'unit';
        let selectedPredicate = 'DES'; // Default to Define operator
        let focusedNode = null;
        let currentView = 'card';

        // ==========================================
        // UNDO HISTORY & RECYCLE BIN
        // ==========================================

        // Undo history stack - stores all changes for undo functionality
        // Each entry: { type: 'create'|'update'|'delete', entityType, data, timestamp, description }
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 100; // Maximum number of undo steps to keep

        // Recycle bin - stores deleted entities and relationships
        // Each entry: { item, itemType: 'entity'|'relationship', entityType, deletedAt, deletedRelationships }
        let recycleBin = [];

        // Mobile detection helper
        function isMobile() {
            return window.innerWidth <= 640;
        }

        // Graph visualization variables
        let width = 800;
        let height = 600;
        let graphSimulation, graphLink, graphNode, graphLinkText;

        // Venn diagram state
        let vennCurrentLevel = 0; // 0: units, 1: teams, 2: roles, 3: people
        const vennLevels = ['unit', 'team', 'role', 'person'];
        const vennLevelLabels = ['Units', 'Teams', 'Roles', 'People'];
        let vennFocusedEntity = null; // When drilling down into a specific entity
        let vennBreadcrumb = []; // Track navigation path

        // View switching
        function switchView(view) {
            currentView = view;

            document.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.view === view) {
                    btn.classList.add('active');
                }
            });

            document.getElementById('treeView').classList.remove('active');
            document.getElementById('cardView').classList.remove('active');
            document.getElementById('graphView').classList.remove('active');
            document.getElementById('vennView').classList.remove('active');

            if (view === 'tree') {
                document.getElementById('treeView').classList.add('active');
                renderTreeView();
            } else if (view === 'card' || view === 'cards') {
                document.getElementById('cardView').classList.add('active');
                renderCardView();
            } else if (view === 'venn') {
                document.getElementById('vennView').classList.add('active');
                setTimeout(() => renderVennView(), 100);
            } else {
                document.getElementById('graphView').classList.add('active');
                setTimeout(() => updateGraph(), 100);
            }
        }

        // Initialize with sample data
        // Entity Modal
        function openEntityModal(entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Store entity data for edit function
            currentModalEntity = entity;
            currentModalEntityType = entityType;

            // Set header content
            document.getElementById('modalEntityIcon').innerHTML = getIcon(entityType);
            document.getElementById('modalEntityName').textContent = entity.name;

            // For roles, show team context in the type badge for disambiguation
            let typeBadgeContent = `${getIcon(entityType)} ${entityType.toUpperCase()}`;
            if (entityType === 'role') {
                const parentTeam = getRoleParentTeam(entityId);
                if (parentTeam) {
                    typeBadgeContent = `${getIcon(entityType)} ROLE in ${getIcon(parentTeam.type)} ${parentTeam.name}`;
                }
            }
            document.getElementById('modalEntityType').innerHTML = typeBadgeContent;

            // Show edit and delete buttons for entities
            document.getElementById('modalEditButton').style.display = 'inline-flex';
            document.getElementById('modalDeleteButton').style.display = 'inline-flex';
            document.getElementById('modalTitleEditBtn').style.display = 'flex';

            // Display description - compact on mobile when empty
            const descriptionEl = document.getElementById('modalDescription');
            if (entity.description && entity.description.trim()) {
                descriptionEl.innerHTML = `
                    <div class="modal-section-title"><i class="ph ph-text-align-left"></i> Description</div>
                    <div class="modal-description-text">${entity.description}</div>
                `;
                descriptionEl.style.display = '';
            } else {
                // On mobile, hide empty description section entirely
                if (isMobile()) {
                    descriptionEl.style.display = 'none';
                } else {
                    descriptionEl.innerHTML = `
                        <div class="modal-section-title"><i class="ph ph-text-align-left"></i> Description</div>
                        <div class="modal-description-empty">No description yet. Click Edit to add one.</div>
                    `;
                    descriptionEl.style.display = '';
                }
            }

            // Separate relationships into Nesting (DES) and Activities (non-DES)
            const nestedRelationships = relationships.filter(r =>
                r.predicate === 'DES' && (r.subject === entityId || r.object === entityId)
            );
            const activityRelationships = relationships.filter(r =>
                r.predicate !== 'DES' && (r.subject === entityId || r.object === entityId)
            );

            // Get nested entities (DES relationships - hierarchical)
            const nestedEntities = [];
            nestedRelationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !nestedEntities.find(c => c.id === conn.id)) {
                        nestedEntities.push({ ...conn, direction: 'child' }); // This entity defines/contains the connected one
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !nestedEntities.find(c => c.id === conn.id)) {
                        nestedEntities.push({ ...conn, direction: 'parent' }); // The connected entity defines/contains this one
                    }
                }
            });

            // Get activity entities (non-DES relationships)
            const activityEntities = [];
            activityRelationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !activityEntities.find(c => c.id === conn.id)) {
                        activityEntities.push(conn);
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !activityEntities.find(c => c.id === conn.id)) {
                        activityEntities.push(conn);
                    }
                }
            });

            // Render Nested section (DES relationships - hierarchical structure)
            const nestedEl = document.getElementById('modalNested');
            const useMobileView = isMobile();

            // Check if entity can have nested items
            const canHaveNested = ['unit', 'team'].includes(entityType);

            if (nestedEntities.length > 0) {
                // Create header with view toggle and inline add button
                nestedEl.innerHTML = `
                    <div class="connections-header">
                        <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-tree-structure"></i> Nested</div>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            ${canHaveNested ? `<button class="section-add-btn" onclick="toggleInlineNestedForm()" title="Add nested"><i class="ph ph-plus"></i></button>` : ''}
                            <div class="view-toggle">
                                <button class="view-toggle-btn" data-view="orbital" onclick="switchNestedView('orbital', '${entityId}', '${entityType}')">
                                    <i class="ph ph-planet"></i>
                                </button>
                                <button class="view-toggle-btn active" data-view="list" onclick="switchNestedView('list', '${entityId}', '${entityType}')">
                                    <i class="ph ph-list"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    ${canHaveNested ? `
                    <div id="inlineNestedForm" class="inline-add-form hidden">
                        <div class="inline-add-row">
                            <select id="inlineNestedSelect">
                                <option value="">Select entity to nest...</option>
                                ${getAllEntitiesForNesting(entityId, entityType)}
                            </select>
                            <button class="inline-add-btn" onclick="addNestedFromInline()"><i class="ph ph-plus"></i> Add</button>
                        </div>
                    </div>
                    ` : ''}
                `;

                // Container for the view content
                const viewContainer = document.createElement('div');
                viewContainer.id = 'nestedViewContainer';
                nestedEl.appendChild(viewContainer);

                // Default to list view for all devices
                renderGroupedConnections(viewContainer, nestedEntities, entityId);
            } else {
                // Empty state - show add form if entity can have nested items
                if (canHaveNested) {
                    nestedEl.innerHTML = `
                        <div class="connections-header">
                            <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-tree-structure"></i> Nested</div>
                            <button class="section-add-btn" onclick="toggleInlineNestedForm()" title="Add nested"><i class="ph ph-plus"></i></button>
                        </div>
                        <div id="inlineNestedForm" class="inline-add-form hidden">
                            <div class="inline-add-row">
                                <select id="inlineNestedSelect">
                                    <option value="">Select entity to nest...</option>
                                    ${getAllEntitiesForNesting(entityId, entityType)}
                                </select>
                                <button class="inline-add-btn" onclick="addNestedFromInline()"><i class="ph ph-plus"></i> Add</button>
                            </div>
                        </div>
                        <div class="modal-empty-state">
                            <i class="ph ph-tree-structure"></i>
                            <div>No nested items</div>
                        </div>
                    `;
                } else {
                    nestedEl.innerHTML = '';
                }
            }

            // Hide the separate Add Nested section - functionality is now inline
            const addNestedEl = document.getElementById('modalAddNested');
            addNestedEl.innerHTML = '';

            // Parent UI - shows what this entity is nested inside
            const nestUnderEl = document.getElementById('modalNestUnder');
            // Show for entity types that can have parents (units can nest under units, teams under units/teams, roles under units/teams)
            const parentOptions = getParentOptionsForNesting(entityId, entityType);

            // Find current parent(s) for this entity
            const currentParents = relationships
                .filter(r => r.predicate === 'DES' && r.subject === entityId)
                .map(r => findEntity(r.object))
                .filter(Boolean);

            if (['unit', 'team', 'role'].includes(entityType)) {
                nestUnderEl.innerHTML = `
                    <div class="connections-header">
                        <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-arrow-bend-up-left"></i> Parent</div>
                        <button class="section-add-btn" onclick="toggleInlineParentForm()" title="Set parent"><i class="ph ph-plus"></i></button>
                    </div>
                    ${currentParents.length > 0 ? `
                        <div class="nested-chips-container" style="margin-bottom: 0.75rem;">
                            ${currentParents.map(parent => `
                                <span class="entity-chip ${parent.type}" onclick="openEntityModal('${parent.id}')" style="cursor: pointer;">
                                    <i class="ph ${getEntityIcon(parent.type)}"></i>
                                    ${parent.name}
                                    <button class="chip-remove-btn" onclick="event.stopPropagation(); removeParentRelationship('${entityId}', '${parent.id}')" title="Remove parent">
                                        <i class="ph ph-x"></i>
                                    </button>
                                </span>
                            `).join('')}
                        </div>
                    ` : ''}
                    <div id="inlineParentForm" class="inline-add-form hidden">
                        <div class="inline-add-row">
                            <select id="modalNestUnderSelect">
                                <option value="">Select parent...</option>
                                ${parentOptions || ''}
                            </select>
                            <button class="inline-add-btn" onclick="nestUnderFromModal()"><i class="ph ph-plus"></i> Add</button>
                        </div>
                    </div>
                    ${currentParents.length === 0 ? `
                        <div class="modal-empty-state">
                            <i class="ph ph-arrow-bend-up-left"></i>
                            <div>No parent</div>
                        </div>
                    ` : ''}
                `;
            } else {
                nestUnderEl.innerHTML = '';
            }

            // Render Activities section (non-DES relationships)
            const activitiesEl = document.getElementById('modalActivities');
            // Build inline add form HTML for activities
            const inlineActivityFormHtml = `
                <div id="inlineActivityForm" class="inline-add-form hidden">
                    <div class="inline-add-row">
                        <select id="inlineOperatorSelect">
                            <option value="">Type...</option>
                            ${Object.entries(eoOperators)
                                .filter(([code]) => code !== 'DES')
                                .map(([code, op]) => `<option value="${code}">${op.label}</option>`)
                                .join('')}
                        </select>
                        <select id="inlineTargetSelect">
                            <option value="">Connect to...</option>
                            ${getAllEntitiesForModal(entityId)}
                        </select>
                        <button class="inline-add-btn" onclick="addActivityFromInline()"><i class="ph ph-plus"></i> Add</button>
                    </div>
                </div>
            `;

            if (activityEntities.length > 0) {
                // Create header with view toggle and inline add button
                activitiesEl.innerHTML = `
                    <div class="connections-header">
                        <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-arrows-left-right"></i> Activities</div>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <button class="section-add-btn" onclick="toggleInlineActivityForm()" title="Add activity"><i class="ph ph-plus"></i></button>
                            <div class="view-toggle">
                                <button class="view-toggle-btn" data-view="orbital" onclick="switchActivitiesView('orbital', '${entityId}', '${entityType}')">
                                    <i class="ph ph-planet"></i>
                                </button>
                                <button class="view-toggle-btn active" data-view="list" onclick="switchActivitiesView('list', '${entityId}', '${entityType}')">
                                    <i class="ph ph-list"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    ${inlineActivityFormHtml}
                `;

                // Container for the view content
                const viewContainer = document.createElement('div');
                viewContainer.id = 'activitiesViewContainer';
                activitiesEl.appendChild(viewContainer);

                // Default to list view for all devices
                renderGroupedConnections(viewContainer, activityEntities, entityId);
            } else {
                activitiesEl.innerHTML = `
                    <div class="connections-header">
                        <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-arrows-left-right"></i> Activities</div>
                        <button class="section-add-btn" onclick="toggleInlineActivityForm()" title="Add activity"><i class="ph ph-plus"></i></button>
                    </div>
                    ${inlineActivityFormHtml}
                    <div class="modal-empty-state">
                        <i class="ph ph-arrows-left-right"></i>
                        <div>No activities yet</div>
                    </div>
                `;
            }

            // Add activity UI
            const addActivityEl = document.getElementById('modalAddActivity');

            // Work products can only be linked to roles and teams, not people
            const canLinkWorkProduct = entityType === 'role' || entityType === 'team';

            addActivityEl.innerHTML = `
                <div class="modal-section-title"><i class="ph ph-plus-circle"></i> Add Activity</div>
                <div class="modal-add-connection">
                    <div class="modal-add-connection-row">
                        <select id="modalOperatorSelect" onchange="handleModalOperatorChange()">
                            <option value="">Type...</option>
                            ${Object.entries(eoOperators)
                                .filter(([code]) => code !== 'DES') // Exclude DES since that's for nesting
                                .map(([code, op]) => `<option value="${code}">${op.label}</option>`)
                                .join('')}
                        </select>
                        <select id="modalTargetSelect">
                            <option value="">Connect to...</option>
                            ${getAllEntitiesForModal(entityId, entityType === 'person')}
                        </select>
                        <button class="modal-add-connection-btn" onclick="addActivityFromModal()">
                            <i class="ph ph-plus"></i> Add
                        </button>
                    </div>
                    ${canLinkWorkProduct ? `
                    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px dashed #E5DDD1;">
                        <div style="font-size: 0.8rem; color: #8B6F47; margin-bottom: 0.5rem; font-weight: 500;">
                            <i class="ph ph-package"></i> Or link to a Work Product
                        </div>
                        <div class="modal-add-connection-row">
                            <select id="modalWorkProductOperatorSelect">
                                <option value="">Type...</option>
                                ${Object.entries(eoOperators)
                                    .filter(([code]) => code !== 'DES')
                                    .map(([code, op]) => `<option value="${code}">${op.label}</option>`)
                                    .join('')}
                            </select>
                            <button type="button" class="modal-work-product-selector-btn" id="modalWorkProductBtn" onclick="openWorkProductSelectorForModal()">
                                <i class="ph ph-package btn-icon"></i>
                                <span id="modalWorkProductBtnText">Select work product...</span>
                            </button>
                            <input type="hidden" id="modalSelectedWorkProductId" value="">
                            <button class="modal-add-connection-btn" onclick="addWorkProductActivityFromModal()">
                                <i class="ph ph-plus"></i> Add
                            </button>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;

            document.getElementById('entityModal').classList.add('active');
        }

        function closeEntityModal() {
            document.getElementById('entityModal').classList.remove('active');
        }

        // Orbital visualization for connections
        // connectionType: 'nested' for DES relationships, 'activity' for non-DES, undefined for all
        function renderOrbitalConnections(container, centerEntity, connections, connectionType) {
            // Guard against invalid container
            if (!container) return;

            // Get dimensions with better fallback
            const containerRect = container.getBoundingClientRect();
            const width = containerRect.width > 0 ? containerRect.width : (container.clientWidth || 400);
            const height = 300;
            const centerX = width / 2;
            const centerY = height / 2;

            // Clear container thoroughly - remove any existing SVG first
            d3.select(container).selectAll('svg').remove();
            container.innerHTML = '';

            // Determine ring color based on connection type
            const ringColor = connectionType === 'nested' ? '#C88F4A' :
                              connectionType === 'activity' ? '#7B95A3' : '#A89984';

            // Group connections by type for better organization
            const groupedConnections = {};
            const typeOrder = ['team', 'unit', 'role', 'person', 'object'];

            connections.forEach(conn => {
                if (!groupedConnections[conn.type]) {
                    groupedConnections[conn.type] = [];
                }
                groupedConnections[conn.type].push(conn);
            });

            // Flatten maintaining type grouping
            const sortedConnections = [];
            typeOrder.forEach(type => {
                if (groupedConnections[type]) {
                    sortedConnections.push(...groupedConnections[type]);
                }
            });

            // Get nested connections for each item (items that THEY connect to)
            const nestedMap = new Map();
            sortedConnections.forEach(conn => {
                const nested = [];
                relationships.forEach(r => {
                    // For nested view, only show DES relationships from the connected items
                    // For activity view, only show non-DES relationships
                    const shouldInclude = connectionType === 'nested' ? r.predicate === 'DES' :
                                          connectionType === 'activity' ? r.predicate !== 'DES' : true;
                    if (shouldInclude && (r.subject === conn.id || r.object === conn.id)) {
                        const otherId = r.subject === conn.id ? r.object : r.subject;
                        if (otherId !== centerEntity.id) {
                            const otherEntity = findEntity(otherId);
                            if (otherEntity && !nested.find(n => n.id === otherEntity.id)) {
                                nested.push(otherEntity);
                            }
                        }
                    }
                });
                nestedMap.set(conn.id, nested);
            });

            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('class', 'orbital-svg')
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            // Draw orbital rings
            const maxConnections = sortedConnections.length;
            const innerRadius = 70;
            const outerRadius = Math.min(width, height) / 2 - 40;

            // Primary orbit ring with color based on connection type
            svg.append('circle')
                .attr('class', 'orbital-ring')
                .attr('cx', centerX)
                .attr('cy', centerY)
                .attr('r', innerRadius)
                .style('stroke', ringColor);

            // Secondary orbit ring (for nested items preview)
            if (Array.from(nestedMap.values()).some(arr => arr.length > 0)) {
                svg.append('circle')
                    .attr('class', 'orbital-ring')
                    .attr('cx', centerX)
                    .attr('cy', centerY)
                    .attr('r', outerRadius)
                    .style('stroke', ringColor)
                    .style('opacity', 0.5);
            }

            // Calculate positions for orbital nodes
            const angleStep = (2 * Math.PI) / Math.max(sortedConnections.length, 1);
            const startAngle = -Math.PI / 2; // Start from top

            // Draw connections lines first (behind nodes)
            sortedConnections.forEach((conn, i) => {
                const angle = startAngle + (i * angleStep);
                const x = centerX + innerRadius * Math.cos(angle);
                const y = centerY + innerRadius * Math.sin(angle);

                svg.append('line')
                    .attr('class', 'orbital-link')
                    .attr('x1', centerX)
                    .attr('y1', centerY)
                    .attr('x2', x)
                    .attr('y2', y)
                    .style('stroke', ringColor);

                // Draw lines to nested items (faded)
                const nested = nestedMap.get(conn.id) || [];
                if (nested.length > 0) {
                    // Show up to 3 nested preview dots
                    const previewCount = Math.min(nested.length, 3);
                    const nestedAngleSpread = Math.PI / 6;

                    for (let j = 0; j < previewCount; j++) {
                        const nestedAngle = angle + (j - (previewCount - 1) / 2) * (nestedAngleSpread / previewCount);
                        const nestedX = centerX + outerRadius * Math.cos(nestedAngle);
                        const nestedY = centerY + outerRadius * Math.sin(nestedAngle);

                        svg.append('line')
                            .attr('class', 'orbital-link')
                            .attr('x1', x)
                            .attr('y1', y)
                            .attr('x2', nestedX)
                            .attr('y2', nestedY)
                            .style('stroke', '#E5DDD1')
                            .style('stroke-width', 1)
                            .style('opacity', 0.5);

                        // Small preview dot for nested item
                        const nestedEntity = nested[j];
                        const previewGroup = svg.append('g')
                            .attr('class', 'orbital-node')
                            .attr('transform', `translate(${nestedX}, ${nestedY})`)
                            .style('cursor', 'pointer')
                            .on('click', () => openEntityModal(nestedEntity.id, nestedEntity.type));

                        previewGroup.append('circle')
                            .attr('r', 12)
                            .attr('class', 'orbital-node-circle')
                            .style('fill', getNodeColor(nestedEntity.type))
                            .style('opacity', 0.7);

                        // Add tiny icon
                        previewGroup.append('text')
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'central')
                            .attr('font-size', '10px')
                            .attr('fill', 'white')
                            .text(getIconChar(nestedEntity.type));
                    }

                    // If more nested items, show count
                    if (nested.length > 3) {
                        const countAngle = angle;
                        const countX = centerX + (outerRadius + 15) * Math.cos(countAngle);
                        const countY = centerY + (outerRadius + 15) * Math.sin(countAngle);

                        svg.append('text')
                            .attr('x', countX)
                            .attr('y', countY)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'central')
                            .attr('font-size', '9px')
                            .attr('fill', '#8B6F47')
                            .text(`+${nested.length - 3}`);
                    }
                }
            });

            // Draw center node
            const centerGroup = svg.append('g')
                .attr('class', 'orbital-center')
                .attr('transform', `translate(${centerX}, ${centerY})`);

            centerGroup.append('circle')
                .attr('r', 32)
                .attr('class', 'orbital-center-circle');

            // Center icon (using text for simplicity with Phosphor)
            centerGroup.append('text')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'central')
                .attr('font-size', '20px')
                .attr('fill', 'white')
                .text(getIconChar(centerEntity.type));

            // Draw orbital nodes
            sortedConnections.forEach((conn, i) => {
                const angle = startAngle + (i * angleStep);
                const x = centerX + innerRadius * Math.cos(angle);
                const y = centerY + innerRadius * Math.sin(angle);
                const nested = nestedMap.get(conn.id) || [];
                const hasNested = nested.length > 0;

                const nodeGroup = svg.append('g')
                    .attr('class', 'orbital-node')
                    .attr('transform', `translate(${x}, ${y})`)
                    .style('cursor', 'pointer')
                    .on('click', () => openEntityModal(conn.id, conn.type));

                // Node circle
                nodeGroup.append('circle')
                    .attr('r', 22)
                    .attr('class', 'orbital-node-circle')
                    .style('fill', getNodeColor(conn.type));

                // Nested indicator ring
                if (hasNested) {
                    nodeGroup.append('circle')
                        .attr('r', 26)
                        .style('fill', 'none')
                        .style('stroke', '#C88F4A')
                        .style('stroke-width', 2)
                        .style('stroke-dasharray', '3,2');
                }

                // Icon
                nodeGroup.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('font-size', '14px')
                    .attr('fill', 'white')
                    .text(getIconChar(conn.type));

                // Label - position radially based on angle
                const labelRadius = 40; // Distance from node center

                // Normalize angle to 0-2 range
                const normalizedAngle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

                // Determine label position based on quadrant
                // Right side: 315 to 45 (labels go right)
                // Left side: 135 to 225 (labels go left)
                // Top: 45 to 135 (labels go up)
                // Bottom: 225 to 315 (labels go down)

                const isRight = normalizedAngle < Math.PI / 4 || normalizedAngle > 7 * Math.PI / 4;
                const isLeft = normalizedAngle > 3 * Math.PI / 4 && normalizedAngle < 5 * Math.PI / 4;
                const isTop = normalizedAngle >= Math.PI / 4 && normalizedAngle <= 3 * Math.PI / 4;
                const isBottom = normalizedAngle >= 5 * Math.PI / 4 && normalizedAngle <= 7 * Math.PI / 4;

                let labelX = 0;
                let labelY = 0;
                let textAnchor = 'middle';

                if (isRight) {
                    labelX = labelRadius;
                    labelY = 4;
                    textAnchor = 'start';
                } else if (isLeft) {
                    labelX = -labelRadius;
                    labelY = 4;
                    textAnchor = 'end';
                } else if (isTop) {
                    labelX = 0;
                    labelY = -labelRadius + 4;
                    textAnchor = 'middle';
                } else if (isBottom) {
                    labelX = 0;
                    labelY = labelRadius + 4;
                    textAnchor = 'middle';
                } else {
                    // Diagonal positions - push outward at angle
                    labelX = Math.cos(angle) * labelRadius;
                    labelY = Math.sin(angle) * labelRadius + 4;
                    textAnchor = Math.cos(angle) > 0 ? 'start' : 'end';
                }

                // Smarter truncation - longer limit for side labels
                const maxChars = (isRight || isLeft) ? 18 : 14;
                const labelText = conn.name.length > maxChars ? conn.name.substring(0, maxChars - 2) + '' : conn.name;

                nodeGroup.append('text')
                    .attr('class', 'orbital-node-label')
                    .attr('x', labelX)
                    .attr('y', labelY)
                    .attr('text-anchor', textAnchor)
                    .text(labelText);

                // Nested count badge
                if (hasNested) {
                    nodeGroup.append('circle')
                        .attr('cx', 16)
                        .attr('cy', -16)
                        .attr('r', 9)
                        .style('fill', '#C88F4A')
                        .style('stroke', 'white')
                        .style('stroke-width', 2);

                    nodeGroup.append('text')
                        .attr('x', 16)
                        .attr('y', -16)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'central')
                        .attr('font-size', '9px')
                        .attr('font-weight', '600')
                        .attr('fill', 'white')
                        .text(nested.length);
                }
            });
        }

        // Helper to get icon character for SVG text
        function getIconChar(type) {
            const icons = {
                unit: '',
                team: '',
                role: '',
                person: '',
                object: ''
            };
            return icons[type] || '';
        }

        // Switch between orbital and list views for connections
        function switchConnectionsView(view, entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Get connections
            const connections = [];
            relationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !connections.find(c => c.id === conn.id)) {
                        connections.push(conn);
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !connections.find(c => c.id === conn.id)) {
                        connections.push(conn);
                    }
                }
            });

            // Update toggle buttons
            document.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Get container and clear it
            const viewContainer = document.getElementById('connectionsViewContainer');
            if (!viewContainer) return;
            viewContainer.innerHTML = '';

            if (view === 'orbital') {
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'orbital-container';
                viewContainer.appendChild(orbitalContainer);
                setTimeout(() => {
                    renderOrbitalConnections(orbitalContainer, entity, connections);
                }, 0);
            } else {
                renderGroupedConnections(viewContainer, connections, entityId);
            }
        }

        // Switch between orbital and list views for nested items
        function switchNestedView(view, entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Get nested entities (DES relationships only)
            const nestedRelationships = relationships.filter(r =>
                r.predicate === 'DES' && (r.subject === entityId || r.object === entityId)
            );
            const nestedEntities = [];
            nestedRelationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !nestedEntities.find(c => c.id === conn.id)) {
                        nestedEntities.push({ ...conn, direction: 'child' });
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !nestedEntities.find(c => c.id === conn.id)) {
                        nestedEntities.push({ ...conn, direction: 'parent' });
                    }
                }
            });

            // Update toggle buttons in nested section
            const nestedEl = document.getElementById('modalNested');
            nestedEl.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Get container and clear it
            const viewContainer = document.getElementById('nestedViewContainer');
            if (!viewContainer) return;
            viewContainer.innerHTML = '';

            if (view === 'orbital') {
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'orbital-container';
                viewContainer.appendChild(orbitalContainer);
                setTimeout(() => {
                    renderOrbitalConnections(orbitalContainer, entity, nestedEntities, 'nested');
                }, 0);
            } else {
                renderGroupedConnections(viewContainer, nestedEntities, entityId);
            }
        }

        // Switch between orbital and list views for activities
        function switchActivitiesView(view, entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Get activity entities (non-DES relationships only)
            const activityRelationships = relationships.filter(r =>
                r.predicate !== 'DES' && (r.subject === entityId || r.object === entityId)
            );
            const activityEntities = [];
            activityRelationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !activityEntities.find(c => c.id === conn.id)) {
                        activityEntities.push(conn);
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !activityEntities.find(c => c.id === conn.id)) {
                        activityEntities.push(conn);
                    }
                }
            });

            // Update toggle buttons in activities section
            const activitiesEl = document.getElementById('modalActivities');
            activitiesEl.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Get container and clear it
            const viewContainer = document.getElementById('activitiesViewContainer');
            if (!viewContainer) return;
            viewContainer.innerHTML = '';

            if (view === 'orbital') {
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'orbital-container';
                viewContainer.appendChild(orbitalContainer);
                setTimeout(() => {
                    renderOrbitalConnections(orbitalContainer, entity, activityEntities, 'activity');
                }, 0);
            } else {
                renderGroupedConnections(viewContainer, activityEntities, entityId);
            }
        }

        // Render grouped connections (fallback for many items)
        function renderGroupedConnections(container, connections, centerEntityId) {
            const typeLabels = {
                unit: { label: 'Units', icon: 'ph-buildings' },
                team: { label: 'Teams', icon: 'ph-users-three' },
                role: { label: 'Roles', icon: 'ph-briefcase' },
                person: { label: 'People', icon: 'ph-user' },
                object: { label: 'Work Products', icon: 'ph-package' }
            };

            // Group by type
            const grouped = {};
            connections.forEach(conn => {
                if (!grouped[conn.type]) grouped[conn.type] = [];
                grouped[conn.type].push(conn);
            });

            const wrapper = document.createElement('div');
            wrapper.className = 'connections-grouped';

            Object.keys(typeLabels).forEach(type => {
                if (grouped[type] && grouped[type].length > 0) {
                    const group = document.createElement('div');
                    group.className = 'connection-group';

                    const title = document.createElement('div');
                    title.className = 'connection-group-title';
                    title.innerHTML = `<i class="ph ${typeLabels[type].icon}"></i> ${typeLabels[type].label}`;
                    group.appendChild(title);

                    const items = document.createElement('div');
                    items.className = 'connection-group-items';

                    grouped[type].forEach(conn => {
                        // Check for nested connections
                        const nestedCount = relationships.filter(r =>
                            (r.subject === conn.id || r.object === conn.id) &&
                            r.subject !== centerEntityId && r.object !== centerEntityId
                        ).length;

                        const badge = document.createElement('div');
                        badge.className = 'connection-badge' + (nestedCount > 0 ? ' has-nested' : '');
                        badge.style.position = 'relative';
                        badge.innerHTML = `${getIcon(conn.type)} ${conn.name}`;

                        if (nestedCount > 0) {
                            const countEl = document.createElement('span');
                            countEl.className = 'nested-count';
                            countEl.textContent = nestedCount;
                            badge.appendChild(countEl);
                        }

                        badge.onclick = () => openEntityModal(conn.id, conn.type);
                        items.appendChild(badge);
                    });

                    group.appendChild(items);
                    wrapper.appendChild(group);
                }
            });

            container.appendChild(wrapper);
        }

        // Helper function to get all entities for modal dropdown (excluding current entity)
        // excludeWorkProducts: if true, work products won't be shown (e.g., for person entities)
        function getAllEntitiesForModal(excludeId, excludeWorkProducts = false) {
            let options = '';
            let entityTypes = ['unit', 'team', 'role', 'person', 'object'];

            // Exclude work products if specified (e.g., for person entities)
            if (excludeWorkProducts) {
                entityTypes = entityTypes.filter(t => t !== 'object');
            }

            const typeLabels = {
                unit: 'Units',
                team: 'Teams',
                role: 'Roles',
                person: 'People',
                object: 'Work Products'
            };

            entityTypes.forEach(type => {
                const typeEntities = entities[type].filter(e => e.id !== excludeId);
                if (typeEntities.length > 0) {
                    options += `<optgroup label="${typeLabels[type]}">`;
                    typeEntities.forEach(e => {
                        // For roles, add team context for disambiguation
                        let displayName = e.name;
                        if (type === 'role') {
                            const parentTeam = getRoleParentTeam(e.id);
                            if (parentTeam) {
                                displayName = `${e.name} (${parentTeam.name})`;
                            }
                        }
                        options += `<option value="${e.id}">${displayName}</option>`;
                    });
                    options += '</optgroup>';
                }
            });

            return options;
        }

        // Add connection from modal
        function addConnectionFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = document.getElementById('modalOperatorSelect').value;
            const targetId = document.getElementById('modalTargetSelect').value;

            if (!operatorCode || !targetId) {
                alert('Please select both an operator and a target entity');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Validate connection
            const validationError = validateConnection(currentModalEntity, targetEntity, operatorCode);
            if (validationError) {
                alert(validationError);
                return;
            }

            // Create the relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[operatorCode];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${currentModalEntity.name}  ${targetEntity.name}`
            });

            // Log to Xano
            logActivityToXano({
                event_verb: `${operatorData.label} Connection`,
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new connection
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Helper function to get entities that can be nested under the current entity
        function getAllEntitiesForNesting(excludeId, entityType) {
            let options = '';
            // Define what can be nested under each entity type
            const nestableTypes = {
                unit: ['unit', 'team', 'role'], // Units can contain sub-units, teams, and roles
                team: ['team', 'role'],          // Teams can contain sub-teams and roles
                role: [],                         // Roles cannot contain other entities
                person: [],                       // People cannot contain other entities
                object: []                        // Objects cannot contain other entities
            };

            const typeLabels = {
                unit: 'Units',
                team: 'Teams',
                role: 'Roles'
            };

            const allowedTypes = nestableTypes[entityType] || [];

            allowedTypes.forEach(type => {
                const typeEntities = entities[type].filter(e => {
                    // Exclude the current entity
                    if (e.id === excludeId) return false;
                    // Exclude entities already nested under this one
                    const alreadyNested = relationships.some(r =>
                        r.predicate === 'DES' && r.subject === excludeId && r.object === e.id
                    );
                    return !alreadyNested;
                });
                if (typeEntities.length > 0) {
                    options += `<optgroup label="${typeLabels[type]}">`;
                    typeEntities.forEach(e => {
                        // For roles, add team context for disambiguation
                        let displayName = e.name;
                        if (type === 'role') {
                            const parentTeam = getRoleParentTeam(e.id);
                            if (parentTeam) {
                                displayName = `${e.name} (${parentTeam.name})`;
                            }
                        }
                        options += `<option value="${e.id}">${displayName}</option>`;
                    });
                    options += '</optgroup>';
                }
            });

            return options;
        }

        // Get valid parent entities that this entity can be nested under
        function getParentOptionsForNesting(entityId, entityType) {
            let options = '';
            // Define what can contain each entity type (inverse of nestableTypes)
            const parentTypes = {
                unit: ['unit'],          // Units can be nested under other units
                team: ['unit', 'team'],  // Teams can be nested under units or other teams
                role: ['unit', 'team'],  // Roles can be nested under units or teams
                person: [],              // People don't get nested
                object: []               // Objects don't get nested
            };

            const typeLabels = {
                unit: 'Units',
                team: 'Teams'
            };

            const allowedTypes = parentTypes[entityType] || [];

            allowedTypes.forEach(type => {
                const typeEntities = entities[type].filter(e => {
                    // Exclude the current entity
                    if (e.id === entityId) return false;
                    // Exclude entities that this is already nested under
                    const alreadyNestedUnder = relationships.some(r =>
                        r.predicate === 'DES' && r.subject === e.id && r.object === entityId
                    );
                    return !alreadyNestedUnder;
                });
                if (typeEntities.length > 0) {
                    options += `<optgroup label="${typeLabels[type]}">`;
                    typeEntities.forEach(e => {
                        options += `<option value="${e.id}">${e.name}</option>`;
                    });
                    options += '</optgroup>';
                }
            });

            return options;
        }

        // Nest this entity under a parent (creates DES relationship with parent as subject)
        function nestUnderFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const parentId = document.getElementById('modalNestUnderSelect').value;

            if (!parentId) {
                alert('Please select a parent to nest under');
                return;
            }

            const parentEntity = findEntity(parentId);
            if (!parentEntity) {
                alert('Parent entity not found');
                return;
            }

            // Create the DES relationship (parent defines/contains this entity)
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: parentId,
                predicate: 'DES',
                object: currentModalEntity.id,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Nest ${currentModalEntity.name} under ${parentEntity.name}`
            });

            // Log to Xano
            const operatorData = eoOperators['DES'];
            logActivityToXano({
                event_verb: 'Nest Entity',
                eo_operator: 'DES',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${parentEntity.name} contains ${currentModalEntity.name}`,
                data_json: {
                    subject_id: parentId,
                    subject_type: parentEntity.type,
                    subject_name: parentEntity.name,
                    predicate: 'DES',
                    predicate_label: operatorData.label,
                    object_id: currentModalEntity.id,
                    object_type: currentModalEntityType,
                    object_name: currentModalEntity.name,
                    connection_type: 'nesting'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new nesting
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Add nested entity from modal (creates DES relationship)
        // Toggle inline nested form visibility
        function toggleInlineNestedForm() {
            const form = document.getElementById('inlineNestedForm');
            if (form) {
                form.classList.toggle('hidden');
            }
        }

        // Toggle inline activity form visibility
        function toggleInlineActivityForm() {
            const form = document.getElementById('inlineActivityForm');
            if (form) {
                form.classList.toggle('hidden');
            }
        }

        // Toggle inline parent form visibility
        function toggleInlineParentForm() {
            const form = document.getElementById('inlineParentForm');
            if (form) {
                form.classList.toggle('hidden');
            }
        }

        // Remove parent relationship (unlink from parent)
        function removeParentRelationship(childId, parentId) {
            // Find and remove the DES relationship where child is subject and parent is object
            const relIndex = relationships.findIndex(r =>
                r.predicate === 'DES' && r.subject === childId && r.object === parentId
            );

            if (relIndex !== -1) {
                const removedRel = relationships.splice(relIndex, 1)[0];

                // Log to Xano
                logToXano({ action: 'delete_relationship', data: removedRel });

                // Refresh views
                render();
                openEntityModal(childId);
            }
        }

        // Add nested from inline form (mobile)
        function addNestedFromInline() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const targetId = document.getElementById('inlineNestedSelect')?.value;
            if (!targetId) {
                alert('Please select an entity to nest');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Create the DES relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: 'DES',
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Nest ${targetEntity.name} under ${currentModalEntity.name}`
            });

            // Log to Xano
            const operatorData = eoOperators['DES'];
            logActivityToXano({
                event_verb: 'Nest Entity',
                eo_operator: 'DES',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} contains ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: 'DES',
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name,
                    connection_type: 'nesting'
                }
            });

            saveToLocalStorage();
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            }
        }

        // Add activity from inline form (mobile)
        function addActivityFromInline() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = document.getElementById('inlineOperatorSelect')?.value;
            const targetId = document.getElementById('inlineTargetSelect')?.value;

            if (!operatorCode || !targetId) {
                alert('Please select both a type and target');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[operatorCode];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${currentModalEntity.name}  ${targetEntity.name}`
            });

            logActivityToXano({
                event_verb: 'Create Relationship',
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name
                }
            });

            saveToLocalStorage();
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            if (currentView === 'graph') {
                updateGraph();
            }
        }

        function addNestedFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const targetId = document.getElementById('modalNestedTargetSelect').value;

            if (!targetId) {
                alert('Please select an entity to nest');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Create the DES relationship (current entity defines/contains the target)
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: 'DES',
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Nest ${targetEntity.name} under ${currentModalEntity.name}`
            });

            // Log to Xano
            const operatorData = eoOperators['DES'];
            logActivityToXano({
                event_verb: 'Nest Entity',
                eo_operator: 'DES',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} contains ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: 'DES',
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name,
                    connection_type: 'nesting'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new nesting
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Add activity from modal (creates non-DES relationship)
        function addActivityFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = document.getElementById('modalOperatorSelect').value;
            const targetId = document.getElementById('modalTargetSelect').value;

            if (!operatorCode || !targetId) {
                alert('Please select both an activity type and a target entity');
                return;
            }

            // DES should not be used here - it's for nesting
            if (operatorCode === 'DES') {
                alert('Use "Add Nested" for hierarchical relationships');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Validate connection
            const validationError = validateConnection(currentModalEntity, targetEntity, operatorCode);
            if (validationError) {
                alert(validationError);
                return;
            }

            // Create the relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[operatorCode];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${currentModalEntity.name}  ${targetEntity.name}`
            });

            // Log to Xano
            logActivityToXano({
                event_verb: `${operatorData.label} Activity`,
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name,
                    connection_type: 'activity'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new activity
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Entity Edit Modal Functions
        function openEntityEditModal() {
            if (!currentModalEntity) return;

            document.getElementById('entityEditNameInput').value = currentModalEntity.name;
            document.getElementById('entityEditDescInput').value = currentModalEntity.description || '';
            updateEditDescCharCount();
            document.getElementById('entityEditModal').classList.add('open');

            // Focus and select the input
            setTimeout(() => {
                const input = document.getElementById('entityEditNameInput');
                input.focus();
                input.select();
            }, 100);
        }

        function updateEditDescCharCount() {
            const textarea = document.getElementById('entityEditDescInput');
            const count = document.getElementById('editDescCharCount');
            if (textarea && count) {
                count.textContent = textarea.value.length;
            }
        }

        function closeEntityEditModal() {
            document.getElementById('entityEditModal').classList.remove('open');
        }

        function saveEntityEdit() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const newName = document.getElementById('entityEditNameInput').value.trim();
            const newDesc = document.getElementById('entityEditDescInput').value.trim();

            if (!newName) {
                closeEntityEditModal();
                return;
            }

            const nameChanged = newName !== currentModalEntity.name;
            const descChanged = newDesc !== (currentModalEntity.description || '');

            if (!nameChanged && !descChanged) {
                closeEntityEditModal();
                return;
            }

            const currentName = currentModalEntity.name;
            const currentDesc = currentModalEntity.description || '';

            // Track in undo history before making changes
            pushToUndoHistory({
                type: 'update_entity',
                entityType: currentModalEntityType,
                data: { id: currentModalEntity.id },
                oldData: { name: currentName, description: currentDesc },
                description: `Edit ${currentModalEntityType}: ${currentName}${nameChanged ? `  ${newName}` : ''}`
            });

            // Update entity
            currentModalEntity.name = newName;
            currentModalEntity.description = newDesc;

            // Log to Xano
            if (nameChanged) {
                logActivityToXano({
                    event_verb: 'Shift Entity',
                    eo_operator: 'ALT',
                    object_type: currentModalEntityType,
                    object_id: currentModalEntity.id,
                    object_label: `${currentName}  ${newName}`,
                    data_json: {
                        old_name: currentName,
                        new_name: newName,
                        entity_type: currentModalEntityType
                    }
                });
            }

            if (descChanged) {
                logActivityToXano({
                    event_verb: 'Shift Description',
                    eo_operator: 'ALT',
                    object_type: currentModalEntityType,
                    object_id: currentModalEntity.id,
                    object_label: `Updated description for ${newName}`,
                    data_json: {
                        entity_name: newName,
                        old_description: currentDesc,
                        new_description: newDesc,
                        entity_type: currentModalEntityType
                    }
                });
            }

            // Close edit modal and update main modal
            closeEntityEditModal();
            document.getElementById('modalEntityName').textContent = newName;

            // Update description display in modal
            const descriptionEl = document.getElementById('modalDescription');
            if (newDesc) {
                descriptionEl.innerHTML = `
                    <div class="modal-section-title"><i class="ph ph-text-align-left"></i> Description</div>
                    <div class="modal-description-text">${newDesc}</div>
                `;
            } else {
                descriptionEl.innerHTML = `
                    <div class="modal-section-title"><i class="ph ph-text-align-left"></i> Description</div>
                    <div class="modal-description-empty">No description yet. Click Edit to add one.</div>
                `;
            }

            // Save and refresh views
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+Z or Cmd+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                // Don't trigger undo if user is typing in an input field
                const activeElement = document.activeElement;
                const isInputField = activeElement.tagName === 'INPUT' ||
                                   activeElement.tagName === 'TEXTAREA' ||
                                   activeElement.isContentEditable;
                if (!isInputField) {
                    e.preventDefault();
                    undo();
                }
            }

            // Enter key for edit modal
            if (e.key === 'Enter' && document.getElementById('entityEditModal').classList.contains('open')) {
                saveEntityEdit();
            }

            // Escape key for closing modals
            if (e.key === 'Escape') {
                if (document.getElementById('deleteConfirmModal').classList.contains('open')) {
                    closeDeleteConfirmModal();
                } else if (document.getElementById('entityEditModal').classList.contains('open')) {
                    closeEntityEditModal();
                } else if (document.getElementById('entityModal').classList.contains('active')) {
                    closeEntityModal();
                }
            }
        });

        // Delete Confirmation Modal Functions
        function openDeleteConfirmModal() {
            if (!currentModalEntity) return;

            document.getElementById('deleteConfirmTitle').textContent = 'Delete Entity?';
            document.getElementById('deleteConfirmText').textContent =
                `This will permanently remove "${currentModalEntity.name}" and all its nested items and activities.`;
            document.getElementById('deleteConfirmModal').classList.add('open');
        }

        function closeDeleteConfirmModal() {
            document.getElementById('deleteConfirmModal').classList.remove('open');
            relationshipToDelete = null;
        }

        function confirmDelete() {
            // Check if we're deleting a relationship or entity
            if (relationshipToDelete) {
                confirmDeleteRelationship();
            } else if (currentModalEntity) {
                confirmDeleteEntity();
            }
        }

        function confirmDeleteEntity() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const entityId = currentModalEntity.id;
            const entityName = currentModalEntity.name;
            const entityType = currentModalEntityType;

            // Capture entity data before deletion
            const entityData = JSON.parse(JSON.stringify(currentModalEntity));

            // Remove related relationships
            const removedRelationships = relationships.filter(r =>
                r.subject === entityId || r.object === entityId
            );

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_entity',
                entityType: entityType,
                data: entityData,
                deletedRelationships: removedRelationships.map(r => JSON.parse(JSON.stringify(r))),
                description: `Delete ${entityType}: ${entityName}`
            });

            // Add to recycle bin
            addToRecycleBin(entityData, 'entity', entityType, removedRelationships);

            // Remove from entities
            entities[entityType] = entities[entityType].filter(e => e.id !== entityId);

            relationships = relationships.filter(r =>
                r.subject !== entityId && r.object !== entityId
            );

            // Log to Xano
            logActivityToXano({
                event_verb: 'Nullify Entity',
                eo_operator: 'NUL',
                object_type: entityType,
                object_id: entityId,
                object_label: entityName,
                data_json: {
                    entity_name: entityName,
                    entity_type: entityType,
                    removed_relationships: removedRelationships.length
                }
            });

            // Close modals and refresh
            closeDeleteConfirmModal();
            closeEntityModal();
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        // Legacy function - redirect to new modal
        function editEntityFromModal() {
            openEntityEditModal();
        }

        // Store current relationship being edited
        let currentEditingRelationship = null;

        function openRelationshipModal(relationshipData) {
            // Get the actual relationship object from the data
            const rel = relationships.find(r => r.id === relationshipData.id);
            if (!rel) return;

            // Store for editing
            currentEditingRelationship = rel;

            // Clear entity data - this is a relationship, not an entity
            currentModalEntity = null;
            currentModalEntityType = null;

            // Hide entity-specific buttons for relationships
            document.getElementById('modalEditButton').style.display = 'none';
            document.getElementById('modalDeleteButton').style.display = 'none';
            document.getElementById('modalTitleEditBtn').style.display = 'none';

            const subject = findEntity(rel.subject);
            const object = findEntity(rel.object);
            const operator = eoOperators[rel.predicate];

            const modal = document.getElementById('entityModal');

            // Set header icon for connection
            document.getElementById('modalEntityIcon').innerHTML = '<i class="ph ph-arrows-left-right"></i>';
            document.getElementById('modalEntityName').innerHTML = `
                ${subject?.name}
                <span style="color: ${operator.color}; font-weight: 600;">${operator.label}</span>
                ${object?.name}
            `;
            document.getElementById('modalEntityType').innerHTML = '<i class="ph ph-link"></i> CONNECTION';

            // Clear description section (relationships don't have descriptions)
            document.getElementById('modalDescription').innerHTML = '';
            document.getElementById('modalNested').innerHTML = '';
            document.getElementById('modalAddNested').innerHTML = '';
            document.getElementById('modalNestUnder').innerHTML = '';

            // Build entity options for dropdowns
            const allEntities = [];
            ['unit', 'team', 'role', 'object'].forEach(type => {
                entities[type].forEach(e => allEntities.push({ ...e, type }));
            });

            const entityOptions = allEntities.map(e =>
                `<option value="${e.id}" ${e.id === rel.subject ? 'selected' : ''}>${e.name} (${e.type})</option>`
            ).join('');

            const entityOptionsTarget = allEntities.map(e =>
                `<option value="${e.id}" ${e.id === rel.object ? 'selected' : ''}>${e.name} (${e.type})</option>`
            ).join('');

            // Build operator options
            const operatorOptions = Object.entries(eoOperators).map(([code, op]) =>
                `<option value="${code}" ${code === rel.predicate ? 'selected' : ''} style="color: ${op.color};">
                    ${op.label} (${code})
                </option>`
            ).join('');

            // Show connection editing form
            const connectionsEl = document.getElementById('modalConnections');
            connectionsEl.innerHTML = `
                <div class="modal-section-title"><i class="ph ph-pencil-simple"></i> Edit Connection</div>
                <div style="background: #FAF7F5; padding: 1rem; border-radius: 8px; border-left: 3px solid ${operator.color};" id="relationshipEditForm">
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: #3D2E1F;">
                            <i class="ph ph-arrow-right"></i> From (Source)
                        </label>
                        <select id="relEditSubject" style="width: 100%; padding: 0.5rem; border: 1px solid #E5DDD1; border-radius: 6px; font-size: 0.9rem;">
                            ${entityOptions}
                        </select>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: #3D2E1F;">
                            <i class="ph ph-flow-arrow"></i> Relationship Type
                        </label>
                        <select id="relEditPredicate" style="width: 100%; padding: 0.5rem; border: 1px solid #E5DDD1; border-radius: 6px; font-size: 0.9rem;" onchange="updateRelEditPreview()">
                            ${operatorOptions}
                        </select>
                        <div id="relEditOperatorDesc" style="margin-top: 0.5rem; font-size: 0.85rem; color: #6B5642;">
                            ${operator.description}
                        </div>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: #3D2E1F;">
                            <i class="ph ph-arrow-left"></i> To (Target)
                        </label>
                        <select id="relEditObject" style="width: 100%; padding: 0.5rem; border: 1px solid #E5DDD1; border-radius: 6px; font-size: 0.9rem;">
                            ${entityOptionsTarget}
                        </select>
                    </div>
                    <button class="modal-action-btn" onclick="saveRelationshipEdit()" style="width: 100%; background: #C88F4A; color: white; margin-top: 0.5rem;">
                        <i class="ph ph-check"></i> Save Changes
                    </button>
                </div>
            `;

            // Show delete action in activities section
            const activitiesEl = document.getElementById('modalActivities');
            activitiesEl.innerHTML = `
                <div class="modal-section-title"><i class="ph ph-gear"></i> Actions</div>
                <button class="modal-action-btn danger" onclick="deleteRelationship('${rel.id}')" style="width: 100%;">
                    <i class="ph ph-trash"></i>
                    Delete Connection
                </button>
            `;

            modal.classList.add('active');
        }

        function updateRelEditPreview() {
            const predicateSelect = document.getElementById('relEditPredicate');
            const descEl = document.getElementById('relEditOperatorDesc');
            if (predicateSelect && descEl) {
                const selectedOp = eoOperators[predicateSelect.value];
                if (selectedOp) {
                    descEl.textContent = selectedOp.description;
                    descEl.style.color = selectedOp.color;
                }
            }
        }

        function saveRelationshipEdit() {
            if (!currentEditingRelationship) return;

            const newSubject = document.getElementById('relEditSubject').value;
            const newPredicate = document.getElementById('relEditPredicate').value;
            const newObject = document.getElementById('relEditObject').value;

            // Validate - can't connect to self
            if (newSubject === newObject) {
                alert('Cannot connect an entity to itself.');
                return;
            }

            // Check for duplicate relationship
            const duplicate = relationships.find(r =>
                r.id !== currentEditingRelationship.id &&
                r.subject === newSubject &&
                r.predicate === newPredicate &&
                r.object === newObject
            );

            if (duplicate) {
                alert('This exact connection already exists.');
                return;
            }

            // Track changes for logging
            const oldSubject = currentEditingRelationship.subject;
            const oldPredicate = currentEditingRelationship.predicate;
            const oldObject = currentEditingRelationship.object;

            const hasChanges = newSubject !== oldSubject ||
                               newPredicate !== oldPredicate ||
                               newObject !== oldObject;

            if (!hasChanges) {
                closeEntityModal();
                return;
            }

            // Apply changes
            currentEditingRelationship.subject = newSubject;
            currentEditingRelationship.predicate = newPredicate;
            currentEditingRelationship.object = newObject;

            // Log to Xano
            const oldSubjectEntity = findEntity(oldSubject);
            const oldObjectEntity = findEntity(oldObject);
            const newSubjectEntity = findEntity(newSubject);
            const newObjectEntity = findEntity(newObject);

            logActivityToXano({
                event_verb: 'Shift Connection',
                eo_operator: 'ALT',
                object_type: 'relationship',
                object_id: currentEditingRelationship.id,
                object_label: `${newSubjectEntity?.name} ${newPredicate} ${newObjectEntity?.name}`,
                data_json: {
                    old_subject: oldSubject,
                    new_subject: newSubject,
                    old_predicate: oldPredicate,
                    new_predicate: newPredicate,
                    old_object: oldObject,
                    new_object: newObject
                }
            });

            // Save and refresh
            saveToLocalStorage();
            closeEntityModal();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        let relationshipToDelete = null;

        function deleteRelationship(relId) {
            // Store relationship for confirmation
            relationshipToDelete = relId;
            const rel = relationships.find(r => r.id === relId);
            if (rel) {
                const subject = findEntity(rel.subject);
                const object = findEntity(rel.object);
                document.getElementById('deleteConfirmTitle').textContent = 'Delete Connection?';
                document.getElementById('deleteConfirmText').textContent =
                    `This will permanently remove the connection between "${subject?.name}" and "${object?.name}".`;
            }
            document.getElementById('deleteConfirmModal').classList.add('open');
        }

        function confirmDeleteRelationship() {
            if (!relationshipToDelete) return;

            const rel = relationships.find(r => r.id === relationshipToDelete);
            if (!rel) {
                relationshipToDelete = null;
                closeDeleteConfirmModal();
                return;
            }

            const subject = findEntity(rel.subject);
            const object = findEntity(rel.object);
            const operatorData = eoOperators[rel.predicate];

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_relationship',
                data: JSON.parse(JSON.stringify(rel)),
                description: `Delete ${operatorData?.label || rel.predicate}: ${subject?.name || rel.subject}  ${object?.name || rel.object}`
            });

            // Add to recycle bin
            addToRecycleBin(rel, 'relationship', null);

            relationships = relationships.filter(r => r.id !== relationshipToDelete);

            // Log deletion to Xano
            logActivityToXano({
                event_verb: 'Notice Removal',
                eo_operator: 'NUL',
                object_type: 'relationship',
                object_id: relationshipToDelete,
                object_label: `${subject?.name}  ${object?.name}`,
                data_json: {
                    relationship_deleted: true,
                    subject_id: rel.subject,
                    object_id: rel.object,
                    predicate: rel.predicate
                }
            });

            relationshipToDelete = null;
            closeDeleteConfirmModal();
            closeEntityModal();
            saveToLocalStorage();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        // Sentence Preview
        function updateSentencePreview() {
            const subjectId = document.getElementById('subjectSelect')?.value;
            const orgEntityId = document.getElementById('orgEntitySelect')?.value;
            const objectId = document.getElementById('objectSelect')?.value;
            const preview = document.getElementById('sentencePreview');

            if (!preview) return; // Safety check

            // Determine which object was selected (org entity or work object)
            const selectedObjectId = objectId || orgEntityId;

            if (!subjectId || !selectedObjectId) {
                preview.innerHTML = '<em style="color: #8B6F47;">Select entities to preview connection...</em>';
                return;
            }

            const subject = findEntity(subjectId);
            const object = findEntity(selectedObjectId);

            if (!subject || !object) {
                preview.innerHTML = '<em style="color: #8B6F47;">Select entities to preview connection...</em>';
                return;
            }

            const operatorLabel = eoOperators[selectedPredicate]?.label || selectedPredicate;
            const operatorColor = eoOperators[selectedPredicate]?.color || '#8B6F47';

            // Get friendly description for the connection type
            const friendlyDescriptions = {
                'DES': 'Creates a hierarchical relationship',
                'INS': 'Assigns or starts a new role/responsibility',
                'CON': 'Connects work or responsibilities',
                'SEG': 'Divides or breaks down into parts',
                'NUL': 'Removes or recognizes absence',
                'ALT': 'Modifies or shifts responsibility',
                'SYN': 'Combines or merges elements',
                'SUP': 'Oversees or balances multiple areas',
                'REC': 'Creates a recurring or iterative process'
            };

            preview.innerHTML = `
                <strong>${subject.name}</strong>
                <span style="color: ${operatorColor}; font-weight: 600;">${operatorLabel}</span>
                <strong>${object.name}</strong>
                <div class="help-text" style="margin-top: 0.5rem;">
                    ${friendlyDescriptions[selectedPredicate] || eoOperators[selectedPredicate]?.description || ''}
                </div>
            `;
        }

        // Handle mutual exclusivity: when org entity is selected, clear work object
        function handleOrgEntityChange() {
            if (document.getElementById('orgEntitySelect').value) {
                document.getElementById('objectSelect').value = '';
            }
            updateSentencePreview();
        }

        // Handle mutual exclusivity: when work object is selected, clear org entity
        function handleWorkObjectChange() {
            if (document.getElementById('objectSelect').value) {
                document.getElementById('orgEntitySelect').value = '';
            }
            updateSentencePreview();
        }

        // Xano Activity Store Integration
        async function logActivityToXano(activity) {
            try {
                // New schema: app_id, data (json), entity_id, event_type
                const payload = {
                    app_id: APP_ID,
                    entity_id: activity.object_id || '',
                    event_type: activity.eo_operator || activity.event_verb || 'unknown',
                    data: {
                        event_verb: activity.event_verb,
                        eo_operator: activity.eo_operator,
                        agent_type: 'user',
                        agent_id: 'user_' + Date.now(),
                        agent_name: 'User',
                        object_type: activity.object_type,
                        object_id: activity.object_id,
                        object_label: activity.object_label,
                        ...(activity.data_json || {})
                    }
                };

                console.log(' Logging activity to Xano:', payload);

                const response = await fetch(`${XANO_BASE_URL}/activity_store`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    console.error(' Failed to log activity:', response.statusText);
                    return null;
                }

                const result = await response.json();
                console.log(' Activity logged:', result);
                return result;
            } catch (error) {
                console.error(' Error logging activity to Xano:', error);
                return null;
            }
        }

        async function getActivitiesFromXano() {
            try {
                const response = await fetch(`${XANO_BASE_URL}/activity_store`);

                if (!response.ok) {
                    console.error('Failed to fetch activities:', response.statusText);
                    return [];
                }

                const activities = await response.json();
                console.log(' Fetched activities from Xano:', activities);

                // Filter by app_id and transform to include nested data
                return activities
                    .filter(a => a.app_id === APP_ID)
                    .map(a => ({
                        id: a.id,
                        created_at: a.created_at,
                        app_id: a.app_id,
                        entity_id: a.entity_id,
                        event_type: a.event_type,
                        // Flatten data fields for easier access
                        ...a.data,
                        // Keep original data object for reference
                        _raw: a
                    }));
            } catch (error) {
                console.error('Error fetching activities from Xano:', error);
                return [];
            }
        }

        async function updateActivityInXano(activityId, updates) {
            try {
                // Build payload conforming to new schema: app_id, data (json), entity_id, event_type
                const payload = {};

                // Only include fields that are being updated
                if (updates.app_id !== undefined) payload.app_id = updates.app_id;
                if (updates.entity_id !== undefined) payload.entity_id = updates.entity_id;
                if (updates.event_type !== undefined) payload.event_type = updates.event_type;

                // If updates contain data-level fields, wrap them in data object
                if (updates.data !== undefined) {
                    payload.data = updates.data;
                } else {
                    // Check for individual data fields and merge them
                    const dataFields = ['event_verb', 'eo_operator', 'agent_type', 'agent_id',
                                       'agent_name', 'object_type', 'object_id', 'object_label'];
                    const dataUpdates = {};
                    let hasDataUpdates = false;

                    dataFields.forEach(field => {
                        if (updates[field] !== undefined) {
                            dataUpdates[field] = updates[field];
                            hasDataUpdates = true;
                        }
                    });

                    if (hasDataUpdates) {
                        payload.data = dataUpdates;
                    }
                }

                console.log(' Updating activity in Xano:', activityId, payload);

                const response = await fetch(`${XANO_BASE_URL}/activity_store/${activityId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    console.error('Failed to update activity:', response.statusText);
                    return null;
                }

                const result = await response.json();
                console.log(' Activity updated:', result);
                return result;
            } catch (error) {
                console.error('Error updating activity in Xano:', error);
                return null;
            }
        }

        function initSampleData() {
            // Units
            entities.unit.push({ id: 'u1', name: 'Immigration Practice', type: 'unit', description: 'Main practice area handling all immigration-related legal matters including asylum, family petitions, and employment visas.' });

            // Teams
            entities.team.push({ id: 't1', name: 'Asylum Team', type: 'team', description: 'Dedicated team handling asylum applications and refugee status cases.' });
            entities.team.push({ id: 't2', name: 'Family Petitions Team', type: 'team', description: 'Handles family-based immigration petitions and reunification cases.' });

            // Roles
            entities.role.push({ id: 'r1', name: 'Managing Attorney', type: 'role', description: 'Oversees case strategy, team coordination, and client relationships.' });
            entities.role.push({ id: 'r2', name: 'Associate Attorney', type: 'role', description: 'Handles day-to-day case work, legal research, and court appearances.' });
            entities.role.push({ id: 'r3', name: 'Case Manager', type: 'role', description: 'Coordinates case logistics, deadlines, and client communications.' });
            entities.role.push({ id: 'r4', name: 'Lead Attorney', type: 'role', description: 'Senior attorney leading complex cases and mentoring associates.' });

            // People
            entities.person.push({ id: 'p1', name: 'Maria Santos', type: 'person', description: '15 years immigration law experience, fluent in Spanish and Portuguese.' });
            entities.person.push({ id: 'p2', name: 'James Chen', type: 'person', description: 'Specializes in employment-based immigration and investor visas.' });
            entities.person.push({ id: 'p3', name: 'Ana Rodriguez', type: 'person', description: 'Bilingual case manager with expertise in asylum documentation.' });

            // Objects (work items)
            entities.object.push({ id: 'o1', name: 'Court Filings', type: 'object', description: 'Legal documents submitted to immigration courts and USCIS.' });
            entities.object.push({ id: 'o2', name: 'Client Interviews', type: 'object', description: 'Initial consultations and ongoing case review meetings.' });
            entities.object.push({ id: 'o3', name: 'Case Preparation', type: 'object', description: 'Document compilation, evidence gathering, and legal research.' });
            entities.object.push({ id: 'o4', name: 'Schedule Management', type: 'object', description: 'Calendar coordination for hearings, deadlines, and appointments.' });
            
            // Hierarchical relationships (Unit DESignates Teams, Teams DESignate Roles)
            relationships.push({ subject: 'u1', predicate: 'DES', object: 't1', id: 'rel_h1' }); // Immigration Practice designates Asylum Team
            relationships.push({ subject: 'u1', predicate: 'DES', object: 't2', id: 'rel_h2' }); // Immigration Practice designates Family Petitions Team
            relationships.push({ subject: 't1', predicate: 'DES', object: 'r1', id: 'rel_h3' }); // Asylum Team designates Managing Attorney
            relationships.push({ subject: 't1', predicate: 'DES', object: 'r2', id: 'rel_h4' }); // Asylum Team designates Associate Attorney
            relationships.push({ subject: 't1', predicate: 'DES', object: 'r3', id: 'rel_h5' }); // Asylum Team designates Case Manager
            relationships.push({ subject: 't2', predicate: 'DES', object: 'r4', id: 'rel_h6' }); // Family Petitions Team designates Lead Attorney
            
            // Work relationships (Roles CONnected to Objects)
            relationships.push({ subject: 'r1', predicate: 'SUP', object: 'o1', id: 'rel1' }); // Managing Attorney supervises Court Filings
            relationships.push({ subject: 'r2', predicate: 'CON', object: 'o3', id: 'rel2' }); // Associate Attorney connects to Case Preparation
            relationships.push({ subject: 'r3', predicate: 'CON', object: 'o4', id: 'rel3' }); // Case Manager connects to Schedule Management
            
            // People INSerted into roles
            relationships.push({ subject: 'p1', predicate: 'INS', object: 'r1', id: 'rel4' }); // Maria Santos inserted into Managing Attorney
            relationships.push({ subject: 'p2', predicate: 'INS', object: 'r2', id: 'rel5' }); // James Chen inserted into Associate Attorney
            relationships.push({ subject: 'p3', predicate: 'INS', object: 'r3', id: 'rel6' }); // Ana Rodriguez inserted into Case Manager
            
            // Oversight relationships  
            relationships.push({ subject: 'r1', predicate: 'SUP', object: 'r2', id: 'rel7' }); // Managing Attorney supersedes Associate Attorney
            
            // Collaborative relationships
            relationships.push({ subject: 'r3', predicate: 'SYN', object: 'o4', id: 'rel8' }); // Case Manager synthesizes Schedule Management
        }

        // Load sample data into current workspace (called from welcome banner)
        function loadSampleData() {
            initSampleData();
            hasSampleData = true;

            const btnText = document.getElementById('sampleDataText');
            if (btnText) {
                btnText.textContent = 'Clear Sample Data';
            }

            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            dismissWelcomeBanner();
        }

        // Entity management
        function selectEntityType(type) {
            selectedEntityType = type;
            document.querySelectorAll('.entity-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
            updateParentOptions();

            // Update add button text based on type
            const addBtn = document.getElementById('addEntityBtn');
            if (addBtn) {
                const typeLabels = { unit: 'Unit', team: 'Team', role: 'Role', person: 'Person', object: 'Object' };
                addBtn.innerHTML = `<i class="ph ph-plus-circle" style="color: white; font-size: 1.25rem;"></i> Add ${typeLabels[type] || 'Entity'}`;
            }
        }

        function updateParentOptions() {
            const parentSelectGroup = document.getElementById('parentSelectGroup');
            const parentSelect = document.getElementById('parentEntitySelect');
            
            // Persons cannot have parents
            if (selectedEntityType === 'person') {
                parentSelectGroup.style.display = 'none';
                return;
            }
            
            parentSelectGroup.style.display = 'block';
            parentSelect.innerHTML = '<option value="">None - Top Level</option>';

            // Determine valid parent types based on selected entity type
            let validParentTypes = [];
            if (selectedEntityType === 'team') {
                validParentTypes = ['unit', 'team']; // Teams can be under units or other teams
            } else if (selectedEntityType === 'role') {
                validParentTypes = ['unit', 'team']; // Roles can be under units or teams
            } else if (selectedEntityType === 'object') {
                validParentTypes = ['role']; // Objects can be under roles
            } else if (selectedEntityType === 'unit') {
                validParentTypes = ['unit']; // Units can be under other units
            }

            // Populate with valid parent entities
            validParentTypes.forEach(type => {
                entities[type].forEach(entity => {
                    const option = document.createElement('option');
                    option.value = entity.id;
                    option.innerHTML = `${getIcon(type)} ${entity.name}`;
                    parentSelect.appendChild(option);
                });
            });
        }

        function addEntity() {
            const name = document.getElementById('entityName').value.trim();
            if (!name) return;

            const id = selectedEntityType[0] + Date.now();
            const entity = {
                id,
                name,
                type: selectedEntityType,
                description: ''
            };

            entities[selectedEntityType].push(entity);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_entity',
                entityType: selectedEntityType,
                data: JSON.parse(JSON.stringify(entity)),
                description: `Create ${selectedEntityType}: ${name}`
            });

            // Log to Xano activity store
            logActivityToXano({
                event_verb: 'Start Entity',
                eo_operator: 'INS',
                object_type: selectedEntityType,
                object_id: id,
                object_label: name,
                data_json: {
                    entity_type: selectedEntityType,
                    entity_name: name
                }
            });

            // If parent is selected, create the parent relationship (persons cannot have parents)
            const parentId = document.getElementById('parentEntitySelect').value;

            if (parentId && selectedEntityType !== 'person') {
                const relId = 'rel' + Date.now();
                const parentEntity = findEntity(parentId);

                const relationship = {
                    id: relId,
                    subject: parentId,
                    predicate: 'DES', // Define relationship for hierarchy
                    object: id
                };

                relationships.push(relationship);

                // Track relationship creation in undo history
                pushToUndoHistory({
                    type: 'create_relationship',
                    data: JSON.parse(JSON.stringify(relationship)),
                    description: `Nest ${name} under ${parentEntity?.name}`
                });

                // Log parent relationship to Xano
                logActivityToXano({
                    event_verb: 'Define Connection',
                    eo_operator: 'DES',
                    object_type: 'relationship',
                    object_id: relId,
                    object_label: `${parentEntity?.name} Define ${name}`,
                    data_json: {
                        subject_id: parentId,
                        subject_type: parentEntity?.type,
                        subject_name: parentEntity?.name,
                        predicate: 'DES',
                        predicate_label: 'Define',
                        object_id: id,
                        object_type: selectedEntityType,
                        object_name: name,
                        connection_target: 'hierarchy'
                    }
                });
            }

            document.getElementById('entityName').value = '';
            document.getElementById('parentEntitySelect').value = '';

            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function quickAddChild(parentId, parentType) {
            const parent = findEntity(parentId);
            if (!parent) return;

            // Determine appropriate child type
            let childType = 'team'; // Default
            if (parentType === 'team') {
                childType = 'role';
            }

            // Set the entity type
            selectEntityType(childType);

            // Set the parent
            document.getElementById('parentEntitySelect').value = parentId;

            // Focus on name input
            document.getElementById('entityName').focus();

            // Scroll to the add entity form
            document.querySelector('.panel-left').scrollTop = 0;
        }

        function deleteEntity(id, type) {
            if (!confirm('Delete this entity? This will also remove related relationships.')) return;

            const entity = entities[type].find(e => e.id === id);
            if (!entity) return;

            // Capture related relationships before deleting
            const deletedRelationships = relationships.filter(r => r.subject === id || r.object === id);

            // Remove entity and relationships
            entities[type] = entities[type].filter(e => e.id !== id);
            relationships = relationships.filter(r => r.subject !== id && r.object !== id);

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_entity',
                entityType: type,
                data: JSON.parse(JSON.stringify(entity)),
                deletedRelationships: deletedRelationships.map(r => JSON.parse(JSON.stringify(r))),
                description: `Delete ${type}: ${entity.name}`
            });

            // Add to recycle bin
            addToRecycleBin(entity, 'entity', type, deletedRelationships);

            // Log to Xano activity store
            logActivityToXano({
                event_verb: 'Notice Removal', // NUL = Notice
                eo_operator: 'NUL',
                object_type: type,
                object_id: id,
                object_label: entity.name,
                data_json: {
                    entity_type: type,
                    entity_name: entity.name,
                    action: 'deleted'
                }
            });

            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function renderEntityList() {
            const list = document.getElementById('entityList');
            if (!list) return; // Safety check
            
            const searchTerm = document.getElementById('entitySearch')?.value.toLowerCase() || '';
            list.innerHTML = '';

            // Helper function to recursively render entity tree
            // Use visited set to prevent infinite recursion from bidirectional relationships
            function renderEntityNode(entity, depth = 0, searchTerm = '', visited = new Set()) {
                // Prevent infinite recursion - skip if already rendered in this branch
                if (visited.has(entity.id)) {
                    return null;
                }
                visited.add(entity.id);

                const marginLeft = depth * 1;
                
                // Skip if doesn't match search
                if (searchTerm && !entity.name.toLowerCase().includes(searchTerm)) {
                    const hasMatchingChildren = findMatchingChildren(entity.id, searchTerm);
                    if (!hasMatchingChildren) return null;
                }

                const container = document.createElement('div');
                const node = document.createElement('div');
                node.className = `tree-node-item ${entity.type}`;
                node.style.marginLeft = `${marginLeft}rem`;
                node.style.cursor = 'pointer';
                node.onclick = (e) => {
                    if (!e.target.closest('.btn-icon') && !e.target.closest('.tree-expand-icon')) {
                        openEntityModal(entity.id, entity.type);
                    }
                };

                const icon = getIcon(entity.type);
                
                // Get all potential children (units, teams, roles - NOT objects)
                let children = [];
                if (entity.type === 'unit') {
                    children = [
                        ...getConnectedEntities(entity.id, 'unit'),
                        ...getConnectedEntities(entity.id, 'team'),
                        ...getConnectedEntities(entity.id, 'role')
                    ];
                } else if (entity.type === 'team') {
                    children = [
                        ...getConnectedEntities(entity.id, 'team'),
                        ...getConnectedEntities(entity.id, 'role')
                    ];
                }
                // Roles don't show objects as children - objects shown separately

                const hasChildren = children.length > 0;

                node.innerHTML = `
                    <span class="tree-expand-icon ${hasChildren ? 'expanded' : ''}" style="${hasChildren ? '' : 'visibility: hidden;'}"></span>
                    <span class="tree-node-icon" style="font-size: ${depth === 0 ? '1.1rem' : '0.95rem'};">${icon}</span>
                    <div class="tree-node-content">
                        <div class="tree-node-name">${entity.name}</div>
                    </div>
                    <div class="tree-node-actions">
                        ${(entity.type === 'unit' || entity.type === 'team') ? `<button class="btn-icon add" onclick="event.stopPropagation(); quickAddChild('${entity.id}', '${entity.type}')" title="Add sub-entity"><i class="ph ph-plus"></i></button>` : ''}
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${entity.id}', '${entity.type}')" title="Delete"><i class="ph ph-x"></i></button>
                    </div>
                `;

                container.appendChild(node);

                if (hasChildren) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'tree-children expanded';

                    children.forEach(child => {
                        if (searchTerm && !child.name.toLowerCase().includes(searchTerm)) {
                            const hasMatchingGrandchildren = findMatchingChildren(child.id, searchTerm);
                            if (!hasMatchingGrandchildren) return;
                        }
                        
                        const childNode = renderEntityNode(child, depth + 1, searchTerm, visited);
                        if (childNode) {
                            childrenContainer.appendChild(childNode);
                        }
                    });

                    if (childrenContainer.children.length > 0) {
                        container.appendChild(childrenContainer);

                        // Add expand/collapse
                        const expandIcon = node.querySelector('.tree-expand-icon');
                        if (expandIcon) {
                            expandIcon.onclick = (e) => {
                                e.stopPropagation();
                                childrenContainer.classList.toggle('expanded');
                                expandIcon.classList.toggle('expanded');
                            };
                        }
                    }
                }

                return container;
            }

            // Find top-level units (not contained by any other unit)
            const topLevelUnits = entities.unit.filter(unit => {
                return !relationships.some(r => 
                    r.object === unit.id && entities.unit.some(u => u.id === r.subject)
                );
            });

            topLevelUnits.forEach(unit => {
                const unitNode = renderEntityNode(unit, 0, searchTerm);
                if (unitNode) {
                    unitNode.style.marginBottom = '1rem';
                    list.appendChild(unitNode);
                }
            });

            // Show orphaned entities (not connected to anything or to non-existent parents)
            const orphanedSection = document.createElement('div');
            orphanedSection.style.marginTop = '1.5rem';
            
            // Orphaned teams (not connected to any unit or team)
            const orphanedTeams = entities.team.filter(team => {
                const isConnected = relationships.some(r => 
                    (r.subject === team.id || r.object === team.id) &&
                    (entities.unit.some(u => u.id === r.subject || u.id === r.object) ||
                     entities.team.some(t => t.id === r.subject || t.id === r.object))
                );
                return !isConnected;
            });

            if (orphanedTeams.length > 0 && (!searchTerm || orphanedTeams.some(t => t.name.toLowerCase().includes(searchTerm)))) {
                const header = document.createElement('div');
                header.className = 'entity-section-header';
                header.textContent = 'Unassigned Teams';
                orphanedSection.appendChild(header);

                orphanedTeams.forEach(team => {
                    if (searchTerm && !team.name.toLowerCase().includes(searchTerm)) return;
                    const node = document.createElement('div');
                    node.className = 'entity-item team';
                    node.style.cursor = 'pointer';
                    node.onclick = (e) => {
                        if (!e.target.closest('.btn-icon')) {
                            openEntityModal(team.id, 'team');
                        }
                    };
                    node.innerHTML = `
                        <div class="entity-name"><i class="ph ph-users-three"></i> ${team.name}</div>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${team.id}', 'team')"><i class="ph ph-x"></i></button>
                    `;
                    orphanedSection.appendChild(node);
                });
            }

            // Orphaned roles
            const orphanedRoles = entities.role.filter(role => {
                const isConnected = relationships.some(r => 
                    (r.subject === role.id || r.object === role.id) &&
                    (entities.team.some(t => t.id === r.subject || t.id === r.object))
                );
                return !isConnected;
            });

            if (orphanedRoles.length > 0 && (!searchTerm || orphanedRoles.some(r => r.name.toLowerCase().includes(searchTerm)))) {
                const section = document.createElement('div');
                section.className = 'entity-section';
                const header = document.createElement('div');
                header.className = 'entity-section-header';
                header.textContent = 'Unassigned Roles';
                section.appendChild(header);

                orphanedRoles.forEach(role => {
                    if (searchTerm && !role.name.toLowerCase().includes(searchTerm)) return;
                    const node = document.createElement('div');
                    node.className = 'entity-item role';
                    node.style.cursor = 'pointer';
                    node.onclick = (e) => {
                        if (!e.target.closest('.btn-icon')) {
                            openEntityModal(role.id, 'role');
                        }
                    };
                    node.innerHTML = `
                        <div class="entity-name"><i class="ph ph-identification-badge"></i> ${role.name}</div>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${role.id}', 'role')"><i class="ph ph-x"></i></button>
                    `;
                    section.appendChild(node);
                });
                orphanedSection.appendChild(section);
            }

            // People
            if (entities.person.length > 0 && (!searchTerm || entities.person.some(p => p.name.toLowerCase().includes(searchTerm)))) {
                const section = document.createElement('div');
                section.className = 'entity-section';
                const header = document.createElement('div');
                header.className = 'entity-section-header';
                header.textContent = 'People';
                section.appendChild(header);

                entities.person.forEach(person => {
                    if (searchTerm && !person.name.toLowerCase().includes(searchTerm)) return;
                    const node = document.createElement('div');
                    node.className = 'entity-item person';
                    node.style.cursor = 'pointer';
                    node.onclick = (e) => {
                        if (!e.target.closest('.btn-icon')) {
                            openEntityModal(person.id, 'person');
                        }
                    };
                    node.innerHTML = `
                        <div class="entity-name"><i class="ph ph-user"></i> ${person.name}</div>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${person.id}', 'person')"><i class="ph ph-x"></i></button>
                    `;
                    section.appendChild(node);
                });
                orphanedSection.appendChild(section);
            }

            // Objects (shown separately since they can connect to multiple roles)
            if (entities.object.length > 0 && (!searchTerm || entities.object.some(o => o.name.toLowerCase().includes(searchTerm)))) {
                const section = document.createElement('div');
                section.className = 'entity-section';
                const header = document.createElement('div');
                header.className = 'entity-section-header';
                header.textContent = 'Work Products';
                section.appendChild(header);

                entities.object.forEach(obj => {
                    if (searchTerm && !obj.name.toLowerCase().includes(searchTerm)) return;

                    // Find roles connected to this object
                    const connectedRoles = relationships
                        .filter(r => r.object === obj.id || r.subject === obj.id)
                        .map(r => {
                            const entityId = r.object === obj.id ? r.subject : r.object;
                            return findEntity(entityId);
                        })
                        .filter(e => e && e.type === 'role');

                    const node = document.createElement('div');
                    node.className = 'entity-item object';
                    node.style.cursor = 'pointer';
                    node.onclick = (e) => {
                        if (!e.target.closest('.btn-icon')) {
                            openEntityModal(obj.id, 'object');
                        }
                    };

                    const connectionBadges = connectedRoles.length > 0
                        ? `<div style="display: flex; gap: 0.25rem; flex-wrap: wrap; margin-top: 0.25rem;">
                            ${connectedRoles.map(role =>
                                `<span style="font-size: 0.65rem; padding: 0.125rem 0.375rem; background: rgba(139, 111, 71, 0.1); color: #8B6F47; border-radius: 10px;"><i class="ph ph-identification-badge"></i> ${role.name}</span>`
                            ).join('')}
                           </div>`
                        : '';

                    node.innerHTML = `
                        <div style="flex: 1;">
                            <div class="entity-name"><i class="ph ph-package"></i> ${obj.name}</div>
                            ${connectionBadges}
                        </div>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${obj.id}', 'object')"><i class="ph ph-x"></i></button>
                    `;
                    section.appendChild(node);
                });
                orphanedSection.appendChild(section);
            }

            if (orphanedSection.children.length > 0) {
                list.appendChild(orphanedSection);
            }

            if (list.children.length === 0) {
                list.innerHTML = '<div style="color: #8B6F47; text-align: center; padding: 2rem;">No matching entities</div>';
            }
        }

        function getConnectedEntities(entityId, targetType) {
            const connected = [];
            relationships.forEach(rel => {
                if (rel.subject === entityId) {
                    // If targetType is specified, look only for that type
                    if (targetType) {
                        const entity = entities[targetType]?.find(e => e.id === rel.object);
                        if (entity && !connected.find(c => c.id === entity.id)) {
                            connected.push(entity);
                        }
                    } else {
                        // If no targetType, find any connected entity
                        const entity = findEntity(rel.object);
                        if (entity && !connected.find(c => c.id === entity.id)) {
                            connected.push(entity);
                        }
                    }
                } else if (rel.object === entityId) {
                    if (targetType) {
                        const entity = entities[targetType]?.find(e => e.id === rel.subject);
                        if (entity && !connected.find(c => c.id === entity.id)) {
                            connected.push(entity);
                        }
                    } else {
                        const entity = findEntity(rel.subject);
                        if (entity && !connected.find(c => c.id === entity.id)) {
                            connected.push(entity);
                        }
                    }
                }
            });
            return connected;
        }

        function findMatchingChildren(entityId, searchTerm) {
            // Check if any children match the search term
            const connectedTeams = getConnectedEntities(entityId, 'team');
            for (let team of connectedTeams) {
                if (team.name.toLowerCase().includes(searchTerm)) return true;
                const connectedRoles = getConnectedEntities(team.id, 'role');
                for (let role of connectedRoles) {
                    if (role.name.toLowerCase().includes(searchTerm)) return true;
                }
            }
            const connectedRoles = getConnectedEntities(entityId, 'role');
            for (let role of connectedRoles) {
                if (role.name.toLowerCase().includes(searchTerm)) return true;
            }
            return false;
        }

        function filterEntities() {
            renderEntityList();
        }

        function applyFilters() {
            updateFilterStatus();
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'cards') {
                renderCardView();
            }
        }

        function updateFilterStatus() {
            const filters = getActiveFilters();
            const statusEl = document.getElementById('filterStatus');
            if (!statusEl) return;

            // Count active filters (9 operators, 5 entity types)
            const activeRelTypes = Object.values(filters.relationships).filter(v => v).length;
            const activeEntityTypes = Object.values(filters.entities).filter(v => v).length;
            
            if (activeRelTypes === 9 && activeEntityTypes === 5) {
                statusEl.textContent = 'Showing all';
            } else if (activeRelTypes === 0 || activeEntityTypes === 0) {
                statusEl.textContent = 'No filters active';
            } else {
                statusEl.textContent = `Filtered: ${activeRelTypes}/9 operators, ${activeEntityTypes}/5 entities`;
            }
        }

        function clearFilters() {
            // Uncheck all operator filters
            Object.keys(eoOperators).forEach(op => {
                const el = document.getElementById(`filter${op}`);
                if (el) el.checked = false;
            });
            // Uncheck entity filters
            document.getElementById('filterUnit').checked = false;
            document.getElementById('filterTeam').checked = false;
            document.getElementById('filterRole').checked = false;
            document.getElementById('filterPerson').checked = false;
            document.getElementById('filterObject').checked = false;
            applyFilters();
        }

        function selectAllFilters() {
            // Check all operator filters
            Object.keys(eoOperators).forEach(op => {
                const el = document.getElementById(`filter${op}`);
                if (el) el.checked = true;
            });
            // Check entity filters
            document.getElementById('filterUnit').checked = true;
            document.getElementById('filterTeam').checked = true;
            document.getElementById('filterRole').checked = true;
            document.getElementById('filterPerson').checked = true;
            document.getElementById('filterObject').checked = true;
            applyFilters();
        }

        function toggleAllFilters() {
            const filters = getActiveFilters();
            // Check if any operator or entity filters are unchecked
            const anyRelUnchecked = Object.values(filters.relationships).some(v => !v);
            const anyEntityUnchecked = Object.values(filters.entities).some(v => !v);
            
            if (anyRelUnchecked || anyEntityUnchecked) {
                selectAllFilters();
            } else {
                clearFilters();
            }
        }

        function getActiveFilters() {
            // Build relationships filter from all EO operators
            const relationshipsFilter = {};
            Object.keys(eoOperators).forEach(op => {
                relationshipsFilter[op] = document.getElementById(`filter${op}`)?.checked !== false;
            });
            
            return {
                relationships: relationshipsFilter,
                entities: {
                    unit: document.getElementById('filterUnit')?.checked !== false,
                    team: document.getElementById('filterTeam')?.checked !== false,
                    role: document.getElementById('filterRole')?.checked !== false,
                    person: document.getElementById('filterPerson')?.checked !== false,
                    object: document.getElementById('filterObject')?.checked !== false
                }
            };
        }

        // Relationship management
        function selectPredicate(predicate) {
            selectedPredicate = predicate;
            // Clear all predicate buttons (advanced)
            document.querySelectorAll('.predicate-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // Clear all quick operator buttons (simplified)
            document.querySelectorAll('.quick-operator-selector .operator-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // Find and activate the button matching this predicate
            // Check advanced operators first
            const advancedBtn = document.querySelector(`.predicate-btn.${predicate}`);
            if (advancedBtn) {
                advancedBtn.classList.add('active');
            }
            // Check quick operator buttons
            const quickBtn = document.querySelector(`.quick-operator-selector .operator-btn[data-predicate="${predicate}"]`);
            if (quickBtn) {
                quickBtn.classList.add('active');
            }
            updateSentencePreview(); // Update preview when operator changes
        }

        function addActivity() {
            const subject = document.getElementById('subjectSelect').value;
            const orgEntity = document.getElementById('orgEntitySelect').value;
            const workObject = document.getElementById('objectSelect').value;

            // Determine which object was selected
            const object = workObject || orgEntity;

            if (!subject || !object) {
                alert('Please select subject and either an organizational entity or work object');
                return;
            }

            const subjectEntity = findEntity(subject);
            const objectEntity = findEntity(object);
            
            // Validate connection rules based on entity types and operators
            const validationError = validateConnection(subjectEntity, objectEntity, selectedPredicate);
            if (validationError) {
                alert(validationError);
                return;
            }

            const id = 'rel' + Date.now();
            const description = document.getElementById('activityDescription').value.trim();
            
            const relationship = {
                id,
                subject,
                predicate: selectedPredicate,
                object,
                description
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[selectedPredicate];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${subjectEntity?.name}  ${objectEntity?.name}`
            });

            // Log to Xano activity store (append-only)
            logActivityToXano({
                event_verb: `${operatorData.label} Connection`, // e.g., "Define Connection"
                eo_operator: selectedPredicate, // Store EO code (DES, INS, etc)
                object_type: 'relationship',
                object_id: id,
                object_label: `${subjectEntity?.name} ${operatorData.label} ${objectEntity?.name}`,
                data_json: {
                    subject_id: subject,
                    subject_type: subjectEntity?.type,
                    subject_name: subjectEntity?.name,
                    predicate: selectedPredicate,
                    predicate_label: operatorData.label,
                    object_id: object,
                    object_type: objectEntity?.type,
                    object_name: objectEntity?.name,
                    connection_target: workObject ? 'work_object' : 'org_entity',
                    description: description
                }
            });

            document.getElementById('subjectSelect').value = '';
            document.getElementById('orgEntitySelect').value = '';
            document.getElementById('objectSelect').value = '';
            document.getElementById('activityDescription').value = '';
            document.getElementById('charCount').textContent = '0';

            saveToLocalStorage();
            renderActivityList();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function validateConnection(subject, object, predicate) {
            if (!subject || !object) return 'Invalid entities selected';

            // Define operator: hierarchical relationships
            if (predicate === 'DES') {
                // Units can Define units, teams, or roles
                if (subject.type === 'unit' && !['unit', 'team', 'role'].includes(object.type)) {
                    return 'Units can only Define other units, teams, or roles';
                }
                // Teams can Define teams or roles
                if (subject.type === 'team' && !['team', 'role'].includes(object.type)) {
                    return 'Teams can only Define other teams or roles';
                }
                // Roles cannot Define
                if (subject.type === 'role') {
                    return 'Roles cannot use Define operator (use Link or other operators)';
                }
            }

            // Start operator: people joining roles, creating work
            if (predicate === 'INS') {
                // People can Start (join) roles
                if (subject.type === 'person' && object.type !== 'role') {
                    return 'People can only Start roles';
                }
            }

            // Link operator: connecting work
            if (predicate === 'CON') {
                // Roles Link to objects
                if (subject.type === 'role' && object.type !== 'object') {
                    return 'Roles should Link to work objects';
                }
            }

            // Work products (objects) can only be linked to roles and teams, NOT people
            if (object.type === 'object') {
                if (subject.type === 'person') {
                    return 'Work products can only be linked to roles and teams, not people directly';
                }
                if (subject.type === 'unit') {
                    return 'Work products should be linked to roles or teams, not units directly';
                }
            }

            // Prevent nonsensical connections
            if (subject.type === 'object' && object.type === 'unit') {
                return 'Work objects cannot connect upward to organizational units';
            }

            return null; // Valid connection
        }

        function deleteActivity(id) {
            const relationship = relationships.find(r => r.id === id);
            if (!relationship) return;

            const subjectEntity = findEntity(relationship.subject);
            const objectEntity = findEntity(relationship.object);
            const operatorData = eoOperators[relationship.predicate];

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Delete ${operatorData?.label || relationship.predicate}: ${subjectEntity?.name || relationship.subject}  ${objectEntity?.name || relationship.object}`
            });

            // Add to recycle bin
            addToRecycleBin(relationship, 'relationship', null);

            relationships = relationships.filter(r => r.id !== id);
            saveToLocalStorage();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function renderActivityList() {
            const list = document.getElementById('activityList');
            const searchTerm = document.getElementById('activitySearch')?.value.toLowerCase() || '';
            
            if (!list) return; // Safety check
            
            list.innerHTML = '';

            if (relationships.length === 0) {
                list.innerHTML = '<div style="color: #8B6F47; font-size: 0.85rem; text-align: center; padding: 1rem;">No activities yet</div>';
                return;
            }

            // Filter out DES (Define) relationships - those are for nesting/hierarchy, not activities
            const filtered = relationships.filter(rel => {
                if (rel.predicate === 'DES') return false; // Exclude nesting relationships
                const subjectEntity = findEntity(rel.subject);
                const objectEntity = findEntity(rel.object);
                const searchText = `${subjectEntity?.name || ''} ${rel.predicate} ${objectEntity?.name || ''}`.toLowerCase();
                return searchText.includes(searchTerm);
            });

            if (filtered.length === 0) {
                list.innerHTML = '<div style="color: #8B6F47; font-size: 0.85rem; text-align: center; padding: 1rem;">No matching activities</div>';
                return;
            }

            filtered.forEach(rel => {
                const subjectEntity = findEntity(rel.subject);
                const objectEntity = findEntity(rel.object);
                const operator = eoOperators[rel.predicate];

                const item = document.createElement('div');
                item.className = `relationship-item ${rel.predicate}`;
                item.innerHTML = `
                    <div class="relationship-text">
                        <strong>${subjectEntity?.name || rel.subject}</strong>
                        <span style="color: ${operator.color}; margin: 0 0.25rem; font-weight: 600;">${operator.label}</span>
                        <strong>${objectEntity?.name || rel.object}</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="relationship-meta">${subjectEntity?.type}  ${objectEntity?.type}</div>
                        <button class="btn-icon" onclick="deleteActivity('${rel.id}')"></button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function updateSelects() {
            const subjectSelect = document.getElementById('subjectSelect');
            const orgEntitySelect = document.getElementById('orgEntitySelect');
            const objectSelect = document.getElementById('objectSelect');

            subjectSelect.innerHTML = '<option value="">Select entity...</option>';
            orgEntitySelect.innerHTML = '<option value="">Select entity...</option>';
            objectSelect.innerHTML = '<option value="">Select work product...</option>';

            // Subject: all entity types
            const types = ['unit', 'team', 'role', 'person', 'object'];
            types.forEach(type => {
                entities[type].forEach(entity => {
                    const option = document.createElement('option');
                    option.value = entity.id;
                    option.textContent = `${entity.name} (${type})`;
                    subjectSelect.appendChild(option);
                });
            });

            // Org Entity: only units, teams, roles
            const orgTypes = ['unit', 'team', 'role'];
            orgTypes.forEach(type => {
                entities[type].forEach(entity => {
                    const option = document.createElement('option');
                    option.value = entity.id;
                    option.textContent = `${entity.name} (${type})`;
                    orgEntitySelect.appendChild(option);
                });
            });

            // Work Products: only objects
            entities.object.forEach(entity => {
                const option = document.createElement('option');
                option.value = entity.id;
                option.textContent = entity.name;
                objectSelect.appendChild(option);
            });
        }

        // Quick create for work objects only
        function toggleQuickCreateObject() {
            const quickCreate = document.getElementById('quickCreateObject');
            quickCreate.style.display = quickCreate.style.display === 'none' ? 'block' : 'none';
            if (quickCreate.style.display === 'block') {
                document.getElementById('quickObjectName').focus();
            }
        }

        function createQuickObject() {
            const name = document.getElementById('quickObjectName').value.trim();

            if (!name) {
                alert('Please enter a name for the work object');
                return;
            }

            const id = 'o' + Date.now();
            const entity = { id, name, type: 'object', description: '' };
            entities.object.push(entity);

            // Log to Xano
            logActivityToXano({
                event_verb: 'Start Entity',
                eo_operator: 'INS',
                object_type: 'object',
                object_id: id,
                object_label: name,
                data_json: {
                    entity_type: 'object',
                    entity_name: name,
                    created_from: 'quick_create_object'
                }
            });

            // Update UI
            updateSelects();
            renderEntityList();
            
            // Select the new object
            document.getElementById('objectSelect').value = id;
            
            // Hide quick create and clear
            document.getElementById('quickCreateObject').style.display = 'none';
            document.getElementById('quickObjectName').value = '';
            
            updateSentencePreview();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            }
        }

        // ==========================================
        // WORK PRODUCT SELECTOR MODAL
        // ==========================================

        let selectedWorkProductId = null;
        let workProductSelectorCallback = null;

        function openWorkProductSelectorModal(callback) {
            workProductSelectorCallback = callback;
            selectedWorkProductId = null;

            // Clear search
            document.getElementById('workProductSearchInput').value = '';
            document.getElementById('newWorkProductName').value = '';

            // Populate work products
            renderWorkProductList();

            // Update selection button
            document.getElementById('confirmWorkProductSelection').disabled = true;

            // Show modal
            document.getElementById('workProductSelectorModal').classList.add('active');

            // Focus search
            setTimeout(() => {
                document.getElementById('workProductSearchInput').focus();
            }, 100);
        }

        function closeWorkProductSelectorModal() {
            document.getElementById('workProductSelectorModal').classList.remove('active');
            selectedWorkProductId = null;
            workProductSelectorCallback = null;
        }

        function renderWorkProductList(searchTerm = '') {
            const content = document.getElementById('workProductSelectorContent');
            const workProducts = entities.object || [];

            // Filter by search term
            const filteredProducts = workProducts.filter(wp =>
                wp.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                (wp.description && wp.description.toLowerCase().includes(searchTerm.toLowerCase()))
            );

            if (filteredProducts.length === 0 && !searchTerm) {
                content.innerHTML = `
                    <div class="modal-empty-state">
                        <i class="ph ph-package"></i>
                        <div>No work products yet</div>
                        <div style="font-size: 0.85rem; margin-top: 0.5rem;">Create one below to get started</div>
                    </div>
                `;
                return;
            }

            if (filteredProducts.length === 0 && searchTerm) {
                content.innerHTML = `
                    <div class="modal-empty-state">
                        <i class="ph ph-magnifying-glass"></i>
                        <div>No matching work products</div>
                        <div style="font-size: 0.85rem; margin-top: 0.5rem;">Try a different search or create a new one</div>
                    </div>
                `;
                return;
            }

            // Group work products by their parent (connected via relationships)
            const groupedProducts = groupWorkProductsByParent(filteredProducts);

            let html = '';

            // Render grouped work products
            Object.entries(groupedProducts).forEach(([parentName, products]) => {
                if (parentName !== 'Uncategorized' || Object.keys(groupedProducts).length === 1) {
                    // Only show category headers if there are multiple categories
                    if (Object.keys(groupedProducts).length > 1) {
                        html += `
                            <div class="work-product-category">
                                <div class="work-product-category-header" onclick="toggleWorkProductCategory(this)">
                                    <i class="ph ph-caret-down category-toggle"></i>
                                    <i class="ph ph-folder"></i>
                                    <span>${parentName}</span>
                                    <span style="margin-left: auto; font-size: 0.8rem; opacity: 0.7;">${products.length}</span>
                                </div>
                                <div class="work-product-category-items">
                        `;
                    }

                    products.forEach(wp => {
                        const isSelected = selectedWorkProductId === wp.id;
                        html += `
                            <div class="work-product-item ${isSelected ? 'selected' : ''}"
                                 onclick="selectWorkProductItem('${wp.id}')"
                                 data-id="${wp.id}">
                                <div class="work-product-item-icon">
                                    <i class="ph ph-file-text"></i>
                                </div>
                                <div class="work-product-item-content">
                                    <div class="work-product-item-name">${wp.name}</div>
                                    ${wp.description ? `<div class="work-product-item-desc">${wp.description}</div>` : ''}
                                </div>
                            </div>
                        `;
                    });

                    if (Object.keys(groupedProducts).length > 1) {
                        html += `
                                </div>
                            </div>
                        `;
                    }
                }
            });

            content.innerHTML = html;
        }

        function groupWorkProductsByParent(workProducts) {
            const grouped = {};

            workProducts.forEach(wp => {
                // Find if this work product is connected to any role/team
                let parentName = 'Uncategorized';

                const connection = relationships.find(r =>
                    r.object === wp.id && r.predicate !== 'DES'
                );

                if (connection) {
                    const parent = findEntity(connection.subject);
                    if (parent) {
                        parentName = `${parent.name} (${parent.type})`;
                    }
                }

                if (!grouped[parentName]) {
                    grouped[parentName] = [];
                }
                grouped[parentName].push(wp);
            });

            // Sort to put Uncategorized last
            const sortedGrouped = {};
            Object.keys(grouped).sort((a, b) => {
                if (a === 'Uncategorized') return 1;
                if (b === 'Uncategorized') return -1;
                return a.localeCompare(b);
            }).forEach(key => {
                sortedGrouped[key] = grouped[key];
            });

            return sortedGrouped;
        }

        function toggleWorkProductCategory(header) {
            header.classList.toggle('collapsed');
            const items = header.nextElementSibling;
            items.classList.toggle('collapsed');
        }

        function selectWorkProductItem(id) {
            // Clear previous selection
            document.querySelectorAll('.work-product-item').forEach(item => {
                item.classList.remove('selected');
            });

            // Set new selection
            selectedWorkProductId = id;
            const selectedItem = document.querySelector(`.work-product-item[data-id="${id}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }

            // Enable confirm button
            document.getElementById('confirmWorkProductSelection').disabled = false;
        }

        function filterWorkProducts() {
            const searchTerm = document.getElementById('workProductSearchInput').value;
            renderWorkProductList(searchTerm);
        }

        function createWorkProductFromModal() {
            const name = document.getElementById('newWorkProductName').value.trim();

            if (!name) {
                alert('Please enter a name for the work product');
                return;
            }

            const id = 'o' + Date.now();
            const entity = { id, name, type: 'object', description: '' };
            entities.object.push(entity);

            // Log to Xano
            logActivityToXano({
                event_verb: 'Start Entity',
                eo_operator: 'INS',
                object_type: 'object',
                object_id: id,
                object_label: name,
                data_json: {
                    entity_type: 'object',
                    entity_name: name,
                    created_from: 'work_product_modal'
                }
            });

            // Update UI
            updateSelects();
            renderEntityList();

            // Save
            saveToLocalStorage();

            // Clear input
            document.getElementById('newWorkProductName').value = '';

            // Refresh the list and select the new item
            renderWorkProductList(document.getElementById('workProductSearchInput').value);
            selectWorkProductItem(id);

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function confirmWorkProductSelection() {
            if (selectedWorkProductId && workProductSelectorCallback) {
                const workProduct = findEntity(selectedWorkProductId);
                workProductSelectorCallback(workProduct);
            }
            closeWorkProductSelectorModal();
        }

        // Open work product selector from the entity modal
        function openWorkProductSelectorForModal() {
            openWorkProductSelectorModal((workProduct) => {
                if (workProduct) {
                    // Update the hidden input and button text
                    document.getElementById('modalSelectedWorkProductId').value = workProduct.id;
                    document.getElementById('modalWorkProductBtnText').textContent = workProduct.name;
                    document.getElementById('modalWorkProductBtn').classList.add('has-selection');
                }
            });
        }

        // Add work product activity from modal
        function addWorkProductActivityFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = document.getElementById('modalWorkProductOperatorSelect').value;
            const workProductId = document.getElementById('modalSelectedWorkProductId').value;

            if (!operatorCode || !workProductId) {
                alert('Please select both an activity type and a work product');
                return;
            }

            // DES should not be used here - it's for nesting
            if (operatorCode === 'DES') {
                alert('Use "Add Nested" for hierarchical relationships');
                return;
            }

            const workProduct = findEntity(workProductId);
            if (!workProduct) {
                alert('Work product not found');
                return;
            }

            // Validate: Work products can only be linked to roles and teams
            if (currentModalEntityType !== 'role' && currentModalEntityType !== 'team') {
                alert('Work products can only be linked to roles and teams');
                return;
            }

            // Create the relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: workProductId,
                description: ''
            };

            relationships.push(relationship);

            // Log to Xano
            const operatorData = eoOperators[operatorCode];
            logActivityToXano({
                event_verb: `${operatorData.label} Activity`,
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${workProduct.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: workProductId,
                    object_type: 'object',
                    object_name: workProduct.name,
                    connection_type: 'work_product_activity'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new activity
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Handler for modal operator change (optional - for future use)
        function handleModalOperatorChange() {
            // Could be used to filter targets based on operator type
        }

        function findEntity(id) {
            const types = ['unit', 'team', 'role', 'person', 'object'];
            for (let type of types) {
                const entity = entities[type].find(e => e.id === id);
                if (entity) return entity;
            }
            return null;
        }

        // ==========================================
        // VENN DIAGRAM VIEW
        // ==========================================

        // Get children entities of a specific entity (entities connected via DES)
        function getVennChildren(parentId, childType) {
            const children = [];
            relationships.forEach(r => {
                if (r.predicate === 'DES') {
                    if (r.subject === parentId) {
                        const child = entities[childType]?.find(e => e.id === r.object);
                        if (child) children.push(child);
                    }
                    if (r.object === parentId) {
                        const child = entities[childType]?.find(e => e.id === r.subject);
                        if (child) children.push(child);
                    }
                }
            });
            return children;
        }

        // Get all sub-entities nested under an entity (recursive)
        function getAllNestedEntities(entityId, includeTypes = ['team', 'role', 'person']) {
            const nested = [];
            const visited = new Set();

            function traverse(id) {
                if (visited.has(id)) return;
                visited.add(id);

                relationships.forEach(r => {
                    if (r.predicate === 'DES' || r.predicate === 'INS') {
                        let childId = null;
                        if (r.subject === id) childId = r.object;
                        else if (r.object === id) childId = r.subject;

                        if (childId && !visited.has(childId)) {
                            const child = findEntity(childId);
                            if (child && includeTypes.includes(child.type)) {
                                nested.push(child);
                                traverse(childId);
                            }
                        }
                    }
                });
            }

            traverse(entityId);
            return nested;
        }

        // Find shared connections between two entities (through their nested children)
        function getSharedConnections(entity1Id, entity2Id) {
            const nested1 = getAllNestedEntities(entity1Id);
            const nested2 = getAllNestedEntities(entity2Id);
            const nested1Ids = new Set([entity1Id, ...nested1.map(e => e.id)]);
            const nested2Ids = new Set([entity2Id, ...nested2.map(e => e.id)]);

            const shared = [];

            // Find relationships that connect entities from both groups
            relationships.forEach(r => {
                const subjectIn1 = nested1Ids.has(r.subject);
                const subjectIn2 = nested2Ids.has(r.subject);
                const objectIn1 = nested1Ids.has(r.object);
                const objectIn2 = nested2Ids.has(r.object);

                // Connection bridges the two groups
                if ((subjectIn1 && objectIn2) || (subjectIn2 && objectIn1)) {
                    const subjectEntity = findEntity(r.subject);
                    const objectEntity = findEntity(r.object);
                    if (subjectEntity && objectEntity) {
                        shared.push({
                            relationship: r,
                            from: subjectEntity,
                            to: objectEntity
                        });
                    }
                }
            });

            return shared;
        }

        // Calculate overlap weight between two entities
        function getOverlapWeight(entity1Id, entity2Id) {
            return getSharedConnections(entity1Id, entity2Id).length;
        }

        // Get entities at current level, optionally filtered by focused parent
        function getVennEntitiesAtLevel() {
            const levelType = vennLevels[vennCurrentLevel];
            let entitiesAtLevel = entities[levelType] || [];

            // If we have a focused entity, only show its children
            if (vennFocusedEntity) {
                const childType = vennLevels[vennCurrentLevel];
                entitiesAtLevel = getVennChildren(vennFocusedEntity.id, childType);

                // Also include entities connected via other relationships
                relationships.forEach(r => {
                    if (r.subject === vennFocusedEntity.id || r.object === vennFocusedEntity.id) {
                        const otherId = r.subject === vennFocusedEntity.id ? r.object : r.subject;
                        const otherEntity = entities[childType]?.find(e => e.id === otherId);
                        if (otherEntity && !entitiesAtLevel.find(e => e.id === otherEntity.id)) {
                            entitiesAtLevel.push(otherEntity);
                        }
                    }
                });
            }

            return entitiesAtLevel;
        }

        // Render the Venn diagram
        function renderVennView() {
            const container = document.getElementById('vennView');
            const svg = d3.select('#vennDiagram');

            if (!container || !svg.node()) return;

            // Clear previous content
            svg.selectAll('*').remove();
            closeOverlapPanel();

            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            const centerX = width / 2;
            const centerY = height / 2;

            svg.attr('viewBox', `0 0 ${width} ${height}`)
               .attr('preserveAspectRatio', 'xMidYMid meet');

            // Update level controls
            updateVennLevelControls();

            // Get entities at current level
            const entitiesAtLevel = getVennEntitiesAtLevel();

            if (entitiesAtLevel.length === 0) {
                // Show empty state
                svg.append('text')
                    .attr('x', centerX)
                    .attr('y', centerY)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#8B6F47')
                    .attr('font-size', '16px')
                    .text(`No ${vennLevelLabels[vennCurrentLevel].toLowerCase()} to display`);
                return;
            }

            // Calculate circle positions and sizes based on number of entities
            const circles = calculateVennCircles(entitiesAtLevel, width, height, centerX, centerY);

            // Calculate overlaps between circles
            const overlaps = calculateVennOverlaps(circles);

            // Draw overlaps first (underneath circles)
            overlaps.forEach(overlap => {
                if (overlap.weight > 0) {
                    drawOverlapRegion(svg, overlap, circles);
                }
            });

            // Draw circles
            circles.forEach(circle => {
                drawVennCircle(svg, circle);
            });

            // Add zoom hint
            showVennZoomHint();
        }

        // Calculate positions for Venn circles using force simulation
        function calculateVennCircles(entitiesAtLevel, width, height, centerX, centerY) {
            const n = entitiesAtLevel.length;
            const maxRadius = Math.min(width, height) * 0.35;
            const minRadius = 60;

            // Calculate radius based on nested entities count
            const circles = entitiesAtLevel.map((entity, i) => {
                const nested = getAllNestedEntities(entity.id);
                const nestedCount = nested.length + 1; // Include self
                const baseRadius = Math.max(minRadius, Math.min(maxRadius, 40 + nestedCount * 8));

                // Initial position in a circle - spread entities further apart
                const angle = (2 * Math.PI * i) / n - Math.PI / 2;
                const spread = Math.min(width, height) * 0.3;

                return {
                    entity: entity,
                    id: entity.id,
                    x: centerX + spread * Math.cos(angle),
                    y: centerY + spread * Math.sin(angle),
                    radius: baseRadius,
                    nestedCount: nestedCount,
                    color: getNodeColor(entity.type)
                };
            });

            // Apply force simulation to position circles with overlaps
            if (n > 1) {
                // Create links for circles that should overlap
                const links = [];
                for (let i = 0; i < circles.length; i++) {
                    for (let j = i + 1; j < circles.length; j++) {
                        const weight = getOverlapWeight(circles[i].id, circles[j].id);
                        if (weight > 0) {
                            // Stronger connection = closer circles, but maintain minimum distance
                            const minDistance = (circles[i].radius + circles[j].radius) * 0.6;
                            const distance = Math.max(minDistance, circles[i].radius + circles[j].radius - Math.min(30, weight * 8));
                            links.push({
                                source: i,
                                target: j,
                                distance: distance
                            });
                        }
                    }
                }

                // Simple force-based positioning with stronger separation
                const simulation = d3.forceSimulation(circles)
                    .force('center', d3.forceCenter(centerX, centerY))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('collision', d3.forceCollide().radius(d => d.radius * 0.9).strength(0.8))
                    .force('link', d3.forceLink(links).distance(d => d.distance).strength(0.3))
                    .stop();

                // Run simulation
                for (let i = 0; i < 100; i++) simulation.tick();

                // Keep circles within bounds
                circles.forEach(c => {
                    c.x = Math.max(c.radius + 10, Math.min(width - c.radius - 10, c.x));
                    c.y = Math.max(c.radius + 60, Math.min(height - c.radius - 10, c.y));
                });
            }

            return circles;
        }

        // Calculate overlaps between all circle pairs
        function calculateVennOverlaps(circles) {
            const overlaps = [];

            for (let i = 0; i < circles.length; i++) {
                for (let j = i + 1; j < circles.length; j++) {
                    const c1 = circles[i];
                    const c2 = circles[j];
                    const dx = c2.x - c1.x;
                    const dy = c2.y - c1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Check if circles overlap
                    if (distance < c1.radius + c2.radius) {
                        const weight = getOverlapWeight(c1.id, c2.id);
                        const sharedConnections = getSharedConnections(c1.id, c2.id);

                        overlaps.push({
                            circle1: c1,
                            circle2: c2,
                            weight: weight,
                            sharedConnections: sharedConnections,
                            distance: distance
                        });
                    }
                }
            }

            return overlaps;
        }

        // Draw a single Venn circle
        function drawVennCircle(svg, circle) {
            const group = svg.append('g')
                .attr('class', 'venn-circle-group')
                .style('cursor', 'pointer');

            // Main circle
            group.append('circle')
                .attr('class', 'venn-circle')
                .attr('cx', circle.x)
                .attr('cy', circle.y)
                .attr('r', circle.radius)
                .attr('fill', circle.color)
                .attr('fill-opacity', 0.25)
                .attr('stroke', circle.color)
                .attr('stroke-width', 3)
                .on('click', () => handleVennCircleClick(circle))
                .on('dblclick', () => drillIntoEntity(circle.entity))
                .on('mouseenter', (event) => showVennTooltip(event, circle))
                .on('mouseleave', hideVennTooltip);

            // Entity name label
            const labelText = circle.entity.name.length > 20
                ? circle.entity.name.substring(0, 17) + '...'
                : circle.entity.name;

            group.append('text')
                .attr('class', 'venn-circle-label')
                .attr('x', circle.x)
                .attr('y', circle.y - 8)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .text(labelText);

            // Count label
            group.append('text')
                .attr('class', 'venn-circle-count')
                .attr('x', circle.x)
                .attr('y', circle.y + 12)
                .attr('text-anchor', 'middle')
                .text(`${circle.nestedCount} nested`);

            // Icon
            group.append('text')
                .attr('x', circle.x)
                .attr('y', circle.y - circle.radius + 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('fill', circle.color)
                .text(getIconChar(circle.entity.type));
        }

        // Draw overlap region between two circles
        function drawOverlapRegion(svg, overlap, circles) {
            const { circle1, circle2, sharedConnections } = overlap;

            // Calculate intersection path
            const path = calculateIntersectionPath(circle1, circle2);
            if (!path) return;

            // Create gradient for overlap
            const gradientId = `overlap-gradient-${circle1.id}-${circle2.id}`;
            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', gradientId)
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '100%').attr('y2', '0%');

            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', circle1.color)
                .attr('stop-opacity', 0.4);
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', circle2.color)
                .attr('stop-opacity', 0.4);

            // Draw overlap area
            const overlapGroup = svg.append('g')
                .attr('class', 'venn-overlap')
                .style('cursor', 'pointer')
                .on('click', () => showOverlapDetails(circle1.entity, circle2.entity, sharedConnections));

            overlapGroup.append('path')
                .attr('d', path)
                .attr('fill', `url(#${gradientId})`)
                .attr('stroke', '#C88F4A')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '4,2');

            // Add connection count indicator in overlap center
            if (sharedConnections.length > 0) {
                const midX = (circle1.x + circle2.x) / 2;
                const midY = (circle1.y + circle2.y) / 2;

                overlapGroup.append('circle')
                    .attr('cx', midX)
                    .attr('cy', midY)
                    .attr('r', 16)
                    .attr('fill', '#C88F4A')
                    .attr('class', 'venn-overlap-indicator');

                overlapGroup.append('text')
                    .attr('x', midX)
                    .attr('y', midY)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('fill', 'white')
                    .attr('font-size', '12px')
                    .attr('font-weight', '600')
                    .attr('class', 'venn-overlap-indicator')
                    .text(sharedConnections.length);
            }
        }

        // Calculate SVG path for circle intersection (lens shape)
        function calculateIntersectionPath(c1, c2) {
            const dx = c2.x - c1.x;
            const dy = c2.y - c1.y;
            const d = Math.sqrt(dx * dx + dy * dy);

            if (d >= c1.radius + c2.radius || d === 0) return null;

            // Calculate intersection points
            const a = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, c1.radius * c1.radius - a * a));

            const px = c1.x + a * dx / d;
            const py = c1.y + a * dy / d;

            const p1x = px + h * dy / d;
            const p1y = py - h * dx / d;
            const p2x = px - h * dy / d;
            const p2y = py + h * dx / d;

            // Create lens-shaped path using arcs
            const largeArc1 = c1.radius > d / 2 ? 1 : 0;
            const largeArc2 = c2.radius > d / 2 ? 1 : 0;

            return `M ${p1x} ${p1y}
                    A ${c1.radius} ${c1.radius} 0 ${largeArc1} 1 ${p2x} ${p2y}
                    A ${c2.radius} ${c2.radius} 0 ${largeArc2} 1 ${p1x} ${p1y}`;
        }

        // Handle click on a Venn circle
        function handleVennCircleClick(circle) {
            openEntityModal(circle.entity.id, circle.entity.type);
        }

        // Drill into an entity to see its children
        function drillIntoEntity(entity) {
            const nextLevel = vennCurrentLevel + 1;
            if (nextLevel >= vennLevels.length) return;

            // Check if entity has children at next level
            const childType = vennLevels[nextLevel];
            const children = getVennChildren(entity.id, childType);

            if (children.length === 0) {
                // Show hint that there's nothing to drill into
                showVennZoomHint(`No ${vennLevelLabels[nextLevel].toLowerCase()} under ${entity.name}`);
                return;
            }

            // Update state and re-render
            vennBreadcrumb.push({ entity: vennFocusedEntity, level: vennCurrentLevel });
            vennFocusedEntity = entity;
            vennCurrentLevel = nextLevel;
            renderVennView();
        }

        // Change hierarchy level
        function changeVennLevel(direction) {
            const newLevel = vennCurrentLevel + direction;

            if (newLevel < 0 || newLevel >= vennLevels.length) return;

            // If going up, clear focus
            if (direction < 0) {
                if (vennBreadcrumb.length > 0) {
                    const prev = vennBreadcrumb.pop();
                    vennFocusedEntity = prev.entity;
                } else {
                    vennFocusedEntity = null;
                }
            }

            vennCurrentLevel = newLevel;
            renderVennView();
        }

        // Update level navigation controls
        function updateVennLevelControls() {
            const upBtn = document.getElementById('vennLevelUp');
            const downBtn = document.getElementById('vennLevelDown');
            const label = document.getElementById('vennLevelLabel');
            const breadcrumb = document.getElementById('vennBreadcrumb');

            if (upBtn) upBtn.disabled = vennCurrentLevel === 0;
            if (downBtn) downBtn.disabled = vennCurrentLevel >= vennLevels.length - 1;
            if (label) label.textContent = vennLevelLabels[vennCurrentLevel];

            // Update breadcrumb
            if (breadcrumb) {
                let html = '';
                vennBreadcrumb.forEach((item, i) => {
                    if (item.entity) {
                        html += `<span class="venn-breadcrumb-item" onclick="navigateVennBreadcrumb(${i})">${item.entity.name}</span>`;
                        html += '<span class="venn-breadcrumb-separator"></span>';
                    }
                });
                if (vennFocusedEntity) {
                    html += `<span class="venn-breadcrumb-item active">${vennFocusedEntity.name}</span>`;
                }
                breadcrumb.innerHTML = html;
            }
        }

        // Navigate via breadcrumb
        function navigateVennBreadcrumb(index) {
            if (index < vennBreadcrumb.length) {
                const target = vennBreadcrumb[index];
                vennBreadcrumb = vennBreadcrumb.slice(0, index);
                vennFocusedEntity = target.entity;
                vennCurrentLevel = target.level;
                renderVennView();
            }
        }

        // Show overlap details panel
        function showOverlapDetails(entity1, entity2, sharedConnections) {
            const panel = document.getElementById('vennOverlapPanel');
            const title = document.getElementById('vennOverlapTitle');
            const content = document.getElementById('vennOverlapContent');

            if (!panel || !content) return;

            title.textContent = `${entity1.name}  ${entity2.name}`;

            let html = '';

            if (sharedConnections.length === 0) {
                html = '<div style="color: #8B6F47; text-align: center; padding: 1rem;">No shared connections</div>';
            } else {
                html += `<div class="venn-shared-label">
                    <i class="ph ph-link"></i> Shared Connections
                    <span class="venn-shared-count">${sharedConnections.length}</span>
                </div>`;

                // Group by relationship type
                const grouped = {};
                sharedConnections.forEach(conn => {
                    const op = eoOperators[conn.relationship.predicate];
                    const key = op ? op.label : conn.relationship.predicate;
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(conn);
                });

                Object.keys(grouped).forEach(key => {
                    html += `<div class="venn-entity-section">
                        <div class="venn-entity-header">
                            <i class="ph ph-arrow-right"></i> ${key}
                        </div>`;

                    grouped[key].forEach(conn => {
                        html += `
                            <div class="venn-connection-item" onclick="openEntityModal('${conn.from.id}', '${conn.from.type}')">
                                <div class="venn-connection-icon" style="background: ${getNodeColor(conn.from.type)}">
                                    ${getIcon(conn.from.type)}
                                </div>
                                <div class="venn-connection-info">
                                    <div class="venn-connection-name">${conn.from.name}</div>
                                    <div class="venn-connection-type">${conn.from.type}</div>
                                </div>
                            </div>
                            <div style="text-align: center; color: #C88F4A; margin: 0.25rem 0;">
                                <i class="ph ph-arrow-down"></i>
                            </div>
                            <div class="venn-connection-item" onclick="openEntityModal('${conn.to.id}', '${conn.to.type}')">
                                <div class="venn-connection-icon" style="background: ${getNodeColor(conn.to.type)}">
                                    ${getIcon(conn.to.type)}
                                </div>
                                <div class="venn-connection-info">
                                    <div class="venn-connection-name">${conn.to.name}</div>
                                    <div class="venn-connection-type">${conn.to.type}</div>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                });
            }

            content.innerHTML = html;
            panel.classList.add('visible');
        }

        // Close overlap details panel
        function closeOverlapPanel() {
            const panel = document.getElementById('vennOverlapPanel');
            if (panel) panel.classList.remove('visible');
        }

        // Show tooltip on hover
        function showVennTooltip(event, circle) {
            const tooltip = document.getElementById('vennTooltip');
            if (!tooltip) return;

            const nested = getAllNestedEntities(circle.entity.id);
            const nestedByType = {};
            nested.forEach(e => {
                if (!nestedByType[e.type]) nestedByType[e.type] = 0;
                nestedByType[e.type]++;
            });

            let nestedText = Object.keys(nestedByType)
                .map(type => `${nestedByType[type]} ${type}${nestedByType[type] > 1 ? 's' : ''}`)
                .join(', ');

            tooltip.innerHTML = `
                <div class="venn-tooltip-title">${circle.entity.name}</div>
                <div class="venn-tooltip-desc">
                    ${circle.entity.description || 'No description'}<br>
                    <strong>Contains:</strong> ${nestedText || 'Nothing nested'}
                </div>
            `;

            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
            tooltip.classList.add('visible');
        }

        // Hide tooltip
        function hideVennTooltip() {
            const tooltip = document.getElementById('vennTooltip');
            if (tooltip) tooltip.classList.remove('visible');
        }

        // Show temporary hint
        function showVennZoomHint(message) {
            const hint = document.querySelector('.venn-zoom-hint');
            if (!hint) {
                // Create hint element
                const vennView = document.getElementById('vennView');
                if (vennView) {
                    const hintEl = document.createElement('div');
                    hintEl.className = 'venn-zoom-hint';
                    hintEl.textContent = message || 'Double-click to drill down';
                    vennView.appendChild(hintEl);
                    setTimeout(() => hintEl.classList.add('visible'), 10);
                    setTimeout(() => {
                        hintEl.classList.remove('visible');
                        setTimeout(() => hintEl.remove(), 300);
                    }, 2000);
                }
            }
        }

        // Card View State
        let cardViewSearchTerm = '';
        let cardViewSortOption = 'name-asc';
        let cardViewTypeFilters = {
            unit: true,
            team: true,
            role: true,
            person: true,
            object: true,
            activity: true
        };
        let cardViewHierarchical = true; // Default to hierarchical view
        let cardViewGroupBy = 'none'; // Group by: 'none', 'unit', 'team', 'role'

        function toggleCardViewMode(isHierarchical) {
            cardViewHierarchical = isHierarchical;
            renderCardView();
        }

        // Build hierarchy tree from DES relationships
        function buildHierarchyTree() {
            // Find all DES relationships (parent defines child)
            const desRelationships = relationships.filter(r => r.predicate === 'DES');

            // Track which entities have parents
            const entitiesWithParents = new Set(desRelationships.map(r => r.object));

            // Get children for a given parent entity
            function getChildren(parentId) {
                return desRelationships
                    .filter(r => r.subject === parentId)
                    .map(r => findEntity(r.object))
                    .filter(e => e !== null);
            }

            // Get people who fill a role (INS relationships)
            function getPeopleInRole(roleId) {
                return relationships
                    .filter(r => r.predicate === 'INS' && r.object === roleId)
                    .map(r => findEntity(r.subject))
                    .filter(e => e !== null && e.type === 'person');
            }

            // Recursively build unit node with nested units, teams, and roles
            function buildUnitNode(unit) {
                const directTeams = getChildren(unit.id).filter(e => e.type === 'team');
                const directRoles = getChildren(unit.id).filter(e => e.type === 'role');
                const childUnits = getChildren(unit.id).filter(e => e.type === 'unit');

                return {
                    entity: unit,
                    units: childUnits.map(childUnit => buildUnitNode(childUnit)),
                    teams: directTeams.map(team => {
                        const teamRoles = getChildren(team.id).filter(e => e.type === 'role');
                        return {
                            entity: team,
                            roles: teamRoles.map(role => ({
                                entity: role,
                                people: getPeopleInRole(role.id)
                            }))
                        };
                    }),
                    roles: directRoles.map(role => ({
                        entity: role,
                        people: getPeopleInRole(role.id)
                    }))
                };
            }

            // Find top-level units (units that don't have a parent unit)
            const topLevelUnits = entities.unit.filter(unit => {
                return !desRelationships.some(r =>
                    r.object === unit.id && entities.unit.some(u => u.id === r.subject)
                );
            });

            // Build tree structure starting from top-level units only
            const hierarchyTree = topLevelUnits.map(unit => buildUnitNode(unit));

            // Find orphan entities (no DES parent)
            const orphanTeams = entities.team.filter(t => !entitiesWithParents.has(t.id));
            const orphanRoles = entities.role.filter(r => !entitiesWithParents.has(r.id));
            const orphanPeople = entities.person.filter(p => {
                // People are orphans if they don't fill any roles
                return !relationships.some(r => r.predicate === 'INS' && r.subject === p.id);
            });

            return {
                units: hierarchyTree,
                orphanTeams,
                orphanRoles,
                orphanPeople,
                objects: entities.object // Objects are always shown separately
            };
        }

        // Get non-DES activities for an entity
        function getEntityActivities(entityId) {
            return relationships.filter(r =>
                (r.subject === entityId || r.object === entityId) && r.predicate !== 'DES' && r.predicate !== 'INS'
            );
        }

        // Card View Filtering and Sorting Functions
        function filterEntitiesBySearch(entitiesArray, searchTerm) {
            if (!searchTerm) return entitiesArray;
            const term = searchTerm.toLowerCase();
            return entitiesArray.filter(entity =>
                entity.name.toLowerCase().includes(term) ||
                (entity.description && entity.description.toLowerCase().includes(term))
            );
        }

        function sortEntities(entitiesArray, sortOption) {
            const sorted = [...entitiesArray];
            switch (sortOption) {
                case 'name-asc':
                    return sorted.sort((a, b) => a.name.localeCompare(b.name));
                case 'name-desc':
                    return sorted.sort((a, b) => b.name.localeCompare(a.name));
                case 'connections-desc':
                    return sorted.sort((a, b) => {
                        const aConnections = relationships.filter(r => r.subject === a.id || r.object === a.id).length;
                        const bConnections = relationships.filter(r => r.subject === b.id || r.object === b.id).length;
                        return bConnections - aConnections;
                    });
                case 'connections-asc':
                    return sorted.sort((a, b) => {
                        const aConnections = relationships.filter(r => r.subject === a.id || r.object === a.id).length;
                        const bConnections = relationships.filter(r => r.subject === b.id || r.object === b.id).length;
                        return aConnections - bConnections;
                    });
                default:
                    return sorted;
            }
        }

        function handleCardViewSearch(event) {
            cardViewSearchTerm = event.target.value;
            renderCardViewContent();
        }

        function handleCardViewSort(event) {
            cardViewSortOption = event.target.value;
            renderCardViewContent();
        }

        function handleCardViewGroupBy(event) {
            cardViewGroupBy = event.target.value;
            renderCardViewContent();
        }

        function toggleCardViewTypeFilter(type) {
            cardViewTypeFilters[type] = !cardViewTypeFilters[type];
            renderCardView();
        }

        // Card View Rendering
        function renderCardView() {
            const container = document.getElementById('cardView');
            if (!container) return;

            container.innerHTML = '';

            // Create controls toolbar
            const controls = document.createElement('div');
            controls.className = 'card-view-controls';

            // Search input
            const searchContainer = document.createElement('div');
            searchContainer.className = 'card-search-container';
            searchContainer.innerHTML = `
                <i class="ph ph-magnifying-glass card-search-icon"></i>
                <input type="text"
                       class="card-search-input"
                       placeholder="Search entities..."
                       value="${cardViewSearchTerm}"
                       oninput="handleCardViewSearch(event)">
            `;
            controls.appendChild(searchContainer);

            // Sort dropdown
            const sortContainer = document.createElement('div');
            sortContainer.className = 'card-sort-container';
            sortContainer.innerHTML = `
                <span class="card-sort-label">Sort by:</span>
                <select class="card-sort-select" onchange="handleCardViewSort(event)">
                    <option value="name-asc" ${cardViewSortOption === 'name-asc' ? 'selected' : ''}>Name (A-Z)</option>
                    <option value="name-desc" ${cardViewSortOption === 'name-desc' ? 'selected' : ''}>Name (Z-A)</option>
                    <option value="connections-desc" ${cardViewSortOption === 'connections-desc' ? 'selected' : ''}>Most Connections</option>
                    <option value="connections-asc" ${cardViewSortOption === 'connections-asc' ? 'selected' : ''}>Fewest Connections</option>
                </select>
            `;
            controls.appendChild(sortContainer);

            // Group By dropdown
            const groupByContainer = document.createElement('div');
            groupByContainer.className = 'card-sort-container';
            groupByContainer.innerHTML = `
                <span class="card-sort-label">Group by:</span>
                <select class="card-sort-select" onchange="handleCardViewGroupBy(event)">
                    <option value="none" ${cardViewGroupBy === 'none' ? 'selected' : ''}>None</option>
                    <option value="unit" ${cardViewGroupBy === 'unit' ? 'selected' : ''}>Unit</option>
                    <option value="team" ${cardViewGroupBy === 'team' ? 'selected' : ''}>Team</option>
                    <option value="role" ${cardViewGroupBy === 'role' ? 'selected' : ''}>Role</option>
                </select>
            `;
            controls.appendChild(groupByContainer);

            // View mode toggle (flat vs hierarchical)
            const viewModeToggle = document.createElement('div');
            viewModeToggle.className = 'view-mode-toggle';
            viewModeToggle.innerHTML = `
                <button class="view-mode-btn ${cardViewHierarchical ? 'active' : ''}" onclick="toggleCardViewMode(true)">
                    <i class="ph ph-tree-structure"></i>
                    Nested
                </button>
                <button class="view-mode-btn ${!cardViewHierarchical ? 'active' : ''}" onclick="toggleCardViewMode(false)">
                    <i class="ph ph-squares-four"></i>
                    Flat
                </button>
            `;
            controls.appendChild(viewModeToggle);

            // Type filter buttons
            const filterButtons = document.createElement('div');
            filterButtons.className = 'card-filter-buttons';

            const typeConfigs = [
                { type: 'unit', label: 'Units', icon: getIcon('unit'), count: entities.unit.length },
                { type: 'team', label: 'Teams', icon: getIcon('team'), count: entities.team.length },
                { type: 'role', label: 'Roles', icon: getIcon('role'), count: entities.role.length },
                { type: 'person', label: 'People', icon: getIcon('person'), count: entities.person.length },
                { type: 'object', label: 'Work Products', icon: getIcon('object'), count: entities.object.length },
                { type: 'activity', label: 'Activities', icon: '', count: relationships.length }
            ];

            typeConfigs.forEach(config => {
                if (config.count > 0) {
                    const btn = document.createElement('button');
                    btn.className = `card-filter-btn ${cardViewTypeFilters[config.type] ? 'active' : ''}`;
                    btn.onclick = () => toggleCardViewTypeFilter(config.type);
                    btn.innerHTML = `
                        <span class="filter-icon">${config.icon}</span>
                        <span>${config.label}</span>
                        <span class="filter-count">${config.count}</span>
                    `;
                    filterButtons.appendChild(btn);
                }
            });
            controls.appendChild(filterButtons);

            container.appendChild(controls);

            // Create content container
            const contentContainer = document.createElement('div');
            contentContainer.className = 'card-view-content';
            contentContainer.id = 'cardViewContent';
            container.appendChild(contentContainer);

            // Render the actual cards
            renderCardViewContent();
        }

        function renderCardViewContent() {
            const contentContainer = document.getElementById('cardViewContent');
            if (!contentContainer) return;

            contentContainer.innerHTML = '';

            const sidebarFilters = getActiveFilters();
            let hasContent = false;

            if (cardViewHierarchical) {
                // Hierarchical/nested view
                hasContent = renderHierarchicalCardView(contentContainer, sidebarFilters);
            } else if (cardViewGroupBy !== 'none') {
                // Grouped flat view
                hasContent = renderGroupedFlatCardView(contentContainer, sidebarFilters);
            } else {
                // Flat view (original behavior)
                hasContent = renderFlatCardView(contentContainer, sidebarFilters);
            }

            // Show no results message if nothing matches
            if (!hasContent) {
                const noResults = document.createElement('div');
                noResults.className = 'card-no-results';
                noResults.innerHTML = `
                    <i class="ph ph-magnifying-glass"></i>
                    <p>No entities match your search or filter criteria.</p>
                `;
                contentContainer.appendChild(noResults);
            }
        }

        function renderFlatCardView(contentContainer, sidebarFilters) {
            let hasContent = false;

            // Units
            if (cardViewTypeFilters.unit && sidebarFilters.entities.unit && entities.unit.length > 0) {
                let filteredUnits = filterEntitiesBySearch(entities.unit, cardViewSearchTerm);
                filteredUnits = sortEntities(filteredUnits, cardViewSortOption);
                if (filteredUnits.length > 0) {
                    contentContainer.appendChild(createCardRow('Units', filteredUnits, getIcon('unit')));
                    hasContent = true;
                }
            }

            // Teams
            if (cardViewTypeFilters.team && sidebarFilters.entities.team && entities.team.length > 0) {
                let filteredTeams = filterEntitiesBySearch(entities.team, cardViewSearchTerm);
                filteredTeams = sortEntities(filteredTeams, cardViewSortOption);
                if (filteredTeams.length > 0) {
                    contentContainer.appendChild(createCardRow('Teams', filteredTeams, getIcon('team')));
                    hasContent = true;
                }
            }

            // Roles
            if (cardViewTypeFilters.role && sidebarFilters.entities.role && entities.role.length > 0) {
                let filteredRoles = filterEntitiesBySearch(entities.role, cardViewSearchTerm);
                filteredRoles = sortEntities(filteredRoles, cardViewSortOption);
                if (filteredRoles.length > 0) {
                    contentContainer.appendChild(createCardRow('Roles', filteredRoles, getIcon('role')));
                    hasContent = true;
                }
            }

            // People
            if (cardViewTypeFilters.person && sidebarFilters.entities.person && entities.person.length > 0) {
                let filteredPeople = filterEntitiesBySearch(entities.person, cardViewSearchTerm);
                filteredPeople = sortEntities(filteredPeople, cardViewSortOption);
                if (filteredPeople.length > 0) {
                    contentContainer.appendChild(createCardRow('People', filteredPeople, getIcon('person')));
                    hasContent = true;
                }
            }

            // Work Products
            if (cardViewTypeFilters.object && sidebarFilters.entities.object && entities.object.length > 0) {
                let filteredObjects = filterEntitiesBySearch(entities.object, cardViewSearchTerm);
                filteredObjects = sortEntities(filteredObjects, cardViewSortOption);
                if (filteredObjects.length > 0) {
                    contentContainer.appendChild(createCardRow('Work Products', filteredObjects, getIcon('object')));
                    hasContent = true;
                }
            }

            // Activities
            if (cardViewTypeFilters.activity && relationships.length > 0) {
                const activityRow = createActivityCardRowFiltered();
                if (activityRow) {
                    contentContainer.appendChild(activityRow);
                    hasContent = true;
                }
            }

            return hasContent;
        }

        // Get the parent team or unit that a role belongs to (for disambiguation)
        function getRoleParentTeam(roleId) {
            // Find DES relationship where role is the object (child)
            const desRelationship = relationships.find(r =>
                r.predicate === 'DES' && r.object === roleId
            );
            if (!desRelationship) return null;

            const parentEntity = findEntity(desRelationship.subject);
            // Return the parent if it's a team or unit
            if (parentEntity && (parentEntity.type === 'team' || parentEntity.type === 'unit')) {
                return parentEntity;
            }
            return null;
        }

        // Get the parent entity of an entity based on the groupBy type
        function getParentEntity(entity, groupByType) {
            // Find DES relationship where entity is the object (child)
            const desRelationship = relationships.find(r =>
                r.predicate === 'DES' && r.object === entity.id
            );

            if (!desRelationship) return null;

            const parentEntity = findEntity(desRelationship.subject);
            if (!parentEntity) return null;

            // If groupByType matches parent type, return it
            if (parentEntity.type === groupByType) {
                return parentEntity;
            }

            // Otherwise, recursively look up the chain
            // e.g., if we want to group roles by unit, but role's parent is team,
            // we need to find team's parent unit
            if (groupByType === 'unit' && parentEntity.type === 'team') {
                return getParentEntity(parentEntity, 'unit');
            }

            // For people, they connect to roles via INS, then roles connect to teams/units via DES
            return null;
        }

        // Get parent for person via INS relationship (person fills role)
        function getPersonParent(person, groupByType) {
            // Find INS relationship where person is the subject
            const insRelationship = relationships.find(r =>
                r.predicate === 'INS' && r.subject === person.id
            );

            if (!insRelationship) return null;

            const role = findEntity(insRelationship.object);
            if (!role) return null;

            if (groupByType === 'role') {
                return role;
            }

            // Look up the hierarchy from role
            return getParentEntity(role, groupByType);
        }

        function renderGroupedFlatCardView(contentContainer, sidebarFilters) {
            let hasContent = false;
            const groupByType = cardViewGroupBy;

            // Helper to get parent for any entity
            function getParentForEntity(entity) {
                if (entity.type === 'person') {
                    return getPersonParent(entity, groupByType);
                }
                return getParentEntity(entity, groupByType);
            }

            // Helper to render a grouped section
            function renderGroupedSection(entityType, typeLabel, icon, allEntities) {
                if (!allEntities || allEntities.length === 0) return false;

                let filteredEntities = filterEntitiesBySearch(allEntities, cardViewSearchTerm);
                filteredEntities = sortEntities(filteredEntities, cardViewSortOption);

                if (filteredEntities.length === 0) return false;

                // Group entities by their parent
                const groups = new Map();
                const ungrouped = [];

                filteredEntities.forEach(entity => {
                    const parent = getParentForEntity(entity);
                    if (parent) {
                        if (!groups.has(parent.id)) {
                            groups.set(parent.id, { parent, entities: [] });
                        }
                        groups.get(parent.id).entities.push(entity);
                    } else {
                        ungrouped.push(entity);
                    }
                });

                // Get groupBy type label and icon
                const groupByLabel = groupByType === 'unit' ? 'Unit' :
                                     groupByType === 'team' ? 'Team' : 'Role';
                const groupByIcon = getIcon(groupByType);

                // Create section for this entity type
                const section = document.createElement('div');
                section.className = 'card-row grouped-section';

                const header = document.createElement('div');
                header.className = 'card-row-header';
                header.innerHTML = `
                    <div class="card-row-title">
                        ${icon} ${typeLabel}
                        <span class="card-row-count">${filteredEntities.length}</span>
                        <span class="grouped-by-label">grouped by ${groupByLabel}</span>
                    </div>
                `;
                section.appendChild(header);

                // Sort groups by parent name
                const sortedGroups = Array.from(groups.values())
                    .sort((a, b) => a.parent.name.localeCompare(b.parent.name));

                // Render each group
                sortedGroups.forEach(group => {
                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'entity-group';

                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'entity-group-header';
                    groupHeader.innerHTML = `
                        <span class="entity-group-icon">${groupByIcon}</span>
                        <span class="entity-group-name">${group.parent.name}</span>
                        <span class="entity-group-count">${group.entities.length}</span>
                    `;
                    groupContainer.appendChild(groupHeader);

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    group.entities.forEach(entity => {
                        grid.appendChild(createSimpleEntityCard(entity));
                    });
                    groupContainer.appendChild(grid);

                    section.appendChild(groupContainer);
                });

                // Render ungrouped entities
                if (ungrouped.length > 0) {
                    const ungroupedContainer = document.createElement('div');
                    ungroupedContainer.className = 'entity-group ungrouped';

                    const ungroupedHeader = document.createElement('div');
                    ungroupedHeader.className = 'entity-group-header';
                    ungroupedHeader.innerHTML = `
                        <span class="entity-group-icon"></span>
                        <span class="entity-group-name">No ${groupByLabel}</span>
                        <span class="entity-group-count">${ungrouped.length}</span>
                    `;
                    ungroupedContainer.appendChild(ungroupedHeader);

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    ungrouped.forEach(entity => {
                        grid.appendChild(createSimpleEntityCard(entity));
                    });
                    ungroupedContainer.appendChild(grid);

                    section.appendChild(ungroupedContainer);
                }

                contentContainer.appendChild(section);
                return true;
            }

            // Can't group units (they're top-level) - render normally
            if (cardViewTypeFilters.unit && sidebarFilters.entities.unit && entities.unit.length > 0) {
                let filteredUnits = filterEntitiesBySearch(entities.unit, cardViewSearchTerm);
                filteredUnits = sortEntities(filteredUnits, cardViewSortOption);
                if (filteredUnits.length > 0) {
                    contentContainer.appendChild(createCardRow('Units', filteredUnits, getIcon('unit')));
                    hasContent = true;
                }
            }

            // Teams - can be grouped by unit
            if (cardViewTypeFilters.team && sidebarFilters.entities.team && entities.team.length > 0) {
                if (groupByType === 'unit') {
                    if (renderGroupedSection('team', 'Teams', getIcon('team'), entities.team)) {
                        hasContent = true;
                    }
                } else {
                    let filteredTeams = filterEntitiesBySearch(entities.team, cardViewSearchTerm);
                    filteredTeams = sortEntities(filteredTeams, cardViewSortOption);
                    if (filteredTeams.length > 0) {
                        contentContainer.appendChild(createCardRow('Teams', filteredTeams, getIcon('team')));
                        hasContent = true;
                    }
                }
            }

            // Roles - can be grouped by unit or team
            if (cardViewTypeFilters.role && sidebarFilters.entities.role && entities.role.length > 0) {
                if (groupByType === 'unit' || groupByType === 'team') {
                    if (renderGroupedSection('role', 'Roles', getIcon('role'), entities.role)) {
                        hasContent = true;
                    }
                } else {
                    let filteredRoles = filterEntitiesBySearch(entities.role, cardViewSearchTerm);
                    filteredRoles = sortEntities(filteredRoles, cardViewSortOption);
                    if (filteredRoles.length > 0) {
                        contentContainer.appendChild(createCardRow('Roles', filteredRoles, getIcon('role')));
                        hasContent = true;
                    }
                }
            }

            // People - can be grouped by unit, team, or role
            if (cardViewTypeFilters.person && sidebarFilters.entities.person && entities.person.length > 0) {
                if (groupByType === 'unit' || groupByType === 'team' || groupByType === 'role') {
                    if (renderGroupedSection('person', 'People', getIcon('person'), entities.person)) {
                        hasContent = true;
                    }
                } else {
                    let filteredPeople = filterEntitiesBySearch(entities.person, cardViewSearchTerm);
                    filteredPeople = sortEntities(filteredPeople, cardViewSortOption);
                    if (filteredPeople.length > 0) {
                        contentContainer.appendChild(createCardRow('People', filteredPeople, getIcon('person')));
                        hasContent = true;
                    }
                }
            }

            // Work Products - can potentially be grouped (via CON relationships)
            // For now, render normally
            if (cardViewTypeFilters.object && sidebarFilters.entities.object && entities.object.length > 0) {
                let filteredObjects = filterEntitiesBySearch(entities.object, cardViewSearchTerm);
                filteredObjects = sortEntities(filteredObjects, cardViewSortOption);
                if (filteredObjects.length > 0) {
                    contentContainer.appendChild(createCardRow('Work Products', filteredObjects, getIcon('object')));
                    hasContent = true;
                }
            }

            // Activities
            if (cardViewTypeFilters.activity && relationships.length > 0) {
                const activityRow = createActivityCardRowFiltered();
                if (activityRow) {
                    contentContainer.appendChild(activityRow);
                    hasContent = true;
                }
            }

            return hasContent;
        }

        function renderHierarchicalCardView(contentContainer, sidebarFilters) {
            const hierarchy = buildHierarchyTree();
            let hasContent = false;

            // Helper to check if entity passes search filter
            function passesSearch(entity) {
                if (!cardViewSearchTerm) return true;
                const term = cardViewSearchTerm.toLowerCase();
                return entity.name.toLowerCase().includes(term) ||
                       (entity.description && entity.description.toLowerCase().includes(term));
            }

            // Helper to check if any child entities pass the search
            function hasMatchingDescendants(unitNode) {
                // Check nested units (recursive)
                if (unitNode.units) {
                    for (const childUnitNode of unitNode.units) {
                        if (passesSearch(childUnitNode.entity)) return true;
                        if (hasMatchingDescendants(childUnitNode)) return true;
                    }
                }
                // Check teams
                for (const teamNode of unitNode.teams) {
                    if (passesSearch(teamNode.entity)) return true;
                    for (const roleNode of teamNode.roles) {
                        if (passesSearch(roleNode.entity)) return true;
                        for (const person of roleNode.people) {
                            if (passesSearch(person)) return true;
                        }
                    }
                }
                // Check direct roles
                for (const roleNode of unitNode.roles) {
                    if (passesSearch(roleNode.entity)) return true;
                    for (const person of roleNode.people) {
                        if (passesSearch(person)) return true;
                    }
                }
                return false;
            }

            // Render unit hierarchy section
            if (cardViewTypeFilters.unit && sidebarFilters.entities.unit && hierarchy.units.length > 0) {
                const hierarchySection = document.createElement('div');
                hierarchySection.className = 'card-row';

                const header = document.createElement('div');
                header.className = 'card-row-header';
                header.innerHTML = `<div class="card-row-title">${getIcon('unit')} Organizational Hierarchy</div>`;
                hierarchySection.appendChild(header);

                const grid = document.createElement('div');
                grid.className = 'hierarchy-grid';

                hierarchy.units.forEach(unitNode => {
                    // Check if this unit or any descendants match the search
                    if (!passesSearch(unitNode.entity) && !hasMatchingDescendants(unitNode)) {
                        return;
                    }

                    const unitCard = createHierarchyUnitCard(unitNode, sidebarFilters);
                    if (unitCard) {
                        grid.appendChild(unitCard);
                        hasContent = true;
                    }
                });

                if (grid.children.length > 0) {
                    hierarchySection.appendChild(grid);
                    contentContainer.appendChild(hierarchySection);
                }
            }

            // Fallback: Render units that have circular parent relationships (no top-level units found)
            // This handles cases where units form cycles (e.g., Unit A defines Unit B and Unit B defines Unit A)
            if (cardViewTypeFilters.unit && sidebarFilters.entities.unit && hierarchy.units.length === 0 && entities.unit.length > 0) {
                const filteredUnits = entities.unit.filter(passesSearch);
                if (filteredUnits.length > 0) {
                    const unitsSection = document.createElement('div');
                    unitsSection.className = 'card-row';

                    const header = document.createElement('div');
                    header.className = 'card-row-header';
                    header.innerHTML = `<div class="card-row-title">${getIcon('unit')} Units</div>`;
                    unitsSection.appendChild(header);

                    const grid = document.createElement('div');
                    grid.className = 'hierarchy-grid';

                    // Build unit nodes for all units and render them
                    filteredUnits.forEach(unit => {
                        // Build a unit node for this unit
                        const desRelationships = relationships.filter(r => r.predicate === 'DES');
                        function getChildren(parentId) {
                            return desRelationships
                                .filter(r => r.subject === parentId)
                                .map(r => findEntity(r.object))
                                .filter(e => e !== null);
                        }
                        function getPeopleInRole(roleId) {
                            return relationships
                                .filter(r => r.predicate === 'INS' && r.object === roleId)
                                .map(r => findEntity(r.subject))
                                .filter(e => e !== null && e.type === 'person');
                        }

                        const directTeams = getChildren(unit.id).filter(e => e.type === 'team');
                        const directRoles = getChildren(unit.id).filter(e => e.type === 'role');

                        const unitNode = {
                            entity: unit,
                            units: [], // Don't recursively include child units to avoid infinite loops
                            teams: directTeams.map(team => {
                                const teamRoles = getChildren(team.id).filter(e => e.type === 'role');
                                return {
                                    entity: team,
                                    roles: teamRoles.map(role => ({
                                        entity: role,
                                        people: getPeopleInRole(role.id)
                                    }))
                                };
                            }),
                            roles: directRoles.map(role => ({
                                entity: role,
                                people: getPeopleInRole(role.id)
                            }))
                        };

                        const unitCard = createHierarchyUnitCard(unitNode, sidebarFilters);
                        if (unitCard) {
                            grid.appendChild(unitCard);
                            hasContent = true;
                        }
                    });

                    if (grid.children.length > 0) {
                        unitsSection.appendChild(grid);
                        contentContainer.appendChild(unitsSection);
                    }
                }
            }

            // Render orphan teams (teams without a parent unit)
            if (cardViewTypeFilters.team && sidebarFilters.entities.team && hierarchy.orphanTeams.length > 0) {
                const filteredOrphanTeams = hierarchy.orphanTeams.filter(passesSearch);
                if (filteredOrphanTeams.length > 0) {
                    const orphanSection = document.createElement('div');
                    orphanSection.className = 'orphan-entities-section';
                    orphanSection.innerHTML = `<div class="orphan-section-title">${getIcon('team')} Teams (unassigned)</div>`;

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    filteredOrphanTeams.forEach(team => {
                        grid.appendChild(createSimpleEntityCard(team));
                    });
                    orphanSection.appendChild(grid);
                    contentContainer.appendChild(orphanSection);
                    hasContent = true;
                }
            }

            // Render orphan roles (roles without a parent)
            if (cardViewTypeFilters.role && sidebarFilters.entities.role && hierarchy.orphanRoles.length > 0) {
                const filteredOrphanRoles = hierarchy.orphanRoles.filter(passesSearch);
                if (filteredOrphanRoles.length > 0) {
                    const orphanSection = document.createElement('div');
                    orphanSection.className = 'orphan-entities-section';
                    orphanSection.innerHTML = `<div class="orphan-section-title">${getIcon('role')} Roles (unassigned)</div>`;

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    filteredOrphanRoles.forEach(role => {
                        grid.appendChild(createSimpleEntityCard(role));
                    });
                    orphanSection.appendChild(grid);
                    contentContainer.appendChild(orphanSection);
                    hasContent = true;
                }
            }

            // Render orphan people (people not filling any role)
            if (cardViewTypeFilters.person && sidebarFilters.entities.person && hierarchy.orphanPeople.length > 0) {
                const filteredOrphanPeople = hierarchy.orphanPeople.filter(passesSearch);
                if (filteredOrphanPeople.length > 0) {
                    const orphanSection = document.createElement('div');
                    orphanSection.className = 'orphan-entities-section';
                    orphanSection.innerHTML = `<div class="orphan-section-title">${getIcon('person')} People (unassigned)</div>`;

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    filteredOrphanPeople.forEach(person => {
                        grid.appendChild(createSimpleEntityCard(person));
                    });
                    orphanSection.appendChild(grid);
                    contentContainer.appendChild(orphanSection);
                    hasContent = true;
                }
            }

            // Render work products (always flat, not part of hierarchy)
            if (cardViewTypeFilters.object && sidebarFilters.entities.object && hierarchy.objects.length > 0) {
                let filteredObjects = filterEntitiesBySearch(hierarchy.objects, cardViewSearchTerm);
                filteredObjects = sortEntities(filteredObjects, cardViewSortOption);
                if (filteredObjects.length > 0) {
                    contentContainer.appendChild(createCardRow('Work Products', filteredObjects, getIcon('object')));
                    hasContent = true;
                }
            }

            // Activities
            if (cardViewTypeFilters.activity && relationships.length > 0) {
                const activityRow = createActivityCardRowFiltered();
                if (activityRow) {
                    contentContainer.appendChild(activityRow);
                    hasContent = true;
                }
            }

            return hasContent;
        }

        function createHierarchyUnitCard(unitNode, sidebarFilters) {
            const unit = unitNode.entity;
            const showUnits = cardViewTypeFilters.unit && sidebarFilters.entities.unit;
            const showTeams = cardViewTypeFilters.team && sidebarFilters.entities.team;
            const showRoles = cardViewTypeFilters.role && sidebarFilters.entities.role;
            const showPeople = cardViewTypeFilters.person && sidebarFilters.entities.person;

            const card = document.createElement('div');
            card.className = 'hierarchy-card-container unit';

            // Unit header
            const headerHTML = `
                <div class="hierarchy-card-header" onclick="openEntityModal('${unit.id}', 'unit')">
                    <div class="hierarchy-card-icon">${getIcon('unit')}</div>
                    <div class="hierarchy-card-title">${unit.name}</div>
                </div>
            `;

            // Unit description
            const descHTML = unit.description ?
                `<div class="hierarchy-card-description">${unit.description.length > 100 ? unit.description.substring(0, 100) + '...' : unit.description}</div>` : '';

            // Unit activities
            const unitActivities = getEntityActivities(unit.id);
            let activitiesHTML = '';
            if (unitActivities.length > 0) {
                activitiesHTML = '<div class="hierarchy-card-activities">';
                unitActivities.slice(0, 2).forEach(rel => {
                    const operator = eoOperators[rel.predicate];
                    const isSubject = rel.subject === unit.id;
                    const otherEntity = findEntity(isSubject ? rel.object : rel.subject);
                    activitiesHTML += `
                        <span class="connection-badge" style="background: ${operator.color}; color: white; border-color: ${operator.color};">
                            ${isSubject ? '' : ''} ${operator.label} ${otherEntity?.name || ''}
                        </span>
                    `;
                });
                if (unitActivities.length > 2) {
                    activitiesHTML += `<span class="connection-badge">+${unitActivities.length - 2} more</span>`;
                }
                activitiesHTML += '</div>';
            }

            card.innerHTML = headerHTML + descHTML + activitiesHTML;

            // Nested units section (sub-units within this unit)
            if (showUnits && unitNode.units && unitNode.units.length > 0) {
                const unitsSection = document.createElement('div');
                unitsSection.className = 'nested-cards-section';
                unitsSection.innerHTML = `<div class="nested-cards-label">${getIcon('unit')} Sub-Units (${unitNode.units.length})</div>`;

                const unitsGrid = document.createElement('div');
                unitsGrid.className = 'nested-cards-grid';

                unitNode.units.forEach(childUnitNode => {
                    const childUnitCard = createHierarchyUnitCard(childUnitNode, sidebarFilters);
                    if (childUnitCard) {
                        childUnitCard.classList.add('nested-unit-card');
                        unitsGrid.appendChild(childUnitCard);
                    }
                });

                unitsSection.appendChild(unitsGrid);
                card.appendChild(unitsSection);
            }

            // Nested teams section
            if (showTeams && unitNode.teams.length > 0) {
                const teamsSection = document.createElement('div');
                teamsSection.className = 'nested-cards-section';
                teamsSection.innerHTML = `<div class="nested-cards-label">${getIcon('team')} Teams (${unitNode.teams.length})</div>`;

                const teamsGrid = document.createElement('div');
                teamsGrid.className = 'nested-cards-grid';

                unitNode.teams.forEach(teamNode => {
                    const teamCard = createNestedTeamCard(teamNode, showRoles, showPeople);
                    teamsGrid.appendChild(teamCard);
                });

                teamsSection.appendChild(teamsGrid);
                card.appendChild(teamsSection);
            }

            // Direct roles (roles that belong to unit, not to a team)
            if (showRoles && unitNode.roles.length > 0) {
                const rolesSection = document.createElement('div');
                rolesSection.className = 'nested-cards-section';
                rolesSection.innerHTML = `<div class="nested-cards-label">${getIcon('role')} Direct Roles (${unitNode.roles.length})</div>`;

                const rolesGrid = document.createElement('div');
                rolesGrid.className = 'nested-cards-grid';

                unitNode.roles.forEach(roleNode => {
                    const roleCard = createNestedRoleCard(roleNode, showPeople);
                    rolesGrid.appendChild(roleCard);
                });

                rolesSection.appendChild(rolesGrid);
                card.appendChild(rolesSection);
            }

            return card;
        }

        function createNestedTeamCard(teamNode, showRoles, showPeople) {
            const team = teamNode.entity;
            const card = document.createElement('div');
            card.className = 'nested-entity-card team';
            card.onclick = (e) => {
                if (e.target.closest('.deep-nested-item')) return;
                openEntityModal(team.id, 'team');
            };

            // Team header
            let cardHTML = `
                <div class="nested-card-header">
                    <div class="nested-card-icon">${getIcon('team')}</div>
                    <div class="nested-card-title">${team.name}</div>
                </div>
            `;

            // Team description
            if (team.description) {
                cardHTML += `<div class="nested-card-description">${team.description.length > 60 ? team.description.substring(0, 60) + '...' : team.description}</div>`;
            }

            // Team activities
            const teamActivities = getEntityActivities(team.id);
            if (teamActivities.length > 0) {
                cardHTML += '<div class="nested-card-connections">';
                teamActivities.slice(0, 2).forEach(rel => {
                    const operator = eoOperators[rel.predicate];
                    const isSubject = rel.subject === team.id;
                    const otherEntity = findEntity(isSubject ? rel.object : rel.subject);
                    cardHTML += `
                        <span class="connection-badge" style="background: ${operator.color}; color: white; font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                            ${isSubject ? '' : ''} ${operator.label}
                        </span>
                    `;
                });
                cardHTML += '</div>';
            }

            card.innerHTML = cardHTML;

            // Nested roles within team
            if (showRoles && teamNode.roles.length > 0) {
                const rolesSection = document.createElement('div');
                rolesSection.className = 'deep-nested-section';
                rolesSection.innerHTML = `<div class="deep-nested-label">${getIcon('role')} Roles (${teamNode.roles.length})</div>`;

                const rolesItems = document.createElement('div');
                rolesItems.className = 'deep-nested-items';

                teamNode.roles.forEach(roleNode => {
                    const roleItem = document.createElement('div');
                    roleItem.className = 'deep-nested-item';
                    roleItem.onclick = (e) => {
                        e.stopPropagation();
                        openEntityModal(roleNode.entity.id, 'role');
                    };

                    let roleHTML = `
                        <span class="item-icon">${getIcon('role')}</span>
                        <span class="item-name">${roleNode.entity.name}</span>
                    `;

                    // Show people filling this role
                    if (showPeople && roleNode.people.length > 0) {
                        roleHTML += `<span style="margin-left: auto; color: #8B6F47; font-size: 0.75rem;">${getIcon('person')} ${roleNode.people.length}</span>`;
                    }

                    roleItem.innerHTML = roleHTML;
                    rolesItems.appendChild(roleItem);
                });

                rolesSection.appendChild(rolesItems);
                card.appendChild(rolesSection);
            }

            return card;
        }

        function createNestedRoleCard(roleNode, showPeople) {
            const role = roleNode.entity;
            const card = document.createElement('div');
            card.className = 'nested-entity-card role';
            card.onclick = (e) => {
                if (e.target.closest('.deep-nested-item')) return;
                openEntityModal(role.id, 'role');
            };

            // Role header
            let cardHTML = `
                <div class="nested-card-header">
                    <div class="nested-card-icon">${getIcon('role')}</div>
                    <div class="nested-card-title">${role.name}</div>
                </div>
            `;

            // Role description
            if (role.description) {
                cardHTML += `<div class="nested-card-description">${role.description.length > 60 ? role.description.substring(0, 60) + '...' : role.description}</div>`;
            }

            // Role activities
            const roleActivities = getEntityActivities(role.id);
            if (roleActivities.length > 0) {
                cardHTML += '<div class="nested-card-connections">';
                roleActivities.slice(0, 2).forEach(rel => {
                    const operator = eoOperators[rel.predicate];
                    const isSubject = rel.subject === role.id;
                    cardHTML += `
                        <span class="connection-badge" style="background: ${operator.color}; color: white; font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                            ${isSubject ? '' : ''} ${operator.label}
                        </span>
                    `;
                });
                cardHTML += '</div>';
            }

            card.innerHTML = cardHTML;

            // People filling this role
            if (showPeople && roleNode.people.length > 0) {
                const peopleSection = document.createElement('div');
                peopleSection.className = 'deep-nested-section';
                peopleSection.innerHTML = `<div class="deep-nested-label">${getIcon('person')} Filled by (${roleNode.people.length})</div>`;

                const peopleItems = document.createElement('div');
                peopleItems.className = 'deep-nested-items';

                roleNode.people.forEach(person => {
                    const personItem = document.createElement('div');
                    personItem.className = 'deep-nested-item';
                    personItem.onclick = (e) => {
                        e.stopPropagation();
                        openEntityModal(person.id, 'person');
                    };
                    personItem.innerHTML = `
                        <span class="item-icon">${getIcon('person')}</span>
                        <span class="item-name">${person.name}</span>
                    `;
                    peopleItems.appendChild(personItem);
                });

                peopleSection.appendChild(peopleItems);
                card.appendChild(peopleSection);
            }

            return card;
        }

        function createSimpleEntityCard(entity) {
            const card = document.createElement('div');
            card.className = `entity-card ${entity.type}`;
            card.onclick = () => openEntityModal(entity.id, entity.type);

            const entityActivities = getEntityActivities(entity.id);

            let activitiesHTML = '';
            if (entityActivities.length > 0) {
                activitiesHTML = '<div class="card-connections">';
                entityActivities.slice(0, 3).forEach(rel => {
                    const operator = eoOperators[rel.predicate];
                    const isSubject = rel.subject === entity.id;
                    const otherEntity = findEntity(isSubject ? rel.object : rel.subject);
                    activitiesHTML += `
                        <span class="connection-badge" style="background: ${operator.color}; color: white; border-color: ${operator.color};">
                            ${isSubject ? '' : ''} ${operator.label} ${otherEntity?.name || ''}
                        </span>
                    `;
                });
                if (entityActivities.length > 3) {
                    activitiesHTML += `<span class="connection-badge">+${entityActivities.length - 3} more</span>`;
                }
                activitiesHTML += '</div>';
            }

            let descriptionHTML = '';
            if (entity.description && entity.description.trim()) {
                const truncatedDesc = entity.description.length > 80
                    ? entity.description.substring(0, 80) + '...'
                    : entity.description;
                descriptionHTML = `<div class="card-description">${truncatedDesc}</div>`;
            }

            // For roles, show team context for disambiguation
            let teamContextHTML = '';
            if (entity.type === 'role') {
                const parentTeam = getRoleParentTeam(entity.id);
                if (parentTeam) {
                    teamContextHTML = `
                        <div class="card-nested-under">
                            <span class="nested-label">In:</span>
                            <span class="nested-parent-badge">
                                <span class="parent-icon">${getIcon(parentTeam.type)}</span>
                                ${parentTeam.name}
                            </span>
                        </div>
                    `;
                }
            }

            card.innerHTML = `
                <div class="card-header">
                    <div class="card-icon">${getIcon(entity.type)}</div>
                    <div class="card-title">${entity.name}</div>
                </div>
                ${teamContextHTML}
                ${descriptionHTML}
                ${activitiesHTML}
            `;

            return card;
        }

        function createActivityCardRowFiltered() {
            const sidebarFilters = getActiveFilters();
            let filteredActivities = relationships.filter(r => sidebarFilters.relationships[r.predicate]);

            // Apply search filter to activities
            if (cardViewSearchTerm) {
                const term = cardViewSearchTerm.toLowerCase();
                filteredActivities = filteredActivities.filter(rel => {
                    const subj = findEntity(rel.subject);
                    const obj = findEntity(rel.object);
                    const operator = eoOperators[rel.predicate];
                    return (
                        (subj && subj.name.toLowerCase().includes(term)) ||
                        (obj && obj.name.toLowerCase().includes(term)) ||
                        operator.label.toLowerCase().includes(term) ||
                        (rel.description && rel.description.toLowerCase().includes(term))
                    );
                });
            }

            if (filteredActivities.length === 0) return null;

            const row = document.createElement('div');
            row.className = 'card-row';

            const header = document.createElement('div');
            header.className = 'card-row-header';
            header.innerHTML = `
                <div class="card-row-title"> Activities (${filteredActivities.length})</div>
            `;
            row.appendChild(header);

            const grid = document.createElement('div');
            grid.className = 'card-grid';

            filteredActivities.forEach(rel => {
                const subj = findEntity(rel.subject);
                const obj = findEntity(rel.object);
                const operator = eoOperators[rel.predicate];

                const card = document.createElement('div');
                card.className = `entity-card activity`;
                card.onclick = () => openRelationshipModal(rel);

                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-icon" style="background: ${operator.color}; color: white; padding: 0.5rem; border-radius: 8px; font-size: 1.25rem;"></div>
                        <div class="card-title">${operator.label}</div>
                    </div>
                    <div class="card-meta">
                        <strong>${subj?.name || rel.subject}</strong>  <strong>${obj?.name || rel.object}</strong>
                    </div>
                    ${rel.description ? `<div class="card-description">${rel.description}</div>` : ''}
                    <div class="card-connections">
                        <span class="connection-badge" style="cursor: pointer;" onclick="event.stopPropagation(); openEntityModal('${rel.subject}', '${subj?.type}')">${getIcon(subj?.type)} ${subj?.name}</span>
                        <span class="connection-badge" style="cursor: pointer;" onclick="event.stopPropagation(); openEntityModal('${rel.object}', '${obj?.type}')">${getIcon(obj?.type)} ${obj?.name}</span>
                    </div>
                `;

                grid.appendChild(card);
            });

            row.appendChild(grid);
            return row;
        }

        function createCardRow(title, entities, icon) {
            const row = document.createElement('div');
            row.className = 'card-row';

            const header = document.createElement('div');
            header.className = 'card-row-header';
            header.innerHTML = `
                <div class="card-row-title">${icon} ${title} (${entities.length})</div>
            `;
            row.appendChild(header);

            const grid = document.createElement('div');
            grid.className = 'card-grid';

            entities.forEach(entity => {
                const card = document.createElement('div');
                card.className = `entity-card ${entity.type}`;
                card.onclick = () => openEntityModal(entity.id, entity.type);

                // For units, teams and roles, find what they're nested under (DES relationships where entity is the object)
                let nestedUnderHTML = '';
                if (entity.type === 'unit' || entity.type === 'team' || entity.type === 'role') {
                    const parentRelationships = relationships.filter(r =>
                        r.predicate === 'DES' && r.object === entity.id
                    );
                    if (parentRelationships.length > 0) {
                        nestedUnderHTML = '<div class="card-nested-under"><span class="nested-label">In:</span>';
                        parentRelationships.forEach(rel => {
                            const parentEntity = findEntity(rel.subject);
                            if (parentEntity) {
                                const parentIcon = getIcon(parentEntity.type);
                                nestedUnderHTML += `
                                    <span class="nested-parent-badge">
                                        <span class="parent-icon">${parentIcon}</span>
                                        ${parentEntity.name}
                                    </span>
                                `;
                            }
                        });
                        nestedUnderHTML += '</div>';
                    }
                }

                // Get all activities this entity is involved in (excluding DES relationships for display)
                const entityActivities = relationships.filter(r =>
                    (r.subject === entity.id || r.object === entity.id) && r.predicate !== 'DES'
                );

                // Build activities HTML
                let activitiesHTML = '';
                if (entityActivities.length > 0) {
                    activitiesHTML = '<div class="card-connections">';
                    entityActivities.slice(0, 3).forEach(rel => {
                        const operator = eoOperators[rel.predicate];
                        const isSubject = rel.subject === entity.id;
                        const otherEntity = findEntity(isSubject ? rel.object : rel.subject);
                        activitiesHTML += `
                            <span class="connection-badge" style="background: ${operator.color}; color: white; border-color: ${operator.color};">
                                ${isSubject ? '' : ''} ${operator.label} ${otherEntity?.name || ''}
                            </span>
                        `;
                    });
                    if (entityActivities.length > 3) {
                        activitiesHTML += `<span class="connection-badge">+${entityActivities.length - 3} more</span>`;
                    }
                    activitiesHTML += '</div>';
                }

                // Build description HTML (truncate if too long)
                let descriptionHTML = '';
                if (entity.description && entity.description.trim()) {
                    const truncatedDesc = entity.description.length > 80
                        ? entity.description.substring(0, 80) + '...'
                        : entity.description;
                    descriptionHTML = `<div class="card-description">${truncatedDesc}</div>`;
                }

                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-icon">${icon}</div>
                        <div class="card-title">${entity.name}</div>
                    </div>
                    ${nestedUnderHTML}
                    ${descriptionHTML}
                    ${activitiesHTML}
                `;

                grid.appendChild(card);
            });

            row.appendChild(grid);
            return row;
        }

        // Tree View Rendering
        function toggleRelationships(relId) {
            const relsDiv = document.getElementById(relId);
            const header = event.target.closest('.tree-relationships-header');
            const icon = header?.querySelector('.tree-expand-icon');

            if (relsDiv && icon) {
                const isHidden = relsDiv.style.display === 'none';
                relsDiv.style.display = isHidden ? 'block' : 'none';
                icon.classList.toggle('expanded', isHidden);
            }
        }

        function handleTreeDrop(draggedData, targetEntity) {
            // Validate drop - can drop unit onto unit, team onto unit, or role onto team/unit
            const validDrops = {
                'unit': ['unit'],           // units can be dropped on units (nesting)
                'team': ['unit'],           // teams can be dropped on units
                'role': ['unit', 'team']    // roles can be dropped on units or teams
            };

            const allowedTargets = validDrops[draggedData.type];
            if (!allowedTargets || !allowedTargets.includes(targetEntity.type)) {
                showNotification(`Cannot move ${draggedData.type} to ${targetEntity.type}`, 'error');
                return;
            }

            // Don't drop on self
            if (draggedData.id === targetEntity.id) {
                return;
            }

            // Prevent circular references when nesting units
            if (draggedData.type === 'unit' && targetEntity.type === 'unit') {
                // Check if target is a descendant of dragged unit
                function isDescendant(parentId, childId) {
                    const children = relationships
                        .filter(r => r.predicate === 'DES' && r.subject === parentId)
                        .map(r => r.object);
                    if (children.includes(childId)) return true;
                    return children.some(cId => isDescendant(cId, childId));
                }
                if (isDescendant(draggedData.id, targetEntity.id)) {
                    showNotification(`Cannot nest ${draggedData.name} inside its own child unit`, 'error');
                    return;
                }
            }

            // Check if already connected to target
            const alreadyConnected = relationships.some(r =>
                r.predicate === 'DES' &&
                ((r.subject === draggedData.id && r.object === targetEntity.id) ||
                 (r.subject === targetEntity.id && r.object === draggedData.id))
            );

            if (alreadyConnected) {
                showNotification(`${draggedData.name} is already in ${targetEntity.name}`, 'info');
                return;
            }

            // Remove existing DES parent relationships for the dragged entity
            // (teams should only be in one unit, roles in one team/unit at hierarchy level)
            const parentTypes = targetEntity.type === 'unit' ? ['unit'] : ['unit', 'team'];
            relationships = relationships.filter(r => {
                if (r.predicate !== 'DES') return true;
                // Check if this relationship connects dragged entity to a parent of same type
                const isParentRel = (r.subject === draggedData.id || r.object === draggedData.id);
                if (!isParentRel) return true;
                const otherId = r.subject === draggedData.id ? r.object : r.subject;
                const otherEntity = findEntity(otherId);
                // Keep relationships that aren't to parent types we're replacing
                return !otherEntity || !parentTypes.includes(otherEntity.type);
            });

            // Create new DES relationship (target contains dragged)
            relationships.push({
                id: 'rel-' + Date.now(),
                subject: targetEntity.id,
                predicate: 'DES',
                object: draggedData.id
            });

            saveState();
            updateViews();
            showNotification(`Moved ${draggedData.name} to ${targetEntity.name}`, 'success');
        }

        function renderTreeView() {
            const container = document.getElementById('treeView');
            if (!container) return; // Safety check
            
            container.innerHTML = '';

            const filters = getActiveFilters();

            if (entities.unit.length === 0 && entities.team.length === 0 && entities.role.length === 0 && entities.person.length === 0 && entities.object.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 3rem; color: #8B6F47;">No entities created yet. Add entities to get started.</div>';
                return;
            }

            // Render each unit (if unit filter is on)
            if (filters.entities.unit) {
                entities.unit.forEach(unit => {
                    const unitEl = createTreeNodeDetailed(unit, filters);
                    container.appendChild(unitEl);
                });
            }

            // Show unassigned teams
            const unassignedTeams = entities.team.filter(team => {
                const isAssigned = relationships.some(r => 
                    (r.subject === team.id || r.object === team.id) &&
                    entities.unit.some(u => u.id === r.subject || u.id === r.object)
                );
                return !isAssigned;
            });

            if (unassignedTeams.length > 0 && filters.entities.team) {
                const section = document.createElement('div');
                section.style.marginTop = '2rem';
                const header = document.createElement('div');
                header.style.fontSize = '1.1rem';
                header.style.color = '#8B6F47';
                header.style.fontWeight = '600';
                header.style.marginBottom = '1rem';
                header.textContent = ' Unassigned Teams';
                section.appendChild(header);

                unassignedTeams.forEach(team => {
                    const teamEl = createTreeNodeDetailed(team, filters);
                    section.appendChild(teamEl);
                });

                container.appendChild(section);
            }

            // Show unassigned roles
            const unassignedRoles = entities.role.filter(role => {
                const isAssigned = relationships.some(r => 
                    (r.subject === role.id || r.object === role.id) &&
                    (entities.team.some(t => t.id === r.subject || t.id === r.object) ||
                     entities.unit.some(u => u.id === r.subject || u.id === r.object))
                );
                return !isAssigned;
            });

            if (unassignedRoles.length > 0 && filters.entities.role) {
                const section = document.createElement('div');
                section.style.marginTop = '2rem';
                const header = document.createElement('div');
                header.style.fontSize = '1.1rem';
                header.style.color = '#8B6F47';
                header.style.fontWeight = '600';
                header.style.marginBottom = '1rem';
                header.textContent = ' Unassigned Roles';
                section.appendChild(header);

                unassignedRoles.forEach(role => {
                    const roleEl = createTreeNodeDetailed(role, filters);
                    section.appendChild(roleEl);
                });

                container.appendChild(section);
            }

            // Show all people
            if (entities.person.length > 0 && filters.entities.person) {
                const section = document.createElement('div');
                section.style.marginTop = '2rem';
                const header = document.createElement('div');
                header.style.fontSize = '1.1rem';
                header.style.color = '#8B6F47';
                header.style.fontWeight = '600';
                header.style.marginBottom = '1rem';
                header.textContent = ' People';
                section.appendChild(header);

                entities.person.forEach(person => {
                    const personEl = createTreeNodeDetailed(person, filters);
                    section.appendChild(personEl);
                });

                container.appendChild(section);
            }

            // Show all objects
            if (entities.object.length > 0 && filters.entities.object) {
                const section = document.createElement('div');
                section.style.marginTop = '2rem';
                const header = document.createElement('div');
                header.style.fontSize = '1.1rem';
                header.style.color = '#8B6F47';
                header.style.fontWeight = '600';
                header.style.marginBottom = '1rem';
                header.textContent = ' Objects';
                section.appendChild(header);

                entities.object.forEach(obj => {
                    const objEl = createTreeNodeDetailed(obj, filters);
                    section.appendChild(objEl);
                });

                container.appendChild(section);
            }
        }

        function createTreeNodeDetailed(entity, filters) {
            const container = document.createElement('div');
            container.className = 'tree-node-container';

            const node = document.createElement('div');
            node.className = `tree-node-item ${entity.type}`;

            const icon = getIcon(entity.type);
            
            // Get connected entities
            const connectedTeams = entity.type === 'unit' ? getConnectedEntities(entity.id, 'team') : [];
            const connectedRoles = (entity.type === 'team' || entity.type === 'unit') ? getConnectedEntities(entity.id, 'role') : [];
            const hasChildren = (connectedTeams.length > 0 && filters.entities.team) || 
                               (connectedRoles.length > 0 && filters.entities.role);

            let expandIcon = '';
            if (hasChildren) {
                expandIcon = '<span class="tree-expand-icon expanded"></span>';
            }

            // Get people assigned to roles
            let peopleHTML = '';
            if (entity.type === 'role' && filters.entities.person) {
                const assignedPeople = entities.person.filter(p => 
                    relationships.some(r => 
                        filters.relationships[r.predicate] &&
                        ((r.subject === p.id && r.object === entity.id) ||
                        (r.object === p.id && r.subject === entity.id))
                    )
                );

                if (assignedPeople.length > 0) {
                    peopleHTML = '<div class="tree-people-assigned">';
                    assignedPeople.forEach(person => {
                        peopleHTML += `<span class="tree-person-badge" onclick="event.stopPropagation(); openEntityModal('${person.id}', 'person')" style="cursor: pointer;"> ${person.name}</span>`;
                    });
                    peopleHTML += '</div>';
                }
            }

            // Get relationships for this entity (filtered)
            const entityRels = relationships.filter(r => 
                filters.relationships[r.predicate] &&
                (r.subject === entity.id || r.object === entity.id)
            );

            let relsHTML = '';
            if (entityRels.length > 0) {
                const relId = 'rels-' + entity.id;
                const operator = eoOperators[entityRels[0].predicate];
                relsHTML = `
                    <div class="tree-relationships-header" onclick="toggleRelationships('${relId}')">
                        <span class="tree-expand-icon"></span>
                        <span>${entityRels.length} connection${entityRels.length > 1 ? 's' : ''}</span>
                    </div>
                    <div id="${relId}" class="tree-relationships" style="display: none;">
                `;
                entityRels.forEach(rel => {
                    const subj = findEntity(rel.subject);
                    const obj = findEntity(rel.object);
                    const op = eoOperators[rel.predicate];
                    relsHTML += `
                        <div class="tree-relationship-item" style="border-left-color: ${op.color}">
                            <strong>${subj?.name || rel.subject}</strong> 
                            <span style="color: ${op.color}; font-weight: 600;">${op.label}</span> 
                            <strong>${obj?.name || rel.object}</strong>
                        </div>
                    `;
                });
                relsHTML += '</div>';
            }

            node.innerHTML = `
                ${expandIcon}
                <span style="font-size: 1.2rem;">${icon}</span>
                <div class="tree-node-content">
                    <div class="tree-node-name">${entity.name}</div>
                    <div class="tree-node-meta">${entity.type}</div>
                    ${peopleHTML}
                </div>
            `;

            container.appendChild(node);

            // Add click handler to open entity modal
            node.onclick = (e) => {
                if (!e.target.closest('.tree-expand-icon') && !e.target.closest('.tree-person-badge')) {
                    openEntityModal(entity.id, entity.type);
                }
            };
            node.style.cursor = 'pointer';

            // Add drag-and-drop for nesting
            node.draggable = true;
            node.dataset.entityId = entity.id;
            node.dataset.entityType = entity.type;

            node.ondragstart = (e) => {
                e.stopPropagation();
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    id: entity.id,
                    type: entity.type,
                    name: entity.name
                }));
                e.dataTransfer.effectAllowed = 'move';
                node.classList.add('dragging');
            };

            node.ondragend = (e) => {
                node.classList.remove('dragging');
                document.querySelectorAll('.tree-node-item.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });
            };

            // Allow dropping on units (for teams) and teams (for roles)
            if (entity.type === 'unit' || entity.type === 'team') {
                node.ondragover = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const dragData = e.dataTransfer.types.includes('text/plain');
                    if (dragData) {
                        node.classList.add('drag-over');
                        e.dataTransfer.dropEffect = 'move';
                    }
                };

                node.ondragleave = (e) => {
                    if (!node.contains(e.relatedTarget)) {
                        node.classList.remove('drag-over');
                    }
                };

                node.ondrop = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    node.classList.remove('drag-over');

                    try {
                        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                        handleTreeDrop(data, entity);
                    } catch (err) {
                        console.error('Drop error:', err);
                    }
                };
            }

            if (relsHTML) {
                const relsDiv = document.createElement('div');
                relsDiv.innerHTML = relsHTML;
                container.appendChild(relsDiv.firstChild);
            }

            // Add children
            if (hasChildren) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'tree-children expanded';

                if (entity.type === 'unit' && filters.entities.team) {
                    connectedTeams.forEach(team => {
                        const teamEl = createTreeNodeDetailed(team, filters);
                        childrenContainer.appendChild(teamEl);
                    });
                }

                if ((entity.type === 'team' || entity.type === 'unit') && filters.entities.role) {
                    connectedRoles.forEach(role => {
                        const roleEl = createTreeNodeDetailed(role, filters);
                        childrenContainer.appendChild(roleEl);
                    });
                }

                container.appendChild(childrenContainer);

                // Add expand/collapse functionality
                const expandBtn = node.querySelector('.tree-expand-icon');
                if (expandBtn) {
                    expandBtn.onclick = (e) => {
                        e.stopPropagation();
                        childrenContainer.classList.toggle('expanded');
                        expandBtn.classList.toggle('expanded');
                    };
                }
            }

            return container;
        }

        // Graph visualization - n8n style
        const svg = d3.select('#graph');
        const tooltip = d3.select('#tooltip');

        // Graph state
        let graphZoom = null;
        let currentZoomScale = 1;
        let graphG = null; // Main graph group for transforms

        // Node dimensions for n8n-style cards
        const NODE_WIDTH = 140;
        const NODE_HEIGHT = 56;
        const PORT_RADIUS = 6;

        // Get node accent color by type
        function getNodeAccentColor(type) {
            const colors = {
                unit: '#C88F4A',
                team: '#B87B5B',
                role: '#8B6F47',
                person: '#6B5642',
                object: '#A89984'
            };
            return colors[type] || '#8B6F47';
        }

        // Calculate auto-layout positions based on hierarchy using d3.tree()
        function calculateAutoLayout(nodes, width, height) {
            const positions = new Map();
            const nodeIds = new Set(nodes.map(n => n.id));

            // Build a lookup of ALL entities for hierarchy calculation
            const allEntities = new Map();
            ['unit', 'team', 'role', 'object'].forEach(type => {
                entities[type].forEach(e => allEntities.set(e.id, e));
            });

            // Build FULL hierarchy from ALL DES relationships (not just filtered nodes)
            const fullParentMap = new Map();
            const fullChildrenMap = new Map();

            relationships.filter(r => r.predicate === 'DES').forEach(rel => {
                if (allEntities.has(rel.subject) && allEntities.has(rel.object)) {
                    fullParentMap.set(rel.object, rel.subject);
                    if (!fullChildrenMap.has(rel.subject)) {
                        fullChildrenMap.set(rel.subject, []);
                    }
                    fullChildrenMap.get(rel.subject).push(rel.object);
                }
            });

            // Build filtered hierarchy - only include relationships where both nodes are visible
            const parentMap = new Map();
            const childrenMap = new Map();

            // For each visible node, find its nearest visible ancestor
            function findVisibleAncestor(nodeId) {
                let current = fullParentMap.get(nodeId);
                const visited = new Set();
                while (current && !visited.has(current)) {
                    visited.add(current);
                    if (nodeIds.has(current)) return current;
                    current = fullParentMap.get(current);
                }
                return null;
            }

            // Build effective parent-child relationships between visible nodes
            nodes.forEach(node => {
                const visibleParent = findVisibleAncestor(node.id);
                if (visibleParent) {
                    parentMap.set(node.id, visibleParent);
                    if (!childrenMap.has(visibleParent)) {
                        childrenMap.set(visibleParent, []);
                    }
                    childrenMap.get(visibleParent).push(node.id);
                }
            });

            // Find root nodes (no visible parent in hierarchy) - these have children
            const rootNodes = nodes.filter(n => !parentMap.has(n.id) && childrenMap.has(n.id));

            // Find orphan nodes (no parent AND no children in hierarchy)
            const orphanNodes = nodes.filter(n => !parentMap.has(n.id) && !childrenMap.has(n.id));

            const VERTICAL_SPACING = 140;
            const HORIZONTAL_SPACING = 180;

            // Use d3.tree() for proper hierarchical layout
            if (rootNodes.length > 0) {
                // Build hierarchy data for d3
                function buildHierarchyData(nodeId) {
                    const children = (childrenMap.get(nodeId) || []).map(childId => buildHierarchyData(childId));
                    return { id: nodeId, children: children.length > 0 ? children : undefined };
                }

                // Create a virtual root that contains all actual roots
                const virtualRoot = {
                    id: '__virtual_root__',
                    children: rootNodes.map(n => buildHierarchyData(n.id))
                };

                // Create d3 hierarchy
                const root = d3.hierarchy(virtualRoot);

                // Calculate tree layout
                const treeLayout = d3.tree()
                    .nodeSize([HORIZONTAL_SPACING, VERTICAL_SPACING])
                    .separation((a, b) => {
                        // More separation between different subtrees
                        return a.parent === b.parent ? 1 : 1.5;
                    });

                treeLayout(root);

                // Extract positions from d3 tree (skip virtual root)
                root.descendants().forEach(d => {
                    if (d.data.id !== '__virtual_root__') {
                        // d3.tree uses x for horizontal, y for vertical (depth)
                        // We want top-to-bottom layout, so y becomes our vertical position
                        positions.set(d.data.id, {
                            x: d.x + width / 2,  // Center horizontally
                            y: d.y + 80         // Offset from top
                        });
                    }
                });
            }

            // Position orphan nodes in a grid below the hierarchy
            if (orphanNodes.length > 0) {
                // Find the maximum y position used so far
                let maxY = 80;
                positions.forEach(pos => {
                    maxY = Math.max(maxY, pos.y);
                });

                // Calculate grid dimensions for orphans
                const gridColumns = Math.ceil(Math.sqrt(orphanNodes.length * 1.5)); // Wider than tall
                const gridRows = Math.ceil(orphanNodes.length / gridColumns);

                const orphanStartY = maxY + VERTICAL_SPACING + 40;
                const gridWidth = (gridColumns - 1) * HORIZONTAL_SPACING;
                const gridStartX = (width - gridWidth) / 2;

                orphanNodes.forEach((n, i) => {
                    const col = i % gridColumns;
                    const row = Math.floor(i / gridColumns);
                    positions.set(n.id, {
                        x: gridStartX + col * HORIZONTAL_SPACING,
                        y: orphanStartY + row * VERTICAL_SPACING
                    });
                });
            }

            // Handle any nodes that still don't have positions
            const remaining = nodes.filter(n => !positions.has(n.id));
            if (remaining.length > 0) {
                let maxY = 80;
                positions.forEach(pos => {
                    maxY = Math.max(maxY, pos.y);
                });

                const startY = maxY + VERTICAL_SPACING;
                remaining.forEach((n, i) => {
                    positions.set(n.id, {
                        x: 100 + (i % 5) * HORIZONTAL_SPACING,
                        y: startY + Math.floor(i / 5) * VERTICAL_SPACING
                    });
                });
            }

            return positions;
        }

        // Apply auto-layout and save positions
        function cleanGraphLayout() {
            const container = document.getElementById('graph');
            if (!container) return;

            const width = container.clientWidth;
            const height = container.clientHeight;

            // Get active filters (same as updateGraph)
            const filters = getActiveFilters();

            // Get filtered nodes (same as updateGraph)
            const nodes = [];
            ['unit', 'team', 'role', 'object'].forEach(type => {
                if (filters.entities[type]) {
                    entities[type].forEach(entity => nodes.push(entity));
                }
            });

            // Calculate new positions
            const positions = calculateAutoLayout(nodes, width, height);

            // Apply positions to entities and save
            positions.forEach((pos, nodeId) => {
                for (const type of ['unit', 'team', 'role', 'object']) {
                    const entity = entities[type].find(e => e.id === nodeId);
                    if (entity) {
                        entity.graphX = pos.x;
                        entity.graphY = pos.y;
                        break;
                    }
                }
            });

            // Save to localStorage
            saveWorkspaces();

            // Re-render graph
            updateGraph();

            // Reset zoom
            if (graphZoom && svg) {
                svg.call(graphZoom.transform, d3.zoomIdentity);
                currentZoomScale = 1;
                updateZoomDisplay();
            }
        }

        // Fit graph to view
        function fitGraphToView() {
            if (!graphG || !graphZoom) return;

            const container = document.getElementById('graph');
            if (!container) return;

            const width = container.clientWidth;
            const height = container.clientHeight;

            // Get bounds of all nodes
            const bounds = graphG.node().getBBox();
            if (bounds.width === 0 || bounds.height === 0) return;

            const padding = 40;
            const scale = Math.min(
                (width - padding * 2) / bounds.width,
                (height - padding * 2) / bounds.height,
                1.5 // Max zoom
            );

            const tx = (width - bounds.width * scale) / 2 - bounds.x * scale;
            const ty = (height - bounds.height * scale) / 2 - bounds.y * scale;

            svg.transition().duration(300).call(
                graphZoom.transform,
                d3.zoomIdentity.translate(tx, ty).scale(scale)
            );

            currentZoomScale = scale;
            updateZoomDisplay();
        }

        // Zoom controls
        function zoomGraph(factor) {
            if (!graphZoom) return;
            currentZoomScale *= factor;
            currentZoomScale = Math.max(0.3, Math.min(3, currentZoomScale));

            svg.transition().duration(200).call(
                graphZoom.scaleTo,
                currentZoomScale
            );

            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const display = document.getElementById('graphZoomLevel');
            if (display) {
                display.textContent = Math.round(currentZoomScale * 100) + '%';
            }
        }

        // Generate bezier curve path for edges
        function generateEdgePath(sourceX, sourceY, targetX, targetY) {
            // Source exits from right port, target enters from left port
            const sourcePortX = sourceX + NODE_WIDTH / 2;
            const sourcePortY = sourceY;
            const targetPortX = targetX - NODE_WIDTH / 2;
            const targetPortY = targetY;

            // Calculate control points for smooth bezier
            const dx = targetPortX - sourcePortX;
            const dy = targetPortY - sourcePortY;

            // Adjust curve based on relative positions
            let cp1x, cp1y, cp2x, cp2y;

            if (dx > 0) {
                // Normal left-to-right flow
                const curveStrength = Math.min(Math.abs(dx) * 0.5, 100);
                cp1x = sourcePortX + curveStrength;
                cp1y = sourcePortY;
                cp2x = targetPortX - curveStrength;
                cp2y = targetPortY;
            } else {
                // Backwards connection - need to curve around
                const curveStrength = Math.max(80, Math.abs(dx) * 0.3);
                const verticalOffset = Math.sign(dy) * Math.max(60, Math.abs(dy) * 0.5);
                cp1x = sourcePortX + curveStrength;
                cp1y = sourcePortY + verticalOffset;
                cp2x = targetPortX - curveStrength;
                cp2y = targetPortY - verticalOffset;
            }

            return `M ${sourcePortX} ${sourcePortY} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${targetPortX} ${targetPortY}`;
        }

        function updateGraph() {
            // Get dimensions
            const container = document.getElementById('graph');
            if (!container) return;

            width = container.clientWidth;
            height = container.clientHeight;

            svg.attr('width', width).attr('height', height);

            // Get active filters
            const filters = getActiveFilters();

            // Prepare data with filters applied
            const nodes = [];
            const types = ['unit', 'team', 'role', 'object'];
            types.forEach(type => {
                if (filters.entities[type]) {
                    entities[type].forEach(entity => {
                        nodes.push({ ...entity });
                    });
                }
            });

            const links = relationships
                .filter(rel => filters.relationships[rel.predicate])
                .filter(rel => {
                    const sourceNode = nodes.find(n => n.id === rel.subject);
                    const targetNode = nodes.find(n => n.id === rel.object);
                    return sourceNode && targetNode;
                })
                .map(rel => ({
                    source: rel.subject,
                    target: rel.object,
                    predicate: rel.predicate,
                    id: rel.id
                }));

            // Clear existing
            svg.selectAll('*').remove();

            // Create defs for markers and filters
            const defs = svg.append('defs');

            // Arrow markers for each operator type
            Object.keys(eoOperators).forEach(type => {
                const opData = eoOperators[type];
                defs.append('marker')
                    .attr('id', `arrow-${type}`)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 8)
                    .attr('refY', 0)
                    .attr('markerWidth', 8)
                    .attr('markerHeight', 8)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-4L10,0L0,4')
                    .attr('fill', opData.color);
            });

            // Create main group for zoom/pan
            graphG = svg.append('g').attr('class', 'graph-container');

            const linkGroup = graphG.append('g').attr('class', 'edges');
            const nodeGroup = graphG.append('g').attr('class', 'nodes');

            // Check if nodes need initial positions
            const needsLayout = nodes.some(n => n.graphX === undefined || n.graphY === undefined);

            if (needsLayout) {
                const positions = calculateAutoLayout(nodes, width, height);
                positions.forEach((pos, nodeId) => {
                    const node = nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.graphX = pos.x;
                        node.graphY = pos.y;
                        // Also update the source entity
                        for (const type of types) {
                            const entity = entities[type].find(e => e.id === nodeId);
                            if (entity) {
                                entity.graphX = pos.x;
                                entity.graphY = pos.y;
                                break;
                            }
                        }
                    }
                });
                saveWorkspaces();
            }

            // Create node lookup for edge rendering
            const nodeMap = new Map(nodes.map(n => [n.id, n]));

            // Create edges with bezier curves
            links.forEach(link => {
                const sourceNode = nodeMap.get(link.source);
                const targetNode = nodeMap.get(link.target);
                if (!sourceNode || !targetNode) return;

                const pathData = generateEdgePath(
                    sourceNode.graphX, sourceNode.graphY,
                    targetNode.graphX, targetNode.graphY
                );

                const opData = eoOperators[link.predicate] || {};

                // Invisible hitbox for easier clicking
                linkGroup.append('path')
                    .attr('class', 'graph-edge-hitbox')
                    .attr('d', pathData)
                    .attr('data-id', link.id)
                    .on('click', function(event) {
                        event.stopPropagation();
                        openEdgeEditModal(link.id);
                    });

                // Visible edge
                const edge = linkGroup.append('path')
                    .attr('class', 'graph-edge')
                    .attr('d', pathData)
                    .attr('stroke', opData.color || '#999')
                    .attr('stroke-dasharray', () => {
                        if (link.predicate === 'SEG' || link.predicate === 'REC') return '8,4';
                        if (link.predicate === 'ALT') return '4,2';
                        return 'none';
                    })
                    .attr('marker-end', `url(#arrow-${link.predicate})`)
                    .attr('data-id', link.id)
                    .on('click', function(event) {
                        event.stopPropagation();
                        openEdgeEditModal(link.id);
                    });

                // Edge label at midpoint
                const midX = (sourceNode.graphX + targetNode.graphX) / 2;
                const midY = (sourceNode.graphY + targetNode.graphY) / 2;

                // Label background
                linkGroup.append('rect')
                    .attr('class', 'graph-edge-label-bg')
                    .attr('x', midX - 16)
                    .attr('y', midY - 8)
                    .attr('width', 32)
                    .attr('height', 16)
                    .attr('rx', 4);

                // Label text
                linkGroup.append('text')
                    .attr('class', 'graph-edge-label')
                    .attr('x', midX)
                    .attr('y', midY + 3)
                    .attr('text-anchor', 'middle')
                    .attr('fill', opData.color || '#666')
                    .style('font-weight', '600')
                    .text(link.predicate);
            });

            // Create n8n-style card nodes
            graphNode = nodeGroup.selectAll('g.graph-node')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'graph-node')
                .attr('transform', d => `translate(${d.graphX - NODE_WIDTH/2}, ${d.graphY - NODE_HEIGHT/2})`)
                .call(d3.drag()
                    .on('start', nodeDragStarted)
                    .on('drag', nodeDragged)
                    .on('end', nodeDragEnded));

            // Node body (white rectangle with rounded corners)
            graphNode.append('rect')
                .attr('class', 'graph-node-body')
                .attr('width', NODE_WIDTH)
                .attr('height', NODE_HEIGHT)
                .attr('rx', 8)
                .attr('ry', 8);

            // Accent bar on left side
            graphNode.append('rect')
                .attr('class', 'graph-node-accent')
                .attr('width', 6)
                .attr('height', NODE_HEIGHT)
                .attr('rx', 8)
                .attr('fill', d => getNodeAccentColor(d.type));

            // Clip the accent bar to just show on left
            graphNode.append('rect')
                .attr('class', 'graph-node-accent')
                .attr('x', 3)
                .attr('width', 3)
                .attr('height', NODE_HEIGHT)
                .attr('fill', d => getNodeAccentColor(d.type));

            // Icon
            graphNode.append('foreignObject')
                .attr('class', 'graph-node-icon')
                .attr('x', 14)
                .attr('y', (NODE_HEIGHT - 24) / 2)
                .attr('width', 24)
                .attr('height', 24)
                .append('xhtml:div')
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('justify-content', 'center')
                .style('width', '100%')
                .style('height', '100%')
                .style('color', d => getNodeAccentColor(d.type))
                .style('font-size', '20px')
                .html(d => getIcon(d.type));

            // Node label (name)
            graphNode.append('text')
                .attr('class', 'graph-node-label')
                .attr('x', 44)
                .attr('y', NODE_HEIGHT / 2 - 4)
                .text(d => {
                    const maxLen = 12;
                    return d.name.length > maxLen ? d.name.substring(0, maxLen - 1) + '' : d.name;
                });

            // Node type label
            graphNode.append('text')
                .attr('class', 'graph-node-type')
                .attr('x', 44)
                .attr('y', NODE_HEIGHT / 2 + 12)
                .text(d => d.type);

            // Input port (left side)
            graphNode.append('circle')
                .attr('class', 'graph-port input-port')
                .attr('cx', 0)
                .attr('cy', NODE_HEIGHT / 2)
                .attr('r', PORT_RADIUS);

            // Output port (right side)
            graphNode.append('circle')
                .attr('class', 'graph-port output-port')
                .attr('cx', NODE_WIDTH)
                .attr('cy', NODE_HEIGHT / 2)
                .attr('r', PORT_RADIUS);

            // Node interactions
            graphNode.on('click', function(event, d) {
                event.stopPropagation();
                // Deselect all, select this one
                graphNode.classed('selected', false);
                d3.select(this).classed('selected', true);
                openEntityModal(d.id, d.type);
            })
            .on('dblclick', function(event, d) {
                event.stopPropagation();
                focusNode(d);
            })
            .on('mouseover', function(event, d) {
                showTooltip(event, d);
            })
            .on('mouseout', function() {
                hideTooltip();
            });

            // Click background to deselect
            svg.on('click', function() {
                graphNode.classed('selected', false);
                unfocusAll();
            });

            // Setup zoom
            graphZoom = d3.zoom()
                .scaleExtent([0.3, 3])
                .on('zoom', (event) => {
                    graphG.attr('transform', event.transform);
                    currentZoomScale = event.transform.k;
                    updateZoomDisplay();
                });

            svg.call(graphZoom);

            // Store link data for updating
            graphLink = linkGroup;
        }

        // Node drag handlers - free movement with position persistence
        function nodeDragStarted(event, d) {
            d3.select(this).raise().classed('dragging', true);
        }

        function nodeDragged(event, d) {
            // Update position
            d.graphX = event.x + NODE_WIDTH / 2;
            d.graphY = event.y + NODE_HEIGHT / 2;

            // Move node
            d3.select(this).attr('transform', `translate(${event.x}, ${event.y})`);

            // Update connected edges
            updateEdgesForNode(d);
        }

        function nodeDragEnded(event, d) {
            d3.select(this).classed('dragging', false);

            // Save position to entity
            for (const type of ['unit', 'team', 'role', 'object']) {
                const entity = entities[type].find(e => e.id === d.id);
                if (entity) {
                    entity.graphX = d.graphX;
                    entity.graphY = d.graphY;
                    break;
                }
            }

            // Persist to storage
            saveWorkspaces();
        }

        // Update edges connected to a node during drag
        function updateEdgesForNode(node) {
            if (!graphLink) return;

            // Get all nodes for position lookup
            const nodePositions = new Map();
            d3.selectAll('.graph-node').each(function(d) {
                nodePositions.set(d.id, { x: d.graphX, y: d.graphY });
            });

            // Update paths that connect to this node
            relationships.forEach(rel => {
                if (rel.subject === node.id || rel.object === node.id) {
                    const sourcePos = nodePositions.get(rel.subject);
                    const targetPos = nodePositions.get(rel.object);
                    if (!sourcePos || !targetPos) return;

                    const pathData = generateEdgePath(
                        sourcePos.x, sourcePos.y,
                        targetPos.x, targetPos.y
                    );

                    // Update visible edge and hitbox
                    graphLink.selectAll(`path[data-id="${rel.id}"]`)
                        .attr('d', pathData);

                    // Update label position
                    const midX = (sourcePos.x + targetPos.x) / 2;
                    const midY = (sourcePos.y + targetPos.y) / 2;

                    // This is simplified - in production you'd need to track label elements
                }
            });
        }

        // Edge edit modal
        function openEdgeEditModal(relationshipId) {
            const rel = relationships.find(r => r.id === relationshipId);
            if (!rel) return;

            openRelationshipModal({ id: relationshipId, ...rel });
        }

        function getNodeRadius(type) {
            // Legacy function - kept for compatibility
            return NODE_WIDTH / 4;
        }

        function getNodeColor(type) {
            return getNodeAccentColor(type);
        }

        function getLinkColor(predicate) {
            return eoOperators[predicate]?.color || '#999';
        }

        function getIcon(type) {
            const icons = {
                unit: '<i class="ph ph-buildings"></i>',
                team: '<i class="ph ph-users-three"></i>',
                role: '<i class="ph ph-briefcase"></i>',
                person: '<i class="ph ph-user"></i>',
                object: '<i class="ph ph-package"></i>'
            };
            return icons[type] || '<i class="ph ph-question"></i>';
        }

        function getInitials(name) {
            return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
        }

        function focusNode(d) {
            if (!d || !d.id) return;
            if (!graphNode || !graphLink) return;
            if (!relationships) return;

            focusedNode = d;

            // Get connected nodes
            const connectedNodes = new Set([d.id]);
            relationships.forEach(rel => {
                if (rel && rel.subject === d.id) connectedNodes.add(rel.object);
                if (rel && rel.object === d.id) connectedNodes.add(rel.subject);
            });

            // Dim unconnected nodes
            graphNode.style('opacity', n => connectedNodes.has(n.id) ? 1 : 0.2);
            graphLink.selectAll('.graph-edge').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                const rel = relationships.find(r => r.id === id);
                return rel && (rel.subject === d.id || rel.object === d.id) ? 1 : 0.1;
            });
        }

        function unfocusAll() {
            focusedNode = null;
            if (graphNode) graphNode.style('opacity', 1);
            if (graphLink) graphLink.selectAll('.graph-edge').style('opacity', 1);
        }

        function toggleNodeCollapse(d) {
            console.log('Toggle collapse for:', d.name);
        }

        function showTooltip(event, d) {
            const connections = relationships.filter(r =>
                r.subject === d.id || r.object === d.id
            );

            tooltip.html(`
                <strong>${d.name}</strong><br>
                <em>${d.type}</em><br>
                ${connections.length} connections
            `);
            tooltip.style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .style('opacity', 1);
        }

        function hideTooltip() {
            tooltip.style('opacity', 0);
        }

        // Legacy drag functions (for compatibility)
        function dragstarted(event, d) {
            nodeDragStarted(event, d);
        }

        function dragged(event, d) {
            nodeDragged(event, d);
        }

        function dragended(event, d) {
            nodeDragEnded(event, d);
        }

        function resetGraph() {
            if (currentView === 'graph') {
                unfocusAll();
                cleanGraphLayout();
            } else if (currentView === 'tree') {
                renderTreeView();
            }
        }

        function exportData() {
            const workspaceName = document.getElementById('workspaceNameText').textContent;
            const data = {
                workspaceName,
                entities,
                relationships
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${workspaceName.toLowerCase().replace(/\s+/g, '-')}-data.json`;
            a.click();
        }

        // ==========================================
        // BULK IMPORT FUNCTIONALITY
        // ==========================================

        let bulkImportState = {
            step: 1,
            entityType: 'person',
            rawData: '',
            parsedData: [],
            headers: [],
            fieldMappings: {},  // { sourceColumn: targetField }
            setAllValues: {},   // { targetField: { enabled: true, value: 'xyz' } }
            processedData: []
        };

        // Field definitions for each entity type
        const bulkImportFields = {
            unit: [
                { key: 'name', label: 'Name', required: true },
                { key: 'parent', label: 'Parent Unit', required: false, type: 'relationship', targetType: 'unit' }
            ],
            team: [
                { key: 'name', label: 'Name', required: true },
                { key: 'parent', label: 'Parent (Unit or Team)', required: false, type: 'relationship', targetTypes: ['unit', 'team'] }
            ],
            role: [
                { key: 'name', label: 'Name', required: true },
                { key: 'parent', label: 'Parent (Unit or Team)', required: false, type: 'relationship', targetTypes: ['unit', 'team'] }
            ],
            person: [
                { key: 'name', label: 'Name', required: true },
                { key: 'role', label: 'Assigned Role', required: false, type: 'relationship', targetType: 'role' }
            ],
            object: [
                { key: 'name', label: 'Name', required: true },
                { key: 'parent', label: 'Parent Role', required: false, type: 'relationship', targetType: 'role' }
            ]
        };

        function openBulkImportModal() {
            // Reset state
            bulkImportState = {
                step: 1,
                entityType: 'person',
                rawData: '',
                parsedData: [],
                headers: [],
                fieldMappings: {},
                setAllValues: {},
                processedData: []
            };

            // Reset UI
            document.getElementById('bulkImportPasteArea').value = '';
            document.getElementById('bulkImportFileInput').value = '';
            document.getElementById('bulkImportFileName').textContent = '';
            document.getElementById('bulkImportDataPreview').style.display = 'none';

            // Reset entity type buttons
            document.querySelectorAll('.bulk-import-entity-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === 'person');
            });

            // Reset tabs
            switchBulkImportTab('paste');

            // Reset steps
            updateBulkImportStep(1);

            // Show modal
            document.getElementById('bulkImportModal').classList.add('open');
        }

        function closeBulkImportModal() {
            document.getElementById('bulkImportModal').classList.remove('open');
        }

        function selectBulkImportType(type) {
            bulkImportState.entityType = type;
            document.querySelectorAll('.bulk-import-entity-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });

            // Re-validate if we have data
            if (bulkImportState.parsedData.length > 0) {
                updateBulkImportNextButton();
            }
        }

        function switchBulkImportTab(tab) {
            document.querySelectorAll('.bulk-import-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.bulk-import-tab:nth-child(${tab === 'paste' ? 1 : 2})`).classList.add('active');

            document.getElementById('bulkImportPasteTab').style.display = tab === 'paste' ? 'block' : 'none';
            document.getElementById('bulkImportFileTab').style.display = tab === 'file' ? 'block' : 'none';
        }

        function parseBulkImportData() {
            const rawData = document.getElementById('bulkImportPasteArea').value.trim();
            if (!rawData) {
                bulkImportState.parsedData = [];
                bulkImportState.headers = [];
                document.getElementById('bulkImportDataPreview').style.display = 'none';
                updateBulkImportNextButton();
                return;
            }

            bulkImportState.rawData = rawData;
            parseDataContent(rawData);
        }

        function parseDataContent(content) {
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                bulkImportState.parsedData = [];
                bulkImportState.headers = [];
                document.getElementById('bulkImportDataPreview').style.display = 'none';
                updateBulkImportNextButton();
                return;
            }

            // Detect delimiter (tab or comma)
            const firstLine = lines[0];
            const delimiter = firstLine.includes('\t') ? '\t' : ',';

            // Parse CSV/TSV with proper quote handling
            function parseLine(line, delim) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        if (inQuotes && line[i + 1] === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === delim && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            }

            // Parse headers
            bulkImportState.headers = parseLine(lines[0], delimiter);

            // Parse data rows
            bulkImportState.parsedData = [];
            for (let i = 1; i < lines.length; i++) {
                const values = parseLine(lines[i], delimiter);
                if (values.some(v => v.trim())) {  // Skip empty rows
                    const row = {};
                    bulkImportState.headers.forEach((header, idx) => {
                        row[header] = values[idx] || '';
                    });
                    bulkImportState.parsedData.push(row);
                }
            }

            // Update preview
            renderBulkImportDataPreview();
            updateBulkImportNextButton();
        }

        function handleBulkImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('bulkImportFileName').innerHTML = `
                <i class="ph ph-file-csv"></i> ${escapeHtml(file.name)}
            `;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                bulkImportState.rawData = content;
                parseDataContent(content);
            };
            reader.readAsText(file);
        }

        function renderBulkImportDataPreview() {
            const previewContainer = document.getElementById('bulkImportDataPreview');
            const table = document.getElementById('bulkImportPreviewTable');
            const rowCount = document.getElementById('bulkImportRowCount');

            if (bulkImportState.parsedData.length === 0) {
                previewContainer.style.display = 'none';
                return;
            }

            previewContainer.style.display = 'block';
            rowCount.textContent = `${bulkImportState.parsedData.length} rows`;

            // Build table
            let html = '<thead><tr>';
            bulkImportState.headers.forEach(h => {
                html += `<th>${escapeHtml(h)}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Show first 10 rows
            const previewRows = bulkImportState.parsedData.slice(0, 10);
            previewRows.forEach(row => {
                html += '<tr>';
                bulkImportState.headers.forEach(h => {
                    html += `<td>${escapeHtml(row[h] || '')}</td>`;
                });
                html += '</tr>';
            });

            if (bulkImportState.parsedData.length > 10) {
                html += `<tr><td colspan="${bulkImportState.headers.length}" style="text-align: center; color: #8B6F47; font-style: italic;">... and ${bulkImportState.parsedData.length - 10} more rows</td></tr>`;
            }

            html += '</tbody>';
            table.innerHTML = html;
        }

        function updateBulkImportNextButton() {
            const nextBtn = document.getElementById('bulkImportNextBtn');
            const footerInfo = document.getElementById('bulkImportFooterInfo');

            if (bulkImportState.step === 1) {
                const hasData = bulkImportState.parsedData.length > 0;
                nextBtn.disabled = !hasData;
                footerInfo.textContent = hasData
                    ? `${bulkImportState.parsedData.length} rows detected. Click Next to map fields.`
                    : 'Select an entity type and paste or upload your data to continue.';
            } else if (bulkImportState.step === 2) {
                // Check if name field is mapped
                const nameMapping = Object.entries(bulkImportState.fieldMappings).find(([src, tgt]) => tgt === 'name');
                const hasNameMapping = !!nameMapping || (bulkImportState.setAllValues.name && bulkImportState.setAllValues.name.enabled);
                nextBtn.disabled = !hasNameMapping;
                footerInfo.textContent = hasNameMapping
                    ? 'Ready to review. Click Next to see the final preview.'
                    : 'Please map at least the Name field to continue.';
            }
        }

        function updateBulkImportStep(step) {
            bulkImportState.step = step;

            // Update step indicators
            for (let i = 1; i <= 3; i++) {
                const stepEl = document.getElementById(`bulkImportStep${i}`);
                stepEl.classList.remove('active', 'completed');
                if (i < step) stepEl.classList.add('completed');
                if (i === step) stepEl.classList.add('active');
            }

            // Show/hide content
            document.getElementById('bulkImportStepContent1').style.display = step === 1 ? 'block' : 'none';
            document.getElementById('bulkImportStepContent2').style.display = step === 2 ? 'block' : 'none';
            document.getElementById('bulkImportStepContent3').style.display = step === 3 ? 'block' : 'none';

            // Show/hide buttons
            document.getElementById('bulkImportBackBtn').style.display = step > 1 ? 'inline-flex' : 'none';
            document.getElementById('bulkImportNextBtn').style.display = step < 3 ? 'inline-flex' : 'none';
            document.getElementById('bulkImportImportBtn').style.display = step === 3 ? 'inline-flex' : 'none';
            document.getElementById('bulkImportDoneBtn').style.display = 'none';

            // Reset success content visibility
            document.getElementById('bulkImportReviewContent').style.display = 'block';
            document.getElementById('bulkImportSuccessContent').style.display = 'none';

            updateBulkImportNextButton();
        }

        function bulkImportNext() {
            if (bulkImportState.step === 1) {
                // Go to step 2: field mapping
                updateBulkImportStep(2);
                renderFieldMappingUI();
            } else if (bulkImportState.step === 2) {
                // Go to step 3: review
                updateBulkImportStep(3);
                processAndPreviewData();
            }
        }

        function bulkImportBack() {
            if (bulkImportState.step > 1) {
                updateBulkImportStep(bulkImportState.step - 1);
            }
        }

        function renderFieldMappingUI() {
            const container = document.getElementById('bulkImportMappingContainer');
            const fields = bulkImportFields[bulkImportState.entityType];

            // Auto-map fields based on header names
            bulkImportState.fieldMappings = {};
            bulkImportState.setAllValues = {};

            fields.forEach(field => {
                // Try to find a matching header
                const matchingHeader = bulkImportState.headers.find(h =>
                    h.toLowerCase().includes(field.key.toLowerCase()) ||
                    h.toLowerCase().includes(field.label.toLowerCase().split(' ')[0].toLowerCase())
                );
                if (matchingHeader) {
                    bulkImportState.fieldMappings[matchingHeader] = field.key;
                }
            });

            let html = '';

            // Field mapping rows
            fields.forEach(field => {
                const currentMapping = Object.entries(bulkImportState.fieldMappings).find(([src, tgt]) => tgt === field.key);
                const mappedColumn = currentMapping ? currentMapping[0] : '';

                html += `
                    <div class="bulk-import-mapping-row" data-field="${field.key}">
                        <div>
                            <div class="bulk-import-mapping-col">
                                ${field.label}${field.required ? ' <span style="color: #d32f2f;">*</span>' : ''}
                            </div>
                            ${field.type === 'relationship' ? `<div style="font-size: 0.7rem; color: #8B6F47; margin-top: 0.25rem;">Links to existing ${field.targetType || field.targetTypes?.join('/')}</div>` : ''}
                        </div>
                        <div class="bulk-import-mapping-arrow"><i class="ph ph-arrow-left"></i></div>
                        <div>
                            <select class="bulk-import-mapping-select" onchange="updateFieldMapping('${field.key}', this.value)">
                                <option value="">-- Select column --</option>
                                ${bulkImportState.headers.map(h => `
                                    <option value="${escapeHtml(h)}" ${mappedColumn === h ? 'selected' : ''}>${escapeHtml(h)}</option>
                                `).join('')}
                            </select>
                        </div>
                        <div class="bulk-import-set-all">
                            <button class="bulk-import-set-all-btn" onclick="toggleSetAll('${field.key}', this)" title="Set a default value for all items">
                                <i class="ph ph-pencil-simple"></i> Set for All
                            </button>
                            <input type="text"
                                class="bulk-import-set-all-input"
                                id="setAllInput_${field.key}"
                                placeholder="Default value..."
                                style="display: none;"
                                oninput="updateSetAllValue('${field.key}', this.value)"
                                ${field.type === 'relationship' ? `list="existingEntities_${field.key}"` : ''}>
                            ${field.type === 'relationship' ? renderExistingEntitiesDatalist(field) : ''}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            updateBulkImportNextButton();
            renderMappedPreview();
        }

        function renderExistingEntitiesDatalist(field) {
            const targetTypes = field.targetTypes || [field.targetType];
            let options = [];

            targetTypes.forEach(type => {
                if (entities[type]) {
                    entities[type].forEach(e => {
                        options.push(e.name);
                    });
                }
            });

            return `<datalist id="existingEntities_${field.key}">${options.map(o => `<option value="${escapeHtml(o)}">`).join('')}</datalist>`;
        }

        function updateFieldMapping(fieldKey, sourceColumn) {
            // Remove any existing mapping to this field
            Object.keys(bulkImportState.fieldMappings).forEach(key => {
                if (bulkImportState.fieldMappings[key] === fieldKey) {
                    delete bulkImportState.fieldMappings[key];
                }
            });

            // Add new mapping
            if (sourceColumn) {
                bulkImportState.fieldMappings[sourceColumn] = fieldKey;
            }

            updateBulkImportNextButton();
            renderMappedPreview();
        }

        function toggleSetAll(fieldKey, btn) {
            const input = document.getElementById(`setAllInput_${fieldKey}`);
            const isActive = btn.classList.contains('active');

            if (isActive) {
                btn.classList.remove('active');
                input.style.display = 'none';
                input.value = '';
                delete bulkImportState.setAllValues[fieldKey];
            } else {
                btn.classList.add('active');
                input.style.display = 'block';
                input.focus();
                bulkImportState.setAllValues[fieldKey] = { enabled: true, value: '' };
            }

            updateBulkImportNextButton();
            renderMappedPreview();
        }

        function updateSetAllValue(fieldKey, value) {
            if (bulkImportState.setAllValues[fieldKey]) {
                bulkImportState.setAllValues[fieldKey].value = value;
            }
            renderMappedPreview();
        }

        function renderMappedPreview() {
            const table = document.getElementById('bulkImportMappedTable');
            const countEl = document.getElementById('bulkImportMappedCount');
            const fields = bulkImportFields[bulkImportState.entityType];

            // Build header
            let html = '<thead><tr>';
            fields.forEach(f => {
                html += `<th>${f.label}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Process and show preview
            const previewRows = bulkImportState.parsedData.slice(0, 10);
            previewRows.forEach(row => {
                html += '<tr>';
                fields.forEach(f => {
                    let value = '';
                    const setAll = bulkImportState.setAllValues[f.key];

                    // Check if there's a column mapping
                    const mappedColumn = Object.entries(bulkImportState.fieldMappings)
                        .find(([src, tgt]) => tgt === f.key);

                    if (mappedColumn && row[mappedColumn[0]]) {
                        value = row[mappedColumn[0]];
                    } else if (setAll && setAll.enabled && setAll.value) {
                        value = `<span class="preview-set-all">${escapeHtml(setAll.value)}</span>`;
                    }

                    html += `<td>${value ? (value.includes('preview-set-all') ? value : escapeHtml(value)) : '<span style="color: #ccc;"></span>'}</td>`;
                });
                html += '</tr>';
            });

            if (bulkImportState.parsedData.length > 10) {
                html += `<tr><td colspan="${fields.length}" style="text-align: center; color: #8B6F47; font-style: italic;">... and ${bulkImportState.parsedData.length - 10} more rows</td></tr>`;
            }

            html += '</tbody>';
            table.innerHTML = html;
            countEl.textContent = `${bulkImportState.parsedData.length} items`;
        }

        function processAndPreviewData() {
            const fields = bulkImportFields[bulkImportState.entityType];
            bulkImportState.processedData = [];
            let validCount = 0;
            let errorCount = 0;

            bulkImportState.parsedData.forEach((row, idx) => {
                const processed = { _original: row, _errors: [], _rowIndex: idx };

                fields.forEach(field => {
                    let value = '';

                    // Check mapped column first
                    const mappedColumn = Object.entries(bulkImportState.fieldMappings)
                        .find(([src, tgt]) => tgt === field.key);

                    if (mappedColumn && row[mappedColumn[0]]) {
                        value = row[mappedColumn[0]].trim();
                    }

                    // Apply "Set for All" if no value from mapping
                    if (!value) {
                        const setAll = bulkImportState.setAllValues[field.key];
                        if (setAll && setAll.enabled && setAll.value) {
                            value = setAll.value.trim();
                            processed[`${field.key}_isSetAll`] = true;
                        }
                    }

                    processed[field.key] = value;

                    // Validate required fields
                    if (field.required && !value) {
                        processed._errors.push(`${field.label} is required`);
                    }
                });

                if (processed._errors.length === 0) {
                    validCount++;
                } else {
                    errorCount++;
                }

                bulkImportState.processedData.push(processed);
            });

            // Update counts
            document.getElementById('bulkImportTotalCount').textContent = bulkImportState.processedData.length;
            document.getElementById('bulkImportValidCount').textContent = validCount;
            document.getElementById('bulkImportErrorCount').textContent = errorCount;
            document.getElementById('bulkImportFinalCount').textContent = `${validCount} valid items`;

            // Update entity type label
            const typeLabels = {
                unit: 'Units',
                team: 'Teams',
                role: 'Roles',
                person: 'People',
                object: 'Objects'
            };
            document.getElementById('bulkImportEntityTypeLabel').innerHTML =
                `Importing as: <strong>${typeLabels[bulkImportState.entityType]}</strong>`;

            // Render final table
            renderFinalPreview();

            // Disable import if no valid items
            document.getElementById('bulkImportImportBtn').disabled = validCount === 0;
            document.getElementById('bulkImportFooterInfo').textContent = validCount > 0
                ? `${validCount} items ready to import.`
                : 'No valid items to import. Please check your data.';
        }

        function renderFinalPreview() {
            const table = document.getElementById('bulkImportFinalTable');
            const fields = bulkImportFields[bulkImportState.entityType];

            let html = '<thead><tr>';
            html += '<th style="width: 40px;">#</th>';
            fields.forEach(f => {
                html += `<th>${f.label}</th>`;
            });
            html += '<th>Status</th>';
            html += '</tr></thead><tbody>';

            bulkImportState.processedData.forEach((row, idx) => {
                const hasErrors = row._errors.length > 0;
                html += `<tr class="${hasErrors ? 'error' : ''}">`;
                html += `<td>${idx + 1}</td>`;
                fields.forEach(f => {
                    const value = row[f.key];
                    const isSetAll = row[`${f.key}_isSetAll`];
                    html += `<td>${value ? `<span class="${isSetAll ? 'preview-set-all' : ''}">${escapeHtml(value)}</span>` : '<span style="color: #ccc;"></span>'}</td>`;
                });
                html += `<td>${hasErrors
                    ? `<span class="preview-error"><i class="ph ph-warning"></i> ${row._errors.join(', ')}</span>`
                    : '<span style="color: #4CAF50;"><i class="ph ph-check"></i> Valid</span>'
                }</td>`;
                html += '</tr>';
            });

            html += '</tbody>';
            table.innerHTML = html;
        }

        function executeBulkImport() {
            const validItems = bulkImportState.processedData.filter(row => row._errors.length === 0);
            const entityType = bulkImportState.entityType;
            const fields = bulkImportFields[entityType];
            let importedCount = 0;

            validItems.forEach(item => {
                const name = item.name;
                if (!name) return;

                // Create entity
                const id = entityType[0] + Date.now() + Math.random().toString(36).substr(2, 5);
                const entity = {
                    id,
                    name,
                    type: entityType
                };

                entities[entityType].push(entity);

                // Log to Xano
                logActivityToXano({
                    event_verb: 'Start Entity (Bulk Import)',
                    eo_operator: 'INS',
                    object_type: entityType,
                    object_id: id,
                    object_label: name,
                    data_json: {
                        entity_type: entityType,
                        entity_name: name,
                        import_source: 'bulk_import'
                    }
                });

                // Handle relationships
                fields.forEach(field => {
                    if (field.type === 'relationship' && item[field.key]) {
                        const targetName = item[field.key];
                        const targetTypes = field.targetTypes || [field.targetType];

                        // Find matching entity
                        let targetEntity = null;
                        for (const tt of targetTypes) {
                            targetEntity = entities[tt]?.find(e =>
                                e.name.toLowerCase() === targetName.toLowerCase()
                            );
                            if (targetEntity) break;
                        }

                        if (targetEntity) {
                            // Create relationship
                            const relId = 'rel' + Date.now() + Math.random().toString(36).substr(2, 5);
                            let subjectId, objectId, predicate;

                            if (field.key === 'role' && entityType === 'person') {
                                // Person fills role: Person INS Role
                                subjectId = id;
                                objectId = targetEntity.id;
                                predicate = 'INS';
                            } else {
                                // Hierarchy: Parent DES Child
                                subjectId = targetEntity.id;
                                objectId = id;
                                predicate = 'DES';
                            }

                            relationships.push({
                                id: relId,
                                subject: subjectId,
                                predicate: predicate,
                                object: objectId
                            });

                            // Log relationship
                            logActivityToXano({
                                event_verb: 'Create Connection (Bulk Import)',
                                eo_operator: predicate,
                                object_type: 'relationship',
                                object_id: relId,
                                object_label: `${findEntity(subjectId)?.name} ${predicate} ${findEntity(objectId)?.name}`,
                                data_json: {
                                    subject_id: subjectId,
                                    object_id: objectId,
                                    predicate: predicate,
                                    import_source: 'bulk_import'
                                }
                            });
                        }
                    }
                });

                importedCount++;
            });

            // Save and refresh
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            // Show success
            document.getElementById('bulkImportReviewContent').style.display = 'none';
            document.getElementById('bulkImportSuccessContent').style.display = 'block';
            document.getElementById('bulkImportSuccessMessage').textContent =
                `Successfully imported ${importedCount} ${bulkImportState.entityType}${importedCount !== 1 ? 's' : ''}.`;

            // Update footer
            document.getElementById('bulkImportImportBtn').style.display = 'none';
            document.getElementById('bulkImportBackBtn').style.display = 'none';
            document.getElementById('bulkImportDoneBtn').style.display = 'inline-flex';
            document.getElementById('bulkImportFooterInfo').textContent = 'Import complete!';
        }

        function saveWorkspaceName() {
            // Now handled by workspace modal - this is a no-op for backwards compatibility
            // The workspace name is saved via the renameWorkspace function
        }

        let hasSampleData = false;

        function toggleSampleData() {
            if (hasSampleData) {
                // Clear sample data
                if (!confirm('Remove all sample data? This cannot be undone.')) return;
                
                entities.unit = [];
                entities.team = [];
                entities.role = [];
                entities.person = [];
                entities.object = [];
                relationships = [];
                
                hasSampleData = false;
                document.getElementById('sampleDataText').textContent = 'Load Sample Data';
                document.getElementById('sampleDataBtn').innerHTML = '<i class="ph ph-database"></i> <span id="sampleDataText">Load Sample Data</span>';
            } else {
                // Load sample data
                initSampleData();
                hasSampleData = true;
                document.getElementById('sampleDataText').textContent = 'Clear Sample Data';
                document.getElementById('sampleDataBtn').innerHTML = '<i class="ph ph-database"></i> <span id="sampleDataText">Clear Sample Data</span>';
            }
            
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function clearAllData() {
            if (!confirm('Clear ALL data including your custom entities? This cannot be undone.')) return;
            
            entities.unit = [];
            entities.team = [];
            entities.role = [];
            entities.person = [];
            entities.object = [];
            relationships = [];
            hasSampleData = false;
            
            document.getElementById('sampleDataText').textContent = 'Load Sample Data';
            document.getElementById('sampleDataBtn').innerHTML = '<i class="ph ph-database"></i> <span id="sampleDataText">Load Sample Data</span>';
            
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function saveToLocalStorage() {
            // Delegate to workspace-aware save
            saveWorkspaces();
        }

        function loadFromLocalStorage() {
            // Delegate to workspace-aware load
            const hasWorkspaces = loadWorkspaces();

            if (hasWorkspaces && currentWorkspaceId && workspaces[currentWorkspaceId]) {
                const ws = workspaces[currentWorkspaceId];

                // Load current workspace data
                entities = JSON.parse(JSON.stringify(ws.entities || { unit: [], team: [], role: [], person: [], object: [] }));
                relationships = JSON.parse(JSON.stringify(ws.relationships || []));
                hasSampleData = ws.hasSampleData || false;

                // Update UI
                const nameEl = document.getElementById('workspaceNameText');
                if (nameEl) {
                    nameEl.textContent = ws.name;
                }

                const btnText = document.getElementById('sampleDataText');
                if (btnText) {
                    btnText.textContent = hasSampleData ? 'Clear Sample Data' : 'Load Sample Data';
                }

                console.log(' Loaded workspace:', ws.name);
                return true;
            }

            return false;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (currentView === 'graph') {
                updateGraph();
            }
        });

        // === SIMPLIFIED UX FUNCTIONS ===

        // Collapsible sections
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        // Collapsible sidebar panels
        function togglePanel(side) {
            const container = document.getElementById('mainContainer');
            const panel = document.getElementById(side === 'left' ? 'panelLeft' : 'panelRight');

            if (!container || !panel) return;

            const isCollapsed = panel.classList.toggle('collapsed');

            // Update container grid class
            if (side === 'left') {
                container.classList.toggle('left-collapsed', isCollapsed);
            } else {
                container.classList.toggle('right-collapsed', isCollapsed);
            }

            // Save state to localStorage
            localStorage.setItem(`panel${side.charAt(0).toUpperCase() + side.slice(1)}Collapsed`, isCollapsed);

            // Trigger graph resize if visible
            setTimeout(() => {
                if (currentView === 'graph') {
                    updateGraph();
                } else if (currentView === 'venn') {
                    renderVennView();
                }
            }, 350);
        }

        // Restore panel collapse states on load
        function restorePanelStates() {
            const leftCollapsed = localStorage.getItem('panelLeftCollapsed') === 'true';
            const rightCollapsed = localStorage.getItem('panelRightCollapsed') === 'true';
            const container = document.getElementById('mainContainer');
            const panelLeft = document.getElementById('panelLeft');
            const panelRight = document.getElementById('panelRight');

            if (leftCollapsed && panelLeft && container) {
                panelLeft.classList.add('collapsed');
                container.classList.add('left-collapsed');
            }

            if (rightCollapsed && panelRight && container) {
                panelRight.classList.add('collapsed');
                container.classList.add('right-collapsed');
            }
        }

        // Welcome banner
        function dismissWelcomeBanner() {
            const banner = document.getElementById('welcomeBanner');
            if (banner) {
                banner.style.display = 'none';
                localStorage.setItem('welcomeBannerDismissed', 'true');
            }
        }

        function checkWelcomeBanner() {
            const banner = document.getElementById('welcomeBanner');
            const dismissed = localStorage.getItem('welcomeBannerDismissed');
            if (banner && dismissed === 'true') {
                banner.style.display = 'none';
            }
        }

        // Advanced entity options toggle
        function toggleAdvancedEntityOptions() {
            const options = document.getElementById('advancedEntityOptions');
            const toggleBtn = document.getElementById('advancedEntityToggle');
            if (options && toggleBtn) {
                const isVisible = options.style.display !== 'none';
                options.style.display = isVisible ? 'none' : 'block';
                toggleBtn.classList.toggle('expanded', !isVisible);
                toggleBtn.innerHTML = isVisible
                    ? '<i class="ph ph-plus"></i> Advanced options'
                    : '<i class="ph ph-minus"></i> Hide advanced options';
            }
        }

        // Advanced operators toggle
        function toggleAdvancedOperators() {
            const operators = document.getElementById('advancedOperators');
            const toggleBtn = document.getElementById('moreOperatorsBtn');
            if (operators && toggleBtn) {
                const isVisible = operators.classList.contains('visible');
                operators.classList.toggle('visible', !isVisible);
                toggleBtn.classList.toggle('expanded', !isVisible);
                toggleBtn.innerHTML = isVisible
                    ? '<i class="ph ph-plus"></i> More operators (6)'
                    : '<i class="ph ph-minus"></i> Hide operators';
            }
        }

        // Activity details toggle
        function toggleActivityDetails() {
            const details = document.getElementById('activityDetailsSection');
            const toggleBtn = document.getElementById('activityDetailsToggle');
            if (details && toggleBtn) {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
                toggleBtn.classList.toggle('expanded', !isVisible);
                toggleBtn.innerHTML = isVisible
                    ? '<i class="ph ph-plus"></i> Add notes or details'
                    : '<i class="ph ph-minus"></i> Hide notes';
            }
        }

        // Simplified predicate selection (for 3 main operators)
        function selectSimplifiedPredicate(predicateCode, btn) {
            // Remove active from all quick operator buttons
            document.querySelectorAll('.quick-operator-selector .operator-btn').forEach(b => {
                b.classList.remove('active');
            });
            // Remove active from advanced operators too
            document.querySelectorAll('.advanced-operators .predicate-btn').forEach(b => {
                b.classList.remove('active');
            });
            // Add active to clicked button
            btn.classList.add('active');
            // Set the predicate and update preview (don't call selectPredicate to avoid clearing active state)
            selectedPredicate = predicateCode;
            updateSentencePreview();
        }

        // Simplified filters (dropdown-based)
        function applySimplifiedFilters() {
            const connectionFilter = document.getElementById('connectionFilterDropdown').value;
            const entityFilter = document.getElementById('entityFilterDropdown').value;

            // Map simplified filters to advanced filter checkboxes
            const operatorFilters = {
                'all': ['NUL', 'DES', 'INS', 'SEG', 'CON', 'ALT', 'SYN', 'SUP', 'REC'],
                'nesting': ['DES'],  // DES for nesting/hierarchy
                'activities': ['NUL', 'INS', 'SEG', 'CON', 'ALT', 'SYN', 'SUP', 'REC']  // All non-DES operators for activities
            };

            const entityFilters = {
                'all': ['Unit', 'Team', 'Role', 'Person', 'Object'],
                'structure': ['Unit', 'Team'],
                'roles': ['Role'],
                'people': ['Person']
            };

            // Set operator checkboxes
            const selectedOps = operatorFilters[connectionFilter] || operatorFilters['all'];
            ['NUL', 'DES', 'INS', 'SEG', 'CON', 'ALT', 'SYN', 'SUP', 'REC'].forEach(op => {
                const checkbox = document.getElementById(`filter${op}`);
                if (checkbox) {
                    checkbox.checked = selectedOps.includes(op);
                }
            });

            // Set entity checkboxes
            const selectedEntities = entityFilters[entityFilter] || entityFilters['all'];
            ['Unit', 'Team', 'Role', 'Person', 'Object'].forEach(ent => {
                const checkbox = document.getElementById(`filter${ent}`);
                if (checkbox) {
                    checkbox.checked = selectedEntities.includes(ent);
                }
            });

            // Apply the filters
            applyFilters();
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const loadingStatus = document.getElementById('loadingStatus');
            
            function updateStatus(message, success = true) {
                if (loadingStatus) {
                    loadingStatus.innerHTML = success 
                        ? `<i class="ph ph-check-circle"></i> ${message}`
                        : `<i class="ph ph-warning-circle"></i> ${message}`;
                    loadingStatus.style.background = success ? 'rgba(76, 175, 80, 0.3)' : 'rgba(244, 67, 54, 0.3)';
                }
                console.log(success ? '' : '', message);
            }
            
            console.log(' Initializing Holonic Knowledge Graph...');
            console.log(' Loading from:', window.location.protocol);
            console.log(' D3.js loaded:', typeof d3 !== 'undefined');
            
            // Check if essential libraries loaded
            if (typeof d3 === 'undefined') {
                updateStatus('D3.js failed to load - Internet required', false);
                alert(' D3.js failed to load from CDN. Graph view will not work.\n\nPlease ensure you have an internet connection.');
            } else {
                updateStatus('Libraries loaded');
            }
            
            // Close modal on outside click
            document.getElementById('entityModal').addEventListener('click', (e) => {
                if (e.target.id === 'entityModal') {
                    closeEntityModal();
                }
            });

            // Try to load from localStorage first
            updateStatus('Checking saved data...');
            let hasStoredData = false;
            try {
                hasStoredData = loadFromLocalStorage();
                console.log(' Has stored data:', hasStoredData);
            } catch (e) {
                console.error(' localStorage error:', e);
                if (window.location.protocol === 'file:') {
                    updateStatus('localStorage restricted (file:// URL)', false);
                    console.warn(' Note: Some browsers restrict localStorage for file:// URLs');
                }
            }
            
            // If no stored data, create default workspace and load sample data
            if (!hasStoredData) {
                updateStatus('Loading sample data...');
                console.log(' Creating default workspace with sample data...');
                try {
                    // Create default workspace
                    const wsId = generateWorkspaceId();
                    workspaces[wsId] = {
                        id: wsId,
                        name: 'My Organization',
                        entities: { unit: [], team: [], role: [], person: [], object: [] },
                        relationships: [],
                        hasSampleData: true,
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };
                    currentWorkspaceId = wsId;

                    initSampleData();
                    hasSampleData = true;

                    // Update workspace with loaded sample data
                    workspaces[wsId].entities = JSON.parse(JSON.stringify(entities));
                    workspaces[wsId].relationships = JSON.parse(JSON.stringify(relationships));
                    saveWorkspaces();

                    const btnText = document.getElementById('sampleDataText');
                    if (btnText) {
                        btnText.textContent = 'Clear Sample Data';
                    }
                    console.log(' Sample data loaded. Entities:', {
                        units: entities.unit.length,
                        teams: entities.team.length,
                        roles: entities.role.length,
                        people: entities.person.length,
                        objects: entities.object.length
                    });
                    console.log(' Relationships:', relationships.length);
                    updateStatus('Sample data loaded');
                } catch (e) {
                    console.error(' Error loading sample data:', e);
                    updateStatus('Error loading sample data', false);
                    alert('Error loading sample data. Check console for details.');
                }
            } else {
                updateStatus('Loaded from storage');
                console.log(' Loaded data from localStorage');
            }

            // Load undo history and recycle bin for current workspace
            loadUndoHistory();

            // Render everything
            try {
                updateStatus('Rendering interface...');
                console.log(' Rendering UI...');
                renderEntityList();
                updateSelects();
                updateParentOptions();
                renderActivityList();
                updateFilterStatus();
                console.log(' UI rendered');
                updateStatus('Ready');

                // Initialize simplified UX
                checkWelcomeBanner();
                restorePanelStates();
            } catch (e) {
                console.error(' Error rendering UI:', e);
                updateStatus('Error rendering UI', false);
                alert('Error rendering interface. Check console for details.');
            }
            
            // Character counter for description
            const descriptionField = document.getElementById('activityDescription');
            const charCount = document.getElementById('charCount');
            if (descriptionField && charCount) {
                descriptionField.addEventListener('input', () => {
                    charCount.textContent = descriptionField.value.length;
                });
            }
            
            // Show card view by default
            try {
                switchView('card');
                console.log(' Card view activated');
            } catch (e) {
                console.error(' Error switching to card view:', e);
                updateStatus('Error loading view', false);
            }
            
            console.log(' Initialization complete!');
            console.log(' Current state:', {
                entities: {
                    units: entities.unit.length,
                    teams: entities.team.length,
                    roles: entities.role.length,
                    people: entities.person.length,
                    objects: entities.object.length
                },
                relationships: relationships.length,
                hasSampleData: hasSampleData
            });
            
            // Hide loading status after 3 seconds if successful
            setTimeout(() => {
                if (loadingStatus && loadingStatus.textContent.includes('Ready')) {
                    loadingStatus.style.display = 'none';
                }
            }, 3000);
        });
    </script>
</body>
</html>
