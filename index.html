    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taskflow - Work Shapes Structure</title>
    <script>
        // D3.js loader with fallback CDNs for Softr iframe compatibility
        (function() {
            var d3Sources = [
                'https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js',
                'https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js',
                'https://unpkg.com/d3@7.8.5/dist/d3.min.js'
            ];
            var loaded = false;

            function loadScript(src, callback) {
                var script = document.createElement('script');
                script.src = src;
                script.async = false;
                script.onload = function() {
                    if (typeof d3 !== 'undefined') {
                        loaded = true;
                        console.log('✅ D3.js loaded from:', src);
                        callback(true);
                    } else {
                        callback(false);
                    }
                };
                script.onerror = function() {
                    console.warn('⚠️ Failed to load D3.js from:', src);
                    callback(false);
                };
                document.head.appendChild(script);
            }

            function tryNextSource(index) {
                if (loaded || index >= d3Sources.length) {
                    if (!loaded) {
                        console.error('❌ Failed to load D3.js from all CDN sources');
                    }
                    return;
                }
                loadScript(d3Sources[index], function(success) {
                    if (!success) {
                        tryNextSource(index + 1);
                    }
                });
            }

            // Start loading from first source
            tryNextSource(0);
        })();
    </script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <!-- Flatpickr date picker for better cross-browser support -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <style>
        /* CSS Reset - Softr Embed Compatible */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Iframe isolation - prevent Softr parent styles from affecting us */
        html {
            font-size: 16px;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            line-height: 1.15;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #F5F2ED;
            color: #3D2E1F;
            overflow: hidden;
            min-height: 100vh;
            width: 100%;
            position: relative;
            /* Prevent inherited styles from Softr */
            text-align: left;
            direction: ltr;
            text-transform: none;
            letter-spacing: normal;
            word-spacing: normal;
        }

        .header {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            padding: 0.75rem 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-shrink: 0;
        }

        .header-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        /* Loading Status */
        .header-loading-status {
            display: none;
            align-items: center;
            gap: 0.4rem;
            color: rgba(255,255,255,0.9);
            font-size: 0.75rem;
            padding: 0.35rem 0.6rem;
            background: rgba(0,0,0,0.15);
            border-radius: 6px;
        }

        .header-loading-status[style*="display: block"],
        .header-loading-status[style*="display:block"] {
            display: flex !important;
        }

        .header-loading-status i {
            animation: spin 1s linear infinite;
        }

        /* Workspace Selector Styles */
        .workspace-selector {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .workspace-dropdown-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            padding: 0.4rem 0.75rem;
            color: white;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            max-width: 280px;
        }

        .workspace-dropdown-toggle:hover {
            background: rgba(255,255,255,0.25);
            border-color: rgba(255,255,255,0.5);
        }

        .workspace-dropdown-toggle .workspace-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .workspace-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            min-width: 320px;
            max-width: 400px;
            z-index: 1000;
            display: none;
            overflow: hidden;
        }

        .workspace-dropdown.open {
            display: block;
        }

        .workspace-dropdown-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #E5DDD1;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .workspace-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .workspace-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.15s;
            color: #3D2E1F;
        }

        .workspace-item:hover {
            background: #FAF7F5;
        }

        .workspace-item.active {
            background: #F5EFE6;
        }

        .workspace-item-name {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            overflow: hidden;
        }

        .workspace-item-name span {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .workspace-item-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .workspace-item:hover .workspace-item-actions {
            opacity: 1;
        }

        .workspace-action-btn {
            background: none;
            border: none;
            padding: 0.25rem;
            cursor: pointer;
            color: #8B6F47;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .workspace-action-btn:hover {
            background: rgba(0,0,0,0.05);
            color: #C88F4A;
        }

        .workspace-action-btn.delete:hover {
            color: #d32f2f;
        }

        .workspace-dropdown-footer {
            border-top: 1px solid #E5DDD1;
            padding: 0.5rem;
        }

        .workspace-new-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.75rem 1rem;
            background: none;
            border: none;
            cursor: pointer;
            color: #C88F4A;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .workspace-new-btn:hover {
            background: #FAF7F5;
        }

        /* Workspace Modal Styles */
        .workspace-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .workspace-modal-overlay.open {
            display: flex;
        }

        .workspace-modal {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .workspace-modal h3 {
            margin-bottom: 1rem;
            color: #3D2E1F;
            font-size: 1.125rem;
        }

        .workspace-modal-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            font-size: 1rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s;
        }

        .workspace-modal-input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .workspace-modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .workspace-modal-btn {
            padding: 0.6rem 1.25rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .workspace-modal-btn.cancel {
            background: #f5f5f5;
            border: 1px solid #E5DDD1;
            color: #6B5642;
        }

        .workspace-modal-btn.cancel:hover {
            background: #eee;
        }

        .workspace-modal-btn.primary {
            background: #D4A54A;
            border: none;
            color: white;
        }

        .workspace-modal-btn.primary:hover {
            background: #E5B555;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        /* View Tabs - Clean tab design */
        .view-tabs {
            display: flex;
            background: rgba(0,0,0,0.15);
            border-radius: 8px;
            padding: 4px;
            gap: 2px;
        }

        .view-tab {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            background: transparent;
            color: rgba(255,255,255,0.85);
            border: none;
            padding: 0.5rem 0.875rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8125rem;
            font-weight: 500;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .view-tab i {
            font-size: 1rem;
            opacity: 0.9;
        }

        .view-tab:hover {
            background: rgba(255,255,255,0.15);
            color: white;
        }

        .view-tab.active {
            background: white;
            color: #9A6B3A;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .view-tab.active i {
            opacity: 1;
        }

        /* Header Icon Buttons */
        .header-icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .header-icon-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.25);
        }

        .header-icon-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .header-icon-btn:disabled:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.15);
        }

        .header-icon-btn i {
            font-size: 1.125rem;
        }

        /* Undo Group */
        .header-undo-group {
            display: flex;
            gap: 2px;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            padding: 2px;
        }

        .header-undo-group .header-icon-btn {
            background: transparent;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 6px;
        }

        .header-undo-group .header-icon-btn:hover:not(:disabled) {
            background: rgba(255,255,255,0.15);
        }

        /* Actions Menu */
        .header-actions-menu {
            position: relative;
        }

        /* Legacy view toggle support */
        .view-toggle {
            display: flex;
            gap: 0.5rem;
            background: rgba(255,255,255,0.2);
            padding: 0.25rem;
            border-radius: 6px;
        }

        .view-toggle-btn {
            background: transparent;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: background 0.2s;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .view-toggle-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .view-toggle-btn.active {
            background: white;
            color: #C88F4A;
            text-shadow: none;
        }

        /* View toggle "More" dropdown */
        .view-toggle-more {
            position: relative;
        }

        .view-toggle-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            min-width: 150px;
            z-index: 100;
            display: none;
            overflow: hidden;
        }

        .view-toggle-dropdown.open {
            display: block;
        }

        .view-dropdown-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.75rem 1rem;
            border: none;
            background: none;
            cursor: pointer;
            color: #3D2E1F;
            font-size: 0.875rem;
            transition: background 0.15s;
            text-align: left;
        }

        .view-dropdown-item:hover {
            background: #FAF7F5;
        }

        .view-dropdown-item.active {
            background: #F5EFE6;
            color: #C88F4A;
        }

        /* Header more menu dropdown */
        .header-more-menu {
            position: relative;
        }

        .header-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            min-width: 180px;
            z-index: 100;
            display: none;
            overflow: hidden;
        }

        .header-dropdown.open {
            display: block;
        }

        .header-dropdown-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.75rem 1rem;
            border: none;
            background: none;
            cursor: pointer;
            color: #3D2E1F;
            font-size: 0.875rem;
            transition: background 0.15s;
            text-align: left;
        }

        .header-dropdown-item:hover {
            background: #FAF7F5;
        }

        .header-dropdown-item.danger {
            color: #d32f2f;
        }

        .header-dropdown-item.danger:hover {
            background: #ffebee;
        }

        .header-dropdown-divider {
            height: 1px;
            background: #E5DDD1;
            margin: 0.25rem 0;
        }

        /* Update Interval Submenu */
        .update-settings-group {
            padding: 0.5rem;
            border-bottom: 1px solid #E5DDD1;
        }

        .update-settings-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            font-size: 0.75rem;
            color: #6B5744;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .update-interval-options {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .update-interval-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border: none;
            background: none;
            cursor: pointer;
            color: #3D2E1F;
            font-size: 0.875rem;
            border-radius: 4px;
            transition: background 0.15s;
            text-align: left;
            width: 100%;
        }

        .update-interval-option:hover {
            background: #FAF7F5;
        }

        .update-interval-option.active {
            background: #F5EFE6;
            color: #C88F4A;
        }

        .update-interval-option .check-icon {
            width: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .update-interval-option .check-icon i {
            opacity: 0;
        }

        .update-interval-option.active .check-icon i {
            opacity: 1;
            color: #C88F4A;
        }

        .update-status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            color: #6B5744;
            background: #FAF7F5;
            border-radius: 4px;
            margin-top: 0.5rem;
        }

        .update-status-indicator.active {
            color: #2e7d32;
            background: #e8f5e9;
        }

        .update-status-indicator .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #9e9e9e;
        }

        .update-status-indicator.active .status-dot {
            background: #4caf50;
            animation: pulse-dot 2s ease-in-out infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* View Filter Dropdown */
        .view-filter-dropdown {
            position: relative;
        }

        .view-filter-btn {
            position: relative;
        }

        .filter-active-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 8px;
            height: 8px;
            background: #C88F4A;
            border-radius: 50%;
        }

        .view-filter-menu {
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            min-width: 180px;
            z-index: 100;
            display: none;
            overflow: hidden;
            padding: 0.5rem 0;
        }

        .view-filter-menu.open {
            display: block;
        }

        .view-filter-section {
            padding: 0.5rem 0;
        }

        .view-filter-section-title {
            padding: 0.25rem 1rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .view-filter-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #3D2E1F;
            font-size: 0.875rem;
            transition: background 0.15s;
        }

        .view-filter-item:hover {
            background: #FAF7F5;
        }

        .view-filter-item input[type="checkbox"] {
            accent-color: #C88F4A;
            width: 16px;
            height: 16px;
        }

        .view-filter-item i {
            color: #8B6F47;
            font-size: 1rem;
        }

        .view-filter-actions {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-top: 1px solid #E5DDD1;
            margin-top: 0.25rem;
        }

        /* Advanced Filter Panel Styles */
        .advanced-filter-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 24px rgba(0,0,0,0.15);
            z-index: 1001;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .advanced-filter-panel.open {
            right: 0;
        }

        .filter-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #E5DDD1;
            background: #FAF7F5;
        }

        .filter-panel-title {
            font-size: 1rem;
            font-weight: 600;
            color: #3D2E1F;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-panel-close {
            background: none;
            border: none;
            color: #8B6F47;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: background 0.15s;
        }

        .filter-panel-close:hover {
            background: #E5DDD1;
        }

        .filter-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .filter-group {
            margin-bottom: 1.25rem;
        }

        .filter-group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-group-title i {
            font-size: 0.875rem;
        }

        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .filter-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            border-radius: 20px;
            font-size: 0.8rem;
            color: #6B5642;
            cursor: pointer;
            transition: all 0.15s;
        }

        .filter-chip:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .filter-chip.active {
            background: #C88F4A;
            border-color: #C88F4A;
            color: white;
        }

        .filter-chip i {
            font-size: 0.875rem;
        }

        .filter-chip.status-pending.active { background: #F59E0B; border-color: #F59E0B; }
        .filter-chip.status-in_progress.active { background: #3B82F6; border-color: #3B82F6; }
        .filter-chip.status-completed.active { background: #10B981; border-color: #10B981; }

        .filter-chip.priority-high.active { background: #EF4444; border-color: #EF4444; }
        .filter-chip.priority-medium.active { background: #F59E0B; border-color: #F59E0B; }
        .filter-chip.priority-low.active { background: #6B7280; border-color: #6B7280; }

        .filter-date-inputs {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .filter-date-input {
            flex: 1;
            padding: 0.5rem 0.75rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #3D2E1F;
            background: #FAF7F5;
        }

        .filter-date-input:focus {
            outline: none;
            border-color: #C88F4A;
            background: white;
        }

        .filter-date-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            margin-top: 0.5rem;
        }

        .filter-date-preset {
            padding: 0.25rem 0.625rem;
            background: transparent;
            border: 1px solid #E5DDD1;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #6B5642;
            cursor: pointer;
            transition: all 0.15s;
        }

        .filter-date-preset:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .filter-date-preset.active {
            background: #C88F4A;
            border-color: #C88F4A;
            color: white;
        }

        .filter-assignee-search {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            background: #FAF7F5;
        }

        .filter-assignee-search:focus {
            outline: none;
            border-color: #C88F4A;
            background: white;
        }

        .filter-assignee-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            background: #FAF7F5;
        }

        .filter-assignee-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .filter-assignee-item:hover {
            background: #F5EFE6;
        }

        .filter-assignee-item.selected {
            background: #FFF9F0;
            border-left: 3px solid #C88F4A;
        }

        .filter-assignee-item input[type="checkbox"] {
            accent-color: #C88F4A;
        }

        .filter-panel-footer {
            display: flex;
            gap: 0.5rem;
            padding: 1rem 1.25rem;
            border-top: 1px solid #E5DDD1;
            background: #FAF7F5;
        }

        .filter-panel-footer .btn {
            flex: 1;
        }

        .filter-active-count {
            background: #C88F4A;
            color: white;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        /* Time Travel UI Styles */
        .time-travel-bar {
            display: none;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #1E3A5F 0%, #2D4A6F 100%);
            color: white;
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            z-index: 999;
            box-shadow: 0 2px 12px rgba(0,0,0,0.2);
        }

        .time-travel-bar.active {
            display: flex;
        }

        .time-travel-icon {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #FFD93D;
        }

        .time-travel-icon i {
            font-size: 1.25rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .time-travel-date-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.15);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .time-travel-date-display:hover {
            background: rgba(255,255,255,0.25);
        }

        .time-travel-slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .time-travel-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
        }

        .time-travel-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #FFD93D;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform 0.15s;
        }

        .time-travel-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .time-travel-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #FFD93D;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .time-travel-date-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.7);
            min-width: 80px;
            text-align: center;
        }

        .time-travel-actions {
            display: flex;
            gap: 0.5rem;
        }

        .time-travel-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .time-travel-btn.primary {
            background: #FFD93D;
            color: #1E3A5F;
        }

        .time-travel-btn.primary:hover {
            background: #FFE566;
        }

        .time-travel-btn.secondary {
            background: rgba(255,255,255,0.15);
            color: white;
        }

        .time-travel-btn.secondary:hover {
            background: rgba(255,255,255,0.25);
        }

        /* Time Travel Mode Indicator */
        .time-travel-mode-indicator {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #1E3A5F 0%, #2D4A6F 100%);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 30px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            display: none;
            align-items: center;
            gap: 0.75rem;
            z-index: 1000;
            animation: slideUp 0.3s ease;
        }

        .time-travel-mode-indicator.active {
            display: flex;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .time-travel-mode-text {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .time-travel-mode-date {
            background: #FFD93D;
            color: #1E3A5F;
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        /* Adjust main content when time travel is active */
        .app-container.time-travel-active {
            margin-top: 52px;
        }

        /* Filter Panel Overlay */
        .filter-panel-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }

        .filter-panel-overlay.open {
            display: block;
        }

        /* Command Palette Styles */
        .command-palette-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: flex-start;
            padding-top: 15vh;
            z-index: 1000;
        }

        .command-palette-overlay.open {
            display: flex;
        }

        .command-palette {
            background: white;
            border-radius: 12px;
            width: 100%;
            max-width: 540px;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        .command-palette-input-wrapper {
            display: flex;
            align-items: center;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #E5DDD1;
            gap: 0.75rem;
        }

        .command-palette-input-wrapper i {
            color: #8B6F47;
            font-size: 1.25rem;
        }

        .command-palette-input-wrapper input {
            flex: 1;
            border: none;
            outline: none;
            font-size: 1rem;
            color: #3D2E1F;
        }

        .command-palette-input-wrapper input::placeholder {
            color: #A09080;
        }

        .command-palette-shortcut {
            padding: 0.25rem 0.5rem;
            background: #F5F2ED;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #8B6F47;
            text-transform: uppercase;
        }

        .command-palette-results {
            max-height: 400px;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .command-palette-group {
            margin-bottom: 0.5rem;
        }

        .command-palette-group-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.5rem 0.75rem;
        }

        .command-palette-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
            padding: 0.75rem;
            border: none;
            background: none;
            border-radius: 8px;
            cursor: pointer;
            color: #3D2E1F;
            font-size: 0.9rem;
            text-align: left;
            transition: background 0.1s;
        }

        .command-palette-item:hover,
        .command-palette-item.selected {
            background: #FAF7F5;
        }

        .command-palette-item i {
            font-size: 1.1rem;
            color: #8B6F47;
            width: 24px;
            text-align: center;
        }

        .command-palette-item span:first-of-type {
            flex: 1;
        }

        .command-palette-item-hint {
            padding: 0.15rem 0.4rem;
            background: #F5F2ED;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #8B6F47;
        }

        .command-palette-item.hidden {
            display: none;
        }

        .command-palette-footer {
            display: flex;
            gap: 1.5rem;
            padding: 0.75rem 1.25rem;
            border-top: 1px solid #E5DDD1;
            background: #FAF7F5;
            font-size: 0.75rem;
            color: #8B6F47;
        }

        .command-palette-footer kbd {
            padding: 0.15rem 0.35rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.7rem;
        }

        /* Softr User Identity Indicator */
        .softr-user-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            padding: 0.35rem 0.75rem;
            color: white;
            font-size: 0.8rem;
            margin-right: 0.5rem;
        }

        .softr-user-indicator.no-user {
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.6);
            font-style: italic;
        }

        .softr-user-indicator .user-avatar {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: rgba(255,255,255,0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.7rem;
            text-transform: uppercase;
        }

        .softr-user-indicator.no-user .user-avatar {
            background: rgba(255,255,255,0.1);
        }

        .softr-user-indicator .user-info {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }

        .softr-user-indicator .user-name {
            font-weight: 500;
        }

        .softr-user-indicator .user-email {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        /* Xano Connection Status Indicator - Hidden (shows only on error via JS) */
        .xano-status-indicator {
            display: none !important; /* Hidden by default - implementation detail */
            /* Previously: display: flex; */
            align-items: center;
            gap: 0.4rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 0.35rem 0.6rem;
            color: white;
            font-size: 0.75rem;
            margin-right: 0.5rem;
            transition: all 0.3s ease;
        }

        .xano-status-indicator.connected {
            background: rgba(76, 175, 80, 0.25);
            border-color: rgba(76, 175, 80, 0.5);
        }

        .xano-status-indicator.disconnected {
            background: rgba(244, 67, 54, 0.25);
            border-color: rgba(244, 67, 54, 0.5);
        }

        .xano-status-indicator.checking {
            background: rgba(255, 193, 7, 0.25);
            border-color: rgba(255, 193, 7, 0.5);
        }

        .xano-status-indicator .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.5);
            transition: background 0.3s ease;
        }

        .xano-status-indicator.connected .status-dot {
            background: #4CAF50;
            box-shadow: 0 0 6px rgba(76, 175, 80, 0.6);
        }

        .xano-status-indicator.disconnected .status-dot {
            background: #F44336;
            box-shadow: 0 0 6px rgba(244, 67, 54, 0.6);
        }

        .xano-status-indicator.checking .status-dot {
            background: #FFC107;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .xano-status-indicator .status-text {
            white-space: nowrap;
        }

        .xano-status-indicator .activity-count {
            background: rgba(255,255,255,0.2);
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
        }

        .xano-status-indicator.connected .activity-count {
            background: rgba(76, 175, 80, 0.3);
        }

        /* Auto-Refresh Toggle */
        .auto-refresh-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 0.35rem 0.6rem;
            color: white;
            font-size: 0.75rem;
            margin-right: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .auto-refresh-toggle:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .auto-refresh-toggle.active {
            background: rgba(76, 175, 80, 0.25);
            border-color: rgba(76, 175, 80, 0.5);
        }

        .auto-refresh-toggle .refresh-icon {
            width: 14px;
            height: 14px;
            transition: transform 0.3s ease;
        }

        .auto-refresh-toggle.active .refresh-icon {
            animation: spin-slow 2s linear infinite;
        }

        .auto-refresh-toggle.refreshing .refresh-icon {
            animation: spin 0.5s linear infinite;
        }

        @keyframes spin-slow {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .auto-refresh-toggle .refresh-status {
            font-size: 0.65rem;
            opacity: 0.8;
        }

        .auto-refresh-toggle.active .refresh-status {
            color: #81C784;
        }

        /* Activity Upload Toast */
        .activity-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #3D2E1F;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            z-index: 9999;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .activity-toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .activity-toast.success {
            background: #2E7D32;
        }

        .activity-toast.error {
            background: #C62828;
        }

        .activity-toast.syncing {
            background: #F57C00;
        }

        .activity-toast i {
            font-size: 1.1rem;
        }

        .activity-toast .toast-content {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .activity-toast .toast-title {
            font-weight: 600;
        }

        .activity-toast .toast-detail {
            font-size: 0.75rem;
            opacity: 0.85;
        }

        /* How It Works Modal */
        .how-it-works-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .how-it-works-overlay.active {
            display: flex;
        }

        .how-it-works-modal {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 520px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: slideUp 0.3s ease-out;
        }

        .how-it-works-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #8B6F47;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
        }

        .how-it-works-close:hover {
            background: #F5EFE6;
            color: #C88F4A;
        }

        .how-it-works-modal h2 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #3D2E1F;
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .how-it-works-modal h2 i {
            color: #C88F4A;
        }

        .how-it-works-tagline {
            color: #8B6F47;
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            font-style: italic;
        }

        .how-it-works-steps {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .how-it-works-step {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }

        .how-it-works-step .step-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #FFF9F0 0%, #FAF7F5 100%);
            border: 2px solid #E5DDD1;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .how-it-works-step .step-icon i {
            font-size: 1.25rem;
            color: #C88F4A;
        }

        .how-it-works-step .step-content h3 {
            font-size: 0.95rem;
            color: #3D2E1F;
            margin-bottom: 0.25rem;
        }

        .how-it-works-step .step-content p {
            font-size: 0.85rem;
            color: #6B5642;
            line-height: 1.4;
        }

        .how-it-works-insight {
            background: linear-gradient(135deg, #FFF9F0 0%, #FAF7F5 100%);
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            color: #6B5642;
            line-height: 1.5;
        }

        .how-it-works-insight strong {
            color: #C88F4A;
        }

        .how-it-works-modal .btn {
            width: 100%;
            padding: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .container {
            display: grid;
            grid-template-columns: 320px 1fr;
            height: calc(100vh - 65px);
        }

        .panel {
            background: white;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .panel-left {
            border-right: 1px solid #E5DDD1;
        }

        .panel-right {
            border-left: 1px solid #E5DDD1;
            display: none; /* Hidden - functionality moved to command palette */
        }

        /* Collapsible Sidebar Styles */
        .panel-left,
        .panel-right {
            position: relative;
            transition: width 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
        }

        .panel-collapse-btn {
            position: absolute;
            top: 12px;
            width: 28px;
            height: 28px;
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8B6F47;
            transition: all 0.2s;
            z-index: 10;
        }

        .panel-collapse-btn:hover {
            background: #F5EFE6;
            color: #C88F4A;
            border-color: #C88F4A;
        }

        .panel-left .panel-collapse-btn {
            right: 12px;
        }

        .panel-right .panel-collapse-btn {
            left: 12px;
        }

        .panel-collapse-btn i {
            font-size: 1rem;
            transition: transform 0.3s ease;
        }

        /* Collapsed state for panels */
        .panel-left.collapsed,
        .panel-right.collapsed {
            width: 48px !important;
            min-width: 48px;
            padding: 1rem 0.5rem;
            overflow: hidden;
        }

        .panel-left.collapsed .panel-collapse-btn,
        .panel-right.collapsed .panel-collapse-btn {
            right: 50%;
            left: 50%;
            transform: translateX(-50%);
        }

        .panel-left.collapsed .panel-collapse-btn i {
            transform: rotate(180deg);
        }

        .panel-right.collapsed .panel-collapse-btn i {
            transform: rotate(180deg);
        }

        .panel-left.collapsed > *:not(.panel-collapse-btn),
        .panel-right.collapsed > *:not(.panel-collapse-btn) {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* Container grid adjustments for collapsed panels */
        .container {
            transition: grid-template-columns 0.3s ease;
        }

        .container.left-collapsed {
            grid-template-columns: 48px 1fr;
        }

        /* Right panel removed - no longer needed */
        .container.right-collapsed {
            grid-template-columns: 320px 1fr;
        }

        .container.left-collapsed.right-collapsed {
            grid-template-columns: 48px 1fr;
        }

        .panel-title {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-bottom: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.7;
        }

        .btn {
            background: #D4A54A;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            transition: background 0.2s;
            display: inline-block;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .btn:hover {
            background: #E5B555;
        }

        .btn-small {
            padding: 0.35rem 0.75rem;
            font-size: 0.75rem;
        }

        .btn-secondary {
            background: #8B6F47;
        }

        .btn-secondary:hover {
            background: #6B5642;
        }

        .work-primary-btn {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            font-weight: 600;
            font-size: 1rem;
            padding: 0.875rem 1rem;
        }

        .work-primary-btn:hover {
            background: linear-gradient(135deg, #D4A054 0%, #C88F6B 100%);
        }

        .work-first-section {
            margin-bottom: 0.5rem;
        }

        .btn-outline {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.9);
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn-outline:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
            color: white;
        }

        .entity-type-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .entity-type-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #E5DDD1;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .entity-type-btn:hover {
            border-color: #C88F4A;
        }

        .filter-pill {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 0.75rem;
            border: 2px solid #E5DDD1;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            color: #8B6F47;
            transition: all 0.2s;
            position: relative;
        }

        .filter-pill input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
        }

        .filter-pill:hover {
            border-color: #C88F4A;
            background: #FAF7F5;
        }

        .filter-pill:has(input:checked) {
            border-color: #C88F4A;
            background: #C88F4A;
            color: white;
        }

        .filter-pill span {
            pointer-events: none;
        }

        .entity-type-btn.active {
            background: #C88F4A;
            color: white;
            border-color: #C88F4A;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #6B5642;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 0.625rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .entity-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .entity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.625rem;
            background: transparent;
            border-radius: 8px;
            border: none;
            transition: all 0.15s ease;
        }

        .entity-item:hover {
            background: rgba(139, 111, 71, 0.06);
        }

        .entity-item .btn-icon {
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .entity-item:hover .btn-icon {
            opacity: 0.6;
        }

        .entity-item:hover .btn-icon:hover {
            opacity: 1;
        }

        .entity-item.team {
            color: #5A4736;
        }

        .entity-item.role {
            color: #6B5642;
        }

        .entity-item.person {
            color: #5A4736;
        }

        .entity-item.object {
            color: #8B6F47;
        }

        .entity-name {
            font-size: 0.875rem;
            color: inherit;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .entity-type {
            font-size: 0.7rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
        }

        .entity-section-header {
            font-size: 0.7rem;
            color: #8B6F47;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.375rem;
            padding: 0.25rem 0.625rem;
            opacity: 0.7;
        }

        .entity-section {
            margin-top: 1.25rem;
        }

        .btn-icon {
            background: none;
            border: none;
            color: #8B6F47;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 6px;
            transition: all 0.15s ease;
            font-size: 0.875rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            opacity: 0.6;
        }

        .btn-icon:hover {
            background: rgba(139, 111, 71, 0.12);
            color: #5A4736;
            opacity: 1;
        }

        .btn-icon.add {
            background: rgba(200, 143, 74, 0.15);
            color: #C88F4A;
            opacity: 0.8;
        }

        .btn-icon.add:hover {
            background: #C88F4A;
            color: white;
            opacity: 1;
        }

        .tree-node-item.unit .btn-icon {
            color: rgba(255, 255, 255, 0.8);
            opacity: 0.7;
        }

        .tree-node-item.unit .btn-icon:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            opacity: 1;
        }

        .tree-node-item.unit .btn-icon.add {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .tree-node-item.unit .btn-icon.add:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #graph {
            width: 100%;
            height: calc(100% - 48px);
            background: #FAFAF8;
            background-image:
                radial-gradient(circle, #E5DDD1 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .graph-toolbar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: white;
            border-bottom: 1px solid #E5DDD1;
            height: 48px;
            box-sizing: border-box;
        }

        .graph-tool-btn {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.5rem 0.75rem;
            border: 1px solid #E5DDD1;
            background: white;
            color: #6B5642;
            font-size: 0.8rem;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .graph-tool-btn:hover {
            background: #FAF7F5;
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .graph-tool-btn.small {
            padding: 0.375rem 0.5rem;
        }

        .graph-zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            padding-left: 1rem;
            border-left: 1px solid #E5DDD1;
        }

        .graph-zoom-controls span {
            font-size: 0.8rem;
            color: #8B6F47;
            min-width: 40px;
            text-align: center;
        }

        /* n8n-style node styling */
        .graph-node {
            cursor: grab;
        }

        .graph-node:active {
            cursor: grabbing;
        }

        .graph-node-body {
            fill: white;
            stroke: #E5DDD1;
            stroke-width: 2;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.08));
            transition: stroke 0.2s, filter 0.2s;
        }

        .graph-node:hover .graph-node-body {
            stroke: #C88F4A;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.12));
        }

        .graph-node.selected .graph-node-body {
            stroke: #C88F4A;
            stroke-width: 3;
        }

        .graph-node-accent {
            pointer-events: none;
        }

        .graph-node-icon {
            pointer-events: none;
        }

        .graph-node-label {
            font-size: 12px;
            font-weight: 500;
            fill: #3D2E1F;
            pointer-events: none;
        }

        .graph-node-type {
            font-size: 10px;
            fill: #8B6F47;
            text-transform: uppercase;
            pointer-events: none;
        }

        .graph-port {
            fill: white;
            stroke: #C88F4A;
            stroke-width: 2;
            cursor: crosshair;
            transition: fill 0.2s, r 0.2s;
        }

        .graph-port:hover {
            fill: #C88F4A;
            r: 7;
        }

        .graph-port.active {
            fill: #C88F4A;
        }

        /* Edge styling */
        .graph-edge {
            fill: none;
            stroke-width: 2;
            cursor: pointer;
            transition: stroke-width 0.2s;
        }

        .graph-edge:hover {
            stroke-width: 4;
        }

        .graph-edge-hitbox {
            fill: none;
            stroke: transparent;
            stroke-width: 20;
            cursor: pointer;
        }

        .graph-edge-label {
            font-size: 10px;
            fill: #6B5642;
            pointer-events: none;
        }

        .graph-edge-label-bg {
            fill: white;
            opacity: 0.9;
        }

        /* Drag preview line */
        .graph-drag-line {
            fill: none;
            stroke: #C88F4A;
            stroke-width: 2;
            stroke-dasharray: 8, 4;
            pointer-events: none;
        }

        .layer-bg {
            pointer-events: none;
        }

        .layer-label {
            pointer-events: none;
            user-select: none;
        }

        .graph-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 0.75rem;
            max-width: 200px;
        }

        .legend-title {
            font-weight: 600;
            color: #6B5642;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.25rem 0;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            background: #8B6F47;
        }

        .legend-line.bold {
            height: 3px;
        }

        .legend-line.dashed {
            background: repeating-linear-gradient(
                to right,
                #8B6F47 0,
                #8B6F47 4px,
                transparent 4px,
                transparent 8px
            );
        }

        .legend-line.dotted {
            background: repeating-linear-gradient(
                to right,
                #8B6F47 0,
                #8B6F47 2px,
                transparent 2px,
                transparent 6px
            );
        }

        .triple-form {
            background: #FAF7F5;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .triple-preview {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
            background: white;
            border-radius: 6px;
            margin-top: 1rem;
            border-left: 3px solid #C88F4A;
        }

        .triple-part {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .triple-label {
            font-weight: 600;
            color: #8B6F47;
            min-width: 80px;
        }

        .triple-value {
            color: #3D2E1F;
        }

        .predicate-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .predicate-btn {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid #E5DDD1;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.2s;
            text-align: center;
        }

        .predicate-btn:hover {
            border-color: #C88F4A;
        }

        .predicate-btn.active {
            border-color: #C88F4A;
            background: #FFF9F0;
            color: #C88F4A;
        }

        /* EO Operator specific colors */
        .predicate-btn.NUL.active { border-color: #6B5642; background: #F5F2ED; color: #6B5642; }
        .predicate-btn.DES.active { border-color: #C88F4A; background: #FFF9F0; color: #C88F4A; }
        .predicate-btn.INS.active { border-color: #8B6F47; background: #F5F0E8; color: #8B6F47; }
        .predicate-btn.SEG.active { border-color: #A89984; background: #FAFAF8; color: #A89984; }
        .predicate-btn.CON.active { border-color: #7B95A3; background: #F0F4F7; color: #7B95A3; }
        .predicate-btn.ALT.active { border-color: #B87B5B; background: #FFF5EB; color: #B87B5B; }
        .predicate-btn.SYN.active { border-color: #D4A574; background: #FFFAF3; color: #D4A574; }
        .predicate-btn.SUP.active { border-color: #9B6F47; background: #F7F3EF; color: #9B6F47; }
        .predicate-btn.REC.active { border-color: #C8997F; background: #FFF8F4; color: #C8997F; }

        .relationship-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .relationship-item {
            padding: 0.75rem;
            background: #FAF7F5;
            border-radius: 6px;
            border-left: 3px solid;
            font-size: 0.85rem;
        }

        .relationship-item.NUL { border-left-color: #6B5642; }
        .relationship-item.DES { border-left-color: #C88F4A; }
        .relationship-item.INS { border-left-color: #8B6F47; }
        .relationship-item.SEG { border-left-color: #A89984; }
        .relationship-item.CON { border-left-color: #7B95A3; }
        .relationship-item.ALT { border-left-color: #B87B5B; }
        .relationship-item.SYN { border-left-color: #D4A574; }
        .relationship-item.SUP { border-left-color: #9B6F47; }
        .relationship-item.REC { border-left-color: #C8997F; }

        .relationship-text {
            color: #3D2E1F;
            margin-bottom: 0.25rem;
        }

        .relationship-meta {
            font-size: 0.75rem;
            color: #8B6F47;
        }

        .graph-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            background: white;
            padding: 0.5rem;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .tooltip {
            position: absolute;
            background: rgba(61, 46, 31, 0.95);
            color: white;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.875rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
            z-index: 1000;
        }

        .section {
            margin-bottom: 2rem;
        }

        .divider {
            height: 1px;
            background: #E5DDD1;
            margin: 1.5rem 0;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-dialog {
            background: white;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .modal-header-section {
            padding: 2rem;
            border-bottom: 2px solid #F5E6D3;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
        }

        .modal-title-text {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-section {
            margin-bottom: 2rem;
        }

        .modal-section-title {
            font-size: 1rem;
            color: #8B6F47;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .related-entity {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: #FAF7F5;
            border-radius: 6px;
            margin: 0.25rem;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid #C88F4A;
        }

        .related-entity:hover {
            background: #F5E6D3;
        }

        .card-view {
            display: none;
            padding: 2rem;
            padding-bottom: 4rem;
            overflow-y: auto;
            height: 100%;
            background: white;
            box-sizing: border-box;
        }

        .card-view.active {
            display: block;
        }

        .card-row {
            margin-bottom: 2.5rem;
        }

        .card-row-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #E5DDD1;
        }

        .card-row-title {
            font-size: 1.25rem;
            color: #3D2E1F;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-row-count {
            font-size: 0.85rem;
            color: #6B5642;
            font-weight: 500;
            background: #F5F0E8;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
        }

        .grouped-by-label {
            font-size: 0.85rem;
            color: #8B7355;
            font-weight: 400;
            font-style: italic;
        }

        /* Entity Group Styles (for grouped view) */
        .entity-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #FDFCFA;
            border-radius: 12px;
            border: 1px solid #E5DDD1;
        }

        .entity-group.ungrouped {
            background: #F8F5F0;
            border-style: dashed;
        }

        .entity-group-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #E5DDD1;
        }

        .entity-group-icon {
            font-size: 1.1rem;
        }

        .entity-group-name {
            font-size: 1rem;
            font-weight: 600;
            color: #3D2E1F;
        }

        .entity-group-count {
            font-size: 0.8rem;
            color: #6B5642;
            background: #EAE4DA;
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            margin-left: auto;
        }

        .grouped-section {
            margin-bottom: 2.5rem;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.25rem;
        }

        .entity-card {
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 12px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 140px;
        }

        .entity-card:hover {
            border-color: #C88F4A;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.2);
        }

        .entity-card.unit { background: linear-gradient(135deg, #FFF9F0 0%, white 100%); }
        .entity-card.team { background: linear-gradient(135deg, #FAF7F5 0%, white 100%); }
        .entity-card.role { background: linear-gradient(135deg, #F5F3F0 0%, white 100%); }
        .entity-card.person { background: linear-gradient(135deg, #F0EDE8 0%, white 100%); }
        .entity-card.object { background: linear-gradient(135deg, #FFFBF5 0%, white 100%); }
        .entity-card.activity { background: linear-gradient(135deg, #F5F8FA 0%, white 100%); }

        /* Nested/Hierarchical Cards Styles */
        .hierarchy-card-container {
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 16px;
            padding: 1.25rem;
            margin-bottom: 1.25rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .hierarchy-card-container:hover {
            border-color: #C88F4A;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.15);
        }

        .hierarchy-card-container.unit {
            background: linear-gradient(135deg, #FFF9F0 0%, #FFFBF7 100%);
            border-color: #D4A574;
        }

        .hierarchy-card-container.team {
            background: linear-gradient(135deg, #FAF7F5 0%, #FEFCFA 100%);
            border-color: #E5DDD1;
        }

        /* Nested unit cards within parent units */
        .hierarchy-card-container.nested-unit-card {
            background: linear-gradient(135deg, #FDF8F2 0%, #FFFBF7 100%);
            border-color: #C9A77A;
            margin-bottom: 0;
            padding: 1rem;
        }

        .hierarchy-card-container.nested-unit-card .hierarchy-card-header {
            margin-bottom: 0.5rem;
        }

        .hierarchy-card-container.nested-unit-card .hierarchy-card-title {
            font-size: 1rem;
        }

        .hierarchy-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
        }

        .hierarchy-card-header:hover .hierarchy-card-title {
            color: #C88F4A;
        }

        .hierarchy-card-icon {
            font-size: 2rem;
            line-height: 1;
        }

        .hierarchy-card-title {
            font-size: 1.15rem;
            font-weight: 600;
            color: #3D2E1F;
            transition: color 0.2s;
        }

        .hierarchy-card-description {
            font-size: 0.85rem;
            color: #8B6F47;
            line-height: 1.5;
            font-style: italic;
            margin-bottom: 0.75rem;
            padding-left: 2.75rem;
        }

        .hierarchy-card-activities {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            padding-left: 2.75rem;
            margin-bottom: 1rem;
        }

        .nested-cards-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px dashed #E5DDD1;
        }

        .nested-cards-label {
            font-size: 0.75rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nested-cards-label::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #E5DDD1;
        }

        .nested-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 1rem;
        }

        .nested-entity-card {
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 10px;
            padding: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .nested-entity-card:hover {
            border-color: #C88F4A;
            box-shadow: 0 2px 6px rgba(200, 143, 74, 0.2);
        }

        .nested-entity-card.team { background: linear-gradient(135deg, #FAF7F5 0%, white 100%); }
        .nested-entity-card.role { background: linear-gradient(135deg, #F5F3F0 0%, white 100%); }
        .nested-entity-card.person { background: linear-gradient(135deg, #F0EDE8 0%, white 100%); }

        .nested-card-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nested-card-icon {
            font-size: 1.25rem;
            line-height: 1;
        }

        .nested-card-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: #3D2E1F;
        }

        .nested-card-description {
            font-size: 0.8rem;
            color: #8B6F47;
            line-height: 1.4;
            font-style: italic;
        }

        .nested-card-connections {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: auto;
        }

        .nested-card-connections .connection-badge {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
        }

        /* Deep nesting - roles/people inside teams */
        .deep-nested-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px dotted #E5DDD1;
        }

        .deep-nested-label {
            font-size: 0.7rem;
            color: #A89B8C;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .deep-nested-items {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .deep-nested-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.625rem;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #3D2E1F;
            cursor: pointer;
            transition: all 0.2s;
        }

        .deep-nested-item:hover {
            background: white;
            border-color: #C88F4A;
        }

        .deep-nested-item .item-icon {
            font-size: 1rem;
        }

        .deep-nested-item .item-name {
            font-weight: 500;
        }

        /* View mode toggle button */
        .view-mode-toggle {
            display: flex;
            background: #E5DDD1;
            border-radius: 8px;
            padding: 3px;
            gap: 2px;
        }

        .view-mode-btn {
            padding: 0.5rem 0.875rem;
            border: none;
            background: transparent;
            color: #6B5642;
            font-size: 0.85rem;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .view-mode-btn:hover {
            color: #3D2E1F;
        }

        .view-mode-btn.active {
            background: white;
            color: #3D2E1F;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Hierarchy row styling */
        .hierarchy-grid {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        /* Orphan entities section */
        .orphan-entities-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 2px solid #E5DDD1;
        }

        .orphan-section-title {
            font-size: 1rem;
            color: #6B5642;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-icon {
            font-size: 2rem;
            line-height: 1;
        }

        .card-title {
            font-size: 1.05rem;
            font-weight: 600;
            color: #3D2E1F;
            line-height: 1.3;
        }

        .card-meta {
            font-size: 0.875rem;
            color: #6B5642;
            line-height: 1.5;
        }

        .card-description {
            font-size: 0.85rem;
            color: #8B6F47;
            line-height: 1.5;
            font-style: italic;
        }

        .card-connections {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            margin-top: auto;
        }

        .connection-badge {
            font-size: 0.75rem;
            padding: 0.375rem 0.625rem;
            background: #F5E6D3;
            color: #6B5642;
            border-radius: 16px;
            font-weight: 500;
            border: 1px solid #E5DDD1;
        }

        .card-nested-under {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            align-items: center;
        }

        .card-nested-under .nested-label {
            font-size: 0.7rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 0.25rem;
        }

        .nested-parent-badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            background: linear-gradient(135deg, #C88F4A 0%, #D4A574 100%);
            color: white;
            border-radius: 12px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }

        .nested-parent-badge .parent-icon {
            font-size: 0.85rem;
        }

        /* Nested chips container for parent display in modal */
        .nested-chips-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .nested-chips-container .entity-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.6rem;
            border-radius: 16px;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .nested-chips-container .entity-chip.unit {
            background: linear-gradient(135deg, #C88F4A 0%, #D4A574 100%);
            color: white;
        }

        .nested-chips-container .entity-chip.team {
            background: linear-gradient(135deg, #5B8C5A 0%, #7CB37B 100%);
            color: white;
        }

        .nested-chips-container .entity-chip:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .chip-remove-btn {
            background: rgba(255,255,255,0.3);
            border: none;
            color: inherit;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            margin-left: 0.15rem;
            transition: all 0.2s;
            padding: 0;
        }

        .chip-remove-btn:hover {
            background: rgba(255,255,255,0.5);
        }

        /* Card View Filter/Sort Controls */
        .card-view-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1rem 1.5rem;
            background: #FAF7F5;
            border-bottom: 2px solid #E5DDD1;
            position: sticky;
            top: 0;
            z-index: 10;
            align-items: center;
        }

        .card-search-container {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
            position: relative;
        }

        .card-search-input {
            width: 100%;
            padding: 0.625rem 1rem 0.625rem 2.5rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #3D2E1F;
            background: white;
            transition: all 0.2s;
        }

        .card-search-input:focus {
            outline: none;
            border-color: #C88F4A;
            box-shadow: 0 0 0 3px rgba(200, 143, 74, 0.15);
        }

        .card-search-input::placeholder {
            color: #A89B8C;
        }

        .card-search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: #8B6F47;
            font-size: 1rem;
            pointer-events: none;
        }

        .card-sort-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-sort-label {
            font-size: 0.85rem;
            color: #6B5642;
            font-weight: 500;
        }

        .card-sort-select {
            padding: 0.5rem 2rem 0.5rem 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #3D2E1F;
            background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236B5642' d='M6 8L2 4h8z'/%3E%3C/svg%3E") no-repeat right 0.75rem center;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            transition: all 0.2s;
        }

        .card-sort-select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .card-sort-select:hover {
            border-color: #C88F4A;
        }

        .card-filter-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .card-filter-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.5rem 0.875rem;
            border: 2px solid #E5DDD1;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            color: #6B5642;
        }

        .card-filter-btn:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .card-filter-btn.active {
            background: linear-gradient(135deg, #C88F4A 0%, #D4A574 100%);
            color: white;
            border-color: #C88F4A;
        }

        .card-filter-btn .filter-icon {
            font-size: 1rem;
        }

        .card-filter-btn .filter-count {
            background: rgba(0, 0, 0, 0.1);
            padding: 0.125rem 0.375rem;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .card-filter-btn.active .filter-count {
            background: rgba(255, 255, 255, 0.25);
        }

        .card-view-content {
            padding: 2rem;
        }

        .card-no-results {
            text-align: center;
            padding: 3rem;
            color: #8B6F47;
        }

        .card-no-results i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .card-no-results p {
            font-size: 1rem;
            margin: 0;
        }

        .sentence-preview {
            padding: 1rem;
            background: #FAF7F5;
            border-radius: 6px;
            border-left: 3px solid #C88F4A;
            margin-top: 1rem;
            font-size: 0.95rem;
            color: #3D2E1F;
            line-height: 1.5;
        }

        .sentence-preview strong {
            color: #C88F4A;
        }

        .inline-add-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.35rem 0.75rem;
            background: transparent;
            border: 1px dashed #C88F4A;
            color: #C88F4A;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin: 0.5rem 0;
            transition: all 0.2s;
        }

        .inline-add-btn:hover {
            background: #FFF9F0;
            border-style: solid;
        }

        .panel-center {
            position: relative;
            overflow: hidden;
            height: 100%;
        }

        .tree-view {
            display: none;
            padding: 2rem;
            padding-bottom: 4rem;
            overflow-y: auto;
            height: 100%;
            background: white;
            box-sizing: border-box;
        }

        .tree-view.active {
            display: block;
        }

        .graph-view {
            display: none;
            position: relative;
            height: 100%;
        }

        .graph-view.active {
            display: block;
        }

        /* Venn View Styles */
        .venn-view {
            display: none;
            position: relative;
            height: 100%;
            background: white;
            overflow: hidden;
        }

        .venn-view.active {
            display: block;
        }

        .venn-controls {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .venn-level-nav {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #E5DDD1;
        }

        .venn-level-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid #E5DDD1;
            background: white;
            color: #6B5642;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .venn-level-btn:hover:not(:disabled) {
            background: #C88F4A;
            color: white;
            border-color: #C88F4A;
        }

        .venn-level-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .venn-level-label {
            font-weight: 600;
            color: #3D2E1F;
            min-width: 80px;
            text-align: center;
            font-size: 0.95rem;
        }

        .venn-breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: #8B6F47;
        }

        .venn-breadcrumb-item {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.15s;
        }

        .venn-breadcrumb-item:hover {
            background: rgba(200, 143, 74, 0.15);
            color: #C88F4A;
        }

        .venn-breadcrumb-separator {
            color: #C8B9A0;
        }

        #vennDiagram {
            width: 100%;
            height: 100%;
        }

        .venn-circle {
            cursor: pointer;
            transition: all 0.2s;
        }

        .venn-circle:hover {
            filter: brightness(1.05);
        }

        .venn-circle-label {
            pointer-events: none;
            font-weight: 600;
            font-size: 14px;
            fill: #3D2E1F;
        }

        .venn-circle-count {
            pointer-events: none;
            font-size: 11px;
            fill: #6B5642;
        }

        .venn-overlap {
            cursor: pointer;
            transition: all 0.2s;
        }

        .venn-overlap:hover {
            filter: brightness(0.95);
        }

        .venn-overlap-indicator {
            pointer-events: none;
        }

        .venn-tooltip {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 0.75rem 1rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 100;
            max-width: 250px;
            border: 1px solid #E5DDD1;
        }

        .venn-tooltip.visible {
            opacity: 1;
        }

        .venn-tooltip-title {
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.25rem;
        }

        .venn-tooltip-desc {
            font-size: 0.85rem;
            color: #6B5642;
        }

        .venn-overlap-panel {
            position: absolute;
            right: 1rem;
            top: 1rem;
            width: 300px;
            max-height: calc(100% - 2rem);
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid #E5DDD1;
            z-index: 50;
            display: none;
            overflow: hidden;
        }

        .venn-overlap-panel.visible {
            display: block;
        }

        .venn-overlap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.875rem 1rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            font-weight: 600;
        }

        .venn-close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .venn-close-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .venn-overlap-content {
            padding: 1rem;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }

        .venn-connection-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.625rem 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            cursor: pointer;
            transition: all 0.15s;
        }

        .venn-connection-item:hover {
            border-color: #C88F4A;
            background: white;
        }

        .venn-connection-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .venn-connection-info {
            flex: 1;
            min-width: 0;
        }

        .venn-connection-name {
            font-weight: 500;
            color: #3D2E1F;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .venn-connection-type {
            font-size: 0.75rem;
            color: #8B6F47;
            text-transform: uppercase;
        }

        .venn-shared-label {
            font-size: 0.85rem;
            color: #6B5642;
            font-weight: 600;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .venn-shared-count {
            background: #C88F4A;
            color: white;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
        }

        .venn-entity-section {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #E5DDD1;
        }

        .venn-entity-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .venn-entity-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.5rem;
        }

        .venn-zoom-hint {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(59, 46, 31, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .venn-zoom-hint.visible {
            opacity: 1;
        }

        /* Org Chart View Styles */
        .orgchart-view {
            display: none;
            position: relative;
            height: 100%;
            background: white;
            overflow: auto;
        }

        .orgchart-view.active {
            display: block;
        }

        .orgchart-container {
            padding: 2rem;
            min-width: max-content;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .orgchart-level {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 0;
            position: relative;
        }

        .orgchart-node-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .orgchart-node {
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 12px;
            padding: 1rem;
            min-width: 180px;
            max-width: 220px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            position: relative;
        }

        .orgchart-node:hover {
            border-color: #C88F4A;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.2);
            transform: translateY(-2px);
        }

        .orgchart-node.type-unit {
            border-left: 4px solid #C88F4A;
        }

        .orgchart-node.type-team {
            border-left: 4px solid #7B9E6B;
        }

        .orgchart-node.type-role {
            border-left: 4px solid #8B6F47;
        }

        .orgchart-node.type-person {
            border-left: 4px solid #6B8B9E;
        }

        .orgchart-node.type-object {
            border-left: 4px solid #9E6B8B;
        }

        .orgchart-node-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 0.75rem;
            font-size: 1.25rem;
            color: white;
        }

        .orgchart-node.type-unit .orgchart-node-icon {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
        }

        .orgchart-node.type-team .orgchart-node-icon {
            background: linear-gradient(135deg, #7B9E6B 0%, #5E8B5B 100%);
        }

        .orgchart-node.type-role .orgchart-node-icon {
            background: linear-gradient(135deg, #8B6F47 0%, #6B5030 100%);
        }

        .orgchart-node.type-person .orgchart-node-icon {
            background: linear-gradient(135deg, #6B8B9E 0%, #4B6B8E 100%);
        }

        .orgchart-node.type-object .orgchart-node-icon {
            background: linear-gradient(135deg, #9E6B8B 0%, #8E4B6B 100%);
        }

        .orgchart-node-name {
            font-weight: 600;
            color: #3D2E1F;
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
            word-wrap: break-word;
        }

        .orgchart-node-type {
            font-size: 0.7rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .orgchart-node-description {
            font-size: 0.8rem;
            color: #6B5642;
            margin-top: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .orgchart-connector-vertical {
            width: 2px;
            height: 30px;
            background: #D5C4B0;
            margin: 0 auto;
        }

        .orgchart-connector-horizontal-container {
            position: relative;
            width: 100%;
            height: 30px;
            display: flex;
            justify-content: center;
        }

        .orgchart-connector-horizontal {
            position: absolute;
            height: 2px;
            background: #D5C4B0;
            top: 0;
        }

        .orgchart-connector-branch {
            width: 2px;
            height: 30px;
            background: #D5C4B0;
            margin: 0 auto;
        }

        .orgchart-children {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            position: relative;
            padding-top: 0;
        }

        .orgchart-child-branch {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .orgchart-child-branch::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 15px;
            background: #D5C4B0;
            transform: translateX(-50%);
        }

        /* Horizontal connector line - spans from first to last child */
        .orgchart-child-branch::after {
            content: '';
            position: absolute;
            top: 0;
            height: 2px;
            background: #D5C4B0;
            right: 50%;
            width: calc(100% + 1.5rem);
        }

        .orgchart-child-branch:first-child::after {
            display: none;
        }

        /* Single child - no horizontal line needed */
        .orgchart-child-branch:only-child::after {
            display: none;
        }

        .orgchart-child-connector {
            display: none;
        }

        .orgchart-child-branch > .orgchart-node-wrapper {
            margin-top: 15px;
        }

        .orgchart-people-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 0.5rem;
        }

        .orgchart-person-badge {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.6rem;
            background: #F5F2ED;
            border-radius: 16px;
            font-size: 0.75rem;
            color: #6B5642;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .orgchart-person-badge:hover {
            background: white;
            border-color: #6B8B9E;
            color: #4B6B8E;
        }

        .orgchart-person-badge i {
            font-size: 0.9rem;
            color: #6B8B9E;
        }

        .orgchart-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: #8B6F47;
        }

        .orgchart-empty i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .orgchart-empty h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }

        .orgchart-empty p {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .orgchart-section {
            margin-bottom: 3rem;
        }

        .orgchart-section-title {
            text-align: center;
            font-size: 0.85rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 1.5rem;
            padding: 0.5rem 1rem;
            background: #F5F2ED;
            border-radius: 20px;
            display: inline-block;
        }

        .orgchart-section-header {
            display: flex;
            justify-content: center;
            margin-bottom: 1rem;
        }

        /* ========================================
           ENTITY ORG CHART - Traditional Hierarchy
           ======================================== */

        .entity-orgchart {
            padding: 2rem;
            overflow-x: auto;
        }

        .entity-orgchart-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: fit-content;
        }

        /* Hierarchy Level Containers */
        .orgchart-level {
            display: flex;
            justify-content: center;
            gap: 2rem;
            position: relative;
            padding: 1rem 0;
        }

        .orgchart-level::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            height: 1rem;
            width: 2px;
            background: #C88F4A;
        }

        .orgchart-level:first-child::before {
            display: none;
        }

        /* Vertical connector from parent */
        .orgchart-connector-down {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 1.5rem;
            background: #C88F4A;
        }

        /* Horizontal connector line for children */
        .orgchart-children-connector {
            position: absolute;
            top: -1.5rem;
            left: 0;
            right: 0;
            height: 2px;
            background: #C88F4A;
        }

        /* Unit Node - Top Level */
        .orgchart-unit-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .orgchart-unit-card {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            min-width: 200px;
            max-width: 280px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(200, 143, 74, 0.3);
            transition: all 0.2s ease;
            position: relative;
        }

        .orgchart-unit-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 143, 74, 0.4);
        }

        .orgchart-unit-card .orgchart-icon {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 0.5rem;
            font-size: 1.25rem;
        }

        .orgchart-unit-card .orgchart-name {
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }

        .orgchart-unit-card .orgchart-meta {
            font-size: 0.75rem;
            opacity: 0.85;
        }

        /* Team Node */
        .orgchart-team-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .orgchart-team-card {
            background: linear-gradient(135deg, #7B9E6B 0%, #5E8B5B 100%);
            color: white;
            padding: 0.875rem 1.25rem;
            border-radius: 10px;
            min-width: 180px;
            max-width: 250px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 3px 12px rgba(123, 158, 107, 0.3);
            transition: all 0.2s ease;
            position: relative;
        }

        .orgchart-team-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 16px rgba(123, 158, 107, 0.4);
        }

        .orgchart-team-card .orgchart-icon {
            width: 32px;
            height: 32px;
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 0.4rem;
            font-size: 1rem;
        }

        .orgchart-team-card .orgchart-name {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .orgchart-team-card .orgchart-meta {
            font-size: 0.7rem;
            opacity: 0.85;
            margin-top: 0.2rem;
        }

        /* Role Node - Contains People */
        .orgchart-role-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .orgchart-role-card {
            background: white;
            border: 2px solid #8B6F47;
            padding: 0;
            border-radius: 10px;
            min-width: 160px;
            max-width: 220px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(139, 111, 71, 0.15);
            transition: all 0.2s ease;
            overflow: hidden;
        }

        .orgchart-role-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 111, 71, 0.25);
            border-color: #6B5030;
        }

        .orgchart-role-header {
            background: linear-gradient(135deg, #8B6F47 0%, #6B5030 100%);
            color: white;
            padding: 0.6rem 0.875rem;
            text-align: center;
        }

        .orgchart-role-header .orgchart-icon {
            width: 28px;
            height: 28px;
            background: rgba(255,255,255,0.2);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 0.3rem;
            font-size: 0.85rem;
        }

        .orgchart-role-header .orgchart-name {
            font-size: 0.8rem;
            font-weight: 600;
        }

        .orgchart-role-vacancy {
            font-size: 0.65rem;
            color: #B87B5B;
            background: #FEF6EE;
            padding: 0.15rem 0.5rem;
            border-radius: 8px;
            border: 1px solid #F0D9C4;
            margin-top: 0.25rem;
            display: inline-block;
        }

        /* Empty State for Units/Teams */
        .orgchart-empty-state {
            font-size: 0.75rem;
            color: #8B7355;
            font-style: italic;
            padding: 0.75rem 1rem;
            text-align: center;
            background: #FAF8F5;
            border: 1px dashed #D5C9B8;
            border-radius: 8px;
            min-width: 120px;
        }

        /* People Container inside Role */
        .orgchart-role-people {
            padding: 0.6rem;
            background: #FAF8F5;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .orgchart-person-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .orgchart-person-row:hover {
            background: linear-gradient(135deg, #F0F6F8 0%, #E8EEF0 100%);
            border-color: #6B8B9E;
        }

        .orgchart-person-avatar {
            width: 26px;
            height: 26px;
            background: linear-gradient(135deg, #6B8B9E 0%, #4B6B8E 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .orgchart-person-name {
            font-size: 0.75rem;
            color: #3D2E1F;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Object styling in org chart */
        .orgchart-role-objects,
        .orgchart-team-objects,
        .orgchart-unit-objects {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            padding: 0.5rem;
            background: #FDF9F3;
            border-top: 1px solid #E5DDD1;
        }

        .orgchart-objects-label {
            font-size: 0.7rem;
            color: #8B7355;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .orgchart-objects-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .orgchart-object-row,
        .orgchart-object-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .orgchart-object-row:hover,
        .orgchart-object-item:hover {
            background: linear-gradient(135deg, #FDF8F0 0%, #F5EBD8 100%);
            border-color: #C88F4A;
        }

        .orgchart-object-icon {
            width: 26px;
            height: 26px;
            background: linear-gradient(135deg, #C88F4A 0%, #A67339 100%);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            flex-shrink: 0;
        }

        .orgchart-object-icon i {
            font-size: 0.85rem;
        }

        .orgchart-object-name {
            font-size: 0.75rem;
            color: #3D2E1F;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .orgchart-orphan-object {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .orgchart-orphan-object:hover {
            background: linear-gradient(135deg, #FDF8F0 0%, #F5EBD8 100%);
            border-color: #C88F4A;
        }

        .orgchart-orphan-icon.object-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #C88F4A 0%, #A67339 100%);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .orgchart-orphan-icon.object-icon i {
            font-size: 1rem;
        }

        /* Children Container with Connecting Lines */
        .orgchart-children {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            position: relative;
            padding-top: 2rem;
            margin-top: 0.5rem;
        }

        .orgchart-children::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 2rem;
            background: #D5C4B0;
        }

        /* When there are multiple children, add horizontal connector */
        .orgchart-children.multiple::after {
            content: '';
            position: absolute;
            top: 2rem;
            left: calc(50% - var(--connector-width, 0px) / 2);
            width: var(--connector-width, 0px);
            height: 2px;
            background: #D5C4B0;
        }

        .orgchart-children > * {
            position: relative;
        }

        .orgchart-children > *::before {
            content: '';
            position: absolute;
            top: -2rem;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 2rem;
            background: #D5C4B0;
        }

        .orgchart-children:not(.multiple) > *::before {
            display: none;
        }

        /* Sub-Units Section */
        .orgchart-subunits {
            margin-top: 0.5rem;
        }

        .orgchart-subunits-label {
            font-size: 0.65rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin-bottom: 0.5rem;
            opacity: 0.8;
        }

        /* Teams Row */
        .orgchart-teams-row {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            flex-wrap: wrap;
        }

        /* Roles Row */
        .orgchart-roles-row {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        /* Direct Roles under Unit */
        .orgchart-direct-roles {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px dashed #D5C4B0;
        }

        .orgchart-direct-roles-label {
            font-size: 0.65rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin-bottom: 0.75rem;
        }

        /* Orphan Sections */
        .orgchart-orphan-section {
            background: #FAF8F5;
            border: 2px dashed #D5C4B0;
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 2rem;
            width: 100%;
        }

        .orgchart-orphan-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            color: #8B6F47;
        }

        .orgchart-orphan-header i {
            font-size: 1.25rem;
            opacity: 0.7;
        }

        .orgchart-orphan-title {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .orgchart-orphan-items {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
        }

        .orgchart-orphan-team {
            background: white;
            border: 2px solid #D5C4B0;
            border-left: 4px solid #7B9E6B;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .orgchart-orphan-team:hover {
            border-color: #7B9E6B;
            box-shadow: 0 2px 8px rgba(123, 158, 107, 0.15);
        }

        .orgchart-orphan-role {
            background: white;
            border: 1px solid #E5DDD1;
            border-left: 3px solid #8B6F47;
            border-radius: 8px;
            padding: 0.6rem 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .orgchart-orphan-role:hover {
            border-color: #8B6F47;
            box-shadow: 0 2px 6px rgba(139, 111, 71, 0.1);
        }

        .orgchart-orphan-person {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: white;
            border: 1px solid #D0DDE3;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .orgchart-orphan-person:hover {
            border-color: #6B8B9E;
            background: #F0F6F8;
        }

        .orgchart-orphan-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            color: white;
        }

        .orgchart-orphan-icon.team-icon {
            background: linear-gradient(135deg, #7B9E6B 0%, #5E8B5B 100%);
        }

        .orgchart-orphan-icon.role-icon {
            background: linear-gradient(135deg, #8B6F47 0%, #6B5030 100%);
        }

        .orgchart-orphan-icon.person-icon {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6B8B9E 0%, #4B6B8E 100%);
            font-size: 0.7rem;
        }

        .orgchart-orphan-name {
            font-size: 0.85rem;
            color: #3D2E1F;
            font-weight: 500;
        }

        /* Empty State */
        .entity-orgchart-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: #8B6F47;
        }

        .entity-orgchart-empty i {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 0.4;
            display: block;
        }

        .entity-orgchart-empty h3 {
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
            color: #3D2E1F;
        }

        .entity-orgchart-empty p {
            font-size: 1rem;
            opacity: 0.8;
            max-width: 400px;
            margin: 0 auto;
        }

        /* Collapse/Expand functionality */
        .orgchart-collapse-btn {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid currentColor;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s ease;
        }

        .orgchart-collapse-btn:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .orgchart-unit-card .orgchart-collapse-btn {
            color: #C88F4A;
        }

        .orgchart-team-card .orgchart-collapse-btn {
            color: #7B9E6B;
        }

        .orgchart-node.collapsed .orgchart-children {
            display: none;
        }

        .orgchart-node.collapsed .orgchart-collapse-btn i {
            transform: rotate(-90deg);
        }

        /* Legacy compatibility - keep old nested classes working */
        .nested-orgchart { display: none; }
        .nested-collapse-icon { transition: transform 0.2s ease; }
        .collapsed .nested-collapse-icon { transform: rotate(-90deg); }

        .tree-node-container {
            margin-bottom: 0.25rem;
            position: relative;
        }

        .tree-node-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.625rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            gap: 0.5rem;
            background: transparent;
            border: none;
            margin-bottom: 0.125rem;
            position: relative;
        }

        .tree-node-item:hover {
            background: rgba(200, 143, 74, 0.08);
        }

        .tree-node-item .tree-node-actions {
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .tree-node-item:hover .tree-node-actions {
            opacity: 1;
        }

        .tree-node-item.unit {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            font-weight: 500;
            padding: 0.625rem 0.75rem;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.25);
            margin-bottom: 0.375rem;
        }

        .tree-node-item.unit:hover {
            background: linear-gradient(135deg, #D9A05B 0%, #C98C6C 100%);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.35);
            transform: translateY(-1px);
        }

        .tree-node-item.unit .tree-node-actions {
            opacity: 0.7;
        }

        .tree-node-item.unit:hover .tree-node-actions {
            opacity: 1;
        }

        .tree-node-item.team {
            background: rgba(184, 123, 91, 0.06);
            font-weight: 500;
            color: #5A4736;
        }

        .tree-node-item.team:hover {
            background: rgba(184, 123, 91, 0.12);
        }

        .tree-node-item.role {
            background: transparent;
            color: #6B5642;
        }

        .tree-node-item.role:hover {
            background: rgba(139, 111, 71, 0.08);
        }

        .tree-node-item.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }

        .tree-node-item.drag-over {
            outline: 2px dashed #C88F4A;
            outline-offset: 2px;
            background: rgba(255, 248, 231, 0.8) !important;
        }

        .tree-node-item.drag-over.unit {
            background: rgba(232, 213, 192, 0.8) !important;
        }

        .tree-expand-icon {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.5;
            border-radius: 4px;
        }

        .tree-expand-icon:hover {
            background: rgba(0, 0, 0, 0.05);
            opacity: 0.8;
        }

        .tree-node-item.unit .tree-expand-icon:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .tree-expand-icon.expanded {
            transform: rotate(90deg);
        }

        .tree-node-content {
            flex: 1;
            min-width: 0;
        }

        .tree-node-name {
            font-size: 0.875rem;
            line-height: 1.4;
            font-weight: inherit;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            word-break: break-word;
        }

        .tree-node-meta {
            font-size: 0.7rem;
            opacity: 0.6;
            margin-top: 0.125rem;
        }

        .tree-node-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .tree-node-item.unit .tree-node-icon {
            opacity: 0.9;
        }

        .tree-node-actions {
            display: flex;
            align-items: center;
            gap: 0.125rem;
        }

        .tree-children {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding-left: 1.25rem;
            margin-left: 0.5rem;
            border-left: 1px solid rgba(139, 111, 71, 0.15);
        }

        .tree-children.expanded {
            max-height: 5000px;
        }

        .tree-people-assigned {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .tree-person-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: #6B5642;
            color: white;
            border-radius: 12px;
            font-size: 0.75rem;
            transition: background 0.2s, transform 0.1s;
        }

        .tree-person-badge:hover {
            background: #5A4736;
            transform: scale(1.05);
        }

        .tree-relationships-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            margin-left: 3rem;
            margin-top: 0.5rem;
            background: #FAF7F5;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #6B5642;
            font-weight: 500;
            transition: background 0.2s;
        }

        .tree-relationships-header:hover {
            background: #F5E6D3;
        }

        .tree-relationships {
            margin-left: 3rem;
            margin-top: 0.25rem;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            border: 1px solid #E5DDD1;
            font-size: 0.85rem;
        }

        .tree-relationship-item {
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.375rem;
            border-radius: 6px;
            background: #FAF7F5;
            border-left: 3px solid #C88F4A;
            line-height: 1.5;
        }

        .tree-relationship-item:last-child {
            margin-bottom: 0;
        }

        .tree-relationship-item.shares {
            background: #F0F4F7;
            color: #7B95A3;
        }

        /* Tree Section Headers - Collapsible */
        .tree-section {
            margin-top: 2rem;
        }

        .tree-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #FAF7F5 0%, #F5EFE6 100%);
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }

        .tree-section-header:hover {
            background: linear-gradient(135deg, #F5EFE6 0%, #EDE4D6 100%);
            border-color: #C88F4A;
        }

        .tree-section-header .tree-expand-icon {
            font-size: 0.7rem;
            transition: transform 0.25s;
        }

        .tree-section-header .tree-expand-icon.expanded {
            transform: rotate(90deg);
        }

        .tree-section-title {
            font-size: 1.1rem;
            color: #8B6F47;
            font-weight: 600;
            flex: 1;
        }

        .tree-section-count {
            background: #6B5642;
            color: white;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .tree-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding-left: 0.5rem;
        }

        .tree-section-content.expanded {
            max-height: 10000px;
        }

        /* Grouping Controls */
        .tree-group-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            margin-right: 0.5rem;
        }

        .tree-group-label {
            font-size: 0.75rem;
            color: #8B6F47;
            font-weight: 500;
        }

        .tree-group-select {
            padding: 0.25rem 0.5rem;
            border: 1px solid #E5DDD1;
            border-radius: 4px;
            background: white;
            color: #6B5642;
            font-size: 0.75rem;
            cursor: pointer;
            outline: none;
        }

        .tree-group-select:hover {
            border-color: #C88F4A;
        }

        .tree-group-select:focus {
            border-color: #C88F4A;
            box-shadow: 0 0 0 2px rgba(200, 143, 74, 0.2);
        }

        /* Subgroup Headers */
        .tree-subgroup {
            margin-top: 0.75rem;
        }

        .tree-subgroup-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: #F5EFE6;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 0.5rem;
            transition: background 0.2s;
        }

        .tree-subgroup-header:hover {
            background: #EDE4D6;
        }

        .tree-subgroup-header .tree-expand-icon {
            font-size: 0.6rem;
        }

        .tree-subgroup-title {
            font-size: 0.9rem;
            color: #6B5642;
            font-weight: 500;
            flex: 1;
        }

        .tree-subgroup-count {
            background: rgba(107, 86, 66, 0.2);
            color: #6B5642;
            padding: 0.125rem 0.375rem;
            border-radius: 8px;
            font-size: 0.7rem;
        }

        .tree-subgroup-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding-left: 1rem;
        }

        .tree-subgroup-content.expanded {
            max-height: 5000px;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Simplified UX Styles */
        .welcome-banner {
            background: linear-gradient(135deg, #FFF9F0 0%, #FAF7F5 100%);
            border: 2px solid #C88F4A;
            border-radius: 8px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
        }

        .welcome-banner h3 {
            color: #C88F4A;
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .welcome-banner ol {
            margin-left: 1.25rem;
            margin-bottom: 1rem;
            color: #6B5642;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        .welcome-banner .actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .collapsible-section {
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .collapsible-header {
            background: #FAF7F5;
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            color: #6B5642;
            transition: background 0.2s;
        }

        .collapsible-header:hover {
            background: #F5E6D3;
        }

        .collapsible-header .collapse-icon {
            transition: transform 0.2s;
        }

        .collapsible-section.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            padding: 1rem;
            max-height: 2000px;
            transition: max-height 0.3s ease-out, padding 0.3s;
            overflow: hidden;
        }

        .collapsible-section.collapsed .collapsible-content {
            max-height: 0;
            padding: 0 1rem;
        }

        .show-more-btn {
            width: 100%;
            padding: 0.5rem;
            background: transparent;
            border: 1px dashed #C88F4A;
            color: #C88F4A;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.375rem;
        }

        .show-more-btn:hover {
            background: #FFF9F0;
        }

        .show-more-btn.expanded {
            border-style: solid;
            background: #FFF9F0;
        }

        .filter-dropdown {
            flex: 1;
            padding: 0.625rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
            cursor: pointer;
            font-family: inherit;
        }

        .filter-simplified {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tooltip-hint {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: #E5DDD1;
            color: #6B5642;
            border-radius: 50%;
            font-size: 0.7rem;
            cursor: help;
            margin-left: 0.25rem;
        }

        .help-text {
            font-size: 0.75rem;
            color: #8B6F47;
            font-style: italic;
            margin-top: 0.25rem;
        }

        .quick-operator-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .operator-btn {
            flex: 1;
            padding: 0.75rem 0.5rem;
            border: 2px solid #E5DDD1;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.2s;
            text-align: center;
        }

        .operator-btn:hover {
            border-color: #C88F4A;
        }

        .operator-btn.active {
            border-color: #C88F4A;
            background: #FFF9F0;
            color: #C88F4A;
        }

        .operator-btn.active.link-type {
            border-color: #7B95A3;
            background: #F0F4F7;
            color: #7B95A3;
        }

        .operator-btn.active.start-type {
            border-color: #8B6F47;
            background: #F5F0E8;
            color: #8B6F47;
        }

        .operator-btn.active.assign-type {
            border-color: #6B8B9E;
            background: #F0F5F7;
            color: #6B8B9E;
        }

        .operator-btn-subtitle {
            font-size: 0.7rem;
            opacity: 0.8;
            font-weight: 400;
            margin-top: 0.125rem;
        }

        .advanced-operators {
            display: none;
            margin-top: 0.75rem;
        }

        .advanced-operators.visible {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .advanced-filters-content {
            display: none;
            padding-top: 1rem;
        }

        .advanced-filters-content.visible {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: #FFF9F0;
            color: #C88F4A;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        /* Hide technical labels by default */
        .technical-label {
            display: none;
        }

        body.technical-mode .technical-label {
            display: inline;
        }

        body.technical-mode .friendly-label {
            display: none;
        }

        /* ========================================== */
        /* Enhanced Entity Modal Styles */
        /* ========================================== */

        .modal-dialog {
            background: white;
            border-radius: 16px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.25);
        }

        .modal-header-section {
            padding: 1.75rem 2rem;
            border-bottom: none;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            position: relative;
            flex-shrink: 0;
        }

        .modal-header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .modal-header-icon {
            font-size: 2.5rem;
            opacity: 0.9;
            margin-right: 1rem;
        }

        .modal-header-content {
            flex: 1;
        }

        .modal-title-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .modal-title-text {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0;
            letter-spacing: -0.02em;
        }

        .modal-title-edit-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.4rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
        }

        .modal-title-edit-btn:hover {
            background: rgba(255,255,255,0.3);
            opacity: 1;
        }

        .modal-type-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            background: rgba(255,255,255,0.2);
            padding: 0.35rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.5rem;
        }

        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 1.25rem;
        }

        .modal-close-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .modal-body {
            padding: 0;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        /* Modal Tabs - Hidden for simplified single-view layout */
        .modal-tabs {
            display: none; /* Tabs removed - all content shown in single scrollable view */
            gap: 0;
            border-bottom: 2px solid #E5DDD1;
            padding: 0 1.5rem;
            background: #FAF7F5;
            flex-shrink: 0;
        }

        .modal-tab {
            padding: 0.75rem 1.25rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            color: #8B6F47;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
        }

        .modal-tab:hover {
            color: #5A4A3A;
            background: rgba(200, 143, 74, 0.1);
        }

        .modal-tab.active {
            color: #C88F4A;
            border-bottom-color: #C88F4A;
            font-weight: 600;
        }

        .modal-tab i {
            font-size: 1rem;
        }

        .modal-tab-content {
            display: block; /* All content visible - no tabs */
            flex: none; /* Don't flex - let container scroll */
            overflow-y: visible;
            min-height: 0;
        }

        .modal-tab-content.active {
            display: block;
        }

        /* Hide the "Add" tab content - duplicates inline functionality */
        #tabConnect {
            display: none !important;
        }

        /* Section headers for unified modal view */
        .modal-section-header {
            padding: 0.75rem 2rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: #FAF7F5;
            border-bottom: 1px solid #E5DDD1;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .modal-section-header i {
            font-size: 1rem;
            opacity: 0.7;
        }

        .modal-section {
            padding: 1.5rem 2rem;
            margin-bottom: 0;
            border-bottom: 1px solid #F0EBE4;
        }

        .modal-section:last-of-type {
            border-bottom: none;
        }

        /* Role Assignment Section - High Visual Priority for Persons */
        .role-assignment-section {
            background: linear-gradient(135deg, #FFF8F0 0%, #FFF4E8 100%);
            border: 2px solid #E8B86D;
            border-radius: 12px;
            margin: 1rem 1rem 0 1rem;
            padding: 1.25rem 1.5rem !important;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.15);
        }

        .role-assignment-section:empty {
            display: none;
        }

        .role-assignment-section .modal-section-title {
            font-size: 0.9rem;
            color: #8B5A2B;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .role-assignment-section .modal-section-title i {
            font-size: 1.2rem;
            color: #C88F4A;
        }

        .role-assignment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .role-assignment-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .role-assignment-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1rem;
            background: white;
            border: 2px solid #C88F4A;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            font-weight: 600;
            color: #5A4A3A;
        }

        .role-assignment-chip:hover {
            background: #FFF4E8;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(200, 143, 74, 0.2);
        }

        .role-assignment-chip i {
            color: #C88F4A;
        }

        .role-assignment-chip .chip-remove-btn {
            margin-left: 0.25rem;
            padding: 0.2rem;
            border: none;
            background: transparent;
            color: #8B6F47;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .role-assignment-chip .chip-remove-btn:hover {
            background: rgba(200, 143, 74, 0.2);
            color: #8B5A2B;
        }

        .role-assignment-chip .chip-role-name {
            font-weight: 600;
        }

        .role-assignment-chip .chip-team-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #B87B5B;
            background: rgba(184, 123, 91, 0.12);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            margin-left: 0.25rem;
        }

        .role-assignment-add-form {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            padding-top: 0.75rem;
            border-top: 1px dashed #E8B86D;
        }

        .role-assignment-add-form select {
            flex: 1;
            padding: 0.6rem 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.875rem;
            background: white;
            color: #3D2E1F;
        }

        .role-assignment-add-form select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .role-assignment-add-btn {
            padding: 0.6rem 1rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.35rem;
            transition: all 0.2s;
        }

        .role-assignment-add-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(200, 143, 74, 0.3);
        }

        .role-assignment-add-form.hidden {
            display: none;
        }

        .role-assignment-empty {
            color: #8B6F47;
            font-size: 0.9rem;
            padding: 0.5rem 0 1rem 0;
            font-style: italic;
        }

        .role-assignment-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 1rem;
            background: white;
            border: 2px solid #C88F4A;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            color: #5A4A3A;
        }

        .role-assignment-name {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .role-assignment-name:hover {
            color: #C88F4A;
        }

        .role-assignment-name i {
            color: #C88F4A;
        }

        .role-assignment-remove {
            padding: 0.25rem;
            border: none;
            background: transparent;
            color: #8B6F47;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .role-assignment-remove:hover {
            background: rgba(200, 50, 50, 0.1);
            color: #c83232;
        }

        /* Custom Styled Role Dropdown with Team Groupings */
        .role-dropdown-container {
            position: relative;
            flex: 1;
        }

        .role-dropdown-trigger {
            width: 100%;
            padding: 0.7rem 1rem;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.875rem;
            color: #3D2E1F;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
        }

        .role-dropdown-trigger:hover {
            border-color: #C88F4A;
            background: #FFFBF5;
        }

        .role-dropdown-trigger.open {
            border-color: #C88F4A;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .role-dropdown-trigger .trigger-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #8B6F47;
        }

        .role-dropdown-trigger .trigger-text.has-selection {
            color: #3D2E1F;
            font-weight: 500;
        }

        .role-dropdown-trigger .trigger-text i {
            color: #C88F4A;
        }

        .role-dropdown-trigger .trigger-arrow {
            color: #8B6F47;
            transition: transform 0.2s;
        }

        .role-dropdown-trigger.open .trigger-arrow {
            transform: rotate(180deg);
        }

        .role-dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #C88F4A;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 320px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.2);
            display: none;
        }

        .role-dropdown-menu.open {
            display: block;
        }

        .role-dropdown-team {
            border-bottom: 1px solid #F0EBE3;
        }

        .role-dropdown-team:last-child {
            border-bottom: none;
        }

        .role-dropdown-team-header {
            padding: 0.6rem 1rem;
            background: linear-gradient(135deg, #FAF7F5 0%, #F5F2ED 100%);
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #B87B5B;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-bottom: 1px solid #E5DDD1;
        }

        .role-dropdown-team-header i {
            color: #B87B5B;
            font-size: 0.9rem;
        }

        .role-dropdown-item {
            padding: 0.65rem 1rem 0.65rem 1.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #3D2E1F;
            transition: all 0.15s;
        }

        .role-dropdown-item:hover {
            background: linear-gradient(135deg, #FFF8F0 0%, #FFF4E8 100%);
        }

        .role-dropdown-item i {
            color: #8B6F47;
            font-size: 0.9rem;
        }

        .role-dropdown-item:hover i {
            color: #C88F4A;
        }

        .role-dropdown-unassigned {
            border-top: 1px dashed #E5DDD1;
        }

        .role-dropdown-unassigned .role-dropdown-team-header {
            background: linear-gradient(135deg, #F5F3F0 0%, #EFEDE8 100%);
            color: #8B6F47;
        }

        .role-dropdown-unassigned .role-dropdown-team-header i {
            color: #8B6F47;
        }

        /* Scrollbar styling for dropdown */
        .role-dropdown-menu::-webkit-scrollbar {
            width: 6px;
        }

        .role-dropdown-menu::-webkit-scrollbar-track {
            background: #F5F2ED;
        }

        .role-dropdown-menu::-webkit-scrollbar-thumb {
            background: #D4C4B0;
            border-radius: 3px;
        }

        .role-dropdown-menu::-webkit-scrollbar-thumb:hover {
            background: #C88F4A;
        }

        .modal-section-title {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-bottom: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .modal-section-title i {
            font-size: 1rem;
        }

        .connection-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1rem;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            margin: 0.25rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            font-weight: 500;
            color: #3D2E1F;
        }

        .connection-badge:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
            transform: translateY(-1px);
        }

        .connection-badge i {
            color: #8B6F47;
        }

        .connection-badge-content {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .connection-remove-btn {
            background: transparent;
            border: none;
            color: #A89B8C;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 0.25rem;
            padding: 0;
            transition: all 0.2s;
            opacity: 0;
        }

        .connection-badge:hover .connection-remove-btn {
            opacity: 1;
        }

        .connection-remove-btn:hover {
            background: #F0E6DC;
            color: #C75050;
        }

        .connection-remove-btn i {
            font-size: 0.75rem;
            color: inherit;
        }

        /* Orbital Connections Visualization */
        .orbital-container {
            position: relative;
            width: 100%;
            height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
        }

        /* Mobile modal optimizations */
        @media (max-width: 640px) {
            .modal-dialog {
                width: 100%;
                max-width: 100%;
                height: 100%;
                max-height: 100%;
                border-radius: 0;
                margin: 0;
            }

            .modal-header-section {
                padding: 1rem 1.25rem;
            }

            .modal-header-icon {
                font-size: 2rem;
                margin-right: 0.75rem;
            }

            .modal-title-text {
                font-size: 1.35rem;
            }

            .modal-section {
                padding: 1rem 1.25rem;
            }

            .modal-actions {
                padding: 1rem 1.25rem;
            }

            /* Hide orbital view on mobile - always use list */
            .orbital-container {
                display: none !important;
            }

            /* Hide view toggle on mobile since we only show list */
            .view-toggle {
                display: none;
            }

            /* Compact empty states */
            .modal-empty-state {
                padding: 0.75rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .modal-empty-state i {
                font-size: 1rem;
                margin-bottom: 0;
            }

            /* Compact description empty state */
            .modal-description-empty {
                padding: 0.75rem;
                font-size: 0.85rem;
            }

            /* Stack connection badges vertically for easier tapping */
            .connection-group-items {
                flex-direction: column;
                gap: 0.5rem;
            }

            .connection-badge {
                width: 100%;
                padding: 0.75rem 1rem;
                margin: 0;
                justify-content: space-between;
            }

            /* Add action sections more compact */
            .modal-add-connection {
                padding: 0.75rem;
            }

            .modal-add-connection-row {
                flex-direction: column;
                gap: 0.5rem;
            }

            .modal-add-connection-row select {
                width: 100%;
            }

            .modal-add-connection-btn {
                width: 100%;
                justify-content: center;
            }

            /* Hide separate add sections on mobile - use inline buttons instead */
            #modalAddNested,
            #modalAddActivity {
                display: none !important;
            }

            /* Hide delete from footer on mobile */
            #modalDeleteButton {
                display: none !important;
            }

            /* Make footer simpler on mobile */
            .modal-actions {
                justify-content: space-between;
            }

            .modal-action-spacer {
                display: none;
            }
        }

        /* Inline add button for section headers */
        .section-add-btn {
            background: rgba(200, 143, 74, 0.15);
            border: none;
            color: #C88F4A;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .section-add-btn:hover {
            background: rgba(200, 143, 74, 0.25);
        }

        /* Inline add form that expands in section */
        .inline-add-form {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: #FAF7F5;
            border-radius: 8px;
            border: 1px dashed #E5DDD1;
        }

        .inline-add-form.hidden {
            display: none;
        }

        .inline-add-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .inline-add-row select {
            flex: 1;
            min-width: 100px;
            padding: 0.5rem;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
        }

        .inline-add-row select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .inline-add-btn {
            padding: 0.5rem 0.75rem;
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .inline-add-btn:hover {
            background: #B87B5B;
        }

        /* Hide mobile-only delete button on desktop */
        .mobile-only-delete {
            display: none;
        }

        @media (max-width: 640px) {
            .mobile-only-delete {
                display: flex;
            }
        }

        .orbital-svg {
            width: 100%;
            height: 100%;
        }

        .orbital-center {
            cursor: default;
        }

        .orbital-center-circle {
            fill: #C88F4A;
            stroke: #B87B5B;
            stroke-width: 3;
        }

        .orbital-center-icon {
            fill: white;
            font-size: 24px;
        }

        .orbital-center-label {
            fill: #3D2E1F;
            font-size: 11px;
            font-weight: 600;
            text-anchor: middle;
        }

        .orbital-ring {
            fill: none;
            stroke: #E5DDD1;
            stroke-width: 1;
            stroke-dasharray: 4,4;
        }

        .orbital-node {
            cursor: pointer;
        }

        .orbital-node-circle {
            stroke-width: 2;
            stroke: white;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .orbital-node-icon {
            fill: white;
            font-size: 14px;
            pointer-events: none;
        }

        .orbital-node-label {
            font-size: 11px;
            font-weight: 500;
            fill: #3D2E1F;
            pointer-events: none;
        }

        .orbital-link {
            stroke: #E5DDD1;
            stroke-width: 1.5;
            fill: none;
        }

        .orbital-link.has-children {
            stroke: #C88F4A;
            stroke-width: 2;
            stroke-dasharray: none;
        }

        /* Grouped connections fallback */
        .connections-grouped {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .connection-group {
            background: #FAF7F5;
            border-radius: 8px;
            padding: 0.75rem;
        }

        .connection-group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .connection-group-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        /* Nested indicator */
        .connection-badge.has-nested {
            border-color: #C88F4A;
            position: relative;
        }

        .connection-badge.has-nested::after {
            content: '';
            position: absolute;
            top: -4px;
            right: -4px;
            width: 12px;
            height: 12px;
            background: #C88F4A;
            border-radius: 50%;
            border: 2px solid white;
        }

        .nested-count {
            position: absolute;
            top: -4px;
            right: -4px;
            min-width: 18px;
            height: 18px;
            background: #C88F4A;
            border-radius: 9px;
            border: 2px solid white;
            color: white;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
        }

        /* Nested hierarchy styles */
        .nested-hierarchy {
            flex-direction: column;
            align-items: flex-start;
        }

        .nested-unit-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.125rem 0;
            position: relative;
        }

        .nested-unit-item::before {
            content: '';
            position: absolute;
            left: -0.75rem;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #E5DDD1;
        }

        .nested-unit-item:first-child::before {
            top: 50%;
        }

        .nested-unit-item:last-child::before {
            bottom: 50%;
        }

        .nested-unit-item:only-child::before {
            display: none;
        }

        .nested-children {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
            margin-top: 0.25rem;
            padding-left: 0.5rem;
            border-left: 1px solid #E5DDD1;
        }

        .connection-badge.unit-badge {
            border-color: #C88F4A;
            background: rgba(200, 143, 74, 0.08);
        }

        .connection-badge.team-badge {
            border-color: #8B6F47;
            background: rgba(139, 111, 71, 0.08);
        }

        .connection-badge.role-badge {
            border-color: #6B5642;
            background: rgba(107, 86, 66, 0.08);
        }

        /* View toggle for connections */
        .connections-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .view-toggle {
            display: flex;
            gap: 0.25rem;
            background: #F5F2ED;
            border-radius: 6px;
            padding: 2px;
        }

        .view-toggle-btn {
            padding: 0.35rem 0.5rem;
            border: none;
            background: transparent;
            color: #8B6F47;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .view-toggle-btn:hover {
            background: #E5DDD1;
        }

        .view-toggle-btn.active {
            background: white;
            color: #C88F4A;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Embedded Unit Cards */
        .embedded-units-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .embedded-unit-card {
            background: linear-gradient(135deg, #FFF9F0 0%, #FFFBF7 100%);
            border: 1px solid #E5DDD1;
            border-radius: 10px;
            padding: 1rem;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .embedded-unit-card:hover {
            border-color: #C88F4A;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.15);
        }

        .embedded-unit-card.expanded {
            border-color: #C88F4A;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.2);
        }

        .embedded-unit-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .embedded-unit-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: #FFF5E6;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #C88F4A;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .embedded-unit-info {
            flex: 1;
            min-width: 0;
        }

        .embedded-unit-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: #3D2E1F;
            margin-bottom: 0.15rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .embedded-unit-type {
            font-size: 0.75rem;
            color: #8B6F47;
            text-transform: capitalize;
        }

        .embedded-unit-actions {
            display: flex;
            gap: 0.375rem;
            flex-shrink: 0;
        }

        .embedded-unit-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(200, 143, 74, 0.1);
            color: #8B6F47;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .embedded-unit-btn:hover {
            background: #C88F4A;
            color: white;
        }

        .embedded-unit-content {
            display: none;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #E5DDD1;
        }

        .embedded-unit-card.expanded .embedded-unit-content {
            display: block;
        }

        .embedded-unit-description {
            font-size: 0.875rem;
            color: #5C4D3A;
            line-height: 1.5;
            margin-bottom: 0.75rem;
        }

        .embedded-unit-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .embedded-unit-stat {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.35rem 0.65rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 16px;
            font-size: 0.75rem;
            color: #6B5642;
        }

        .embedded-unit-stat i {
            color: #8B6F47;
            font-size: 0.8rem;
        }

        .embedded-unit-nested-preview {
            margin-top: 0.75rem;
        }

        .embedded-nested-label {
            font-size: 0.75rem;
            color: #8B6F47;
            margin-bottom: 0.375rem;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .embedded-nested-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
        }

        .embedded-nested-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.3rem 0.6rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 14px;
            font-size: 0.75rem;
            color: #5C4D3A;
            cursor: pointer;
            transition: all 0.15s;
        }

        .embedded-nested-chip:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .embedded-nested-chip i {
            font-size: 0.7rem;
            color: #8B6F47;
        }

        .embedded-nested-more {
            color: #8B6F47;
            font-style: italic;
        }

        /* Entity type colors for embedded cards */
        .embedded-unit-card.team {
            background: linear-gradient(135deg, #FAF7F5 0%, #FEFEFE 100%);
        }
        .embedded-unit-card.team .embedded-unit-icon {
            background: #F0EDE8;
            color: #7A6B5A;
        }

        .embedded-unit-card.role {
            background: linear-gradient(135deg, #F8F6F3 0%, #FEFEFE 100%);
        }
        .embedded-unit-card.role .embedded-unit-icon {
            background: #EDEAE5;
            color: #6B5F4F;
        }

        .embedded-unit-card.person {
            background: linear-gradient(135deg, #F5F3F0 0%, #FEFEFE 100%);
        }
        .embedded-unit-card.person .embedded-unit-icon {
            background: #EAE7E2;
            color: #5C5248;
        }

        .embedded-unit-card.object {
            background: linear-gradient(135deg, #FFFBF5 0%, #FEFEFE 100%);
        }
        .embedded-unit-card.object .embedded-unit-icon {
            background: #FFF5E6;
            color: #B8860B;
        }

        /* Mobile adjustments for embedded cards */
        @media (max-width: 768px) {
            .embedded-unit-card {
                padding: 0.875rem;
            }

            .embedded-unit-icon {
                width: 32px;
                height: 32px;
                font-size: 1rem;
            }

            .embedded-unit-name {
                font-size: 0.9rem;
            }
        }

        .activity-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            border-left: 3px solid #C88F4A;
        }

        .activity-item:last-child {
            margin-bottom: 0;
        }

        .activity-operator {
            font-weight: 700;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .modal-actions {
            display: flex;
            gap: 0.75rem;
            padding: 1.5rem 2rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
            flex-shrink: 0;
        }

        .modal-action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .modal-action-btn.primary {
            background: #D4A54A;
            color: white;
            border-color: #D4A54A;
        }

        .modal-action-btn.primary:hover {
            background: #E5B555;
            border-color: #E5B555;
        }

        .modal-action-btn.secondary {
            background: white;
            color: #6B5642;
            border-color: #E5DDD1;
        }

        .modal-action-btn.secondary:hover {
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .modal-action-btn.danger {
            background: white;
            color: #d32f2f;
            border-color: #E5DDD1;
        }

        .modal-action-btn.danger:hover {
            border-color: #d32f2f;
            background: #fff5f5;
        }

        .modal-action-spacer {
            flex: 1;
        }

        /* Entity Edit Modal */
        .entity-edit-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }

        .entity-edit-modal-overlay.open {
            display: flex;
        }

        .entity-edit-modal {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 450px;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.25);
            overflow: hidden;
        }

        .entity-edit-modal-header {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            padding: 1.5rem;
            color: white;
        }

        .entity-edit-modal-header h3 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .entity-edit-modal-body {
            padding: 1.5rem;
        }

        .entity-edit-field {
            margin-bottom: 1.25rem;
        }

        .entity-edit-field:last-child {
            margin-bottom: 0;
        }

        .entity-edit-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            color: #6B5642;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .entity-edit-input {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s;
            color: #3D2E1F;
        }

        .entity-edit-input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .entity-edit-textarea {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
            color: #3D2E1F;
            resize: vertical;
            min-height: 80px;
            max-height: 160px;
            font-family: inherit;
            line-height: 1.5;
        }

        .entity-edit-textarea:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .entity-edit-label .char-limit {
            font-weight: 400;
            color: #8B6F47;
            font-size: 0.75rem;
        }

        /* Modal description display */
        .modal-description-text {
            color: #6B5642;
            font-size: 0.95rem;
            line-height: 1.6;
            padding: 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            border-left: 3px solid #C88F4A;
        }

        .modal-description-empty {
            color: #8B6F47;
            font-style: italic;
            font-size: 0.9rem;
            padding: 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            text-align: center;
        }

        /* Inline editing styles for modal fields */
        .modal-title-display {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            margin: -0.25rem -0.5rem;
            border-radius: 6px;
            transition: background 0.15s;
        }

        .modal-title-display:hover {
            background: rgba(255,255,255,0.15);
        }

        .modal-title-display .edit-hint {
            opacity: 0;
            font-size: 0.75rem;
            color: rgba(255,255,255,0.7);
            transition: opacity 0.15s;
        }

        .modal-title-display:hover .edit-hint {
            opacity: 1;
        }

        .modal-title-edit-form {
            display: none;
            align-items: center;
            gap: 0.5rem;
        }

        .modal-title-edit-form.active {
            display: flex;
        }

        .modal-title-edit-form input {
            font-size: 1.5rem;
            font-weight: 700;
            padding: 0.25rem 0.5rem;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 6px;
            background: rgba(255,255,255,0.2);
            color: white;
            width: 100%;
            max-width: 300px;
        }

        .modal-title-edit-form input:focus {
            outline: none;
            border-color: white;
            background: rgba(255,255,255,0.3);
        }

        .modal-title-edit-form input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .inline-edit-actions {
            display: flex;
            gap: 0.25rem;
        }

        .inline-edit-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.35rem;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
        }

        .inline-edit-btn:hover {
            background: rgba(255,255,255,0.35);
        }

        .inline-edit-btn.save {
            background: rgba(255,255,255,0.3);
        }

        .inline-edit-btn.save:hover {
            background: rgba(255,255,255,0.45);
        }

        /* Description inline editing */
        .modal-description-display {
            cursor: pointer;
            position: relative;
            transition: all 0.15s;
        }

        .modal-description-display:hover {
            background: #F5EFE6;
            border-left-color: #D4A54A;
        }

        .modal-description-display .edit-hint-desc {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            opacity: 0;
            font-size: 0.7rem;
            color: #8B6F47;
            background: rgba(255,255,255,0.9);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            transition: opacity 0.15s;
        }

        .modal-description-display:hover .edit-hint-desc {
            opacity: 1;
        }

        .modal-description-edit-form {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
        }

        .modal-description-edit-form.active {
            display: flex;
        }

        .modal-description-edit-form textarea {
            width: 100%;
            min-height: 100px;
            padding: 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.6;
            resize: vertical;
            font-family: inherit;
            color: #3D2E1F;
            background: white;
        }

        .modal-description-edit-form textarea:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .modal-description-edit-form .desc-edit-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-description-edit-form .char-count {
            font-size: 0.75rem;
            color: #8B6F47;
        }

        .modal-description-edit-form .desc-edit-actions {
            display: flex;
            gap: 0.5rem;
        }

        .desc-edit-btn {
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.15s;
        }

        .desc-edit-btn.cancel {
            background: #F5F2ED;
            color: #6B5642;
            border: 1px solid #E5DDD1;
        }

        .desc-edit-btn.cancel:hover {
            background: #E5DDD1;
        }

        .desc-edit-btn.save {
            background: #C88F4A;
            color: white;
        }

        .desc-edit-btn.save:hover {
            background: #B87B5B;
        }

        /* Add connection in modal */
        .modal-add-connection {
            background: #FAF7F5;
            border-radius: 8px;
            padding: 1rem;
            border: 1px dashed #E5DDD1;
        }

        .modal-add-connection-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .modal-add-connection-row select {
            flex: 1;
            min-width: 120px;
            padding: 0.625rem 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
            color: #3D2E1F;
            cursor: pointer;
        }

        .modal-add-connection-row select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .modal-add-connection-btn {
            padding: 0.625rem 1rem;
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.375rem;
            transition: background 0.2s;
        }

        .modal-add-connection-btn:hover {
            background: #B87B5B;
        }

        .modal-add-connection-btn:disabled {
            background: #E5DDD1;
            cursor: not-allowed;
        }

        /* ========================================== */
        /* Modal Header Parent Badge Styles */
        /* ========================================== */

        .modal-header-parent {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .modal-parent-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.65rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .modal-parent-badge:hover {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .modal-parent-badge .parent-type-icon {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .modal-parent-badge .parent-name {
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .modal-parent-badge .dropdown-arrow {
            font-size: 0.7rem;
            opacity: 0.8;
            transition: transform 0.2s;
        }

        .modal-parent-badge.dropdown-open .dropdown-arrow {
            transform: rotate(180deg);
        }

        .modal-parent-badge-empty {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.65rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.4);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.8;
        }

        .modal-parent-badge-empty:hover {
            background: rgba(255, 255, 255, 0.2);
            opacity: 1;
        }

        /* Parent Dropdown in Header */
        .modal-parent-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            min-width: 220px;
            max-width: 280px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 6px 24px rgba(61, 46, 31, 0.2);
            z-index: 100;
            display: none;
            overflow: hidden;
        }

        .modal-parent-dropdown.visible {
            display: block;
        }

        .modal-parent-dropdown-header {
            padding: 0.75rem 1rem;
            background: #FAF7F5;
            border-bottom: 1px solid #E5DDD1;
            font-size: 0.75rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .modal-parent-dropdown-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .modal-parent-dropdown-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.65rem 1rem;
            font-size: 0.875rem;
            color: #3D2E1F;
            cursor: pointer;
            transition: background 0.15s;
        }

        .modal-parent-dropdown-item:hover {
            background: #FAF7F5;
        }

        .modal-parent-dropdown-item.current {
            background: #FFF9F0;
            font-weight: 600;
        }

        .modal-parent-dropdown-item .item-icon {
            font-size: 1rem;
            color: #8B6F47;
        }

        .modal-parent-dropdown-item.remove-parent {
            color: #B87B5B;
            border-top: 1px solid #E5DDD1;
        }

        .modal-parent-dropdown-item.remove-parent .item-icon {
            color: #B87B5B;
        }

        /* ========================================== */
        /* Create Connection Panel Styles */
        /* ========================================== */

        .create-connection-panel {
            background: linear-gradient(135deg, #FAF7F5 0%, #FFF9F0 100%);
            border-radius: 12px;
            border: 2px solid #E5DDD1;
            overflow: hidden;
        }

        .create-connection-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .create-connection-header i {
            font-size: 1.1rem;
        }

        .create-connection-body {
            padding: 1rem;
        }

        /* Operator Buttons - Primary Row */
        .operator-buttons-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .operator-button {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            padding: 0.75rem 0.5rem;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .operator-button:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .operator-button.active {
            border-color: var(--operator-color, #C88F4A);
            background: var(--operator-bg, #FFF9F0);
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.2);
        }

        .operator-button-icon {
            font-size: 1.25rem;
            color: #8B6F47;
            transition: color 0.2s;
        }

        .operator-button.active .operator-button-icon {
            color: var(--operator-color, #C88F4A);
        }

        .operator-button-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #3D2E1F;
        }

        .operator-button-sublabel {
            font-size: 0.65rem;
            color: #8B6F47;
            font-weight: 400;
        }

        /* Operator specific colors */
        .operator-button[data-operator="DES"] {
            --operator-color: #C88F4A;
            --operator-bg: #FFF9F0;
        }

        .operator-button[data-operator="CON"] {
            --operator-color: #7B95A3;
            --operator-bg: #F0F4F7;
        }

        .operator-button[data-operator="ALT"] {
            --operator-color: #B87B5B;
            --operator-bg: #FFF5F0;
        }

        /* More Operators Toggle */
        .more-operators-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
            color: #8B6F47;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 6px;
        }

        .more-operators-toggle:hover {
            background: rgba(200, 143, 74, 0.1);
            color: #C88F4A;
        }

        .more-operators-toggle i {
            transition: transform 0.2s;
        }

        .more-operators-toggle.expanded i {
            transform: rotate(180deg);
        }

        /* Advanced Operators Grid */
        .advanced-operators-grid {
            display: none;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.4rem;
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            border: 1px dashed #E5DDD1;
        }

        .advanced-operators-grid.visible {
            display: grid;
        }

        .advanced-operator-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.15rem;
            padding: 0.5rem 0.25rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.7rem;
        }

        .advanced-operator-btn:hover {
            border-color: var(--adv-op-color, #8B6F47);
            background: var(--adv-op-bg, #FAF7F5);
        }

        .advanced-operator-btn.active {
            border-color: var(--adv-op-color, #8B6F47);
            background: var(--adv-op-bg, #FAF7F5);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        }

        .advanced-operator-btn i {
            font-size: 1rem;
            color: var(--adv-op-color, #8B6F47);
        }

        .advanced-operator-btn span {
            font-weight: 500;
            color: #3D2E1F;
        }

        /* Advanced operator colors */
        .advanced-operator-btn[data-operator="SEG"] {
            --adv-op-color: #A89984;
            --adv-op-bg: #F5F3F0;
        }

        .advanced-operator-btn[data-operator="SYN"] {
            --adv-op-color: #D4A574;
            --adv-op-bg: #FFF9F0;
        }

        .advanced-operator-btn[data-operator="SUP"] {
            --adv-op-color: #9B6F47;
            --adv-op-bg: #FAF5F0;
        }

        .advanced-operator-btn[data-operator="REC"] {
            --adv-op-color: #C8997F;
            --adv-op-bg: #FFF8F5;
        }

        .advanced-operator-btn[data-operator="NUL"] {
            --adv-op-color: #6B5642;
            --adv-op-bg: #F5F0EB;
        }

        /* Target Entity Selector */
        .target-entity-section {
            margin-bottom: 0.75rem;
        }

        .target-entity-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .target-entity-select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.9rem;
            background: white;
            color: #3D2E1F;
            cursor: pointer;
        }

        .target-entity-select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        /* Sentence Preview */
        .connection-sentence-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.4rem;
            padding: 0.875rem 1rem;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            min-height: 50px;
        }

        .connection-sentence-preview.has-content {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .sentence-placeholder {
            color: #A89984;
            font-size: 0.875rem;
            font-style: italic;
        }

        .sentence-subject,
        .sentence-object {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.65rem;
            border-radius: 16px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .sentence-subject {
            background: linear-gradient(135deg, #C88F4A 0%, #D4A574 100%);
            color: white;
        }

        .sentence-operator {
            padding: 0.25rem 0.5rem;
            background: var(--sentence-op-color, #8B6F47);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sentence-object {
            background: linear-gradient(135deg, #7B95A3 0%, #9BB5C3 100%);
            color: white;
        }

        .sentence-object.work-product {
            background: linear-gradient(135deg, #D4A574 0%, #E8C9A8 100%);
        }

        /* Collapsible Notes Section */
        .notes-section {
            margin-bottom: 0.75rem;
        }

        .notes-section-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.65rem 0.75rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
            color: #8B6F47;
        }

        .notes-section-toggle:hover {
            background: #FAF7F5;
            border-color: #C88F4A;
        }

        .notes-section-toggle.has-content {
            background: #FFF9F0;
            border-color: #C88F4A;
            color: #3D2E1F;
        }

        .notes-section-toggle i.toggle-icon {
            transition: transform 0.2s;
        }

        .notes-section-toggle.expanded i.toggle-icon {
            transform: rotate(90deg);
        }

        .notes-section-content {
            display: none;
            margin-top: 0.5rem;
        }

        .notes-section-content.visible {
            display: block;
        }

        .notes-textarea {
            width: 100%;
            min-height: 80px;
            padding: 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.875rem;
            font-family: inherit;
            resize: vertical;
            background: white;
            color: #3D2E1F;
        }

        .notes-textarea:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .notes-char-count {
            font-size: 0.7rem;
            color: #A89984;
            text-align: right;
            margin-top: 0.25rem;
        }

        /* Work Product Section */
        .work-product-section {
            padding-top: 0.75rem;
            border-top: 1px dashed #E5DDD1;
            margin-bottom: 0.75rem;
        }

        .work-product-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: #8B6F47;
            margin-bottom: 0.5rem;
        }

        .work-product-selector-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.75rem;
            background: white;
            border: 2px dashed #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            color: #8B6F47;
        }

        .work-product-selector-btn:hover {
            border-color: #D4A574;
            background: #FFF9F0;
        }

        .work-product-selector-btn.selected {
            border-style: solid;
            border-color: #D4A574;
            background: #FFF9F0;
            color: #3D2E1F;
        }

        .work-product-selector-btn i.package-icon {
            color: #D4A574;
            font-size: 1.1rem;
        }

        .quick-create-btn {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.5rem 0.75rem;
            margin-top: 0.5rem;
            background: transparent;
            border: none;
            color: #7B95A3;
            font-size: 0.8rem;
            cursor: pointer;
            transition: color 0.2s;
        }

        .quick-create-btn:hover {
            color: #5A7A8A;
        }

        /* Create Connection Action Button */
        .create-connection-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            padding-top: 0.75rem;
            border-top: 1px solid #E5DDD1;
        }

        .create-connection-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .create-connection-btn:hover {
            background: linear-gradient(135deg, #B87B5B 0%, #A66A4A 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.3);
        }

        .create-connection-btn:disabled {
            background: #E5DDD1;
            color: #A89984;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .create-connection-btn i {
            font-size: 1rem;
        }

        /* Work Product Selector Modal */
        .work-product-selector-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .work-product-selector-overlay.active {
            display: flex;
        }

        .work-product-selector-modal {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 70vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        }

        .work-product-selector-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 2px solid #F5E6D3;
            background: linear-gradient(135deg, #D4A574 0%, #C88F4A 100%);
            color: white;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .work-product-selector-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .work-product-selector-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: background 0.2s;
        }

        .work-product-selector-close:hover {
            background: rgba(255, 255, 255, 0.35);
        }

        .work-product-selector-search {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #E5DDD1;
            background: #FAF7F5;
        }

        .work-product-selector-search input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.9rem;
            background: white;
        }

        .work-product-selector-search input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .work-product-selector-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
        }

        .work-product-category {
            margin-bottom: 0.5rem;
        }

        .work-product-category-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: #F5F0E8;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #6B5642;
            transition: background 0.2s;
        }

        .work-product-category-header:hover {
            background: #EDE5D8;
        }

        .work-product-category-header .category-toggle {
            transition: transform 0.2s;
        }

        .work-product-category-header.collapsed .category-toggle {
            transform: rotate(-90deg);
        }

        .work-product-category-items {
            padding-left: 0.5rem;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .work-product-category-items.collapsed {
            max-height: 0;
        }

        .work-product-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.875rem 1rem;
            margin: 0.25rem 0;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .work-product-item:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .work-product-item.selected {
            border-color: #C88F4A;
            background: #FFF9F0;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.2);
        }

        .work-product-item-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: linear-gradient(135deg, #D4A574 0%, #C88F4A 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.1rem;
        }

        .work-product-item-content {
            flex: 1;
        }

        .work-product-item-name {
            font-weight: 600;
            color: #3D2E1F;
            font-size: 0.95rem;
        }

        .work-product-item-desc {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-top: 0.125rem;
        }

        .work-product-selector-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid #E5DDD1;
            background: #FAF7F5;
            border-radius: 0 0 12px 12px;
            display: flex;
            gap: 0.75rem;
            justify-content: space-between;
            align-items: center;
        }

        .work-product-create-new {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex: 1;
        }

        .work-product-create-new input {
            flex: 1;
            padding: 0.625rem 0.875rem;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .work-product-create-new input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .work-product-create-btn {
            padding: 0.625rem 1rem;
            background: #8B6F47;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.375rem;
            transition: background 0.2s;
        }

        .work-product-create-btn:hover {
            background: #6B5642;
        }

        .work-product-select-btn {
            padding: 0.625rem 1.25rem;
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .work-product-select-btn:hover {
            background: #B87B5B;
        }

        .work-product-select-btn:disabled {
            background: #E5DDD1;
            cursor: not-allowed;
        }

        /* Work product selector button in modal */
        .modal-work-product-selector-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.625rem 0.875rem;
            background: white;
            border: 2px solid #E5DDD1;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            color: #6B5642;
            transition: all 0.2s;
            flex: 1;
            min-width: 150px;
        }

        .modal-work-product-selector-btn:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .modal-work-product-selector-btn.has-selection {
            border-color: #C88F4A;
            background: #FFF9F0;
            color: #3D2E1F;
            font-weight: 600;
        }

        .modal-work-product-selector-btn .btn-icon {
            color: #C88F4A;
        }

        .entity-edit-modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            padding: 1.25rem 1.5rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
        }

        /* Empty state styles */
        .modal-empty-state {
            text-align: center;
            padding: 1.5rem;
            color: #8B6F47;
            font-size: 0.9rem;
        }

        .modal-empty-state i {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }

        /* Delete confirmation */
        .delete-confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .delete-confirm-overlay.open {
            display: flex;
        }

        .delete-confirm-modal {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.3);
            overflow: hidden;
            text-align: center;
        }

        .delete-confirm-icon {
            padding: 2rem 2rem 1rem;
            font-size: 3rem;
            color: #d32f2f;
        }

        .delete-confirm-content {
            padding: 0 2rem 1.5rem;
        }

        .delete-confirm-content h3 {
            margin: 0 0 0.5rem;
            color: #3D2E1F;
            font-size: 1.25rem;
        }

        .delete-confirm-content p {
            margin: 0;
            color: #6B5642;
            font-size: 0.9rem;
        }

        .delete-confirm-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            padding: 1.25rem 1.5rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
        }

        /* ========================================== */
        /* Task Movement Confirmation Modal */
        /* ========================================== */

        .task-confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .task-confirm-overlay.active {
            display: flex;
        }

        .task-confirm-modal {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 440px;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.3);
            overflow: hidden;
            text-align: center;
        }

        .task-confirm-icon {
            padding: 2rem 2rem 1rem;
            font-size: 3rem;
            color: #f59e0b;
        }

        .task-confirm-content {
            padding: 0 2rem 1.5rem;
        }

        .task-confirm-content h3 {
            margin: 0 0 0.75rem;
            color: #3D2E1F;
            font-size: 1.25rem;
        }

        .task-confirm-content p {
            margin: 0;
            color: #6B5642;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .task-confirm-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            padding: 1.25rem 1.5rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
        }

        .task-confirm-actions .modal-action-btn.warning {
            background: #f59e0b;
            color: white;
        }

        .task-confirm-actions .modal-action-btn.warning:hover {
            background: #d97706;
        }

        /* ========================================== */
        /* Bulk Import Modal Styles */
        /* ========================================== */

        .bulk-import-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .bulk-import-overlay.open {
            display: flex;
        }

        .bulk-import-modal {
            background: white;
            border-radius: 16px;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(61, 46, 31, 0.25);
            display: flex;
            flex-direction: column;
        }

        .bulk-import-header {
            padding: 1.5rem 2rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bulk-import-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            transition: all 0.2s;
        }

        .bulk-import-close:hover {
            background: rgba(255,255,255,0.3);
        }

        .bulk-import-body {
            padding: 1.5rem 2rem;
            overflow-y: auto;
            flex: 1;
        }

        .bulk-import-steps {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .bulk-import-step {
            flex: 1;
            padding: 0.75rem 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            text-align: center;
            font-size: 0.875rem;
            color: #8B6F47;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .bulk-import-step.active {
            background: #FFF9F0;
            border-color: #C88F4A;
            color: #C88F4A;
            font-weight: 600;
        }

        .bulk-import-step.completed {
            background: #E8F5E9;
            color: #4CAF50;
        }

        .bulk-import-step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #E5DDD1;
            border-radius: 50%;
            margin-right: 0.5rem;
            font-weight: 700;
            font-size: 0.75rem;
        }

        .bulk-import-step.active .bulk-import-step-number {
            background: #C88F4A;
            color: white;
        }

        .bulk-import-step.completed .bulk-import-step-number {
            background: #4CAF50;
            color: white;
        }

        .bulk-import-section {
            margin-bottom: 1.5rem;
        }

        .bulk-import-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #6B5642;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-entity-type {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .bulk-import-entity-btn {
            padding: 0.6rem 1rem;
            border: 2px solid #E5DDD1;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-entity-btn:hover {
            border-color: #C88F4A;
        }

        .bulk-import-entity-btn.active {
            background: #C88F4A;
            color: white;
            border-color: #C88F4A;
        }

        .bulk-import-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #E5DDD1;
            padding-bottom: 0.5rem;
        }

        .bulk-import-tab {
            padding: 0.5rem 1rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.875rem;
            color: #8B6F47;
            border-radius: 6px 6px 0 0;
            transition: all 0.2s;
        }

        .bulk-import-tab:hover {
            background: #FAF7F5;
        }

        .bulk-import-tab.active {
            background: #C88F4A;
            color: white;
            font-weight: 600;
        }

        .bulk-import-textarea {
            width: 100%;
            min-height: 150px;
            padding: 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
            resize: vertical;
            transition: border-color 0.2s;
        }

        .bulk-import-textarea:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .bulk-import-textarea::placeholder {
            color: #B0A090;
        }

        .bulk-import-hint {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .bulk-import-file-upload {
            border: 2px dashed #E5DDD1;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bulk-import-file-upload:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .bulk-import-file-upload i {
            font-size: 2.5rem;
            color: #C88F4A;
            margin-bottom: 0.75rem;
        }

        .bulk-import-file-upload input {
            display: none;
        }

        .bulk-import-mapping {
            background: #FAF7F5;
            border-radius: 8px;
            padding: 1rem;
        }

        .bulk-import-mapping-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr auto;
            gap: 0.75rem;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border: 1px solid #E5DDD1;
        }

        .bulk-import-mapping-row:last-child {
            margin-bottom: 0;
        }

        .bulk-import-mapping-col {
            padding: 0.5rem 0.75rem;
            background: #F5E6D3;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            color: #6B5642;
        }

        .bulk-import-mapping-arrow {
            color: #C88F4A;
            font-size: 1.25rem;
        }

        .bulk-import-mapping-select {
            padding: 0.5rem 0.75rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
            cursor: pointer;
            min-width: 150px;
        }

        .bulk-import-mapping-select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .bulk-import-set-all {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-set-all-btn {
            padding: 0.4rem 0.6rem;
            background: #E5DDD1;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            color: #6B5642;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .bulk-import-set-all-btn:hover {
            background: #C88F4A;
            color: white;
        }

        .bulk-import-set-all-btn.active {
            background: #C88F4A;
            color: white;
        }

        .bulk-import-set-all-input {
            padding: 0.4rem 0.6rem;
            border: 1px solid #E5DDD1;
            border-radius: 4px;
            font-size: 0.8rem;
            width: 120px;
        }

        .bulk-import-set-all-input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .bulk-import-preview {
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 1rem;
        }

        .bulk-import-preview-header {
            background: #FAF7F5;
            padding: 0.75rem 1rem;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #E5DDD1;
        }

        .bulk-import-preview-count {
            background: #C88F4A;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .bulk-import-preview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        .bulk-import-preview-table th {
            background: #F5F2ED;
            padding: 0.6rem 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #6B5642;
            border-bottom: 1px solid #E5DDD1;
        }

        .bulk-import-preview-table td {
            padding: 0.6rem 0.75rem;
            border-bottom: 1px solid #F0EBE4;
        }

        .bulk-import-preview-table tr:hover {
            background: #FFF9F0;
        }

        .bulk-import-preview-table tr.error {
            background: #FFF5F5;
        }

        .bulk-import-preview-table .preview-error {
            color: #d32f2f;
            font-size: 0.75rem;
        }

        .bulk-import-preview-table .preview-set-all {
            color: #C88F4A;
            font-style: italic;
        }

        .bulk-import-preview-table .row-number {
            color: #B8A99A;
            font-size: 0.7rem;
            font-weight: 400;
            text-align: center;
            width: 30px;
            padding-right: 0.5rem;
        }

        .bulk-import-preview-table th.row-number-header {
            color: #B8A99A;
            font-size: 0.7rem;
            font-weight: 400;
            text-align: center;
            width: 30px;
        }

        .bulk-import-footer {
            padding: 1rem 2rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bulk-import-footer-info {
            font-size: 0.875rem;
            color: #8B6F47;
        }

        .bulk-import-footer-actions {
            display: flex;
            gap: 0.75rem;
        }

        .bulk-import-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-import-btn.secondary {
            background: white;
            border: 2px solid #E5DDD1;
            color: #6B5642;
        }

        .bulk-import-btn.secondary:hover {
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .bulk-import-btn.primary {
            background: #C88F4A;
            border: 2px solid #C88F4A;
            color: white;
        }

        .bulk-import-btn.primary:hover {
            background: #B87B5B;
            border-color: #B87B5B;
        }

        .bulk-import-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bulk-import-success {
            text-align: center;
            padding: 2rem;
        }

        .bulk-import-success i {
            font-size: 4rem;
            color: #4CAF50;
            margin-bottom: 1rem;
        }

        .bulk-import-success h3 {
            font-size: 1.25rem;
            color: #3D2E1F;
            margin-bottom: 0.5rem;
        }

        .bulk-import-success p {
            color: #8B6F47;
        }

        /* Undo Button Styles */
        .undo-btn {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            padding: 0.4rem 0.75rem;
            color: white;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .undo-btn:hover:not(:disabled) {
            background: rgba(255,255,255,0.25);
            border-color: rgba(255,255,255,0.5);
        }

        .undo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .undo-btn .undo-count {
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 0 0.4rem;
            font-size: 0.75rem;
            min-width: 1.25rem;
            text-align: center;
        }

        .header-icon-btn .undo-count {
            position: absolute;
            top: -4px;
            right: -4px;
            background: rgba(255,255,255,0.9);
            color: #9A6B3A;
            border-radius: 10px;
            padding: 0 0.3rem;
            font-size: 0.65rem;
            min-width: 1rem;
            text-align: center;
            font-weight: 600;
        }

        /* Undo Notification Styles */
        .undo-notification {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #3D2E1F;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            font-size: 0.9rem;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .undo-notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Activity Feed Section Styles */
        .activity-feed-section {
            margin-top: 1rem;
            border-top: 1px solid #E5DDD1;
            padding-top: 1rem;
        }

        .activity-feed-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: background 0.15s;
        }

        .activity-feed-header:hover {
            background: #FAF7F5;
        }

        .activity-feed-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.85rem;
        }

        .activity-feed-count {
            background: #E8B86D;
            color: white;
            border-radius: 10px;
            padding: 0.1rem 0.5rem;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .activity-feed-toggle {
            color: #8B6F47;
            transition: transform 0.2s;
        }

        .activity-feed-section.collapsed .activity-feed-toggle {
            transform: rotate(-90deg);
        }

        .activity-feed-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .activity-feed-section.collapsed .activity-feed-list {
            display: none;
        }

        .activity-feed-empty {
            text-align: center;
            padding: 1rem;
            color: #8B6F47;
            font-size: 0.8rem;
        }

        .activity-feed-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #5A4A3A;
            transition: background 0.15s;
        }

        .activity-feed-item:hover {
            background: #FAF7F5;
        }

        .activity-feed-item i {
            color: #C88F4A;
            font-size: 0.9rem;
            margin-top: 0.1rem;
        }

        .activity-feed-item-content {
            flex: 1;
        }

        .activity-feed-item-text {
            line-height: 1.3;
        }

        .activity-feed-item-time {
            font-size: 0.7rem;
            color: #8B6F47;
            margin-top: 0.15rem;
        }

        /* Entity History Section Styles */
        .entity-history-section {
            margin-top: 1rem;
            border-top: 1px solid #E5DDD1;
            padding-top: 1rem;
        }

        .entity-history-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: background 0.15s;
        }

        .entity-history-header:hover {
            background: #FAF7F5;
        }

        .entity-history-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.85rem;
        }

        .entity-history-toggle {
            color: #8B6F47;
            transition: transform 0.2s;
        }

        .entity-history-section.collapsed .entity-history-toggle {
            transform: rotate(-90deg);
        }

        .entity-history-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .entity-history-section.collapsed .entity-history-list {
            display: none;
        }

        .entity-history-empty {
            text-align: center;
            padding: 1rem;
            color: #8B6F47;
            font-size: 0.8rem;
        }

        .entity-history-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            background: #FAF7F5;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            color: #5A4A3A;
        }

        .entity-history-item:last-child {
            margin-bottom: 0;
        }

        .entity-history-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 0.85rem;
        }

        .entity-history-icon.alt {
            background: #E8F5E9;
            color: #2E7D32;
        }

        .entity-history-icon.des {
            background: #E3F2FD;
            color: #1565C0;
        }

        .entity-history-icon.con {
            background: #FFF3E0;
            color: #E65100;
        }

        .entity-history-icon.nul {
            background: #FFEBEE;
            color: #C62828;
        }

        .entity-history-content {
            flex: 1;
            min-width: 0;
        }

        .entity-history-action {
            font-weight: 600;
            color: #3D2E1F;
            line-height: 1.4;
        }

        .entity-history-change {
            margin-top: 0.25rem;
            padding: 0.4rem 0.6rem;
            background: white;
            border-radius: 4px;
            border: 1px solid #E5DDD1;
            font-size: 0.75rem;
        }

        .entity-history-change-old {
            text-decoration: line-through;
            color: #999;
        }

        .entity-history-change-arrow {
            color: #C88F4A;
            margin: 0 0.25rem;
        }

        .entity-history-change-new {
            color: #2E7D32;
            font-weight: 500;
        }

        .entity-history-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.35rem;
            font-size: 0.7rem;
            color: #8B6F47;
        }

        .entity-history-user {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .entity-history-time {
            opacity: 0.8;
        }

        .entity-history-loading {
            text-align: center;
            padding: 1rem;
            color: #8B6F47;
        }

        .entity-history-loading i {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Recycle Bin Section Styles */
        .recycle-bin-section {
            margin-top: 1rem;
            border-top: 1px solid #E5DDD1;
            padding-top: 1rem;
        }

        .recycle-bin-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .recycle-bin-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.9rem;
        }

        .recycle-bin-count {
            background: #E5DDD1;
            color: #6B5642;
            border-radius: 10px;
            padding: 0.1rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .recycle-bin-empty-btn {
            background: none;
            border: none;
            color: #8B6F47;
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.15s;
        }

        .recycle-bin-empty-btn:hover {
            background: #FAF7F5;
            color: #d32f2f;
        }

        .recycle-bin-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .recycle-bin-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            color: #A89984;
            text-align: center;
        }

        .recycle-bin-empty i {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }

        .recycle-bin-empty p {
            margin: 0;
            font-size: 0.85rem;
        }

        .recycle-bin-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: #FAF7F5;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            transition: all 0.15s;
        }

        .recycle-bin-item:hover {
            background: #F5EFE6;
        }

        .recycle-bin-item-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            min-width: 0;
        }

        .recycle-bin-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.5rem;
            color: #8B6F47;
        }

        .recycle-bin-details {
            flex: 1;
            min-width: 0;
        }

        .recycle-bin-name {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: #3D2E1F;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .recycle-bin-meta {
            display: block;
            font-size: 0.7rem;
            color: #A89984;
        }

        .recycle-bin-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .recycle-bin-item:hover .recycle-bin-actions {
            opacity: 1;
        }

        .recycle-bin-actions .btn-icon {
            padding: 0.25rem;
            border-radius: 4px;
            color: #8B6F47;
        }

        .recycle-bin-actions .btn-icon:hover {
            background: rgba(0,0,0,0.05);
            color: #C88F4A;
        }

        .recycle-bin-actions .btn-icon.delete:hover {
            color: #d32f2f;
        }

        /* Sidebar Tabs Styles */
        .sidebar-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            padding: 4px;
            margin-top: 2.5rem;
        }

        .sidebar-tab {
            flex: 1;
            padding: 0.5rem 0.75rem;
            border: none;
            background: transparent;
            color: #8B6F47;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.35rem;
        }

        .sidebar-tab:hover {
            color: #6B5642;
            background: rgba(255, 255, 255, 0.5);
        }

        .sidebar-tab.active {
            background: white;
            color: #3D2E1F;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .sidebar-tab i {
            font-size: 1rem;
        }

        .sidebar-tab-content {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .sidebar-tab-content.active {
            display: flex;
        }

        .sidebar-tab-scroll {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        /* People tab specific styles */
        .people-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .person-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: #FAF7F5;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .person-card:hover {
            background: #F5EFE6;
            transform: translateX(2px);
        }

        .person-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        .person-info {
            flex: 1;
            min-width: 0;
        }

        .person-name {
            font-weight: 500;
            color: #3D2E1F;
            font-size: 0.9rem;
            margin-bottom: 0.15rem;
        }

        .person-roles {
            font-size: 0.75rem;
            color: #8B6F47;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            word-break: break-word;
        }

        .person-actions {
            opacity: 0;
            transition: opacity 0.15s;
        }

        .person-card:hover .person-actions {
            opacity: 1;
        }

        /* Recent tab styles */
        .recent-section {
            margin-bottom: 1rem;
        }

        .recent-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #E5DDD1;
            margin-bottom: 0.5rem;
        }

        .recent-section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Sidebar add button */
        .sidebar-add-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: auto;
            flex-shrink: 0;
        }

        .sidebar-add-btn:hover {
            background: linear-gradient(135deg, #D9A05B 0%, #C98C6C 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.3);
        }

        .sidebar-add-btn i {
            font-size: 1.1rem;
        }

        /* Adjust panel-left for flex layout */
        .panel-left {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-left .entity-list {
            flex: 1;
            overflow-y: auto;
        }

        /* Activity feed in Recent tab - remove max-height constraint */
        .recent-section .activity-feed-list {
            max-height: none;
        }

        .recent-section .recycle-bin-list {
            max-height: none;
        }

        /* Empty state for tabs */
        .tab-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem 1rem;
            text-align: center;
            color: #8B6F47;
        }

        .tab-empty-state i {
            font-size: 2.5rem;
            opacity: 0.4;
            margin-bottom: 0.75rem;
        }

        .tab-empty-state p {
            margin: 0;
            font-size: 0.85rem;
            opacity: 0.8;
        }

        /* Task Wizard Styles */
        .task-wizard {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            margin-bottom: 1rem;
        }

        .task-wizard-cta {
            text-align: center;
        }

        .task-wizard-cta h3 {
            display: none; /* Simplified - just show button */
        }

        .task-wizard-cta .btn-create-task {
            background: #C88F4A;
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.3);
        }

        .task-wizard-cta .btn-create-task:hover {
            background: #B07D3A;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.4);
        }

        .task-wizard-cta .helper-links {
            display: none; /* Simplified - hide helper links */
        }

        .task-wizard-cta .helper-links a {
            color: #C88F4A;
            cursor: pointer;
            text-decoration: underline;
        }

        .task-wizard-steps {
            display: none;
        }

        .task-wizard-steps.active {
            display: block;
        }

        .wizard-step {
            display: none;
        }

        .wizard-step.active {
            display: block;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .wizard-step-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .wizard-step-number {
            background: #C88F4A;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .wizard-step-title {
            color: #6B5642;
            font-weight: 600;
            font-size: 1rem;
        }

        .wizard-step-subtitle {
            color: #8B6F47;
            font-size: 0.85rem;
            margin-left: auto;
        }

        .wizard-input {
            width: 100%;
            padding: 0.875rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        .wizard-input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .wizard-select-grid {
            display: grid;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .wizard-select-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
            background: white;
        }

        .wizard-select-option:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .wizard-select-option.selected {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .wizard-select-option i {
            font-size: 1.25rem;
            color: #8B6F47;
        }

        .wizard-select-option.selected i {
            color: #C88F4A;
        }

        .wizard-create-new {
            border-style: dashed;
            color: #8B6F47;
        }

        .wizard-create-new:hover {
            border-style: solid;
        }

        .wizard-inline-create {
            display: none;
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: white;
            border-radius: 8px;
            border: 1px solid #E5DDD1;
        }

        .wizard-inline-create.active {
            display: block;
        }

        .wizard-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.25rem;
        }

        .wizard-actions .btn {
            flex: 1;
        }

        .wizard-actions .btn-back {
            background: transparent;
            color: #8B6F47;
            border: 1px solid #E5DDD1;
        }

        .wizard-summary {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .wizard-summary-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid #E5DDD1;
        }

        .wizard-summary-item:last-child {
            border-bottom: none;
        }

        .wizard-summary-label {
            color: #8B6F47;
            font-size: 0.85rem;
            min-width: 60px;
        }

        .wizard-summary-value {
            color: #6B5642;
            font-weight: 500;
        }

        .wizard-progress {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .wizard-progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #E5DDD1;
            transition: all 0.2s;
        }

        .wizard-progress-dot.active {
            background: #C88F4A;
            transform: scale(1.25);
        }

        .wizard-progress-dot.completed {
            background: #8B6F47;
        }

        .wizard-skip-hint {
            text-align: center;
            margin-top: 0.75rem;
            font-size: 0.8rem;
            color: #8B6F47;
        }

        .wizard-skip-hint a {
            color: #C88F4A;
            cursor: pointer;
        }

        /* Compact Task CTA - Always visible quick action */
        .task-quick-cta {
            background: linear-gradient(135deg, #FFF9F0 0%, #FAF7F5 100%);
            border: 2px solid #C88F4A;
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
            text-align: center;
        }

        .task-quick-cta .btn-create-task {
            background: #C88F4A;
            color: white;
            border: none;
            padding: 0.875rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.3);
            width: 100%;
            justify-content: center;
        }

        .task-quick-cta .btn-create-task:hover {
            background: #B07D3A;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.4);
        }

        .task-quick-cta .btn-create-task i {
            font-size: 1.25rem;
        }

        /* ============================================
           HERO TASK CREATION STYLES
           ============================================ */

        /* Floating Action Button (FAB) */
        .task-fab {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(200, 143, 74, 0.4), 0 8px 32px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .task-fab:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 28px rgba(200, 143, 74, 0.5), 0 12px 40px rgba(0, 0, 0, 0.2);
        }

        .task-fab i {
            font-size: 2rem;
            color: white;
        }

        .task-fab-label {
            position: absolute;
            right: 80px;
            background: #3D2E1F;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            transform: translateX(10px);
            transition: all 0.3s;
            pointer-events: none;
        }

        .task-fab:hover .task-fab-label {
            opacity: 1;
            transform: translateX(0);
        }

        .task-fab-pulse {
            animation: fabPulse 2s infinite;
        }

        @keyframes fabPulse {
            0%, 100% { box-shadow: 0 4px 20px rgba(200, 143, 74, 0.4), 0 8px 32px rgba(0, 0, 0, 0.15); }
            50% { box-shadow: 0 4px 20px rgba(200, 143, 74, 0.6), 0 8px 32px rgba(0, 0, 0, 0.15), 0 0 0 8px rgba(200, 143, 74, 0.15); }
        }

        /* Hero Task Modal */
        .hero-task-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }

        .hero-task-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .hero-task-modal {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .hero-task-header {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            padding: 1.5rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .hero-task-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .hero-task-header h2 i {
            font-size: 1.75rem;
        }

        .hero-task-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .hero-task-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .hero-task-body {
            padding: 2rem;
        }

        .hero-task-input-group {
            margin-bottom: 1.5rem;
        }

        .hero-task-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            color: #6B5642;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .hero-task-main-input {
            width: 100%;
            padding: 1.25rem 1rem;
            font-size: 1.25rem;
            border: 2px solid #E5DDD1;
            border-radius: 12px;
            background: #FAF7F5;
            color: #3D2E1F;
            transition: all 0.2s;
        }

        .hero-task-main-input:focus {
            outline: none;
            border-color: #C88F4A;
            background: white;
            box-shadow: 0 0 0 4px rgba(200, 143, 74, 0.15);
        }

        .hero-task-main-input::placeholder {
            color: #A99D8F;
        }

        .hero-task-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        .hero-task-select-wrapper {
            position: relative;
        }

        .hero-task-select {
            width: 100%;
            padding: 0.875rem 1rem;
            font-size: 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            background: #FAF7F5;
            color: #3D2E1F;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
            padding-right: 2.5rem;
        }

        .hero-task-select:focus {
            outline: none;
            border-color: #C88F4A;
            background: white;
        }

        .hero-task-select-wrapper::after {
            content: '▼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            color: #6B5642;
            pointer-events: none;
        }

        .hero-task-or-create {
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #8B6F47;
        }

        .hero-task-or-create a {
            color: #C88F4A;
            cursor: pointer;
            font-weight: 500;
        }

        .hero-task-or-create a:hover {
            text-decoration: underline;
        }

        .hero-task-inline-create {
            margin-top: 0.75rem;
            display: none;
        }

        .hero-task-inline-create.active {
            display: block;
        }

        .hero-task-inline-row {
            display: flex;
            gap: 0.5rem;
        }

        .hero-task-inline-input {
            flex: 1;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            border: 2px solid #C88F4A;
            border-radius: 8px;
            background: #FFF9F0;
        }

        .hero-task-inline-input:focus {
            outline: none;
            background: white;
        }

        .hero-task-inline-btn {
            padding: 0.75rem 1rem;
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .hero-task-inline-btn:hover {
            background: #B07D3A;
        }

        .hero-task-workflow-prompt {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #FFF9F0 0%, #F5EDE0 100%);
            border: 1px dashed #C88F4A;
            border-radius: 8px;
            color: #8B6914;
            font-size: 0.85rem;
        }

        .hero-task-workflow-prompt i {
            color: #C88F4A;
            font-size: 1.1rem;
        }

        .hero-task-date-input {
            width: 100%;
            padding: 0.875rem 1rem;
            font-size: 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            background: #FAF7F5;
            color: #3D2E1F;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hero-task-date-input:focus {
            outline: none;
            border-color: #C88F4A;
            background: white;
        }

        .hero-task-dependency-warning {
            margin-top: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: #FFF3E0;
            border: 1px solid #FFB74D;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #E65100;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hero-task-dependency-warning i {
            font-size: 1rem;
        }

        .hero-task-dependency-info {
            margin-top: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: #E8F5E9;
            border: 1px solid #A5D6A7;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #2E7D32;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Advanced Options Toggle */
        .hero-task-advanced-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.75rem 1rem;
            margin: 0.5rem 0 1rem 0;
            background: transparent;
            border: 1px dashed #D5C9B9;
            border-radius: 8px;
            color: #8B6F47;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hero-task-advanced-toggle:hover {
            background: #FAF7F5;
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .hero-task-advanced-toggle i {
            transition: transform 0.2s;
        }

        .hero-task-advanced-toggle.expanded i {
            transform: rotate(180deg);
        }

        .hero-task-advanced-options {
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .hero-task-essential-options {
            margin-bottom: 0.5rem;
        }

        /* Flatpickr custom theme to match app */
        .flatpickr-calendar {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
            border: 1px solid #E5DDD1;
        }

        .flatpickr-months {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            border-radius: 11px 11px 0 0;
            padding: 0.5rem 0;
        }

        .flatpickr-months .flatpickr-month {
            color: white;
            fill: white;
        }

        .flatpickr-current-month .flatpickr-monthDropdown-months,
        .flatpickr-current-month input.cur-year {
            color: white;
            font-weight: 600;
        }

        .flatpickr-months .flatpickr-prev-month,
        .flatpickr-months .flatpickr-next-month {
            color: white;
            fill: white;
        }

        .flatpickr-months .flatpickr-prev-month:hover,
        .flatpickr-months .flatpickr-next-month:hover {
            color: #FFF9F0;
        }

        .flatpickr-weekdays {
            background: #FAF7F5;
        }

        .flatpickr-weekday {
            color: #6B5642;
            font-weight: 600;
        }

        .flatpickr-day {
            color: #3D2E1F;
            border-radius: 6px;
        }

        .flatpickr-day:hover {
            background: #FFF9F0;
            border-color: #C88F4A;
        }

        .flatpickr-day.selected,
        .flatpickr-day.selected:hover {
            background: #C88F4A;
            border-color: #C88F4A;
            color: white;
        }

        .flatpickr-day.today {
            border-color: #C88F4A;
        }

        .flatpickr-day.today:hover {
            background: #FFF9F0;
        }

        .flatpickr-day.disabled,
        .flatpickr-day.disabled:hover {
            color: #D5C9B9;
        }

        .hero-task-preview {
            background: linear-gradient(135deg, #FFF9F0 0%, #FAF7F5 100%);
            border: 2px dashed #E5DDD1;
            border-radius: 12px;
            padding: 1.25rem;
            margin-top: 1.5rem;
        }

        .hero-task-preview-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.75rem;
        }

        .hero-task-preview-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .hero-task-preview-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.9rem;
            color: #3D2E1F;
            border: 1px solid #E5DDD1;
        }

        .hero-task-preview-item i {
            font-size: 1rem;
        }

        .hero-task-preview-item.task {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .hero-task-preview-item.role {
            border-color: #4A90C8;
            background: #F0F7FF;
        }

        .hero-task-preview-item.person {
            border-color: #5AB07B;
            background: #F0FFF5;
        }

        .hero-task-preview-item.workflow {
            border-color: #9C27B0;
            background: #F3E5F5;
        }

        .hero-task-preview-item.due-date {
            border-color: #8B6F47;
            background: #FFF9F0;
        }

        .hero-task-preview-item.dependency {
            border-color: #1565C0;
            background: #E3F2FD;
            font-size: 0.85rem;
        }

        .hero-task-preview-arrow {
            color: #C88F4A;
            font-weight: bold;
        }

        .hero-task-footer {
            padding: 1.5rem 2rem;
            background: #FAF7F5;
            border-top: 1px solid #E5DDD1;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .hero-task-shortcut-hint {
            font-size: 0.8rem;
            color: #8B6F47;
        }

        .hero-task-shortcut-hint kbd {
            background: white;
            border: 1px solid #E5DDD1;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.75rem;
        }

        .hero-task-actions {
            display: flex;
            gap: 0.75rem;
        }

        .hero-task-btn {
            padding: 0.875rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hero-task-btn i {
            font-size: 1.25rem;
        }

        .hero-task-btn-secondary {
            background: white;
            border: 2px solid #E5DDD1;
            color: #6B5642;
        }

        .hero-task-btn-secondary:hover {
            background: #FAF7F5;
            border-color: #C88F4A;
        }

        .hero-task-btn-primary {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            border: none;
            color: white;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.3);
        }

        .hero-task-btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.4);
        }

        .hero-task-btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* ============================================
           QUICK ADD MODAL STYLES
           ============================================ */

        .quick-add-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.5);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }

        .quick-add-modal-overlay.active {
            display: flex;
        }

        .quick-add-modal {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow: visible;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease-out;
            position: relative;
        }

        .quick-add-modal-header {
            padding: 24px 24px 16px 24px;
            border-bottom: 1px solid #f0f0f0;
        }

        .quick-add-modal-title-input {
            font-size: 20px;
            font-weight: 600;
            border: none;
            width: 100%;
            outline: none;
            color: #333;
            background: #fafafa;
            padding: 12px 16px;
            border-radius: 8px;
            transition: background 0.2s, box-shadow 0.2s;
        }

        .quick-add-modal-title-input:focus {
            background: white;
            box-shadow: 0 0 0 2px rgba(200, 143, 74, 0.3);
        }

        .quick-add-modal-prompt {
            background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
            border-left: 3px solid #10b981;
            padding: 12px 16px;
            margin-top: 16px;
            border-radius: 6px;
            font-size: 14px;
            color: #065f46;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: gentle-pulse 2.5s ease-in-out infinite;
        }

        @keyframes gentle-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }

        .quick-add-modal-prompt i {
            font-size: 18px;
            color: #10b981;
        }

        .quick-add-modal-prompt strong {
            background: rgba(16, 185, 129, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
        }

        .quick-add-modal-meta {
            padding: 16px 24px;
            background: #fafafa;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .quick-add-meta-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: white;
            border: 1px dashed #d0d0d0;
            border-radius: 8px;
            font-size: 13px;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-add-meta-chip:hover {
            border-color: #C88F4A;
            color: #333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 143, 74, 0.15);
        }

        .quick-add-meta-chip.filled {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            border: 1px solid #C88F4A;
            border-style: solid;
        }

        .quick-add-meta-chip.filled:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.3);
        }

        .quick-add-meta-chip.error {
            border: 2px solid #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        .quick-add-meta-chip i {
            font-size: 16px;
        }

        .quick-add-dropdown {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
            border: 1px solid #e5e5e5;
            padding: 8px 0;
            min-width: 180px;
            z-index: 100;
            display: none;
            left: 24px;
            top: auto;
            margin-top: 4px;
        }

        .quick-add-dropdown.show {
            display: block;
            animation: dropdownSlide 0.2s ease-out;
        }

        @keyframes dropdownSlide {
            from { opacity: 0; transform: translateY(-8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .quick-add-dropdown-item {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #555;
            font-size: 14px;
            transition: background 0.15s;
        }

        .quick-add-dropdown-item:hover {
            background: #f5f5f5;
            color: #333;
        }

        .quick-add-dropdown-item i {
            font-size: 16px;
            color: #C88F4A;
        }

        .quick-add-dropdown-item.selected {
            background: rgba(200, 143, 74, 0.1);
            color: #C88F4A;
            font-weight: 500;
        }

        /* Hierarchical Role Selector Styles */
        .role-hierarchy-section {
            border-bottom: 1px solid #eee;
        }

        .role-hierarchy-section:last-child {
            border-bottom: none;
        }

        .role-hierarchy-header {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #666;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #fafafa;
            transition: background 0.15s;
        }

        .role-hierarchy-header:hover {
            background: #f0f0f0;
        }

        .role-hierarchy-header i {
            font-size: 14px;
            transition: transform 0.2s;
        }

        .role-hierarchy-header.expanded i.toggle-icon {
            transform: rotate(90deg);
        }

        .role-hierarchy-header .header-icon {
            color: #C88F4A;
        }

        .role-hierarchy-content {
            display: none;
        }

        .role-hierarchy-content.expanded {
            display: block;
        }

        .role-hierarchy-team {
            border-left: 2px solid #e0e0e0;
            margin-left: 16px;
        }

        .role-hierarchy-team-header {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #555;
            font-size: 13px;
            font-weight: 500;
            background: #f8f8f8;
            transition: background 0.15s;
        }

        .role-hierarchy-team-header:hover {
            background: #f0f0f0;
        }

        .role-hierarchy-team-header i {
            font-size: 13px;
        }

        .role-hierarchy-team-header i.toggle-icon {
            transition: transform 0.2s;
        }

        .role-hierarchy-team-header.expanded i.toggle-icon {
            transform: rotate(90deg);
        }

        .role-hierarchy-team-header .header-icon {
            color: #6B5642;
        }

        .role-hierarchy-team-content {
            display: none;
        }

        .role-hierarchy-team-content.expanded {
            display: block;
        }

        .role-hierarchy-roles {
            padding-left: 8px;
        }

        .role-hierarchy-orphan-header {
            padding: 10px 16px;
            color: #888;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #f5f5f5;
        }

        .quick-add-modal-description {
            padding: 20px 24px;
        }

        .quick-add-description-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .quick-add-description-label i {
            font-size: 14px;
        }

        .quick-add-description-textarea {
            width: 100%;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 14px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
            line-height: 1.5;
        }

        .quick-add-description-textarea:focus {
            border-color: #C88F4A;
            box-shadow: 0 0 0 3px rgba(200, 143, 74, 0.1);
        }

        .quick-add-description-textarea::placeholder {
            color: #aaa;
        }

        .quick-add-modal-footer {
            padding: 16px 24px;
            border-top: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fafafa;
            border-radius: 0 0 12px 12px;
        }

        .quick-add-footer-hint {
            font-size: 13px;
            color: #888;
        }

        .quick-add-footer-hint strong {
            background: #e5e5e5;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            color: #555;
        }

        .quick-add-footer-actions {
            display: flex;
            gap: 10px;
        }

        .quick-add-btn {
            padding: 10px 18px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .quick-add-btn-ghost {
            background: transparent;
            color: #666;
        }

        .quick-add-btn-ghost:hover {
            background: #f0f0f0;
            color: #333;
        }

        .quick-add-btn-primary {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.3);
        }

        .quick-add-btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.4);
        }

        /* ============================================
           WORKFLOW SUGGESTION MODAL STYLES
           ============================================ */

        .workflow-suggestion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            backdrop-filter: blur(4px);
            z-index: 2100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }

        .workflow-suggestion-overlay.active {
            display: flex;
        }

        .workflow-suggestion-modal {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease-out;
        }

        .workflow-suggestion-header {
            background: linear-gradient(135deg, #7B95A3 0%, #6B8593 100%);
            color: white;
            padding: 1.25rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .workflow-suggestion-header h3 {
            font-size: 1.125rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .workflow-suggestion-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .workflow-suggestion-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .workflow-suggestion-body {
            padding: 1.5rem;
        }

        .workflow-suggestion-message {
            font-size: 0.95rem;
            color: #3D2E1F;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .workflow-suggestion-tasks {
            background: #FAF7F5;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.25rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .workflow-suggestion-task {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.625rem;
            background: white;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border: 1px solid #E5DDD1;
        }

        .workflow-suggestion-task:last-child {
            margin-bottom: 0;
        }

        .suggestion-task-order {
            background: #C88F4A;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .suggestion-task-name {
            flex: 1;
            font-size: 0.9rem;
            color: #3D2E1F;
        }

        .suggestion-similarity {
            font-size: 0.75rem;
            color: #7B95A3;
            background: #F0F4F6;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }

        .workflow-suggestion-input {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.95rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s;
        }

        .workflow-suggestion-input:focus {
            outline: none;
            border-color: #7B95A3;
        }

        .workflow-suggestion-footer {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .workflow-suggestion-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .workflow-suggestion-btn-secondary {
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            color: #6B5642;
        }

        .workflow-suggestion-btn-secondary:hover {
            background: #F5F0EB;
        }

        .workflow-suggestion-btn-primary {
            background: #7B95A3;
            border: none;
            color: white;
        }

        .workflow-suggestion-btn-primary:hover {
            background: #6B8593;
        }

        /* ============================================
           TASK LINK MODAL STYLES
           ============================================ */

        .task-link-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(61, 46, 31, 0.7);
            backdrop-filter: blur(4px);
            z-index: 2100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }

        .task-link-overlay.active {
            display: flex;
        }

        .task-link-modal {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 450px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease-out;
        }

        .task-link-header {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            padding: 1.25rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .task-link-header h3 {
            font-size: 1.125rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-link-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .task-link-body {
            padding: 1.5rem;
        }

        .task-link-select-group {
            margin-bottom: 1.25rem;
        }

        .task-link-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            color: #6B5642;
            margin-bottom: 0.5rem;
        }

        .task-link-select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.9rem;
            background: white;
        }

        .task-link-select:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .task-link-option-group {
            margin-bottom: 1.25rem;
        }

        .task-link-option {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.875rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .task-link-option:hover {
            border-color: #C88F4A;
            background: #FAF7F5;
        }

        .task-link-option.selected {
            border-color: #C88F4A;
            background: #FDF8F3;
        }

        .task-link-option input[type="radio"] {
            margin-top: 2px;
        }

        .task-link-option-content {
            flex: 1;
        }

        .task-link-option-title {
            font-weight: 600;
            color: #3D2E1F;
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .task-link-option-desc {
            font-size: 0.8rem;
            color: #8B6F47;
        }

        .task-link-footer {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            padding-top: 0.5rem;
        }

        .task-link-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .task-link-btn-secondary {
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            color: #6B5642;
        }

        .task-link-btn-primary {
            background: #C88F4A;
            border: none;
            color: white;
        }

        .task-link-btn-primary:hover {
            background: #B87B5B;
        }

        /* ============================================
           VIOLATION BADGE STYLES
           ============================================ */

        .violation-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.625rem;
            background: #FEF3C7;
            color: #92400E;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .violation-badge:hover {
            background: #FDE68A;
        }

        .violation-badge i {
            font-size: 0.875rem;
        }

        .task-linked-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.625rem;
            background: #DBEAFE;
            color: #1E40AF;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .task-linked-badge.hard-link {
            background: #FEE2E2;
            color: #991B1B;
        }

        /* ============================================
           TASK BOARD VIEW STYLES
           ============================================ */

        .task-board-view {
            display: none;
            flex-direction: column;
            height: 100%;
            background: #FAF7F5;
        }

        .task-board-view.active {
            display: flex;
        }

        .task-board-header {
            padding: 1.5rem;
            background: white;
            border-bottom: 1px solid #E5DDD1;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .task-board-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #3D2E1F;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .task-board-title i {
            color: #C88F4A;
        }

        .task-board-stats {
            display: flex;
            gap: 1.5rem;
        }

        .task-board-stat {
            text-align: center;
        }

        .task-board-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #C88F4A;
        }

        .task-board-stat-label {
            font-size: 0.75rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .task-board-controls {
            padding: 1rem 1.5rem;
            background: white;
            border-bottom: 1px solid #E5DDD1;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .task-board-search {
            padding: 0.625rem 1rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.9rem;
            width: 160px;
        }

        .task-board-search:focus {
            outline: none;
            border-color: #C88F4A;
        }

        .task-board-filter {
            padding: 0.625rem 1rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* Inline Filter Controls */
        .inline-filter-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .inline-filter-group {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #F8F5F0;
            border-radius: 6px;
            padding: 4px;
        }

        .inline-filter-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            background: transparent;
            font-size: 0.8rem;
            cursor: pointer;
            color: #6B5642;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .inline-filter-btn:hover {
            background: rgba(200, 143, 74, 0.15);
        }

        .inline-filter-btn.active {
            background: white;
            color: #3D2E1F;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .inline-filter-btn i {
            font-size: 0.9rem;
        }

        .inline-filter-btn.status-pending.active { color: #8B6F47; }
        .inline-filter-btn.status-in_progress.active { color: #C88F4A; }
        .inline-filter-btn.status-completed.active { color: #5B8A5A; }

        .inline-filter-divider {
            width: 1px;
            height: 20px;
            background: #E5DDD1;
            margin: 0 4px;
        }

        .inline-filter-more-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px 10px;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            background: white;
            font-size: 0.8rem;
            cursor: pointer;
            color: #6B5642;
            gap: 4px;
            transition: all 0.15s ease;
        }

        .inline-filter-more-btn:hover {
            background: #F8F5F0;
            border-color: #C88F4A;
        }

        .inline-filter-more-btn.has-filters {
            background: #FDF8F3;
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .inline-filter-badge {
            background: #C88F4A;
            color: white;
            font-size: 0.65rem;
            padding: 2px 5px;
            border-radius: 10px;
            font-weight: 600;
        }

        /* Content-Level Filter Bar - filters at engagement level */
        .content-filter-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #FDFBF8;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid #EDE8E0;
        }

        .content-filter-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .content-filter-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .content-filter-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid #E5DDD1;
            border-radius: 20px;
            background: white;
            font-size: 0.85rem;
            cursor: pointer;
            color: #8B6F47;
            transition: all 0.15s ease;
        }

        .content-filter-chip:hover {
            border-color: #C88F4A;
            background: #FDF8F3;
        }

        .content-filter-chip.active {
            background: #3D2E1F;
            border-color: #3D2E1F;
            color: white;
        }

        .content-filter-chip.active:hover {
            background: #2A1F14;
            border-color: #2A1F14;
        }

        .content-filter-chip i {
            font-size: 1rem;
        }

        .content-filter-count {
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(0,0,0,0.08);
            padding: 2px 6px;
            border-radius: 10px;
        }

        .content-filter-chip.active .content-filter-count {
            background: rgba(255,255,255,0.2);
        }

        .content-filter-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .content-filter-more {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            background: white;
            font-size: 0.85rem;
            cursor: pointer;
            color: #6B5642;
            transition: all 0.15s ease;
        }

        .content-filter-more:hover {
            border-color: #C88F4A;
            background: #FDF8F3;
        }

        .content-filter-more.has-filters {
            background: #FDF8F3;
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .content-filter-more i {
            font-size: 1rem;
        }

        .content-filter-badge {
            background: #C88F4A;
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 600;
        }

        /* Quick Add Bar - Simplified task creation */
        .quick-add-bar {
            display: flex;
            gap: 12px;
            align-items: center;
            background: white;
            padding: 14px 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            position: relative;
            transition: all 0.2s ease;
            border: 1px solid #E5DDD1;
            flex: 1;
        }

        .quick-add-bar.focused {
            box-shadow: 0 4px 16px rgba(200, 143, 74, 0.2);
            border-color: #C88F4A;
        }

        .quick-add-bar input {
            border: none;
            font-size: 15px;
            flex: 1;
            outline: none;
            color: #3D2E1F;
            background: transparent;
        }

        .quick-add-bar input::placeholder {
            color: #A09080;
        }

        .priority-dots {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .priority-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .priority-dot::after {
            content: attr(data-label);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: #3D3229;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 1000;
        }

        .priority-dot::before {
            content: '';
            position: absolute;
            bottom: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: #3D3229;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 1000;
        }

        .priority-dot:hover::after,
        .priority-dot:hover::before {
            opacity: 1;
            visibility: visible;
        }

        .priority-dot:hover {
            transform: scale(1.3);
        }

        .priority-dot.active {
            border-width: 3px;
            transform: scale(1.15);
        }

        .priority-dot.low { border-color: #94a3b8; }
        .priority-dot.low.active { background: #94a3b8; }

        .priority-dot.medium { border-color: #3b82f6; }
        .priority-dot.medium.active { background: #3b82f6; }

        .priority-dot.high { border-color: #f59e0b; }
        .priority-dot.high.active { background: #f59e0b; }

        .priority-dot.urgent { border-color: #ef4444; }
        .priority-dot.urgent.active { background: #ef4444; }

        .keyboard-hint {
            font-size: 11px;
            color: #A09080;
            font-family: 'SF Mono', Monaco, monospace;
            padding: 2px 6px;
            background: #F5F2ED;
            border-radius: 4px;
        }

        /* Show "/" hint when unfocused, "⏎" hint when focused */
        .quick-add-bar .slash-hint { display: inline; }
        .quick-add-bar .enter-hint { display: none; }
        .quick-add-bar.focused .slash-hint { display: none; }
        .quick-add-bar.focused .enter-hint { display: inline; }

        /* Inline Suggestions */
        .inline-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            padding: 10px;
            z-index: 100;
            display: none;
            border: 1px solid #E5DDD1;
        }

        .inline-suggestions.show {
            display: block;
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .suggestion-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            color: #6B5642;
            transition: all 0.15s;
        }

        .suggestion-item:hover {
            background: #FAF7F5;
            color: #3D2E1F;
        }

        .suggestion-item strong {
            color: #C88F4A;
            font-family: 'SF Mono', Monaco, monospace;
        }

        /* Toast Notification */
        .toast-notification {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: #3D2E1F;
            color: white;
            padding: 14px 22px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            display: none;
            z-index: 10000;
            font-size: 14px;
            font-weight: 500;
        }

        .toast-notification.show {
            display: flex;
            align-items: center;
            gap: 8px;
            animation: slideInRight 0.3s ease-out;
        }

        .toast-notification.success {
            background: #059669;
        }

        .toast-notification.error {
            background: #DC2626;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* New task card slide-in animation */
        .kanban-card.new-task {
            animation: slideInTask 0.3s ease-out;
            border-color: #C88F4A;
        }

        @keyframes slideInTask {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Quick Actions Row in Task Modal */
        .task-quick-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 1.25rem;
        }

        .quick-action-btn {
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid #E5DDD1;
            background: white;
            font-size: 13px;
            color: #6B5642;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .quick-action-btn:hover {
            border-color: #C88F4A;
            color: #3D2E1F;
        }

        .quick-action-btn.active {
            background: #C88F4A;
            color: white;
            border-color: #C88F4A;
        }

        .quick-action-btn i {
            font-size: 14px;
        }

        /* Priority colors on quick action buttons */
        .quick-action-btn.priority-low {
            color: #64748b;
            border-color: #94a3b8;
        }
        .quick-action-btn.priority-low i { color: #94a3b8; }

        .quick-action-btn.priority-medium {
            color: #2563eb;
            border-color: #3b82f6;
        }
        .quick-action-btn.priority-medium i { color: #3b82f6; }

        .quick-action-btn.priority-high {
            color: #d97706;
            border-color: #f59e0b;
        }
        .quick-action-btn.priority-high i { color: #f59e0b; }

        .quick-action-btn.priority-urgent {
            color: #dc2626;
            border-color: #ef4444;
        }
        .quick-action-btn.priority-urgent i { color: #ef4444; }

        /* Date Picker Popup */
        .date-picker-popup {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 10px;
            padding: 14px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
            display: none;
            z-index: 200;
            min-width: 280px;
        }

        .date-picker-popup.show {
            display: block;
            animation: slideDown 0.2s ease-out;
        }

        .date-quick-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .date-option {
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid #E5DDD1;
            background: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            color: #6B5642;
        }

        .date-option:hover {
            border-color: #C88F4A;
            background: #FAF7F5;
            color: #3D2E1F;
        }

        .date-option.selected {
            background: #C88F4A;
            color: white;
            border-color: #C88F4A;
        }

        .date-picker-custom {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #E5DDD1;
        }

        .date-picker-custom input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 13px;
        }

        .date-picker-custom input:focus {
            outline: none;
            border-color: #C88F4A;
        }

        /* Inline Date Picker for Task Lists */
        .inline-date-trigger {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 12px;
            position: relative;
        }

        .inline-date-trigger:hover {
            background: rgba(200, 143, 74, 0.15);
        }

        .inline-date-trigger.empty {
            color: #999;
            border: 1px dashed #ccc;
        }

        .inline-date-trigger.empty:hover {
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .inline-date-popup {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            display: none;
            z-index: 1000;
            min-width: 200px;
        }

        .inline-date-popup.show {
            display: block;
            animation: slideDown 0.15s ease-out;
        }

        .inline-date-options {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .inline-date-option {
            padding: 8px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            color: #555;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
        }

        .inline-date-option:hover {
            background: #FAF7F5;
            color: #3D2E1F;
        }

        .inline-date-option i {
            font-size: 14px;
            color: #888;
            width: 18px;
        }

        .inline-date-option:hover i {
            color: #C88F4A;
        }

        .inline-date-option.clear {
            border-top: 1px solid #eee;
            margin-top: 4px;
            padding-top: 10px;
            color: #999;
        }

        .inline-date-option.clear:hover {
            color: #dc2626;
        }

        .inline-date-option.calendar {
            border-top: 1px solid #eee;
            margin-top: 4px;
            padding-top: 10px;
            color: #666;
        }

        /* Quick Date Buttons in Modal */
        .quick-date-section {
            margin-bottom: 16px;
            padding: 12px;
            background: #FAFAFA;
            border-radius: 8px;
            border: 1px solid #f0f0f0;
        }

        .quick-date-label {
            font-size: 12px;
            color: #888;
            font-weight: 500;
            margin-bottom: 8px;
            display: block;
        }

        .quick-date-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .quick-date-btn {
            padding: 6px 12px;
            border-radius: 16px;
            border: 1px solid #E5DDD1;
            background: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
            color: #6B5642;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .quick-date-btn:hover {
            border-color: #C88F4A;
            background: #FAF7F5;
            color: #C88F4A;
        }

        .quick-date-btn.active {
            background: #C88F4A;
            border-color: #C88F4A;
            color: white;
        }

        .quick-date-btn i {
            font-size: 12px;
        }

        /* Role Selector Grid */
        .role-selector-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .role-option-card {
            padding: 14px;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 13px;
            color: #6B5642;
            background: white;
        }

        .role-option-card:hover {
            border-color: #C88F4A;
            background: #FAF7F5;
        }

        .role-option-card.selected {
            border-color: #C88F4A;
            background: #C88F4A;
            color: white;
        }

        .role-option-card .role-icon {
            font-size: 22px;
            margin-bottom: 6px;
        }

        .role-option-card .role-name {
            font-weight: 500;
        }

        /* Expandable Sections */
        .expandable-section {
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.25s;
            margin-bottom: 12px;
        }

        .expandable-section.expanded {
            border-color: #C88F4A;
        }

        .expandable-header {
            padding: 12px 14px;
            background: #FAF7F5;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background 0.15s;
        }

        .expandable-header:hover {
            background: #F5F2ED;
        }

        .expandable-title {
            font-size: 13px;
            color: #6B5642;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .expandable-count {
            background: #E5DDD1;
            color: #6B5642;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .expandable-chevron {
            transition: transform 0.25s;
            color: #A09080;
        }

        .expandable-section.expanded .expandable-chevron {
            transform: rotate(180deg);
        }

        .expandable-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .expandable-section.expanded .expandable-content {
            max-height: 500px;
            border-top: 1px solid #E5DDD1;
        }

        .expandable-inner {
            padding: 14px;
        }

        /* Simplified Subtask List */
        .subtask-simple-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .subtask-simple-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 6px;
            transition: all 0.15s;
        }

        .subtask-simple-item:hover {
            background: #FAF7F5;
        }

        .subtask-simple-item.new {
            animation: slideInTask 0.25s ease-out;
        }

        .subtask-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid #E5DDD1;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .subtask-checkbox:hover {
            border-color: #C88F4A;
        }

        .subtask-checkbox.completed {
            background: #10B981;
            border-color: #10B981;
        }

        .subtask-checkbox.completed i {
            color: white;
            font-size: 11px;
        }

        .subtask-text {
            flex: 1;
            font-size: 13px;
            color: #3D2E1F;
        }

        .subtask-text.completed {
            text-decoration: line-through;
            color: #A09080;
        }

        .subtask-add-input {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .subtask-add-input input {
            flex: 1;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            padding: 10px 12px;
            font-size: 13px;
            outline: none;
        }

        .subtask-add-input input:focus {
            border-color: #C88F4A;
        }

        .subtask-add-btn {
            padding: 10px 16px;
            border-radius: 6px;
            border: none;
            background: #C88F4A;
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .subtask-add-btn:hover {
            background: #B07E3A;
        }

        .task-board-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .task-board-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: #8B6F47;
        }

        .task-board-empty i {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: #C88F4A;
            opacity: 0.5;
        }

        .task-board-empty h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: #3D2E1F;
        }

        .task-board-empty p {
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }

        .empty-state-hint {
            margin-top: 1.5rem;
            font-size: 0.8rem;
            color: #A09080;
        }

        .empty-state-hint kbd {
            padding: 0.2rem 0.4rem;
            background: #F5F2ED;
            border: 1px solid #E5DDD1;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.75rem;
        }

        .task-board-empty .hero-task-btn {
            padding: 0.75rem 1.25rem !important;
            font-size: 0.95rem;
            width: auto !important;
            max-width: 200px;
            min-width: 0;
            flex: 0 0 auto !important;
            align-self: center;
            height: auto !important;
            max-height: 48px;
            min-height: 0;
        }

        .task-board-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .task-board-card {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            border: 1px solid #E5DDD1;
            transition: all 0.2s;
            cursor: pointer;
        }

        .task-board-card:hover {
            border-color: #C88F4A;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.15);
        }

        .task-board-card-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .task-board-card-title {
            font-size: 1rem;
            font-weight: 600;
            color: #3D2E1F;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-board-card-title i {
            color: #C88F4A;
        }

        .task-board-card-menu {
            background: none;
            border: none;
            color: #8B6F47;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
        }

        .task-board-card-menu:hover {
            background: #FAF7F5;
        }

        .task-board-card-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
        }

        .task-board-card-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .task-board-card-tag.role {
            background: #F0F7FF;
            color: #4A7EC8;
            border: 1px solid #BDD7F5;
        }

        .task-board-card-tag.person {
            background: #F0FFF5;
            color: #3D9960;
            border: 1px solid #B8E5C8;
        }

        .task-board-card-tag.due-date {
            background: #FFF9F0;
            color: #8B6F47;
            border: 1px solid #E5DDD1;
        }

        .task-board-card-tag.due-date.due-soon {
            background: #FFF8E1;
            color: #F57F17;
            border: 1px solid #FFE082;
        }

        .task-board-card-tag.due-date.due-today {
            background: #FFF3E0;
            color: #E65100;
            border: 1px solid #FFB74D;
        }

        .task-board-card-tag.due-date.overdue {
            background: #FFEBEE;
            color: #C62828;
            border: 1px solid #EF9A9A;
        }

        .task-board-card-tag i {
            font-size: 0.875rem;
        }

        /* Structural context breadcrumb */
        .task-board-card-structure {
            margin-top: 0.5rem;
            padding: 0.35rem 0.5rem;
            background: #F5F2ED;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #8B6F47;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .task-board-card-structure i {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .task-board-card-deps {
            margin-top: 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .task-dep-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            font-size: 0.7rem;
            color: #999;
        }

        .task-dep-tag i {
            color: #ccc;
        }

        .task-dep-tag.predecessor {
            color: #666;
        }

        .task-dep-tag.predecessor.conflict {
            color: #C62828;
        }

        .task-dep-tag.predecessor.conflict i {
            color: #C62828;
            animation: pulse 1s infinite;
        }

        .task-dep-tag.dependents {
            color: #666;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .task-board-card.overdue {
            border-left: 3px solid #C62828;
        }

        .task-board-card.due-today {
            border-left: 3px solid #E65100;
        }

        .task-board-card.due-soon {
            border-left: 3px solid #F57F17;
        }

        /* View dropdown divider */
        .view-dropdown-divider {
            height: 1px;
            background: #E5DDD1;
            margin: 0.5rem 0;
        }

        /* ============================================
           KANBAN BOARD STYLES
           ============================================ */

        .kanban-board {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            min-height: calc(100vh - 250px);
            overflow-x: auto;
        }

        .kanban-column {
            flex: 1;
            min-width: 280px;
            max-width: 350px;
            background: #FAF7F5;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
        }

        .kanban-column-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            font-weight: 600;
            color: #6B5642;
            border-bottom: 1px solid #E5DDD1;
        }

        .kanban-column-header i {
            font-size: 1.1rem;
        }

        .kanban-column-count {
            background: #E5DDD1;
            color: #6B5642;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 10px;
            margin-left: auto;
        }

        .kanban-column-content {
            flex: 1;
            padding: 0.75rem;
            overflow-y: auto;
            min-height: 200px;
            transition: background 0.2s;
            position: relative;
        }

        .kanban-column-content.drag-over {
            background: #F0EBE5;
        }

        .kanban-card {
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            padding: 0.875rem;
            margin-bottom: 0.625rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .kanban-card:hover {
            border-color: #C88F4A;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.15);
        }

        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .kanban-card.overdue {
            border-left: 3px solid #C62828;
        }

        .kanban-card.due-today {
            border-left: 3px solid #E65100;
        }

        .kanban-card.due-soon {
            border-left: 3px solid #F57F17;
        }

        .kanban-card-title {
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.5rem;
        }

        .kanban-card-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            font-size: 0.8rem;
        }

        .kanban-card-assignee,
        .kanban-card-due {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            color: #3D2E1F;
            font-weight: 500;
        }

        .kanban-card-assignee i,
        .kanban-card-due i {
            font-size: 0.9rem;
            color: #7B95A3;
        }

        .kanban-card-role-only {
            color: #8B6F47;
            font-style: italic;
        }

        .kanban-card-role-only i {
            color: #C88F4A;
        }

        .kanban-card-parent-link {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            color: #999;
            font-size: 0.7rem;
            width: 100%;
            margin-bottom: 0.25rem;
        }

        .kanban-card-parent-link i {
            color: #ccc;
            font-size: 0.75rem;
        }

        .kanban-card-parent-link em {
            font-style: normal;
            color: #6B5642;
        }

        .kanban-card-parent-link em:hover {
            color: #C88F4A;
            text-decoration: underline;
            cursor: pointer;
        }

        /* Clean dependency link styles (flat, minimal) */
        .kanban-card-dependency-link {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.7rem;
            color: #999;
            margin-bottom: 0.5rem;
            padding-left: 0;
        }

        .kanban-card-dependency-link i {
            font-size: 0.75rem;
            color: #ccc;
        }

        .kanban-card-dependency-link a {
            color: #6B5642;
            text-decoration: none;
            cursor: pointer;
        }

        .kanban-card-dependency-link a:hover {
            color: #C88F4A;
            text-decoration: underline;
        }

        .kanban-card-dependency-link.blocked {
            color: #f59e0b;
        }

        .kanban-card-dependency-link.blocked i {
            color: #f59e0b;
        }

        /* Clean status indicator */
        .kanban-card-status-icon {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            flex-shrink: 0;
        }

        .kanban-card-status-icon.has-subtasks {
            background: #f0f0f0;
            color: #666;
        }

        .kanban-card-status-icon.blocked {
            background: #fef3c7;
            color: #f59e0b;
        }

        .kanban-card-status-icon.ready {
            background: #d1fae5;
            color: #10b981;
        }

        .kanban-card-due.overdue {
            color: #C62828;
        }

        .kanban-card-due.due-today {
            color: #E65100;
        }

        .kanban-card-due.due-soon {
            color: #F57F17;
        }

        /* Parent-Subtask Kanban Styling - Clean, minimal */
        .kanban-card.has-subtasks {
            border-left: 3px solid #94a3b8;
        }

        .kanban-card.has-subtasks:hover {
            border-left-color: #64748b;
        }

        .kanban-card.is-subtask {
            margin-left: 1.25rem;
            border-left: 3px solid #cbd5e1;
            position: relative;
        }

        .kanban-card.is-subtask::before {
            content: '↳';
            position: absolute;
            left: -1.1rem;
            top: 0.75rem;
            font-size: 0.75rem;
            color: #cbd5e1;
        }

        .kanban-card.is-subtask:hover {
            border-left-color: #94a3b8;
        }

        .kanban-card.subtask-related {
            border: 2px solid #C88F4A;
            box-shadow: 0 0 12px rgba(200, 143, 74, 0.4);
            z-index: 10;
            position: relative;
        }

        .kanban-card.subtask-faded {
            opacity: 0.15;
            pointer-events: none;
            filter: grayscale(50%);
            transition: opacity 0.2s, filter 0.2s;
        }

        .kanban-card.parent-blocked {
            cursor: not-allowed !important;
        }

        .kanban-card.parent-blocked::after {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 5px,
                rgba(198, 40, 40, 0.1) 5px,
                rgba(198, 40, 40, 0.1) 10px
            );
            border-radius: 8px;
            pointer-events: none;
        }

        /* Subtask progress badge - clean minimal style */
        .kanban-card-subtask-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: #f5f5f5;
            color: #666;
            font-size: 0.65rem;
            font-weight: 500;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            margin-left: auto;
            cursor: help;
        }

        .kanban-card-subtask-badge i {
            color: #999;
            font-size: 0.7rem;
        }

        /* Connection lines between parent and subtasks */
        .kanban-subtask-connector {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
        }

        .kanban-subtask-connector line {
            stroke: #C88F4A;
            stroke-width: 2;
            stroke-dasharray: 6 4;
            animation: dash-flow 0.5s linear infinite;
        }

        @keyframes dash-flow {
            to {
                stroke-dashoffset: -10;
            }
        }

        /* Drop zone warning indicator (soft hint, not blocking) */
        .kanban-column-content.drop-warning {
            background: repeating-linear-gradient(
                -45deg,
                rgba(245, 158, 11, 0.05),
                rgba(245, 158, 11, 0.05) 10px,
                rgba(245, 158, 11, 0.1) 10px,
                rgba(245, 158, 11, 0.1) 20px
            ) !important;
            border: 2px dashed #f59e0b;
            position: relative;
        }

        .kanban-column-content.drop-warning::before {
            content: attr(data-warning-reason);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            white-space: normal;
            text-align: center;
            max-width: 85%;
            line-height: 1.4;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .kanban-column-content.drop-warning::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(245, 158, 11, 0.05);
            pointer-events: none;
        }

        /* ============================================
           COLLAPSIBLE TASK SEQUENCE STYLES
           ============================================ */

        .task-sequence {
            margin-bottom: 0.5rem;
        }

        .task-sequence-header {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            cursor: pointer;
            padding: 0;
        }

        .task-sequence-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            background: #f0f0f0;
            color: #666;
            font-size: 0.7rem;
            flex-shrink: 0;
            transition: all 0.15s ease;
        }

        .task-sequence-toggle:hover {
            background: #e0e0e0;
            color: #333;
        }

        .task-sequence-toggle i {
            transition: transform 0.2s ease;
        }

        .task-sequence.collapsed .task-sequence-toggle i {
            transform: rotate(-90deg);
        }

        .task-sequence-content {
            overflow: hidden;
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 2000px;
            opacity: 1;
        }

        .task-sequence.collapsed .task-sequence-content {
            max-height: 0;
            opacity: 0;
        }

        .task-sequence-count {
            font-size: 0.65rem;
            color: #888;
            background: #f5f5f5;
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            margin-left: 0.25rem;
        }

        /* Kanban view specific sequence styling */
        .kanban-task-sequence {
            margin-bottom: 0.5rem;
        }

        .kanban-sequence-header {
            display: flex;
            align-items: stretch;
            gap: 0;
        }

        .kanban-sequence-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-right: none;
            border-radius: 8px 0 0 8px;
            color: #888;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        .kanban-sequence-toggle:hover {
            background: #e8e8e8;
            color: #555;
        }

        .kanban-sequence-toggle i {
            transition: transform 0.2s ease;
        }

        .kanban-task-sequence.collapsed .kanban-sequence-toggle i {
            transform: rotate(-90deg);
        }

        .kanban-task-sequence.collapsed .kanban-sequence-toggle {
            border-radius: 8px 0 0 8px;
        }

        .kanban-sequence-header .kanban-card {
            border-radius: 0 8px 8px 0;
            flex: 1;
            margin-bottom: 0;
        }

        .kanban-sequence-content {
            margin-left: 24px;
            overflow: hidden;
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 2000px;
            opacity: 1;
        }

        .kanban-task-sequence.collapsed .kanban-sequence-content {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        .kanban-sequence-content .kanban-card {
            border-left: 2px solid #ddd;
            border-radius: 0 8px 8px 0;
            margin-left: 0;
            margin-top: 2px;
        }

        .kanban-sequence-content .kanban-card::before {
            display: none;
        }

        .kanban-sequence-content .kanban-card:last-child {
            border-radius: 0 8px 8px 8px;
        }

        /* Board view specific sequence styling */
        .board-task-sequence {
            margin-bottom: 0.5rem;
        }

        .board-sequence-header {
            display: flex;
            align-items: stretch;
            gap: 0;
        }

        .board-sequence-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            background: #f8f6f4;
            border: 1px solid #e5ddd1;
            border-right: none;
            border-radius: 8px 0 0 8px;
            color: #8b7355;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        .board-sequence-toggle:hover {
            background: #f0ebe5;
            color: #6b5642;
        }

        .board-sequence-toggle i {
            transition: transform 0.2s ease;
        }

        .board-task-sequence.collapsed .board-sequence-toggle i {
            transform: rotate(-90deg);
        }

        .board-sequence-header .task-board-card {
            border-radius: 0 8px 8px 0;
            flex: 1;
            margin-bottom: 0;
        }

        .board-sequence-content {
            margin-left: 28px;
            overflow: hidden;
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 2000px;
            opacity: 1;
        }

        .board-task-sequence.collapsed .board-sequence-content {
            max-height: 0;
            opacity: 0;
        }

        .board-sequence-content .task-board-card {
            border-left: 2px solid #e5ddd1;
            border-radius: 0 8px 8px 0;
            margin-left: 0;
            margin-top: 2px;
        }

        .board-sequence-content .task-board-card:last-child {
            border-radius: 0 8px 8px 8px;
        }

        /* Sequence badge showing count of linked tasks */
        .sequence-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: #f0f0f0;
            color: #666;
            font-size: 0.65rem;
            font-weight: 500;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            margin-left: auto;
        }

        .sequence-badge i {
            font-size: 0.7rem;
            color: #888;
        }

        /* ============================================
           TABLE VIEW STYLES
           ============================================ */

        .task-table-container {
            padding: 1rem;
            overflow-x: auto;
        }

        .task-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .task-table thead {
            background: #FAF7F5;
        }

        .task-table th {
            padding: 0.875rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #6B5642;
            font-size: 0.875rem;
            border-bottom: 2px solid #E5DDD1;
            white-space: nowrap;
        }

        .task-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .task-table th.sortable:hover {
            background: #F0EBE5;
        }

        .task-table th i {
            margin-left: 0.5rem;
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .task-table td {
            padding: 0.875rem 1rem;
            border-bottom: 1px solid #F0EBE5;
            color: #3D2E1F;
        }

        .task-table tr:hover {
            background: #FAF7F5;
        }

        .task-table-name {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-table-name i {
            color: #C88F4A;
        }

        .task-table-status {
            display: inline-flex;
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .task-table-status.pending {
            background: #F5F5F5;
            color: #757575;
        }

        .task-table-status.in_progress {
            background: #E3F2FD;
            color: #1976D2;
        }

        .task-table-status.completed {
            background: #E8F5E9;
            color: #388E3C;
        }

        .task-table-empty {
            color: #A99D8F;
        }

        .task-table td.overdue {
            color: #C62828;
            font-weight: 500;
        }

        .task-table td.due-today {
            color: #E65100;
            font-weight: 500;
        }

        .task-table td.due-soon {
            color: #F57F17;
        }

        /* ============================================
           TIMELINE VIEW STYLES
           ============================================ */

        .timeline-container {
            padding: 1rem;
            height: calc(100vh - 250px);
            display: flex;
            flex-direction: column;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .timeline-legend {
            display: flex;
            gap: 1.5rem;
        }

        .timeline-legend-item {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            font-size: 0.8rem;
            color: #6B5642;
        }

        .timeline-legend-item.pending i { color: #757575; }
        .timeline-legend-item.in-progress i { color: #1976D2; }
        .timeline-legend-item.completed i { color: #388E3C; }

        .timeline-scroll {
            flex: 1;
            overflow-x: auto;
            padding-bottom: 1rem;
        }

        .timeline-track {
            display: flex;
            gap: 0;
            min-width: max-content;
        }

        .timeline-day {
            flex: 0 0 140px;
            border-right: 1px solid #E5DDD1;
            display: flex;
            flex-direction: column;
        }

        .timeline-day.weekend {
            background: #F9F7F4;
        }

        .timeline-day.past {
            opacity: 0.6;
        }

        .timeline-day.today {
            background: #FFF9F0;
            border-color: #C88F4A;
        }

        .timeline-day-header {
            padding: 0.75rem;
            text-align: center;
            border-bottom: 1px solid #E5DDD1;
            position: relative;
        }

        .timeline-day-name {
            display: block;
            font-size: 0.7rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .timeline-day-date {
            display: block;
            font-size: 1.25rem;
            font-weight: 600;
            color: #3D2E1F;
        }

        .timeline-day.today .timeline-day-date {
            color: #C88F4A;
        }

        .timeline-today-badge {
            display: block;
            font-size: 0.65rem;
            background: #C88F4A;
            color: white;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            margin-top: 0.25rem;
        }

        .timeline-day-tasks {
            flex: 1;
            padding: 0.5rem;
            min-height: 200px;
        }

        .timeline-task {
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            padding: 0.5rem 0.625rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-task:hover {
            border-color: #C88F4A;
            box-shadow: 0 2px 8px rgba(200, 143, 74, 0.15);
        }

        .timeline-task.pending {
            border-left: 3px solid #9E9E9E;
        }

        .timeline-task.in_progress {
            border-left: 3px solid #1976D2;
        }

        .timeline-task.completed {
            border-left: 3px solid #388E3C;
            opacity: 0.7;
        }

        .timeline-task-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: #3D2E1F;
            line-height: 1.3;
        }

        .timeline-task-role {
            font-size: 0.7rem;
            color: #8B6F47;
            margin-top: 0.25rem;
        }

        /* Task View Toggle in Header */
        .view-btn.tasks-view-btn {
            position: relative;
        }

        .view-btn.tasks-view-btn .task-count-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #C88F4A;
            color: white;
            font-size: 0.625rem;
            font-weight: 700;
            padding: 0.125rem 0.375rem;
            border-radius: 10px;
            min-width: 16px;
            text-align: center;
        }

        /* ============================================
           TASK MODAL SPECIFIC STYLES
           ============================================ */

        .task-modal-info {
            background: #FAF7F5;
            border-radius: 12px;
            padding: 1.25rem;
            margin-bottom: 1rem;
        }

        .task-status-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #E5DDD1;
        }

        .task-status-toggle {
            display: flex;
            gap: 0.375rem;
            background: #F5F0EB;
            border-radius: 10px;
            padding: 0.375rem;
            border: 1px solid #E5DDD1;
        }

        .task-status-btn {
            padding: 0.625rem 1.25rem;
            border: none;
            background: transparent;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            color: #8B6F47;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-status-btn:hover {
            background: rgba(255, 255, 255, 0.7);
        }

        .task-status-btn.active {
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }

        .task-status-btn.active.pending {
            background: linear-gradient(135deg, #FEF3C7, #FDE68A);
            color: #92400E;
            border: 1px solid #F59E0B;
        }

        .task-status-btn.active.in-progress {
            background: linear-gradient(135deg, #DBEAFE, #BFDBFE);
            color: #1E40AF;
            border: 1px solid #3B82F6;
        }

        .task-status-btn.active.completed {
            background: linear-gradient(135deg, #D1FAE5, #A7F3D0);
            color: #065F46;
            border: 1px solid #10B981;
        }

        .task-meta-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .task-meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .task-meta-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            color: #8B6F47;
            letter-spacing: 0.05em;
        }

        .task-meta-value {
            font-size: 0.9375rem;
            color: #3D2E1F;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .task-meta-value.empty {
            color: #A89984;
            font-style: italic;
        }

        .task-meta-value.clickable {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            margin: -0.25rem -0.5rem;
            border-radius: 6px;
            transition: background 0.15s;
        }

        .task-meta-value.clickable:hover {
            background: rgba(200, 143, 74, 0.1);
        }

        .task-meta-value i {
            color: #C88F4A;
        }

        .task-due-date {
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            font-weight: 500;
        }

        .task-due-date.pending {
            background: #F5F5F5;
            color: #6B5642;
        }

        .task-due-date.due-soon {
            background: #FFF8E1;
            color: #F57F17;
        }

        .task-due-date.due-today {
            background: #FFF3E0;
            color: #E65100;
        }

        .task-due-date.overdue {
            background: #FFEBEE;
            color: #C62828;
        }

        .task-due-date.completed {
            background: #E8F5E9;
            color: #2E7D32;
        }

        .task-dependencies-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #E5DDD1;
        }

        .task-dep-group {
            margin-bottom: 0.75rem;
        }

        .task-dep-group:last-child {
            margin-bottom: 0;
        }

        .task-dep-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            color: #8B6F47;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .task-dep-label i {
            font-size: 0.875rem;
        }

        .task-dep-list {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .task-dep-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: white;
            border-radius: 8px;
            border: 1px solid #E5DDD1;
            cursor: pointer;
            transition: all 0.15s;
        }

        .task-dep-item:hover {
            border-color: #C88F4A;
            background: #FFFBF7;
        }

        .task-dep-item .dep-checkbox {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 2px solid #C88F4A;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            flex-shrink: 0;
        }

        .task-dep-item .dep-checkbox.completed {
            background: #2E7D32;
            border-color: #2E7D32;
        }

        .task-dep-item .dep-name {
            flex: 1;
            font-size: 0.875rem;
            color: #3D2E1F;
        }

        .task-dep-item.completed .dep-name {
            text-decoration: line-through;
            color: #8B6F47;
        }

        .task-dep-item .dep-due {
            font-size: 0.75rem;
            color: #8B6F47;
        }

        .task-dep-empty {
            font-size: 0.875rem;
            color: #A89984;
            font-style: italic;
            padding: 0.5rem 0;
        }

        /* Task Quick Actions */
        .task-quick-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .task-quick-action {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: #FAF7F5;
            border: 1px dashed #D4C4B0;
            border-radius: 8px;
            color: #6B5642;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .task-quick-action:hover {
            background: #FFFBF7;
            border-color: #C88F4A;
            color: #C88F4A;
        }

        .task-quick-action i {
            font-size: 1.125rem;
        }

        /* Task Modal Footer */
        .task-modal-footer {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding-top: 1rem;
            border-top: 1px solid #E5DDD1;
            margin-top: 1rem;
        }

        .task-complete-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.875rem 1.5rem;
            background: #2E7D32;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9375rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }

        .task-complete-btn:hover {
            background: #1B5E20;
        }

        .task-complete-btn.completed {
            background: #8B6F47;
        }

        .task-complete-btn.completed:hover {
            background: #6B5642;
        }

        /* Connected Entities List (simpler than grouped) */
        .task-connected-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .task-connected-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: #FAF7F5;
            border-radius: 8px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .task-connected-item:hover {
            background: #F0E9E0;
        }

        .task-connected-item i {
            color: #C88F4A;
        }

        /* ============================================
           SIMPLIFIED TASK MODAL STYLES
           ============================================ */

        .simple-task-modal {
            padding: 0;
        }

        .simple-task-meta-bar {
            display: flex;
            gap: 8px;
            padding: 16px 0;
            flex-wrap: wrap;
            border-bottom: 1px solid #f0f0f0;
            margin-bottom: 16px;
        }

        .simple-task-chip {
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .simple-task-chip.empty {
            border: 1px dashed #d0d0d0;
            color: #888;
            background: white;
        }

        .simple-task-chip.empty:hover {
            border-color: #C88F4A;
            color: #666;
            transform: translateY(-1px);
        }

        .simple-task-chip.filled {
            background: #f5f5f5;
            color: #555;
            border: 1px solid #e5e5e5;
        }

        .simple-task-chip.filled:hover {
            background: #eee;
            transform: translateY(-1px);
        }

        /* Date chip with edit hint */
        .simple-task-chip.filled:has(+ .quick-date-buttons),
        .simple-task-chip.empty:first-of-type {
            position: relative;
        }

        .simple-task-chip.filled:has(+ .quick-date-buttons)::after,
        .simple-task-chip.empty:first-of-type::after {
            content: '';
            position: absolute;
            right: 8px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid currentColor;
            opacity: 0.5;
        }

        /* Due date color states for inline date triggers */
        .inline-date-trigger.overdue {
            color: #dc2626 !important;
            background: rgba(220, 38, 38, 0.1);
        }

        .inline-date-trigger.due-today {
            color: #ea580c !important;
            background: rgba(234, 88, 12, 0.1);
        }

        .inline-date-trigger.due-soon {
            color: #ca8a04 !important;
            background: rgba(202, 138, 4, 0.1);
        }

        .simple-task-chip.status-pending {
            background: #FEF3C7;
            border-color: #F59E0B;
            color: #92400E;
        }

        .simple-task-chip.status-in-progress {
            background: #DBEAFE;
            border-color: #3B82F6;
            color: #1E40AF;
        }

        .simple-task-chip.status-completed {
            background: #D1FAE5;
            border-color: #10B981;
            color: #065F46;
        }

        .simple-task-chip.priority-urgent {
            background: #FEE2E2;
            border-color: #F87171;
            color: #DC2626;
        }

        .simple-task-chip.priority-high {
            background: #FEF3C7;
            border-color: #F59E0B;
            color: #B45309;
        }

        .simple-task-chip.priority-medium {
            background: #DBEAFE;
            border-color: #60A5FA;
            color: #1D4ED8;
        }

        .simple-task-chip.priority-low {
            background: #F3F4F6;
            border-color: #D1D5DB;
            color: #4B5563;
        }

        .simple-task-chip i {
            font-size: 14px;
        }

        .simple-task-description {
            margin-bottom: 20px;
        }

        .simple-task-description-field {
            width: 100%;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 14px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
            outline: none;
            color: #555;
            line-height: 1.6;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .simple-task-description-field:focus {
            border-color: #C88F4A;
            box-shadow: 0 0 0 3px rgba(200, 143, 74, 0.1);
        }

        .simple-task-description-field::placeholder {
            color: #bbb;
        }

        .simple-task-options {
            margin-bottom: 8px;
        }

        .simple-task-option-link {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 4px;
            color: #666;
            font-size: 14px;
            cursor: pointer;
            border-bottom: 1px solid #f5f5f5;
            transition: all 0.2s;
        }

        .simple-task-option-link:hover {
            color: #333;
            padding-left: 12px;
            background: #fafafa;
        }

        .simple-task-option-link:last-child {
            border-bottom: none;
        }

        .simple-task-option-text {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .simple-task-option-text i {
            font-size: 18px;
            color: #888;
        }

        .simple-task-option-link:hover .simple-task-option-text i {
            color: #C88F4A;
        }

        .simple-task-option-arrow {
            color: #ccc;
            font-size: 14px;
        }

        .simple-task-option-badge {
            background: #f0f0f0;
            color: #666;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
        }

        .simple-task-expanded-section {
            margin-top: 12px;
            padding: 16px;
            background: #fafafa;
            border-radius: 8px;
            border: 1px solid #f0f0f0;
        }

        /* Status dropdown for simplified modal */
        .simple-task-status-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
            border: 1px solid #e5e5e5;
            padding: 8px 0;
            min-width: 160px;
            z-index: 100;
            display: none;
        }

        .simple-task-status-dropdown.show {
            display: block;
            animation: dropdownSlide 0.2s ease-out;
        }

        .simple-task-status-option {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            transition: background 0.15s;
        }

        .simple-task-status-option:hover {
            background: #f5f5f5;
        }

        .simple-task-status-option.pending {
            color: #92400E;
        }

        .simple-task-status-option.in-progress {
            color: #1E40AF;
        }

        .simple-task-status-option.completed {
            color: #065F46;
        }

        /* Role Work Dashboard Styles */
        .role-work-dashboard {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .role-work-section {
            background: #FAF7F5;
            border-radius: 12px;
            padding: 1rem;
        }

        .role-work-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .role-work-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            color: #8B6F47;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .role-work-section-title i {
            font-size: 0.875rem;
        }

        .role-work-count {
            font-size: 0.75rem;
            color: #A89984;
            font-weight: 500;
        }

        /* Assigned People */
        .role-people-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .role-person-chip {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 20px;
            font-size: 0.875rem;
            color: #3D2E1F;
            cursor: pointer;
            transition: all 0.15s;
        }

        .role-person-chip:hover {
            border-color: #C88F4A;
            background: #FFFBF7;
        }

        .role-person-chip i {
            color: #C88F4A;
        }

        .role-empty-state {
            padding: 0.75rem;
            text-align: center;
            color: #A89984;
            font-size: 0.875rem;
            font-style: italic;
        }

        /* Role Person Assignment UI */
        .role-person-chip-with-remove {
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 20px;
            overflow: hidden;
            transition: all 0.15s;
        }

        .role-person-chip-with-remove:hover {
            border-color: #C88F4A;
        }

        .role-person-chip-content {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.5rem 0.375rem 0.75rem;
            font-size: 0.875rem;
            color: #3D2E1F;
            cursor: pointer;
            transition: background 0.15s;
        }

        .role-person-chip-content:hover {
            background: #FFFBF7;
        }

        .role-person-chip-content i {
            color: #C88F4A;
        }

        .role-person-remove-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            margin-right: 4px;
            border: none;
            background: transparent;
            color: #A89984;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.15s;
        }

        .role-person-remove-btn:hover {
            background: #FEE2E2;
            color: #DC2626;
        }

        .role-person-remove-btn i {
            font-size: 0.75rem;
        }

        .role-assign-person-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #E5DDD1;
        }

        .role-assign-person-row {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .role-assign-person-select {
            flex: 1;
            padding: 0.5rem 0.75rem;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            background: white;
            font-size: 0.875rem;
            color: #3D2E1F;
            cursor: pointer;
            transition: all 0.15s;
        }

        .role-assign-person-select:hover {
            border-color: #C88F4A;
        }

        .role-assign-person-select:focus {
            outline: none;
            border-color: #C88F4A;
            box-shadow: 0 0 0 2px rgba(200, 143, 74, 0.15);
        }

        .role-assign-person-btn {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.5rem 0.875rem;
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .role-assign-person-btn:hover {
            background: #B07E3E;
        }

        .role-assign-person-btn:disabled {
            background: #E5DDD1;
            color: #A89984;
            cursor: not-allowed;
        }

        .role-assign-person-btn i {
            font-size: 0.875rem;
        }

        /* Role Tasks */
        .role-task-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .role-task-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.625rem 0.75rem;
            background: white;
            border-radius: 8px;
            border: 1px solid #E5DDD1;
            cursor: pointer;
            transition: all 0.15s;
        }

        .role-task-item:hover {
            border-color: #C88F4A;
            background: #FFFBF7;
        }

        .role-task-status {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .role-task-status.pending {
            border: 2px solid #A89984;
            color: #A89984;
        }

        .role-task-status.in_progress {
            border: 2px solid #1565C0;
            background: #E3F2FD;
            color: #1565C0;
        }

        .role-task-status.completed {
            border: 2px solid #2E7D32;
            background: #E8F5E9;
            color: #2E7D32;
        }

        .role-task-status i {
            font-size: 0.75rem;
        }

        .role-task-info {
            flex: 1;
            min-width: 0;
        }

        .role-task-name {
            font-size: 0.875rem;
            color: #3D2E1F;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .role-task-meta {
            font-size: 0.75rem;
            color: #8B6F47;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.125rem;
        }

        .role-task-due {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .role-task-due.overdue {
            color: #C62828;
        }

        .role-task-due.due-today {
            color: #E65100;
        }

        .role-task-due.due-soon {
            color: #F57F17;
        }

        /* Role Workflows */
        .role-workflow-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .role-workflow-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.75rem;
            background: white;
            border-radius: 8px;
            border: 1px solid #E5DDD1;
            cursor: pointer;
            transition: all 0.15s;
        }

        .role-workflow-item:hover {
            border-color: #C88F4A;
            background: #FFFBF7;
        }

        .role-workflow-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .role-workflow-header i {
            color: #C88F4A;
        }

        .role-workflow-name {
            font-size: 0.875rem;
            font-weight: 500;
            color: #3D2E1F;
        }

        .role-workflow-roles {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            padding-left: 1.5rem;
        }

        .role-workflow-role-chip {
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            background: #F5EDE4;
            border-radius: 12px;
            color: #6B5642;
        }

        .role-workflow-role-chip.current {
            background: #C88F4A;
            color: white;
        }

        /* Task Status Summary */
        .role-task-summary {
            display: flex;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background: white;
            border-radius: 8px;
            margin-bottom: 0.75rem;
        }

        .role-task-stat {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            font-size: 0.8125rem;
        }

        .role-task-stat-count {
            font-weight: 600;
        }

        .role-task-stat.pending { color: #8B6F47; }
        .role-task-stat.in_progress { color: #1565C0; }
        .role-task-stat.completed { color: #2E7D32; }

        @media (max-width: 480px) {
            .task-meta-grid {
                grid-template-columns: 1fr;
            }

            .task-status-toggle {
                flex-wrap: wrap;
            }

            .task-status-btn {
                flex: 1;
                justify-content: center;
            }
        }

        /* ============================================
           FLOW VIEW STYLES
           ============================================ */

        .flow-view {
            display: none;
            flex-direction: column;
            height: 100%;
            background: #FAF7F5;
        }

        .flow-view.active {
            display: flex;
        }

        .flow-view-header {
            padding: 1.5rem;
            background: white;
            border-bottom: 1px solid #E5DDD1;
        }

        .flow-view-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #3D2E1F;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .flow-view-title i {
            color: #7B95A3;
        }

        .flow-view-subtitle {
            font-size: 0.875rem;
            color: #8B6F47;
            margin-top: 0.25rem;
        }

        .flow-view-controls {
            padding: 1rem 1.5rem;
            background: white;
            border-bottom: 1px solid #E5DDD1;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .flow-view-search {
            flex: 1;
            max-width: 300px;
            padding: 0.625rem 1rem;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .flow-view-search:focus {
            outline: none;
            border-color: #7B95A3;
        }

        .flow-view-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .flow-view-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: #8B6F47;
        }

        .flow-view-empty i {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: #7B95A3;
            opacity: 0.5;
        }

        .flow-view-empty h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: #3D2E1F;
        }

        .flow-view-empty p {
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            max-width: 400px;
        }

        .flow-view-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .workflow-card {
            background: white;
            border-radius: 12px;
            border: 1px solid #E5DDD1;
            overflow: hidden;
            transition: all 0.2s;
        }

        .workflow-card:hover {
            border-color: #7B95A3;
            box-shadow: 0 4px 12px rgba(123, 149, 163, 0.15);
        }

        .workflow-card-header {
            padding: 1.25rem;
            border-bottom: 1px solid #E5DDD1;
            cursor: pointer;
        }

        .workflow-card-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #3D2E1F;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .workflow-card-title i {
            color: #7B95A3;
        }

        .workflow-card-meta {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            color: #8B6F47;
        }

        .workflow-card-body {
            padding: 1.25rem;
        }

        .workflow-section {
            margin-bottom: 1rem;
        }

        .workflow-section:last-child {
            margin-bottom: 0;
        }

        .workflow-section-label {
            font-size: 0.75rem;
            color: #8B6F47;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .workflow-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .workflow-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            border-radius: 16px;
            font-size: 0.8rem;
            color: #3D2E1F;
            cursor: pointer;
            transition: all 0.2s;
        }

        .workflow-chip:hover {
            background: #F0EBE4;
            border-color: #C88F4A;
        }

        .workflow-chip i {
            font-size: 0.9rem;
            color: #8B6F47;
        }

        .workflow-add-chip {
            border-style: dashed;
            color: #8B6F47;
        }

        .workflow-add-chip:hover {
            background: #F5EFE6;
            color: #C88F4A;
        }

        /* Flow section headers */
        .flow-section {
            margin-bottom: 2rem;
        }

        .flow-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.5rem;
        }

        .flow-section-header i {
            color: #C88F4A;
        }

        .flow-section-count {
            font-size: 0.75rem;
            font-weight: 500;
            color: #8B6F47;
            background: #FAF7F5;
            padding: 0.25rem 0.5rem;
            border-radius: 10px;
            margin-left: auto;
        }

        .flow-section-hint {
            font-size: 0.8rem;
            color: #8B6F47;
            margin-bottom: 1rem;
        }

        /* Discovered pattern styling */
        .workflow-card.discovered {
            border-color: #F5D89A;
            background: linear-gradient(135deg, #FFFDF5 0%, #FFF9E6 100%);
        }

        .workflow-card.discovered:hover {
            border-color: #C88F4A;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.2);
        }

        .workflow-card.discovered .workflow-card-title i {
            color: #C88F4A;
        }

        .workflow-card-badge {
            font-size: 0.7rem;
            font-weight: 600;
            color: #C88F4A;
            background: rgba(200, 143, 74, 0.15);
            padding: 0.25rem 0.5rem;
            border-radius: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .workflow-card-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
        }

        .workflow-task-list {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .workflow-task-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #3D2E1F;
            cursor: pointer;
            transition: all 0.15s;
        }

        .workflow-task-item:hover {
            border-color: #C88F4A;
            background: #FFF9F0;
        }

        .workflow-task-item i {
            color: #8B6F47;
            font-size: 0.9rem;
        }

        .workflow-task-more {
            font-size: 0.8rem;
            color: #8B6F47;
            padding: 0.25rem 0.75rem;
        }

        .workflow-name-btn {
            width: 100%;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
            transition: all 0.2s;
        }

        .workflow-name-btn:hover {
            background: linear-gradient(135deg, #D4A054 0%, #C88F6B 100%);
        }

        /* Workflow relationship builder */
        .workflow-relationship-builder {
            padding: 1rem;
            background: #FAF7F5;
            border-radius: 8px;
            margin-top: 0.75rem;
        }

        .relationship-search-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
        }

        .relationship-search-input:focus {
            outline: none;
            border-color: #7B95A3;
        }

        .relationship-suggestions {
            display: none;
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .relationship-suggestions.active {
            display: block;
        }

        .relationship-suggestion {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #F5F2ED;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .relationship-suggestion:last-child {
            border-bottom: none;
        }

        .relationship-suggestion:hover {
            background: #FAF7F5;
        }

        .relationship-suggestion-verb {
            font-weight: 600;
            color: #7B95A3;
        }

        .relationship-suggestion-desc {
            color: #8B6F47;
            font-size: 0.85rem;
        }

        /* ============================================
           SHAPE VIEW STYLES
           ============================================ */

        .shape-view {
            display: none;
            flex-direction: column;
            height: 100%;
            background: #FAF7F5;
        }

        .shape-view.active {
            display: flex;
        }

        .shape-view-header {
            padding: 1.5rem;
            background: white;
            border-bottom: 1px solid #E5DDD1;
        }

        .shape-view-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #3D2E1F;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .shape-view-title i {
            color: #C88F4A;
        }

        .shape-view-subtitle {
            font-size: 0.875rem;
            color: #8B6F47;
            margin-top: 0.25rem;
        }

        .shape-view-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .shape-view-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: #8B6F47;
        }

        .shape-view-empty i {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: #C88F4A;
            opacity: 0.5;
        }

        .shape-view-empty h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: #3D2E1F;
        }

        .shape-view-empty p {
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            max-width: 400px;
        }

        .shape-tree {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .shape-node {
            background: white;
            border-radius: 8px;
            border: 1px solid #E5DDD1;
            overflow: hidden;
        }

        .shape-node-header {
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .shape-node-header:hover {
            background: #FAF7F5;
        }

        .shape-node-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8B6F47;
            transition: transform 0.2s;
        }

        .shape-node.expanded .shape-node-toggle {
            transform: rotate(90deg);
        }

        .shape-node-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }

        .shape-node-icon.unit { background: #FFF9F0; color: #C88F4A; }
        .shape-node-icon.team { background: #F0F4F7; color: #7B95A3; }
        .shape-node-icon.role { background: #F5F0E8; color: #8B6F47; }

        .shape-node-name {
            font-weight: 500;
            color: #3D2E1F;
            flex: 1;
        }

        .shape-node-count {
            font-size: 0.75rem;
            color: #8B6F47;
            background: #F5F2ED;
            padding: 0.25rem 0.5rem;
            border-radius: 10px;
        }

        .shape-node-children {
            display: none;
            padding: 0 0.5rem 0.5rem 2.5rem;
        }

        .shape-node.expanded .shape-node-children {
            display: block;
        }

        .shape-insights {
            background: white;
            border-radius: 12px;
            border: 1px solid #E5DDD1;
            padding: 1.25rem;
            margin-bottom: 1rem;
        }

        .shape-insights-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .shape-insights-title i {
            color: #C88F4A;
        }

        .shape-insight-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid #F5F2ED;
            font-size: 0.875rem;
            color: #6B5642;
        }

        .shape-insight-item:last-child {
            border-bottom: none;
        }

        .shape-insight-item i {
            color: #8B6F47;
        }

        .shape-insight-value {
            font-weight: 600;
            color: #3D2E1F;
        }

        .shape-insight-item.active {
            color: #4CAF50;
        }

        .shape-insight-item.idle {
            color: #F5A623;
        }

        .shape-suggestion {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 1rem;
            background: linear-gradient(135deg, #FFFDF5 0%, #FFF9E6 100%);
            border: 1px solid #F5D89A;
            border-radius: 12px;
            margin-bottom: 1rem;
        }

        .shape-suggestion i {
            color: #C88F4A;
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .shape-suggestion-content {
            font-size: 0.875rem;
            color: #6B5642;
        }

        .shape-suggestion-content strong {
            color: #3D2E1F;
            display: block;
            margin-bottom: 0.25rem;
        }

        .shape-suggestion-content p {
            margin: 0;
        }

        .shape-section {
            margin-bottom: 1.5rem;
        }

        .shape-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .shape-section-title i {
            color: #8B6F47;
        }

        .shape-roles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 0.75rem;
        }

        .shape-role-card {
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 10px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .shape-role-card:hover {
            border-color: #C88F4A;
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.15);
        }

        .shape-role-card.active {
            border-left: 3px solid #4CAF50;
        }

        .shape-role-card.idle {
            border-left: 3px solid #E5DDD1;
            opacity: 0.75;
        }

        .shape-role-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .shape-role-name {
            font-weight: 600;
            color: #3D2E1F;
            font-size: 0.9rem;
        }

        .shape-role-badge {
            font-size: 0.7rem;
            font-weight: 500;
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
        }

        .shape-role-badge.active {
            background: rgba(76, 175, 80, 0.15);
            color: #4CAF50;
        }

        .shape-role-badge.idle {
            background: #F5F2ED;
            color: #8B6F47;
        }

        .shape-role-people {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
        }

        .shape-person-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            color: #6B5642;
            background: #FAF7F5;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
        }

        .shape-role-empty {
            font-size: 0.75rem;
            color: #A89C8C;
            font-style: italic;
        }

        .shape-node-badge {
            font-size: 0.65rem;
            font-weight: 600;
            padding: 0.15rem 0.4rem;
            border-radius: 8px;
            margin-left: 0.5rem;
        }

        .shape-node-badge.active {
            background: rgba(76, 175, 80, 0.15);
            color: #4CAF50;
        }

        .shape-node-badge.idle {
            background: #F5F2ED;
            color: #A89C8C;
        }

        /* ============================================
           GANTT VIEW STYLES
           ============================================ */

        .gantt-view {
            display: none;
            flex-direction: column;
            height: 100%;
            background: #FAF7F5;
        }

        .gantt-view.active {
            display: flex;
        }

        .gantt-view-content {
            flex: 1;
            overflow: auto;
            padding: 1.5rem;
        }

        .gantt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .gantt-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .gantt-container {
            background: white;
            border-radius: 8px;
            border: 1px solid #E5DDD1;
            overflow: hidden;
        }

        .gantt-timeline-header {
            display: flex;
            border-bottom: 1px solid #E5DDD1;
            background: #FAF7F5;
            font-size: 0.75rem;
            color: #6B5642;
            font-weight: 600;
        }

        .gantt-task-column {
            width: 250px;
            min-width: 250px;
            padding: 0.5rem 1rem;
            border-right: 1px solid #E5DDD1;
        }

        .gantt-timeline-dates {
            flex: 1;
            display: flex;
            overflow-x: auto;
        }

        .gantt-date-cell {
            min-width: 40px;
            padding: 0.5rem 0.25rem;
            text-align: center;
            border-right: 1px solid #E5DDD1;
        }

        .gantt-date-cell.weekend {
            background: #F5F2ED;
        }

        .gantt-date-cell.today {
            background: rgba(200, 143, 74, 0.15);
            color: #C88F4A;
            font-weight: 600;
        }

        .gantt-row {
            display: flex;
            border-bottom: 1px solid #E5DDD1;
            min-height: 40px;
        }

        .gantt-row:last-child {
            border-bottom: none;
        }

        .gantt-task-cell {
            width: 250px;
            min-width: 250px;
            padding: 0.5rem 1rem;
            border-right: 1px solid #E5DDD1;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .gantt-task-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .gantt-task-status.pending { background: #F59E0B; }
        .gantt-task-status.in-progress { background: #3B82F6; }
        .gantt-task-status.completed { background: #10B981; }

        .gantt-bar-area {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            min-height: 40px;
        }

        .gantt-bar {
            position: absolute;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 0.5rem;
            font-size: 0.75rem;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            transition: filter 0.2s;
        }

        .gantt-bar:hover {
            filter: brightness(0.9);
        }

        .gantt-bar.pending { background: #F59E0B; }
        .gantt-bar.in-progress { background: #3B82F6; }
        .gantt-bar.completed { background: #10B981; }
        .gantt-bar.overdue { background: #EF4444; }

        .gantt-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            text-align: center;
            color: #8B6F47;
        }

        .gantt-empty i {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: #C88F4A;
            opacity: 0.5;
        }

        .gantt-empty h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: #3D2E1F;
        }

        /* ============================================
           CALENDAR VIEW STYLES
           ============================================ */

        .calendar-view {
            display: none;
            flex-direction: column;
            height: 100%;
            background: #FAF7F5;
        }

        .calendar-view.active {
            display: flex;
        }

        .calendar-view-content {
            flex: 1;
            overflow: auto;
            padding: 1.5rem;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .calendar-nav-btn {
            background: white;
            border: 1px solid #E5DDD1;
            border-radius: 6px;
            padding: 0.5rem;
            cursor: pointer;
            color: #3D2E1F;
            transition: background 0.2s;
        }

        .calendar-nav-btn:hover {
            background: #FAF7F5;
        }

        .calendar-month-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #3D2E1F;
            min-width: 180px;
            text-align: center;
        }

        .calendar-today-btn {
            background: #C88F4A;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: background 0.2s;
        }

        .calendar-today-btn:hover {
            background: #A87339;
        }

        .calendar-grid {
            background: white;
            border-radius: 8px;
            border: 1px solid #E5DDD1;
            overflow: hidden;
        }

        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            background: #FAF7F5;
            border-bottom: 1px solid #E5DDD1;
        }

        .calendar-weekday {
            padding: 0.75rem;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: #6B5642;
            text-transform: uppercase;
        }

        .calendar-days {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }

        .calendar-day {
            min-height: 100px;
            padding: 0.5rem;
            border-right: 1px solid #E5DDD1;
            border-bottom: 1px solid #E5DDD1;
            cursor: pointer;
            transition: background 0.2s;
        }

        .calendar-day:nth-child(7n) {
            border-right: none;
        }

        .calendar-day:hover {
            background: #FAF7F5;
        }

        .calendar-day.other-month {
            background: #F5F2ED;
            color: #A89C8C;
        }

        .calendar-day.today {
            background: rgba(200, 143, 74, 0.1);
        }

        .calendar-day-number {
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .calendar-day.today .calendar-day-number {
            color: #C88F4A;
            font-weight: 600;
        }

        .calendar-day-tasks {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .calendar-task {
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        .calendar-task.pending {
            background: rgba(245, 158, 11, 0.15);
            color: #B45309;
        }

        .calendar-task.in-progress {
            background: rgba(59, 130, 246, 0.15);
            color: #1D4ED8;
        }

        .calendar-task.completed {
            background: rgba(16, 185, 129, 0.15);
            color: #047857;
        }

        .calendar-task.overdue {
            background: rgba(239, 68, 68, 0.15);
            color: #DC2626;
        }

        .calendar-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            text-align: center;
            color: #8B6F47;
        }

        .calendar-empty i {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: #C88F4A;
            opacity: 0.5;
        }

        .calendar-empty h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: #3D2E1F;
        }

        /* ============================================
           ENHANCED TASK MANAGEMENT STYLES
           Asana-style features with EO holonic integration
           ============================================ */

        /* Priority Badges */
        .task-priority {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .task-priority i {
            font-size: 0.9rem;
        }

        .task-priority.urgent {
            background: linear-gradient(135deg, #FEE2E2, #FECACA);
            color: #DC2626;
            border: 1px solid #F87171;
            animation: pulse-urgent 2s infinite;
        }

        @keyframes pulse-urgent {
            0%, 100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.3); }
            50% { box-shadow: 0 0 0 4px rgba(220, 38, 38, 0); }
        }

        .task-priority.high {
            background: linear-gradient(135deg, #FEF3C7, #FDE68A);
            color: #B45309;
            border: 1px solid #F59E0B;
        }

        .task-priority.medium {
            background: linear-gradient(135deg, #DBEAFE, #BFDBFE);
            color: #1D4ED8;
            border: 1px solid #60A5FA;
        }

        .task-priority.low {
            background: linear-gradient(135deg, #F3F4F6, #E5E7EB);
            color: #4B5563;
            border: 1px solid #D1D5DB;
        }

        /* Tags System */
        .task-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            margin-top: 0.5rem;
        }

        .task-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            background: #F3F4F6;
            border-radius: 12px;
            font-size: 0.75rem;
            color: #4B5563;
            cursor: pointer;
            transition: all 0.15s;
        }

        .task-tag:hover {
            background: #E5E7EB;
        }

        .task-tag .tag-remove {
            font-size: 0.65rem;
            opacity: 0.6;
        }

        .task-tag .tag-remove:hover {
            opacity: 1;
        }

        /* Custom tag colors */
        .task-tag[data-color="blue"] { background: #DBEAFE; color: #1E40AF; }
        .task-tag[data-color="green"] { background: #D1FAE5; color: #065F46; }
        .task-tag[data-color="yellow"] { background: #FEF3C7; color: #92400E; }
        .task-tag[data-color="red"] { background: #FEE2E2; color: #991B1B; }
        .task-tag[data-color="purple"] { background: #EDE9FE; color: #5B21B6; }
        .task-tag[data-color="pink"] { background: #FCE7F3; color: #9D174D; }
        .task-tag[data-color="orange"] { background: #FFEDD5; color: #9A3412; }

        /* Tags Input */
        .tags-input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            padding: 0.5rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            background: #FAF7F5;
            min-height: 42px;
            cursor: text;
        }

        .tags-input-container:focus-within {
            border-color: #C88F4A;
            background: white;
        }

        .tags-input-container input {
            flex: 1;
            min-width: 100px;
            border: none;
            background: transparent;
            outline: none;
            font-size: 0.9rem;
            padding: 0.25rem;
        }

        /* Collaborators/Followers */
        .task-collaborators {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .collaborator-avatars {
            display: flex;
        }

        .collaborator-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
            border: 2px solid white;
            margin-left: -8px;
            cursor: pointer;
            transition: transform 0.15s;
        }

        .collaborator-avatar:first-child {
            margin-left: 0;
        }

        .collaborator-avatar:hover {
            transform: scale(1.1);
            z-index: 1;
        }

        .collaborator-add {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #F3F4F6;
            border: 2px dashed #D1D5DB;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #9CA3AF;
            transition: all 0.15s;
        }

        .collaborator-add:hover {
            background: #E5E7EB;
            border-color: #9CA3AF;
            color: #6B7280;
        }

        /* Comments Section */
        .task-comments {
            margin-top: 1rem;
            border-top: 1px solid #E5DDD1;
            padding-top: 1rem;
        }

        .task-comments-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .task-comments-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #6B5642;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-comments-count {
            background: #E5DDD1;
            color: #6B5642;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
        }

        .comment-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem;
            background: #FAF7F5;
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        .comment-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #7B95A3 0%, #5B7585 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .comment-content {
            flex: 1;
        }

        .comment-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .comment-author {
            font-weight: 600;
            font-size: 0.875rem;
            color: #3D2E1F;
        }

        .comment-time {
            font-size: 0.75rem;
            color: #8B6F47;
        }

        .comment-text {
            font-size: 0.875rem;
            color: #4B5563;
            line-height: 1.5;
        }

        .comment-text .mention {
            color: #C88F4A;
            font-weight: 500;
            cursor: pointer;
        }

        .comment-text .mention:hover {
            text-decoration: underline;
        }

        .comment-input-container {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem;
            background: #FAF7F5;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .comment-input-container:focus-within {
            border-color: #C88F4A;
            background: white;
        }

        .comment-input {
            flex: 1;
            border: none;
            background: transparent;
            outline: none;
            font-size: 0.875rem;
            resize: none;
            min-height: 24px;
            max-height: 120px;
        }

        .comment-submit-btn {
            background: #C88F4A;
            color: white;
            border: none;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.15s;
        }

        .comment-submit-btn:hover {
            background: #B07D3A;
        }

        .comment-submit-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* @Mention Autocomplete */
        .mention-autocomplete {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            min-width: 200px;
            display: none;
        }

        .mention-autocomplete.active {
            display: block;
        }

        .mention-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .mention-option:hover,
        .mention-option.highlighted {
            background: #FAF7F5;
        }

        .mention-option-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #E5DDD1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: #6B5642;
        }

        .mention-option-icon.role {
            background: #DBEAFE;
            color: #1E40AF;
        }

        .mention-option-icon.person {
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
        }

        .mention-option-name {
            font-size: 0.875rem;
            color: #3D2E1F;
        }

        .mention-option-type {
            font-size: 0.7rem;
            color: #8B6F47;
            margin-left: auto;
        }

        /* Comment Actions & Reactions */
        .comment-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .comment-item:hover .comment-actions {
            opacity: 1;
        }

        .comment-action-btn {
            background: none;
            border: none;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            color: #8B6F47;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.15s;
        }

        .comment-action-btn:hover {
            background: #E5DDD1;
            color: #6B5642;
        }

        .comment-action-btn.resolve {
            color: #059669;
        }

        .comment-action-btn.resolve:hover {
            background: #D1FAE5;
        }

        .comment-action-btn.delete {
            color: #DC2626;
        }

        .comment-action-btn.delete:hover {
            background: #FEE2E2;
        }

        /* Comment Reactions */
        .comment-reactions {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            margin-top: 0.5rem;
        }

        .comment-reaction {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: #FAF7F5;
            border: 1px solid #E5DDD1;
            border-radius: 999px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .comment-reaction:hover {
            background: #F5EFE6;
            border-color: #D1C6B5;
        }

        .comment-reaction.active {
            background: #FEF3C7;
            border-color: #F59E0B;
        }

        .comment-reaction-emoji {
            font-size: 0.875rem;
        }

        .comment-reaction-count {
            color: #6B5642;
            font-weight: 500;
        }

        .add-reaction-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #FAF7F5;
            border: 1px dashed #D1C6B5;
            color: #8B6F47;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            transition: all 0.15s;
        }

        .add-reaction-btn:hover {
            background: #F5EFE6;
            border-style: solid;
        }

        /* Emoji Picker */
        .emoji-picker {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 0.5rem;
            z-index: 1001;
            display: none;
        }

        .emoji-picker.active {
            display: block;
        }

        .emoji-picker-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.25rem;
        }

        .emoji-picker-item {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
        }

        .emoji-picker-item:hover {
            background: #FAF7F5;
        }

        /* Resolved Comment Style */
        .comment-item.resolved {
            opacity: 0.7;
            background: #F0FDF4;
            border-left: 3px solid #10B981;
        }

        .comment-resolved-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            color: #059669;
            background: #D1FAE5;
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        /* Collapsible Section Styles */
        .collapsible-section {
            margin-top: 1rem;
            border-top: 1px solid #E5DDD1;
            padding-top: 0.75rem;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.5rem 0;
            user-select: none;
        }

        .collapsible-header:hover {
            opacity: 0.8;
        }

        .collapsible-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #6B5642;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .collapsible-toggle {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            font-size: 0.75rem;
            color: #8B6F47;
        }

        .collapsible-toggle i {
            transition: transform 0.2s;
        }

        .collapsible-section.collapsed .collapsible-toggle i {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            max-height: 2000px;
        }

        .collapsible-section.collapsed .collapsible-content {
            max-height: 0;
        }

        .collapsible-badge {
            background: #E5DDD1;
            color: #6B5642;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .subtask-prereq-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #C88F4A;
            font-style: italic;
        }

        /* Comment Input Wrapper with Mention Dropdown */
        .comment-input-wrapper {
            position: relative;
            flex: 1;
        }

        /* Description Field */
        .task-description-field {
            width: 100%;
            min-height: 80px;
            padding: 0.875rem 1rem;
            font-size: 0.9rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            background: #FAF7F5;
            color: #3D2E1F;
            resize: vertical;
            font-family: inherit;
            line-height: 1.5;
            transition: all 0.2s;
        }

        .task-description-field:focus {
            outline: none;
            border-color: #C88F4A;
            background: white;
        }

        .task-description-field::placeholder {
            color: #A99D8F;
        }

        /* Role Context Display */
        .role-context-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, #FAF7F5 0%, #F5EFE6 100%);
            border-radius: 8px;
            border: 1px solid #E5DDD1;
            margin-bottom: 1rem;
        }

        .role-context-breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.8rem;
            color: #6B5642;
        }

        .role-context-breadcrumb i {
            font-size: 0.7rem;
            color: #A99D8F;
        }

        .role-context-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .role-context-item:hover {
            background: rgba(200, 143, 74, 0.1);
        }

        .role-context-item.unit {
            color: #7B95A3;
        }

        .role-context-item.team {
            color: #B87B5B;
        }

        .role-context-item.role {
            color: #C88F4A;
            font-weight: 600;
        }

        /* Required Role Indicator */
        .required-indicator {
            color: #DC2626;
            font-weight: 500;
            margin-left: 0.25rem;
        }

        .role-required-notice {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.625rem 0.875rem;
            background: #FEF3C7;
            border: 1px solid #FCD34D;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #92400E;
            margin-top: 0.5rem;
        }

        .role-required-notice i {
            font-size: 1rem;
        }

        /* Subtasks Section */
        .subtasks-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #E5DDD1;
        }

        .subtasks-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .subtasks-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #6B5642;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Help tooltip for section explanations */
        .section-help-tooltip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: #E5DDD1;
            border-radius: 50%;
            cursor: help;
            font-size: 0.65rem;
            color: #8B6F47;
            transition: all 0.15s;
        }

        .section-help-tooltip:hover {
            background: #C88F4A;
            color: white;
        }

        .section-help-tooltip i {
            font-size: 0.6rem;
        }

        .subtask-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .subtask-progress-bar {
            width: 60px;
            height: 6px;
            background: #E5DDD1;
            border-radius: 3px;
            overflow: hidden;
        }

        .subtask-progress-fill {
            height: 100%;
            background: #10B981;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .subtask-progress-text {
            font-size: 0.75rem;
            color: #6B5642;
        }

        .subtask-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.625rem;
            background: #FAF7F5;
            border-radius: 6px;
            margin-bottom: 0.375rem;
            transition: all 0.15s;
        }

        .subtask-item:hover {
            background: #F5EFE6;
        }

        .subtask-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid #D1D5DB;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            margin-top: 2px;
            transition: all 0.15s;
        }

        .subtask-checkbox:hover {
            border-color: #C88F4A;
        }

        .subtask-checkbox.checked {
            background: #10B981;
            border-color: #10B981;
            color: white;
        }

        .subtask-content {
            flex: 1;
        }

        .subtask-name {
            font-size: 0.875rem;
            color: #3D2E1F;
        }

        .subtask-item.completed .subtask-name {
            text-decoration: line-through;
            color: #9CA3AF;
        }

        .subtask-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }

        .subtask-role {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            color: #6B5642;
            background: #E5DDD1;
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
        }

        .subtask-due {
            font-size: 0.75rem;
            color: #8B6F47;
        }

        .add-subtask-btn {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.5rem 0.75rem;
            background: transparent;
            border: 1px dashed #D1D5DB;
            border-radius: 6px;
            color: #6B5642;
            font-size: 0.8rem;
            cursor: pointer;
            width: 100%;
            justify-content: center;
            transition: all 0.15s;
        }

        .add-subtask-btn:hover {
            background: #FAF7F5;
            border-color: #C88F4A;
            color: #C88F4A;
        }

        /* Inline Subtask Input Row */
        .subtask-input-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.625rem;
            background: transparent;
            border: 1px dashed #D1D5DB;
            border-radius: 6px;
            cursor: text;
            transition: all 0.15s;
        }

        .subtask-input-row:hover {
            background: #FAF7F5;
            border-color: #C88F4A;
        }

        .subtask-input-row:focus-within {
            background: #FAF7F5;
            border: 1px solid #C88F4A;
            box-shadow: 0 0 0 3px rgba(200, 143, 74, 0.1);
        }

        .subtask-input-row .input-icon {
            color: #9CA3AF;
            font-size: 0.875rem;
            flex-shrink: 0;
            transition: color 0.15s;
        }

        .subtask-input-row:focus-within .input-icon {
            color: #C88F4A;
        }

        .subtask-input-row input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 0.8rem;
            color: #3D2E1F;
            outline: none;
            font-family: inherit;
        }

        .subtask-input-row input::placeholder {
            color: #9CA3AF;
        }

        .subtask-input-row input:focus::placeholder {
            color: #C88F4A;
            opacity: 0.6;
        }

        .subtask-input-actions {
            display: none;
            align-items: center;
            gap: 0.25rem;
        }

        .subtask-input-row:focus-within .subtask-input-actions {
            display: flex;
        }

        .subtask-input-btn {
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .subtask-input-btn.submit {
            background: #C88F4A;
            color: white;
        }

        .subtask-input-btn.submit:hover {
            background: #B07D3A;
        }

        .subtask-input-btn.submit:disabled {
            background: #D1D5DB;
            cursor: not-allowed;
        }

        .subtask-input-hint {
            font-size: 0.65rem;
            color: #9CA3AF;
            margin-left: auto;
        }

        .subtask-input-row:focus-within .subtask-input-hint {
            color: #8B6F47;
        }

        .subtask-blocking-notice {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            margin-top: 0.75rem;
            background: #FEF3C7;
            border: 1px solid #F59E0B;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #92400E;
        }

        .subtask-blocking-notice i {
            font-size: 1rem;
            color: #F59E0B;
        }

        /* Automation Rules */
        .automation-rules-section {
            margin-top: 1.5rem;
            padding: 1rem;
            background: #F9FAFB;
            border-radius: 8px;
            border: 1px solid #E5E7EB;
        }

        .automation-rule {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            border: 1px solid #E5E7EB;
            margin-bottom: 0.5rem;
        }

        .automation-rule-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: #EDE9FE;
            color: #7C3AED;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .automation-rule-content {
            flex: 1;
        }

        .automation-rule-name {
            font-weight: 600;
            font-size: 0.875rem;
            color: #3D2E1F;
        }

        .automation-rule-description {
            font-size: 0.8rem;
            color: #6B7280;
            margin-top: 0.125rem;
        }

        .automation-rule-toggle {
            width: 40px;
            height: 22px;
            background: #D1D5DB;
            border-radius: 11px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }

        .automation-rule-toggle.active {
            background: #10B981;
        }

        .automation-rule-toggle::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }

        .automation-rule-toggle.active::after {
            transform: translateX(18px);
        }

        /* Notifications Panel */
        .notifications-panel {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 380px;
            max-height: calc(100vh - 100px);
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            z-index: 1001;
            display: none;
            overflow: hidden;
        }

        .notifications-panel.open {
            display: block;
        }

        .notifications-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #E5E7EB;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .notifications-title {
            font-weight: 600;
            font-size: 1rem;
            color: #3D2E1F;
        }

        .notifications-actions {
            display: flex;
            gap: 0.5rem;
        }

        .notifications-action-btn {
            background: none;
            border: none;
            color: #6B5642;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
        }

        .notifications-action-btn:hover {
            background: #F3F4F6;
        }

        .notifications-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .notification-item {
            display: flex;
            gap: 0.75rem;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #F3F4F6;
            cursor: pointer;
            transition: background 0.15s;
        }

        .notification-item:hover {
            background: #FAF7F5;
        }

        .notification-item.unread {
            background: #FEF3C7;
        }

        .notification-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .notification-icon.task {
            background: #DBEAFE;
            color: #2563EB;
        }

        .notification-icon.comment {
            background: #D1FAE5;
            color: #059669;
        }

        .notification-icon.mention {
            background: #FCE7F3;
            color: #DB2777;
        }

        .notification-icon.assignment {
            background: #EDE9FE;
            color: #7C3AED;
        }

        .notification-content {
            flex: 1;
        }

        .notification-text {
            font-size: 0.875rem;
            color: #3D2E1F;
            line-height: 1.4;
        }

        .notification-text strong {
            font-weight: 600;
        }

        .notification-time {
            font-size: 0.75rem;
            color: #8B6F47;
            margin-top: 0.25rem;
        }

        .notification-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 18px;
            height: 18px;
            background: #DC2626;
            color: white;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Dashboard Cards */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            padding: 1.5rem;
        }

        .dashboard-card {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .dashboard-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .dashboard-card-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: #3D2E1F;
        }

        .dashboard-stat {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }

        .dashboard-stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #C88F4A;
        }

        .dashboard-stat-label {
            font-size: 0.8rem;
            color: #6B5642;
        }

        .dashboard-chart {
            height: 120px;
            margin-top: 1rem;
        }

        /* Workload Distribution */
        .workload-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid #F3F4F6;
        }

        .workload-item:last-child {
            border-bottom: none;
        }

        .workload-role {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .workload-role-name {
            font-size: 0.875rem;
            color: #3D2E1F;
        }

        .workload-bar {
            width: 100px;
            height: 8px;
            background: #E5DDD1;
            border-radius: 4px;
            overflow: hidden;
        }

        .workload-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .workload-bar-fill.low { background: #10B981; }
        .workload-bar-fill.medium { background: #F59E0B; }
        .workload-bar-fill.high { background: #EF4444; }

        .workload-count {
            font-size: 0.8rem;
            color: #6B5642;
            min-width: 50px;
            text-align: right;
        }

        /* Recurring Task Indicator */
        .recurring-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            background: #EDE9FE;
            color: #7C3AED;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        /* Custom Fields Section */
        .custom-fields-section {
            margin-top: 1rem;
        }

        .custom-field-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
        }

        .custom-field-label {
            font-size: 0.8rem;
            color: #6B5642;
            min-width: 100px;
        }

        .custom-field-value {
            flex: 1;
            font-size: 0.875rem;
            color: #3D2E1F;
        }

        /* Hero Task Modal Enhancements */
        .hero-task-description-group {
            margin-top: 1rem;
        }

        .hero-task-priority-group {
            margin-top: 1rem;
        }

        .priority-select {
            display: flex;
            gap: 0.5rem;
        }

        .priority-option {
            flex: 1;
            padding: 0.625rem 0.75rem;
            border: 2px solid #E5DDD1;
            border-radius: 8px;
            background: #FAF7F5;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.15s;
        }

        .priority-option:hover {
            border-color: #C88F4A;
        }

        .priority-option.selected {
            border-color: currentColor;
            background: currentColor;
        }

        .priority-option.selected span {
            color: white;
        }

        .priority-option.urgent { color: #DC2626; }
        .priority-option.high { color: #D97706; }
        .priority-option.medium { color: #2563EB; }
        .priority-option.low { color: #6B7280; }

        .priority-option.urgent.selected { background: #DC2626; border-color: #DC2626; }
        .priority-option.high.selected { background: #D97706; border-color: #D97706; }
        .priority-option.medium.selected { background: #2563EB; border-color: #2563EB; }
        .priority-option.low.selected { background: #6B7280; border-color: #6B7280; }

        /* ==========================================
           LOGIN / AUTHENTICATION STYLES
           ========================================== */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #F5F2ED 0%, #E8E2D9 100%);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .login-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .login-container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 40px rgba(0,0,0,0.12);
            padding: 2.5rem;
            width: 100%;
            max-width: 420px;
            text-align: center;
        }

        .login-logo {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1.5rem;
            color: white;
            font-size: 2rem;
        }

        .login-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #3D2E1F;
            margin-bottom: 0.5rem;
        }

        .login-subtitle {
            color: #6B5642;
            font-size: 0.95rem;
            margin-bottom: 2rem;
        }

        .login-form-group {
            margin-bottom: 1.25rem;
            text-align: left;
        }

        .login-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            color: #3D2E1F;
            margin-bottom: 0.5rem;
        }

        .login-input {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid #E5DDD1;
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            background: #FAF7F5;
        }

        .login-input:focus {
            outline: none;
            border-color: #C88F4A;
            box-shadow: 0 0 0 3px rgba(200, 143, 74, 0.15);
            background: white;
        }

        .login-input::placeholder {
            color: #A89A8B;
        }

        .login-input.error {
            border-color: #DC2626;
            background: #FEF2F2;
        }

        .login-code-input {
            text-align: center;
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: 0.5rem;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .login-btn {
            width: 100%;
            padding: 0.875rem 1.5rem;
            background: linear-gradient(135deg, #C88F4A 0%, #B87B5B 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .login-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(200, 143, 74, 0.3);
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .login-btn .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .login-error {
            background: #FEF2F2;
            border: 1px solid #FECACA;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: #DC2626;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            display: none;
        }

        .login-error.show {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .login-success {
            background: #F0FDF4;
            border: 1px solid #BBF7D0;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: #166534;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            display: none;
        }

        .login-success.show {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .login-back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            color: #6B5642;
            font-size: 0.875rem;
            cursor: pointer;
            margin-top: 1.25rem;
            transition: color 0.15s;
        }

        .login-back-link:hover {
            color: #C88F4A;
        }

        .login-step {
            display: none;
        }

        .login-step.active {
            display: block;
        }

        .login-email-display {
            background: #FAF7F5;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            color: #3D2E1F;
            word-break: break-all;
        }

        .login-resend {
            color: #6B5642;
            font-size: 0.85rem;
            margin-top: 1rem;
        }

        .login-resend-link {
            color: #C88F4A;
            cursor: pointer;
            font-weight: 500;
        }

        .login-resend-link:hover {
            text-decoration: underline;
        }

        .login-resend-link.disabled {
            color: #A89A8B;
            cursor: not-allowed;
        }

        /* User menu in header for logged-in users */
        .user-menu-container {
            position: relative;
        }

        .user-menu-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            padding: 0.35rem 0.75rem;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .user-menu-btn:hover {
            background: rgba(255,255,255,0.25);
            border-color: rgba(255,255,255,0.5);
        }

        .user-menu-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(255,255,255,0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.7rem;
        }

        .user-menu-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            min-width: 200px;
            z-index: 1000;
            display: none;
            overflow: hidden;
        }

        .user-menu-dropdown.open {
            display: block;
        }

        .user-menu-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #E5DDD1;
        }

        .user-menu-email {
            font-size: 0.85rem;
            color: #3D2E1F;
            font-weight: 500;
            word-break: break-all;
        }

        .user-menu-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.75rem 1rem;
            border: none;
            background: none;
            cursor: pointer;
            color: #3D2E1F;
            font-size: 0.875rem;
            transition: background 0.15s;
            text-align: left;
        }

        .user-menu-item:hover {
            background: #FAF7F5;
        }

        .user-menu-item.danger {
            color: #DC2626;
        }

        .user-menu-item.danger:hover {
            background: #FEF2F2;
        }
    </style>

    <!-- Login Overlay - gates app until authenticated -->
    <div id="loginOverlay" class="login-overlay">
        <div class="login-container">
            <div class="login-logo">
                <i class="ph ph-check-square"></i>
            </div>

            <!-- Step 1: Email Input -->
            <div id="loginStepEmail" class="login-step active">
                <h2 class="login-title">Welcome to Taskflow</h2>
                <p class="login-subtitle">Enter your email to receive a login code</p>

                <div id="loginErrorEmail" class="login-error">
                    <i class="ph ph-warning-circle"></i>
                    <span id="loginErrorEmailText">An error occurred</span>
                </div>

                <form id="loginEmailForm" onsubmit="AuthManager.handleEmailSubmit(event)">
                    <div class="login-form-group">
                        <label class="login-label" for="loginEmail">Email address</label>
                        <input
                            type="email"
                            id="loginEmail"
                            class="login-input"
                            placeholder="you@example.com"
                            required
                            autocomplete="email"
                        >
                    </div>
                    <button type="submit" class="login-btn" id="loginEmailBtn">
                        <span id="loginEmailBtnText">Send Login Code</span>
                    </button>
                </form>
            </div>

            <!-- Step 2: Code Verification -->
            <div id="loginStepCode" class="login-step">
                <h2 class="login-title">Check your email</h2>
                <p class="login-subtitle">We sent a 6-digit code to</p>
                <div class="login-email-display" id="loginEmailDisplay">user@example.com</div>

                <div id="loginSuccessCode" class="login-success">
                    <i class="ph ph-check-circle"></i>
                    <span>Code sent! Check your email.</span>
                </div>

                <div id="loginErrorCode" class="login-error">
                    <i class="ph ph-warning-circle"></i>
                    <span id="loginErrorCodeText">Invalid code</span>
                </div>

                <form id="loginCodeForm" onsubmit="AuthManager.handleCodeSubmit(event)">
                    <div class="login-form-group">
                        <label class="login-label" for="loginCode">Enter code</label>
                        <input
                            type="text"
                            id="loginCode"
                            class="login-input login-code-input"
                            placeholder="000000"
                            maxlength="6"
                            pattern="[0-9]{6}"
                            inputmode="numeric"
                            autocomplete="one-time-code"
                            required
                        >
                    </div>
                    <button type="submit" class="login-btn" id="loginCodeBtn">
                        <span id="loginCodeBtnText">Verify Code</span>
                    </button>
                </form>

                <div class="login-resend">
                    Didn't receive the code?
                    <span class="login-resend-link" id="loginResendLink" onclick="AuthManager.resendCode()">Resend</span>
                </div>

                <div class="login-back-link" onclick="AuthManager.backToEmail()">
                    <i class="ph ph-arrow-left"></i> Use a different email
                </div>
            </div>
        </div>
    </div>

    <!-- Main App Container (hidden until authenticated) -->
    <div id="mainAppContainer">
    <div class="header">
        <!-- LEFT ZONE: Navigation & Context -->
        <div class="header-left">
            <div class="workspace-selector">
                <button class="workspace-dropdown-toggle" onclick="toggleWorkspaceDropdown(event)">
                    <span class="workspace-name" id="workspaceNameText">My Organization</span>
                    <i class="ph ph-caret-down"></i>
                </button>
                <div class="workspace-dropdown" id="workspaceDropdown">
                    <div class="workspace-dropdown-header">Workspaces</div>
                    <div class="workspace-list" id="workspaceList">
                        <!-- Workspace items populated by JS -->
                    </div>
                    <div class="workspace-dropdown-footer">
                        <button class="workspace-new-btn" onclick="openNewWorkspaceModal()">
                            <i class="ph ph-plus-circle"></i> New Workspace
                        </button>
                    </div>
                </div>
            </div>
            <div id="loadingStatus" class="header-loading-status">
                <i class="ph ph-spinner"></i>
            </div>
        </div>

        <!-- CENTER ZONE: View Tabs -->
        <div class="header-center">
            <div class="view-tabs">
                <button class="view-tab active" data-view="kanban" onclick="switchView('kanban')">
                    <i class="ph ph-columns"></i>
                    <span>Kanban</span>
                </button>
                <button class="view-tab" data-view="table" onclick="switchView('table')">
                    <i class="ph ph-table"></i>
                    <span>Table</span>
                </button>
                <button class="view-tab" data-view="gantt" onclick="switchView('gantt')">
                    <i class="ph ph-chart-bar-horizontal"></i>
                    <span>Gantt</span>
                </button>
                <button class="view-tab" data-view="timeline" onclick="switchView('timeline')">
                    <i class="ph ph-clock-countdown"></i>
                    <span>Timeline</span>
                </button>
                <button class="view-tab" data-view="calendar" onclick="switchView('calendar')">
                    <i class="ph ph-calendar"></i>
                    <span>Calendar</span>
                </button>
            </div>
        </div>

        <!-- RIGHT ZONE: Actions & User -->
        <div class="header-right">
            <!-- Advanced Filter Button -->
            <button class="header-icon-btn" onclick="openAdvancedFilterPanel()" title="Filters & History">
                <i class="ph ph-funnel"></i>
                <span class="filter-active-badge" id="viewFilterBadge" style="display: none;"></span>
            </button>

            <!-- Time Travel Button -->
            <button class="header-icon-btn" onclick="openAdvancedFilterPanel(); document.getElementById('timeTravelDateInput').focus();" title="Time Travel" id="timeTravelBtn">
                <i class="ph ph-clock-counter-clockwise"></i>
            </button>

            <!-- Legacy Filter Dropdown (hidden, kept for compatibility) -->
            <div class="view-filter-dropdown" style="display: none;">
                <div class="view-filter-menu" id="viewFilterMenu">
                    <div class="view-filter-section">
                        <div class="view-filter-section-title">Filter by</div>
                        <label class="view-filter-item">
                            <input type="checkbox" id="viewFilterRole" checked onchange="applyViewFilters()">
                            <i class="ph ph-briefcase"></i> Roles
                        </label>
                        <label class="view-filter-item">
                            <input type="checkbox" id="viewFilterPerson" checked onchange="applyViewFilters()">
                            <i class="ph ph-user"></i> People
                        </label>
                        <label class="view-filter-item">
                            <input type="checkbox" id="viewFilterTeam" checked onchange="applyViewFilters()">
                            <i class="ph ph-users"></i> Teams
                        </label>
                        <label class="view-filter-item">
                            <input type="checkbox" id="viewFilterUnit" checked onchange="applyViewFilters()">
                            <i class="ph ph-buildings"></i> Units
                        </label>
                    </div>
                    <div class="view-filter-actions">
                        <button class="btn btn-small" onclick="selectAllViewFilters()">All</button>
                        <button class="btn btn-small btn-outline" onclick="clearViewFilters()">None</button>
                    </div>
                </div>
            </div>

            <!-- Undo/Redo -->
            <div class="header-undo-group">
                <button class="header-icon-btn" id="undoBtn" onclick="undo()" disabled title="Undo (Ctrl+Z)">
                    <i class="ph ph-arrow-counter-clockwise"></i>
                    <span class="undo-count" id="undoCount" style="display: none;">0</span>
                </button>
                <button class="header-icon-btn" id="redoBtn" onclick="redo()" disabled title="Redo (Ctrl+Y)">
                    <i class="ph ph-arrow-clockwise"></i>
                    <span class="undo-count" id="redoCount" style="display: none;">0</span>
                </button>
            </div>

            <!-- Actions Menu -->
            <div class="header-actions-menu">
                <button class="header-icon-btn" onclick="toggleActionsMenu(event)" title="Actions">
                    <i class="ph ph-dots-three"></i>
                </button>
                <div class="header-dropdown" id="actionsDropdown">
                    <button class="header-dropdown-item" onclick="exportData(); closeActionsMenu()">
                        <i class="ph ph-download"></i> Export Data
                    </button>
                    <button class="header-dropdown-item" onclick="importData(); closeActionsMenu()">
                        <i class="ph ph-upload"></i> Import (JSON)
                    </button>
                    <button class="header-dropdown-item" onclick="openBulkImportModal(); closeActionsMenu()">
                        <i class="ph ph-upload-simple"></i> Bulk Import (CSV)
                    </button>
                    <div class="header-dropdown-divider"></div>
                    <!-- Update Settings -->
                    <div class="update-settings-group" id="updateSettingsGroup">
                        <div class="update-settings-label">
                            <i class="ph ph-arrows-clockwise"></i> Auto-Update Settings
                        </div>
                        <div class="update-interval-options">
                            <button class="update-interval-option" onclick="setUpdateInterval(0)" id="updateIntervalOff">
                                <span class="check-icon"><i class="ph ph-check"></i></span>
                                <span>Off</span>
                            </button>
                            <button class="update-interval-option" onclick="setUpdateInterval(30000)" id="updateInterval30s">
                                <span class="check-icon"><i class="ph ph-check"></i></span>
                                <span>Every 30 seconds</span>
                            </button>
                            <button class="update-interval-option" onclick="setUpdateInterval(60000)" id="updateInterval60s">
                                <span class="check-icon"><i class="ph ph-check"></i></span>
                                <span>Every 1 minute</span>
                            </button>
                        </div>
                        <div class="update-status-indicator" id="updateStatusIndicator">
                            <span class="status-dot"></span>
                            <span id="updateStatusText">Updates disabled</span>
                        </div>
                    </div>
                    <button class="header-dropdown-item" onclick="checkForUpdatesNow(); closeActionsMenu()">
                        <i class="ph ph-cloud-arrow-down"></i> Check for Updates Now
                    </button>
                    <button class="header-dropdown-item" onclick="restoreFromXano(); closeActionsMenu()">
                        <i class="ph ph-cloud-arrow-down"></i> Restore from Cloud
                    </button>
                    <div class="header-dropdown-divider"></div>
                    <button class="header-dropdown-item" onclick="toggleSampleData(); closeActionsMenu()" id="sampleDataBtn">
                        <i class="ph ph-database"></i> <span id="sampleDataText">Toggle Sample Data</span>
                    </button>
                    <button class="header-dropdown-item" onclick="resetGraph(); closeActionsMenu()">
                        <i class="ph ph-arrow-counter-clockwise"></i> Reset View
                    </button>
                    <div class="header-dropdown-divider"></div>
                    <button class="header-dropdown-item danger" onclick="clearAllData(); closeActionsMenu()">
                        <i class="ph ph-trash"></i> Clear All Data
                    </button>
                </div>
            </div>

            <!-- Notifications -->
            <button class="header-icon-btn" onclick="toggleNotificationsPanel()" title="Notifications">
                <i class="ph ph-bell"></i>
                <span class="notification-badge" id="notificationBadge" style="display: none;"></span>
            </button>

            <!-- User Menu -->
            <div class="user-menu-container" id="userMenuContainer"></div>

            <!-- Hidden elements for backwards compatibility -->
            <div class="xano-status-indicator checking" id="xanoStatusIndicator" style="display: none !important;">
                <span class="status-dot"></span>
                <span class="status-text">Checking...</span>
                <span class="activity-count" id="xanoActivityCount" style="display: none;">0</span>
            </div>
            <div class="auto-refresh-toggle" id="autoRefreshToggle" style="display: none !important;">
                <span class="refresh-status" id="autoRefreshStatus">Off</span>
            </div>
            <div class="softr-user-indicator no-user" id="softrUserIndicator" style="display: none !important;">
                <div class="user-avatar"><i class="ph ph-user"></i></div>
                <div class="user-info">
                    <span class="user-name">No user detected</span>
                    <span class="user-email">Embed on Softr to see user</span>
                </div>
            </div>
            <!-- Old header menu kept for compatibility -->
            <div class="header-more-menu" style="display: none !important;">
                <div class="header-dropdown" id="headerDropdown"></div>
            </div>
        </div>
    </div>

    <!-- Time Travel Bar -->
    <div class="time-travel-bar" id="timeTravelBar">
        <div class="time-travel-icon">
            <i class="ph ph-clock-counter-clockwise"></i>
            <span>Time Travel</span>
        </div>
        <div class="time-travel-date-display" onclick="openTimeTravelDatePicker()">
            <i class="ph ph-calendar"></i>
            <span id="timeTravelDateText">Select date...</span>
        </div>
        <div class="time-travel-slider-container">
            <span class="time-travel-date-label" id="timeTravelStartLabel">Start</span>
            <input type="range" class="time-travel-slider" id="timeTravelSlider" min="0" max="100" value="100" oninput="onTimeTravelSliderChange()">
            <span class="time-travel-date-label" id="timeTravelEndLabel">Now</span>
        </div>
        <div class="time-travel-actions">
            <button class="time-travel-btn secondary" onclick="stepTimeTravel(-1)">
                <i class="ph ph-caret-left"></i> Prev
            </button>
            <button class="time-travel-btn secondary" onclick="stepTimeTravel(1)">
                Next <i class="ph ph-caret-right"></i>
            </button>
            <button class="time-travel-btn primary" onclick="exitTimeTravel()">
                <i class="ph ph-arrow-counter-clockwise"></i> Return to Present
            </button>
        </div>
    </div>

    <!-- Time Travel Mode Indicator (bottom floating) -->
    <div class="time-travel-mode-indicator" id="timeTravelIndicator">
        <i class="ph ph-clock-counter-clockwise"></i>
        <span class="time-travel-mode-text">Viewing history from</span>
        <span class="time-travel-mode-date" id="timeTravelIndicatorDate">-</span>
        <button class="time-travel-btn primary" onclick="exitTimeTravel()" style="padding: 0.25rem 0.75rem; font-size: 0.75rem;">
            Exit
        </button>
    </div>

    <!-- Advanced Filter Panel -->
    <div class="filter-panel-overlay" id="filterPanelOverlay" onclick="closeAdvancedFilterPanel()"></div>
    <div class="advanced-filter-panel" id="advancedFilterPanel">
        <div class="filter-panel-header">
            <div class="filter-panel-title">
                <i class="ph ph-funnel"></i>
                Filters
                <span class="filter-active-count" id="filterActiveCount" style="display: none;">0</span>
            </div>
            <button class="filter-panel-close" onclick="closeAdvancedFilterPanel()">
                <i class="ph ph-x"></i>
            </button>
        </div>
        <div class="filter-panel-content">
            <!-- Status Filter -->
            <div class="filter-group">
                <div class="filter-group-title">
                    <i class="ph ph-flag"></i> Status
                </div>
                <div class="filter-chips">
                    <div class="filter-chip status-pending active" data-filter="status" data-value="pending" onclick="toggleFilterChip(this)">
                        <i class="ph ph-circle"></i> Pending
                    </div>
                    <div class="filter-chip status-in_progress active" data-filter="status" data-value="in_progress" onclick="toggleFilterChip(this)">
                        <i class="ph ph-spinner"></i> In Progress
                    </div>
                    <div class="filter-chip status-completed active" data-filter="status" data-value="completed" onclick="toggleFilterChip(this)">
                        <i class="ph ph-check-circle"></i> Completed
                    </div>
                </div>
            </div>

            <!-- Priority Filter -->
            <div class="filter-group">
                <div class="filter-group-title">
                    <i class="ph ph-warning"></i> Priority
                </div>
                <div class="filter-chips">
                    <div class="filter-chip priority-high active" data-filter="priority" data-value="high" onclick="toggleFilterChip(this)">
                        <i class="ph ph-arrow-up"></i> High
                    </div>
                    <div class="filter-chip priority-medium active" data-filter="priority" data-value="medium" onclick="toggleFilterChip(this)">
                        <i class="ph ph-minus"></i> Medium
                    </div>
                    <div class="filter-chip priority-low active" data-filter="priority" data-value="low" onclick="toggleFilterChip(this)">
                        <i class="ph ph-arrow-down"></i> Low
                    </div>
                </div>
            </div>

            <!-- Due Date Filter -->
            <div class="filter-group">
                <div class="filter-group-title">
                    <i class="ph ph-calendar"></i> Due Date
                </div>
                <div class="filter-date-inputs">
                    <input type="date" class="filter-date-input" id="filterDateFrom" onchange="applyAdvancedFilters()" placeholder="From">
                    <span style="color: #8B6F47;">to</span>
                    <input type="date" class="filter-date-input" id="filterDateTo" onchange="applyAdvancedFilters()" placeholder="To">
                </div>
                <div class="filter-date-presets">
                    <button class="filter-date-preset" data-preset="overdue" onclick="setDatePreset('overdue')">Overdue</button>
                    <button class="filter-date-preset" data-preset="today" onclick="setDatePreset('today')">Today</button>
                    <button class="filter-date-preset" data-preset="week" onclick="setDatePreset('week')">This Week</button>
                    <button class="filter-date-preset" data-preset="month" onclick="setDatePreset('month')">This Month</button>
                    <button class="filter-date-preset" data-preset="nodate" onclick="setDatePreset('nodate')">No Date</button>
                </div>
            </div>

            <!-- Assignee Filter -->
            <div class="filter-group">
                <div class="filter-group-title">
                    <i class="ph ph-user"></i> Assigned To
                </div>
                <input type="text" class="filter-assignee-search" id="filterAssigneeSearch" placeholder="Search people..." oninput="filterAssigneeList()">
                <div class="filter-assignee-list" id="filterAssigneeList">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Entity Type Filter -->
            <div class="filter-group">
                <div class="filter-group-title">
                    <i class="ph ph-squares-four"></i> Entity Type
                </div>
                <div class="filter-chips">
                    <div class="filter-chip active" data-filter="entity" data-value="unit" onclick="toggleFilterChip(this)">
                        <i class="ph ph-buildings"></i> Units
                    </div>
                    <div class="filter-chip active" data-filter="entity" data-value="team" onclick="toggleFilterChip(this)">
                        <i class="ph ph-users"></i> Teams
                    </div>
                    <div class="filter-chip active" data-filter="entity" data-value="role" onclick="toggleFilterChip(this)">
                        <i class="ph ph-briefcase"></i> Roles
                    </div>
                    <div class="filter-chip active" data-filter="entity" data-value="person" onclick="toggleFilterChip(this)">
                        <i class="ph ph-user"></i> People
                    </div>
                </div>
            </div>

            <!-- Tags Filter -->
            <div class="filter-group">
                <div class="filter-group-title">
                    <i class="ph ph-tag"></i> Tags
                </div>
                <div class="filter-chips" id="filterTagsChips">
                    <!-- Populated dynamically based on existing tags -->
                </div>
            </div>

            <!-- Time Travel Section -->
            <div class="filter-group" style="border-top: 1px solid #E5DDD1; padding-top: 1rem; margin-top: 0.5rem;">
                <div class="filter-group-title">
                    <i class="ph ph-clock-counter-clockwise"></i> Historical View
                </div>
                <p style="font-size: 0.8rem; color: #6B5642; margin-bottom: 0.75rem;">
                    Travel back in time to see how things looked at a specific date.
                </p>
                <div class="filter-date-inputs">
                    <input type="datetime-local" class="filter-date-input" id="timeTravelDateInput" style="flex: 2;">
                    <button class="btn btn-primary" onclick="activateTimeTravel()" style="white-space: nowrap;">
                        <i class="ph ph-clock-counter-clockwise"></i> Go
                    </button>
                </div>
            </div>
        </div>
        <div class="filter-panel-footer">
            <button class="btn btn-outline" onclick="clearAllFilters()">Clear All</button>
            <button class="btn btn-primary" onclick="applyAdvancedFilters(); closeAdvancedFilterPanel()">Apply Filters</button>
        </div>
    </div>

    <!-- Notifications Panel -->
    <div class="notifications-panel" id="notificationsPanel">
        <div class="notifications-header">
            <span class="notifications-title">Notifications</span>
            <div class="notifications-actions">
                <button class="notifications-action-btn" onclick="markAllNotificationsRead()" title="Mark all as read">
                    <i class="ph ph-checks"></i>
                </button>
                <button class="notifications-action-btn" onclick="toggleNotificationsPanel()" title="Close">
                    <i class="ph ph-x"></i>
                </button>
            </div>
        </div>
        <div class="notifications-list" id="notificationsList">
            <!-- Populated dynamically -->
        </div>
    </div>

    <div class="container" id="mainContainer">
        <!-- Left Panel: Entities -->
        <div class="panel panel-left" id="panelLeft">
            <button class="panel-collapse-btn" onclick="togglePanel('left')" title="Collapse sidebar">
                <i class="ph ph-caret-left"></i>
            </button>

            <!-- Sidebar Tabs -->
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" data-tab="org" onclick="switchSidebarTab('org')">
                    <i class="ph ph-tree-structure"></i>
                    <span>Org</span>
                </button>
                <button class="sidebar-tab" data-tab="people" onclick="switchSidebarTab('people')">
                    <i class="ph ph-users"></i>
                    <span>People</span>
                </button>
                <button class="sidebar-tab" data-tab="recent" onclick="switchSidebarTab('recent')">
                    <i class="ph ph-clock-counter-clockwise"></i>
                    <span>Recent</span>
                </button>
            </div>

            <!-- Search -->
            <div class="input-group" style="margin-bottom: 1rem;">
                <input type="text" id="entitySearch" placeholder="Search..." oninput="filterSidebarContent()">
            </div>

            <!-- Tab Content: Org -->
            <div class="sidebar-tab-content active" id="tabOrg">
                <div class="sidebar-tab-scroll">
                    <div id="entityList" class="entity-list"></div>
                </div>
            </div>

            <!-- Tab Content: People -->
            <div class="sidebar-tab-content" id="tabPeople">
                <div class="sidebar-tab-scroll">
                    <div id="peopleList" class="people-list"></div>
                </div>
            </div>

            <!-- Tab Content: Recent -->
            <div class="sidebar-tab-content" id="tabRecent">
                <div class="sidebar-tab-scroll">
                    <!-- Activity Feed -->
                    <div class="recent-section">
                        <div class="recent-section-header">
                            <div class="recent-section-title">
                                <i class="ph ph-clock-counter-clockwise"></i>
                                Activity
                                <span class="activity-feed-count" id="activityFeedCount">0</span>
                            </div>
                        </div>
                        <div class="activity-feed-list" id="activityFeedList">
                            <div class="activity-feed-empty">
                                <p>No recent activity</p>
                            </div>
                        </div>
                    </div>

                    <!-- Recycle Bin -->
                    <div class="recent-section">
                        <div class="recent-section-header">
                            <div class="recent-section-title">
                                <i class="ph ph-trash"></i>
                                Recycle Bin
                                <span class="recycle-bin-count" id="recycleBinCount" style="display: none;">0</span>
                            </div>
                            <button class="recycle-bin-empty-btn" onclick="emptyRecycleBin()" title="Empty recycle bin">
                                Empty
                            </button>
                        </div>
                        <div class="recycle-bin-list" id="recycleBinList">
                            <div class="recycle-bin-empty">
                                <i class="ph ph-trash"></i>
                                <p>Recycle bin is empty</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Contextual Add Button -->
            <button class="sidebar-add-btn" id="sidebarAddBtn" onclick="handleSidebarAdd()">
                <i class="ph ph-plus"></i>
                <span id="sidebarAddBtnText">Add Unit</span>
            </button>
        </div>

        <!-- Center Panel: Multiple Views -->
        <div class="panel-center">
            <!-- Tree View -->
            <div id="treeView" class="tree-view"></div>
            
            <!-- Card View -->
            <div id="cardView" class="card-view"></div>
            
            <!-- Graph View -->
            <div id="graphView" class="graph-view active">
                <div class="graph-toolbar">
                    <button class="graph-tool-btn" onclick="cleanGraphLayout()" title="Auto-arrange nodes">
                        <i class="ph ph-magic-wand"></i> Clean Layout
                    </button>
                    <button class="graph-tool-btn" onclick="fitGraphToView()" title="Fit to view">
                        <i class="ph ph-arrows-out"></i> Fit
                    </button>
                    <div class="graph-zoom-controls">
                        <button class="graph-tool-btn small" onclick="zoomGraph(0.8)" title="Zoom out">
                            <i class="ph ph-minus"></i>
                        </button>
                        <span id="graphZoomLevel">100%</span>
                        <button class="graph-tool-btn small" onclick="zoomGraph(1.25)" title="Zoom in">
                            <i class="ph ph-plus"></i>
                        </button>
                    </div>
                </div>
                <svg id="graph"></svg>
                <div class="tooltip" id="tooltip"></div>
            </div>

            <!-- Venn View -->
            <div id="vennView" class="venn-view">
                <div class="venn-controls">
                    <div class="venn-level-nav">
                        <button class="venn-level-btn" onclick="changeVennLevel(-1)" id="vennLevelUp" disabled>
                            <i class="ph ph-arrow-up"></i>
                        </button>
                        <span class="venn-level-label" id="vennLevelLabel">Units</span>
                        <button class="venn-level-btn" onclick="changeVennLevel(1)" id="vennLevelDown">
                            <i class="ph ph-arrow-down"></i>
                        </button>
                    </div>
                    <div class="venn-breadcrumb" id="vennBreadcrumb"></div>
                </div>
                <svg id="vennDiagram"></svg>
                <div class="venn-tooltip" id="vennTooltip"></div>
                <div class="venn-overlap-panel" id="vennOverlapPanel">
                    <div class="venn-overlap-header">
                        <span id="vennOverlapTitle">Shared Connections</span>
                        <button class="venn-close-btn" onclick="closeOverlapPanel()">
                            <i class="ph ph-x"></i>
                        </button>
                    </div>
                    <div class="venn-overlap-content" id="vennOverlapContent"></div>
                </div>
            </div>

            <!-- Org Chart View -->
            <div id="orgchartView" class="orgchart-view"></div>

            <!-- Task Board View (Work) -->
            <div id="taskBoardView" class="task-board-view">
                <div class="task-board-header">
                    <div class="task-board-title">
                        <i class="ph ph-kanban"></i>
                        <span>Work</span>
                    </div>
                    <div class="task-board-stats">
                        <div class="task-board-stat">
                            <div class="task-board-stat-value" id="taskBoardTotal">0</div>
                            <div class="task-board-stat-label">Total</div>
                        </div>
                    </div>
                </div>
                <div class="task-board-controls">
                    <div class="quick-add-bar" id="quickAddBar">
                        <input type="text"
                               id="quickAddInput"
                               placeholder="Add a task... (press Enter)"
                               onkeypress="handleQuickAddKeypress(event)"
                               onfocus="document.getElementById('quickAddBar').classList.add('focused')"
                               onblur="document.getElementById('quickAddBar').classList.remove('focused')"
                               oninput="handleQuickAddInput(event)">
                        <div class="priority-dots" id="quickAddPriorityDots">
                            <div class="priority-dot low" data-priority="low" data-label="Low" onclick="selectQuickAddPriority('low')" title="Low priority"></div>
                            <div class="priority-dot medium active" data-priority="medium" data-label="Medium" onclick="selectQuickAddPriority('medium')" title="Medium priority"></div>
                            <div class="priority-dot high" data-priority="high" data-label="High" onclick="selectQuickAddPriority('high')" title="High priority"></div>
                            <div class="priority-dot urgent" data-priority="urgent" data-label="Urgent" onclick="selectQuickAddPriority('urgent')" title="Urgent"></div>
                        </div>
                        <span class="keyboard-hint slash-hint">/</span>
                        <span class="keyboard-hint enter-hint">⏎</span>
                        <div class="inline-suggestions" id="quickAddSuggestions">
                            <div class="suggestion-item"><strong>!</strong> <strong>!!</strong> <strong>!!!</strong> — Set priority (low/high/urgent)</div>
                            <div class="suggestion-item"><strong>@today</strong> <strong>@tomorrow</strong> <strong>@friday</strong> — Set due date</div>
                            <div class="suggestion-item"><strong>#tag</strong> — Add tags</div>
                        </div>
                    </div>
                    <!-- Inline Filters -->
                    <div class="inline-filter-bar" id="inlineFilterBar">
                        <div class="inline-filter-group">
                            <button class="inline-filter-btn status-pending active" data-status="pending" onclick="toggleInlineStatusFilter('pending')" title="To Do">
                                <i class="ph ph-circle"></i> To Do
                            </button>
                            <button class="inline-filter-btn status-in_progress active" data-status="in_progress" onclick="toggleInlineStatusFilter('in_progress')" title="In Progress">
                                <i class="ph ph-spinner"></i> In Progress
                            </button>
                            <button class="inline-filter-btn status-completed active" data-status="completed" onclick="toggleInlineStatusFilter('completed')" title="Done">
                                <i class="ph ph-check-circle"></i> Done
                            </button>
                        </div>
                        <button class="inline-filter-more-btn" id="inlineFilterMoreBtn" onclick="openAdvancedFilterPanel()" title="More filters">
                            <i class="ph ph-funnel"></i>
                            <span>More</span>
                            <span class="inline-filter-badge" id="inlineFilterBadge" style="display: none;">0</span>
                        </button>
                    </div>
                    <input type="text"
                           id="taskBoardSearch"
                           class="task-board-search"
                           placeholder="Search..."
                           oninput="filterTaskBoard()"
                           style="max-width: 160px;">
                    <button class="hero-task-btn hero-task-btn-secondary" onclick="openHeroTaskModal()" style="padding: 0.625rem 1rem;" title="Advanced task creation">
                        <i class="ph ph-dots-three"></i>
                    </button>
                </div>
                <div class="task-board-content" id="taskBoardContent">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Flow View (Workflows - patterns that emerge from work) -->
            <div id="flowView" class="flow-view">
                <div class="flow-view-header">
                    <div class="flow-view-title">
                        <i class="ph ph-flow-arrow"></i>
                        <span>Flow</span>
                    </div>
                    <div class="flow-view-subtitle">Patterns emerging from your work</div>
                </div>
                <div class="flow-view-controls">
                    <input type="text"
                           id="flowViewSearch"
                           class="flow-view-search"
                           placeholder="Search patterns..."
                           oninput="filterFlowView()">
                </div>
                <div class="flow-view-content" id="flowViewContent">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Shape View (Structure - what emerged) -->
            <div id="shapeView" class="shape-view">
                <div class="shape-view-header">
                    <div class="shape-view-title">
                        <i class="ph ph-tree-structure"></i>
                        <span>Shape</span>
                    </div>
                    <div class="shape-view-subtitle">Structure that emerged from work</div>
                </div>
                <div class="shape-view-content" id="shapeViewContent">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Gantt View -->
            <div id="ganttView" class="gantt-view">
                <div class="gantt-view-content" id="ganttViewContent">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Calendar View -->
            <div id="calendarView" class="calendar-view">
                <div class="calendar-view-content" id="calendarViewContent">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Right Panel: Connections -->
        <div class="panel panel-right" id="panelRight">
            <button class="panel-collapse-btn" onclick="togglePanel('right')" title="Collapse sidebar">
                <i class="ph ph-caret-right"></i>
            </button>

            <!-- Simple Quick Connect -->
            <div class="panel-title" style="display: flex; align-items: center; gap: 0.5rem;">
                <i class="ph ph-link"></i>
                Quick Connect
            </div>

            <div style="background: #FAF7F5; padding: 1rem; border-radius: 6px;">
                <div class="help-text" style="margin-bottom: 0.75rem;">Connect things in your workspace</div>

                <div class="input-group">
                    <label>Connect this...</label>
                    <select id="subjectSelect" onchange="updateSentencePreview(); autoDetectConnectionType()">
                        <option value="">Select something...</option>
                    </select>
                </div>

                <div class="input-group" style="margin-top: 0.75rem;">
                    <label>...to this</label>
                    <select id="orgEntitySelect" onchange="handleOrgEntityChange(); autoDetectConnectionType()">
                        <option value="">Select something...</option>
                    </select>
                </div>

                <!-- Hidden predicate selector - auto-determined -->
                <input type="hidden" id="selectedPredicate" value="CON">

                <!-- Connection type indicator -->
                <div class="connection-type-hint" id="connectionTypeHint" style="display: none; margin-top: 0.75rem; padding: 0.5rem 0.75rem; background: white; border-radius: 6px; font-size: 0.8rem; color: #8B6F47;">
                    <i class="ph ph-info"></i>
                    <span id="connectionTypeText">This will link them together</span>
                </div>

                <div class="sentence-preview" id="sentencePreview">
                    <em style="color: #8B6F47;">Select items to connect...</em>
                </div>

                <button class="btn" onclick="addActivity()" style="width: 100%; margin-top: 0.75rem;">
                    <i class="ph ph-plus-circle" style="margin-right: 0.25rem;"></i>
                    Connect
                </button>
            </div>

            <!-- Hidden elements for compatibility - keep filters working -->
            <div style="display: none;">
                <select id="objectSelect"></select>
                <input type="checkbox" id="filterNUL" checked>
                <input type="checkbox" id="filterDES" checked>
                <input type="checkbox" id="filterSEG" checked>
                <input type="checkbox" id="filterCON" checked>
                <input type="checkbox" id="filterALT" checked>
                <input type="checkbox" id="filterSYN" checked>
                <input type="checkbox" id="filterSUP" checked>
                <input type="checkbox" id="filterREC" checked>
                <input type="checkbox" id="filterUnit" checked>
                <input type="checkbox" id="filterTeam" checked>
                <input type="checkbox" id="filterRole" checked>
                <input type="checkbox" id="filterPerson" checked>
                <input type="checkbox" id="filterTask" checked>
                <input type="checkbox" id="filterProduct" checked>
                <input type="checkbox" id="filterWorkflow" checked>
                <select id="connectionFilterDropdown"><option value="all">All</option></select>
                <select id="entityFilterDropdown"><option value="all">All</option></select>
            </div>

            <div class="divider"></div>

            <div class="panel-title" style="font-size: 1rem;">
                <i class="ph ph-clock-counter-clockwise"></i>
                Recent Connections
            </div>
            <div class="input-group" style="margin-bottom: 1rem;">
                <input type="text" id="activitySearch" placeholder="Search..." oninput="renderActivityList()">
            </div>
            <div id="activityList" class="relationship-list"></div>

            <!-- Hidden elements for notes functionality -->
            <div style="display: none;">
                <textarea id="activityDescription"></textarea>
                <span id="charCount">0</span>
            </div>
        </div>
    </div>

    <!-- Entity Detail Modal -->
    <div id="entityModal" class="modal-overlay" onclick="if(event.target === this) closeEntityModal()">
        <div class="modal-dialog">
            <div class="modal-header-section">
                <button class="modal-close-btn" onclick="closeEntityModal()">
                    <i class="ph ph-x"></i>
                </button>
                <div class="modal-header-top">
                    <span class="modal-header-icon" id="modalEntityIcon"></span>
                    <div class="modal-header-content">
                        <div class="modal-title-wrapper">
                            <div class="modal-title-display" id="modalTitleDisplay" onclick="startInlineNameEdit()">
                                <span class="modal-title-text" id="modalEntityName"></span>
                                <span class="edit-hint"><i class="ph ph-pencil-simple"></i> click to edit</span>
                            </div>
                            <div class="modal-title-edit-form" id="modalTitleEditForm">
                                <input type="text" id="inlineNameInput" placeholder="Enter name..." onkeydown="handleInlineNameKeydown(event)">
                                <div class="inline-edit-actions">
                                    <button class="inline-edit-btn save" onclick="saveInlineName()" title="Save">
                                        <i class="ph ph-check"></i>
                                    </button>
                                    <button class="inline-edit-btn" onclick="cancelInlineNameEdit()" title="Cancel">
                                        <i class="ph ph-x"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-type-badge" id="modalEntityType"></div>
                        <div class="modal-header-parent" id="modalHeaderParent"></div>
                    </div>
                </div>
            </div>
            <div class="modal-body">
                <div class="modal-section" id="modalDescription"></div>
                <div class="modal-section role-assignment-section" id="modalRoleAssignment"></div>

                <!-- Modal Tabs - Work first, Structure second -->
                <div class="modal-tabs" id="modalTabs">
                    <button class="modal-tab" data-tab="connections" onclick="switchModalTab('connections')">
                        <i class="ph ph-briefcase"></i> <span class="tab-label">Work</span>
                    </button>
                    <button class="modal-tab" data-tab="structure" onclick="switchModalTab('structure')">
                        <i class="ph ph-tree-structure"></i> <span class="tab-label">Structure</span>
                    </button>
                    <button class="modal-tab" data-tab="connect" onclick="switchModalTab('connect')">
                        <i class="ph ph-plus-circle"></i> <span class="tab-label">Add</span>
                    </button>
                </div>

                <!-- Structure Section (parent/nested - for units/teams/roles) -->
                <div class="modal-tab-content" id="tabStructure">
                    <div class="modal-section-header">
                        <i class="ph ph-tree-structure"></i> Structure
                    </div>
                    <div class="modal-section" id="modalNestUnder"></div>
                    <div class="modal-section" id="modalNested"></div>
                    <div class="modal-section" id="modalAddNested"></div>
                </div>

                <!-- Work Section (activities/relationships) -->
                <div class="modal-tab-content" id="tabConnections">
                    <div class="modal-section-header">
                        <i class="ph ph-briefcase"></i> Work
                    </div>
                    <div class="modal-section" id="modalActivities"></div>
                </div>

                <!-- Tab Content: Add (create connections) -->
                <div class="modal-tab-content" id="tabConnect">
                    <div class="modal-section" id="modalAddActivity"></div>
                </div>

                <!-- Hidden sections for compatibility -->
                <div class="modal-section" id="modalConnections" style="display: none;"></div>

                <!-- History Section - shows change history for this entity -->
                <div class="modal-section" id="modalHistory"></div>
            </div>
            <div class="modal-actions" id="modalFooterButtons">
                <button class="modal-action-btn danger" id="modalDeleteButton" onclick="openDeleteConfirmModal()">
                    <i class="ph ph-trash"></i>
                    Delete
                </button>
                <button class="modal-action-btn" id="modalViewFromButton" onclick="openViewFromEntity(currentModalEntity?.id, currentModalEntityType)" style="display: none;">
                    <i class="ph ph-squares-four"></i>
                    View
                </button>
                <div class="modal-action-spacer"></div>
                <button class="modal-action-btn secondary" onclick="closeEntityModal()">
                    Close
                </button>
                <button class="modal-action-btn primary" id="modalEditButton" onclick="openEntityEditModal()">
                    <i class="ph ph-pencil-simple"></i>
                    Edit
                </button>
            </div>
        </div>
    </div>

    <!-- Entity Edit Modal -->
    <div id="entityEditModal" class="entity-edit-modal-overlay" onclick="if(event.target === this) closeEntityEditModal()">
        <div class="entity-edit-modal">
            <div class="entity-edit-modal-header">
                <h3>
                    <i class="ph ph-pencil-simple"></i>
                    Edit Entity
                </h3>
            </div>
            <div class="entity-edit-modal-body">
                <div class="entity-edit-field">
                    <label class="entity-edit-label">Name</label>
                    <input type="text" class="entity-edit-input" id="entityEditNameInput" placeholder="Enter name...">
                </div>
                <div class="entity-edit-field">
                    <label class="entity-edit-label">Description <span class="char-limit">(<span id="editDescCharCount">0</span>/240)</span></label>
                    <textarea class="entity-edit-textarea" id="entityEditDescInput" placeholder="Add a description..." maxlength="240" oninput="updateEditDescCharCount()"></textarea>
                </div>
            </div>
            <div class="entity-edit-modal-actions">
                <button class="modal-action-btn danger mobile-only-delete" onclick="openDeleteConfirmModal()">
                    <i class="ph ph-trash"></i> Delete
                </button>
                <div style="flex: 1;"></div>
                <button class="modal-action-btn secondary" onclick="closeEntityEditModal()">Cancel</button>
                <button class="modal-action-btn primary" onclick="saveEntityEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="deleteConfirmModal" class="delete-confirm-overlay" onclick="if(event.target === this) closeDeleteConfirmModal()">
        <div class="delete-confirm-modal">
            <div class="delete-confirm-icon">
                <i class="ph ph-warning-circle"></i>
            </div>
            <div class="delete-confirm-content">
                <h3 id="deleteConfirmTitle">Delete Entity?</h3>
                <p id="deleteConfirmText">This will permanently remove this entity and all its nested items and activities.</p>
            </div>
            <div class="delete-confirm-actions">
                <button class="modal-action-btn secondary" onclick="closeDeleteConfirmModal()">Cancel</button>
                <button class="modal-action-btn danger" onclick="confirmDelete()">
                    <i class="ph ph-trash"></i>
                    Delete
                </button>
            </div>
        </div>
    </div>

    <!-- Task Movement Confirmation Modal -->
    <div id="taskConfirmModal" class="task-confirm-overlay" onclick="if(event.target === this) closeTaskConfirmModal()">
        <div class="task-confirm-modal">
            <div class="task-confirm-icon">
                <i class="ph ph-warning"></i>
            </div>
            <div class="task-confirm-content">
                <h3 id="taskConfirmTitle">Move Task?</h3>
                <p id="taskConfirmText">Are you sure you want to move this task?</p>
            </div>
            <div class="task-confirm-actions">
                <button class="modal-action-btn secondary" onclick="closeTaskConfirmModal()">Cancel</button>
                <button class="modal-action-btn warning" id="taskConfirmBtn" onclick="confirmTaskMove()">
                    <i class="ph ph-arrow-right"></i>
                    Move Anyway
                </button>
            </div>
        </div>
    </div>

    <!-- Work Product Selector Modal -->
    <div id="workProductSelectorModal" class="work-product-selector-overlay" onclick="if(event.target === this) closeWorkProductSelectorModal()">
        <div class="work-product-selector-modal">
            <div class="work-product-selector-header">
                <h3><i class="ph ph-package"></i> Select Work Product</h3>
                <button class="work-product-selector-close" onclick="closeWorkProductSelectorModal()">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="work-product-selector-search">
                <input type="text" id="workProductSearchInput" placeholder="Search work products..." oninput="filterWorkProducts()">
            </div>
            <div class="work-product-selector-content" id="workProductSelectorContent">
                <!-- Work products will be populated here dynamically -->
            </div>
            <div class="work-product-selector-footer">
                <div class="work-product-create-new">
                    <input type="text" id="newWorkProductName" placeholder="New work product name..." onkeypress="if(event.key==='Enter') createWorkProductFromModal()">
                    <button class="work-product-create-btn" onclick="createWorkProductFromModal()">
                        <i class="ph ph-plus"></i> Create
                    </button>
                </div>
                <button class="work-product-select-btn" id="confirmWorkProductSelection" onclick="confirmWorkProductSelection()" disabled>
                    Select
                </button>
            </div>
        </div>
    </div>

    <!-- Workspace Modal (Create/Rename) -->
    <div id="workspaceModal" class="workspace-modal-overlay" onclick="if(event.target === this) closeWorkspaceModal()">
        <div class="workspace-modal">
            <h3 id="workspaceModalTitle">New Workspace</h3>
            <input type="text" class="workspace-modal-input" id="workspaceModalInput" placeholder="Workspace name..." onkeypress="if(event.key==='Enter') saveWorkspaceFromModal()">
            <div class="workspace-modal-actions">
                <button class="workspace-modal-btn cancel" onclick="closeWorkspaceModal()">Cancel</button>
                <button class="workspace-modal-btn primary" onclick="saveWorkspaceFromModal()">Save</button>
            </div>
        </div>
    </div>

    <!-- Command Palette (Cmd+K) -->
    <div id="commandPalette" class="command-palette-overlay" onclick="if(event.target === this) closeCommandPalette()">
        <div class="command-palette">
            <div class="command-palette-input-wrapper">
                <i class="ph ph-magnifying-glass"></i>
                <input type="text" id="commandPaletteInput" placeholder="Type a command or search..." autocomplete="off" oninput="filterCommandPaletteItems()">
                <span class="command-palette-shortcut">esc</span>
            </div>
            <div class="command-palette-results" id="commandPaletteResults">
                <div class="command-palette-group">
                    <div class="command-palette-group-title">Actions</div>
                    <button class="command-palette-item" data-action="create-task" onclick="executeCommand('create-task')">
                        <i class="ph ph-plus-circle"></i>
                        <span>Create new task</span>
                        <span class="command-palette-item-hint">T</span>
                    </button>
                    <button class="command-palette-item" data-action="create-role" onclick="executeCommand('create-role')">
                        <i class="ph ph-briefcase"></i>
                        <span>Create new role</span>
                    </button>
                    <button class="command-palette-item" data-action="create-person" onclick="executeCommand('create-person')">
                        <i class="ph ph-user"></i>
                        <span>Create new person</span>
                    </button>
                </div>
                <div class="command-palette-group">
                    <div class="command-palette-group-title">Views</div>
                    <button class="command-palette-item" data-action="view-work" onclick="executeCommand('view-work')">
                        <i class="ph ph-kanban"></i>
                        <span>Work (Tasks Board)</span>
                    </button>
                    <button class="command-palette-item" data-action="view-flow" onclick="executeCommand('view-flow')">
                        <i class="ph ph-flow-arrow"></i>
                        <span>Flow View</span>
                    </button>
                    <button class="command-palette-item" data-action="view-shape" onclick="executeCommand('view-shape')">
                        <i class="ph ph-tree-structure"></i>
                        <span>Shape View</span>
                    </button>
                    <button class="command-palette-item" data-action="view-graph" onclick="executeCommand('view-graph')">
                        <i class="ph ph-graph"></i>
                        <span>Graph View</span>
                    </button>
                </div>
                <div class="command-palette-group">
                    <div class="command-palette-group-title">Data</div>
                    <button class="command-palette-item" data-action="export" onclick="executeCommand('export')">
                        <i class="ph ph-download"></i>
                        <span>Export data</span>
                    </button>
                    <button class="command-palette-item" data-action="import" onclick="executeCommand('import')">
                        <i class="ph ph-upload"></i>
                        <span>Import data</span>
                    </button>
                    <button class="command-palette-item" data-action="restore" onclick="executeCommand('restore')">
                        <i class="ph ph-cloud-arrow-down"></i>
                        <span>Restore from Xano</span>
                    </button>
                </div>
            </div>
            <div class="command-palette-footer">
                <span><kbd>↑↓</kbd> navigate</span>
                <span><kbd>↵</kbd> select</span>
                <span><kbd>esc</kbd> close</span>
            </div>
        </div>
    </div>

    <!-- Bulk Import Modal -->
    <div id="bulkImportModal" class="bulk-import-overlay" onclick="if(event.target === this) closeBulkImportModal()">
        <div class="bulk-import-modal">
            <div class="bulk-import-header">
                <h2><i class="ph ph-upload-simple"></i> Bulk Import</h2>
                <button class="bulk-import-close" onclick="closeBulkImportModal()">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="bulk-import-body">
                <!-- Step Indicator -->
                <div class="bulk-import-steps">
                    <div class="bulk-import-step active" id="bulkImportStep1">
                        <span class="bulk-import-step-number">1</span>
                        Select Type & Input Data
                    </div>
                    <div class="bulk-import-step" id="bulkImportStep2">
                        <span class="bulk-import-step-number">2</span>
                        Map Fields
                    </div>
                    <div class="bulk-import-step" id="bulkImportStep3">
                        <span class="bulk-import-step-number">3</span>
                        Review & Import
                    </div>
                </div>

                <!-- Step 1: Select Entity Type & Input Data -->
                <div id="bulkImportStepContent1">
                    <div class="bulk-import-section">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-tag"></i> What type of entity are you importing?
                        </div>
                        <div class="bulk-import-entity-type">
                            <button class="bulk-import-entity-btn" data-type="unit" onclick="selectBulkImportType('unit')">
                                <i class="ph ph-buildings"></i> Units
                            </button>
                            <button class="bulk-import-entity-btn" data-type="team" onclick="selectBulkImportType('team')">
                                <i class="ph ph-users-three"></i> Teams
                            </button>
                            <button class="bulk-import-entity-btn" data-type="role" onclick="selectBulkImportType('role')">
                                <i class="ph ph-briefcase"></i> Roles
                            </button>
                            <button class="bulk-import-entity-btn active" data-type="person" onclick="selectBulkImportType('person')">
                                <i class="ph ph-user"></i> People
                            </button>
                            <button class="bulk-import-entity-btn" data-type="product" onclick="selectBulkImportType('product')">
                                <i class="ph ph-package"></i> Products
                            </button>
                        </div>
                    </div>

                    <div class="bulk-import-section">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-clipboard-text"></i> How would you like to input data?
                        </div>
                        <div class="bulk-import-tabs">
                            <button class="bulk-import-tab active" onclick="switchBulkImportTab('paste')">
                                <i class="ph ph-clipboard"></i> Paste from Spreadsheet
                            </button>
                            <button class="bulk-import-tab" onclick="switchBulkImportTab('file')">
                                <i class="ph ph-file-csv"></i> Upload CSV File
                            </button>
                        </div>

                        <!-- Paste Tab -->
                        <div id="bulkImportPasteTab">
                            <textarea
                                id="bulkImportPasteArea"
                                class="bulk-import-textarea"
                                placeholder="Paste rows from your spreadsheet here...

Example (tab-separated):
Name    Team    Email
John Doe    Engineering    john@example.com
Jane Smith    Design    jane@example.com

Or comma-separated:
Name,Team,Email
John Doe,Engineering,john@example.com"
                                oninput="parseBulkImportData()"></textarea>
                            <div class="bulk-import-hint">
                                <i class="ph ph-info"></i>
                                Supports tab-separated (copy from Excel/Sheets) or comma-separated values. First row should be headers.
                            </div>
                        </div>

                        <!-- File Upload Tab -->
                        <div id="bulkImportFileTab" style="display: none;">
                            <div class="bulk-import-file-upload" onclick="document.getElementById('bulkImportFileInput').click()">
                                <i class="ph ph-file-arrow-up"></i>
                                <div><strong>Click to upload</strong> or drag and drop</div>
                                <div style="font-size: 0.8rem; color: #8B6F47; margin-top: 0.5rem;">CSV files supported</div>
                                <input type="file" id="bulkImportFileInput" accept=".csv,.tsv,.txt" onchange="handleBulkImportFile(event)">
                            </div>
                            <div id="bulkImportFileName" style="margin-top: 0.75rem; font-size: 0.875rem; color: #6B5642;"></div>
                        </div>
                    </div>

                    <div id="bulkImportDataPreview" style="display: none;">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-eye"></i> Data Preview
                        </div>
                        <div class="bulk-import-preview">
                            <div class="bulk-import-preview-header">
                                <span>Detected Data</span>
                                <span class="bulk-import-preview-count" id="bulkImportRowCount">0 rows</span>
                            </div>
                            <div style="overflow-x: auto; max-height: 200px;">
                                <table class="bulk-import-preview-table" id="bulkImportPreviewTable">
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Field Mapping -->
                <div id="bulkImportStepContent2" style="display: none;">
                    <div class="bulk-import-section">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-arrows-left-right"></i> Map your columns to entity fields
                        </div>
                        <p style="font-size: 0.875rem; color: #8B6F47; margin-bottom: 1rem;">
                            Match your spreadsheet columns to the appropriate fields. Use "Set for All" to apply a default value to all imported items.
                        </p>
                        <div class="bulk-import-mapping" id="bulkImportMappingContainer">
                            <!-- Mapping rows will be dynamically generated -->
                        </div>
                    </div>

                    <div id="bulkImportMappedPreview" style="margin-top: 1.5rem;">
                        <div class="bulk-import-section-title">
                            <i class="ph ph-eye"></i> Preview with Mapping Applied
                        </div>
                        <div class="bulk-import-preview">
                            <div class="bulk-import-preview-header">
                                <span>Mapped Data Preview</span>
                                <span class="bulk-import-preview-count" id="bulkImportMappedCount">0 items</span>
                            </div>
                            <div style="overflow-x: auto; max-height: 250px;">
                                <table class="bulk-import-preview-table" id="bulkImportMappedTable">
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 3: Review & Import -->
                <div id="bulkImportStepContent3" style="display: none;">
                    <div id="bulkImportReviewContent">
                        <div class="bulk-import-section">
                            <div class="bulk-import-section-title">
                                <i class="ph ph-check-square"></i> Review Import
                            </div>
                            <div style="background: #FAF7F5; padding: 1.25rem; border-radius: 8px; margin-bottom: 1rem;">
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
                                    <div>
                                        <div style="font-size: 2rem; font-weight: 700; color: #C88F4A;" id="bulkImportTotalCount">0</div>
                                        <div style="font-size: 0.875rem; color: #6B5642;">Total Items</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 2rem; font-weight: 700; color: #4CAF50;" id="bulkImportValidCount">0</div>
                                        <div style="font-size: 0.875rem; color: #6B5642;">Valid</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 2rem; font-weight: 700; color: #d32f2f;" id="bulkImportErrorCount">0</div>
                                        <div style="font-size: 0.875rem; color: #6B5642;">Errors</div>
                                    </div>
                                </div>
                            </div>
                            <div style="font-size: 0.875rem; color: #6B5642; margin-bottom: 1rem;" id="bulkImportEntityTypeLabel">
                                Importing as: <strong>People</strong>
                            </div>
                        </div>

                        <div class="bulk-import-preview">
                            <div class="bulk-import-preview-header">
                                <span>Final Preview</span>
                                <span class="bulk-import-preview-count" id="bulkImportFinalCount">0 items</span>
                            </div>
                            <div style="overflow-x: auto; max-height: 300px;">
                                <table class="bulk-import-preview-table" id="bulkImportFinalTable">
                                </table>
                            </div>
                        </div>
                    </div>

                    <div id="bulkImportSuccessContent" style="display: none;">
                        <div class="bulk-import-success">
                            <i class="ph ph-check-circle"></i>
                            <h3>Import Successful!</h3>
                            <p id="bulkImportSuccessMessage">Successfully imported 0 items.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="bulk-import-footer">
                <div class="bulk-import-footer-info" id="bulkImportFooterInfo">
                    Select an entity type and paste or upload your data to continue.
                </div>
                <div class="bulk-import-footer-actions">
                    <button class="bulk-import-btn secondary" id="bulkImportBackBtn" onclick="bulkImportBack()" style="display: none;">
                        <i class="ph ph-arrow-left"></i> Back
                    </button>
                    <button class="bulk-import-btn primary" id="bulkImportNextBtn" onclick="bulkImportNext()" disabled>
                        <i class="ph ph-arrow-right"></i> Next
                    </button>
                    <button class="bulk-import-btn primary" id="bulkImportImportBtn" onclick="executeBulkImport()" style="display: none;">
                        <i class="ph ph-check"></i> Import
                    </button>
                    <button class="bulk-import-btn primary" id="bulkImportDoneBtn" onclick="closeBulkImportModal()" style="display: none;">
                        <i class="ph ph-check"></i> Done
                    </button>
                </div>
            </div>
        </div>
    </div>
    </div><!-- End mainAppContainer -->

    <script>
        // ==========================================
        // AUTHENTICATION MANAGER
        // ==========================================

        const AuthManager = {
            // Configuration
            webhookUrl: 'https://n8n.intelechia.com/webhook/6dab38a9-d010-43b4-9669-5a58dbcfab36',
            sessionKey: 'taskflow_auth_session',
            pendingCodeKey: 'taskflow_pending_code',
            codeExpiryMinutes: 10,

            // State
            currentEmail: null,
            pendingCode: null,
            codeExpiry: null,
            isLoading: false,
            resendCooldown: false,

            // Initialize auth - check if user is already logged in
            init() {
                console.log('🔐 AuthManager: Initializing...');

                // Check for existing session
                const session = this.getSession();
                if (session && session.email) {
                    console.log('🔐 AuthManager: Found existing session for', session.email);
                    this.onAuthSuccess(session.email, false);
                    return true;
                }

                // No session - show login overlay
                console.log('🔐 AuthManager: No session found, showing login');
                this.showLoginOverlay();
                return false;
            },

            // Get current session from localStorage
            getSession() {
                try {
                    const data = localStorage.getItem(this.sessionKey);
                    if (data) {
                        const session = JSON.parse(data);
                        // Check if session is still valid (30 day expiry)
                        if (session.expiresAt && new Date(session.expiresAt) > new Date()) {
                            return session;
                        }
                        // Session expired
                        localStorage.removeItem(this.sessionKey);
                    }
                } catch (e) {
                    console.error('🔐 AuthManager: Error reading session', e);
                }
                return null;
            },

            // Save session to localStorage
            saveSession(email) {
                const session = {
                    email: email,
                    loggedInAt: new Date().toISOString(),
                    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days
                };
                localStorage.setItem(this.sessionKey, JSON.stringify(session));
                console.log('🔐 AuthManager: Session saved for', email);
            },

            // Clear session (logout)
            clearSession() {
                localStorage.removeItem(this.sessionKey);
                localStorage.removeItem(this.pendingCodeKey);
                console.log('🔐 AuthManager: Session cleared');
            },

            // Generate a 6-digit code
            generateCode() {
                return Math.floor(100000 + Math.random() * 900000).toString();
            },

            // Store pending code for verification
            storePendingCode(email, code) {
                const data = {
                    email: email,
                    code: code,
                    createdAt: new Date().toISOString(),
                    expiresAt: new Date(Date.now() + this.codeExpiryMinutes * 60 * 1000).toISOString()
                };
                localStorage.setItem(this.pendingCodeKey, JSON.stringify(data));
                this.currentEmail = email;
                this.pendingCode = code;
                this.codeExpiry = new Date(data.expiresAt);
            },

            // Get pending code data
            getPendingCode() {
                try {
                    const data = localStorage.getItem(this.pendingCodeKey);
                    if (data) {
                        const pending = JSON.parse(data);
                        if (new Date(pending.expiresAt) > new Date()) {
                            return pending;
                        }
                        // Code expired
                        localStorage.removeItem(this.pendingCodeKey);
                    }
                } catch (e) {
                    console.error('🔐 AuthManager: Error reading pending code', e);
                }
                return null;
            },

            // Show login overlay
            showLoginOverlay() {
                const overlay = document.getElementById('loginOverlay');
                if (overlay) {
                    overlay.classList.remove('hidden');
                }
            },

            // Hide login overlay
            hideLoginOverlay() {
                const overlay = document.getElementById('loginOverlay');
                if (overlay) {
                    overlay.classList.add('hidden');
                }
            },

            // Show email step
            showEmailStep() {
                document.getElementById('loginStepEmail').classList.add('active');
                document.getElementById('loginStepCode').classList.remove('active');
                this.hideErrors();
            },

            // Show code step
            showCodeStep() {
                document.getElementById('loginStepEmail').classList.remove('active');
                document.getElementById('loginStepCode').classList.add('active');
                document.getElementById('loginEmailDisplay').textContent = this.currentEmail;
                document.getElementById('loginCode').value = '';
                document.getElementById('loginCode').focus();
                this.hideErrors();
            },

            // Show/hide loading state
            setLoading(isLoading, buttonId, textId) {
                this.isLoading = isLoading;
                const btn = document.getElementById(buttonId);
                const text = document.getElementById(textId);

                if (btn && text) {
                    btn.disabled = isLoading;
                    if (isLoading) {
                        text.innerHTML = '<span class="spinner"></span>';
                    } else {
                        text.textContent = buttonId === 'loginEmailBtn' ? 'Send Login Code' : 'Verify Code';
                    }
                }
            },

            // Show error message
            showError(step, message) {
                const errorEl = document.getElementById(step === 'email' ? 'loginErrorEmail' : 'loginErrorCode');
                const errorText = document.getElementById(step === 'email' ? 'loginErrorEmailText' : 'loginErrorCodeText');

                if (errorEl && errorText) {
                    errorText.textContent = message;
                    errorEl.classList.add('show');
                }
            },

            // Show success message
            showSuccess() {
                const successEl = document.getElementById('loginSuccessCode');
                if (successEl) {
                    successEl.classList.add('show');
                    setTimeout(() => successEl.classList.remove('show'), 3000);
                }
            },

            // Hide all errors
            hideErrors() {
                document.getElementById('loginErrorEmail')?.classList.remove('show');
                document.getElementById('loginErrorCode')?.classList.remove('show');
                document.getElementById('loginSuccessCode')?.classList.remove('show');
            },

            // Handle email form submission
            async handleEmailSubmit(event) {
                event.preventDefault();

                if (this.isLoading) return;

                const emailInput = document.getElementById('loginEmail');
                const email = emailInput.value.trim().toLowerCase();

                if (!email || !this.isValidEmail(email)) {
                    this.showError('email', 'Please enter a valid email address');
                    return;
                }

                this.hideErrors();
                this.setLoading(true, 'loginEmailBtn', 'loginEmailBtnText');

                try {
                    await this.sendLoginCode(email);
                    this.showCodeStep();
                    this.showSuccess();
                } catch (error) {
                    console.error('🔐 AuthManager: Error sending code', error);
                    this.showError('email', 'Failed to send login code. Please try again.');
                } finally {
                    this.setLoading(false, 'loginEmailBtn', 'loginEmailBtnText');
                }
            },

            // Handle code form submission
            async handleCodeSubmit(event) {
                event.preventDefault();

                if (this.isLoading) return;

                const codeInput = document.getElementById('loginCode');
                const code = codeInput.value.trim();

                if (!code || code.length !== 6) {
                    this.showError('code', 'Please enter a 6-digit code');
                    return;
                }

                this.hideErrors();
                this.setLoading(true, 'loginCodeBtn', 'loginCodeBtnText');

                try {
                    const isValid = await this.verifyCode(code);

                    if (isValid) {
                        this.onAuthSuccess(this.currentEmail, true);
                    } else {
                        this.showError('code', 'Invalid or expired code. Please try again.');
                        codeInput.classList.add('error');
                        setTimeout(() => codeInput.classList.remove('error'), 2000);
                    }
                } catch (error) {
                    console.error('🔐 AuthManager: Error verifying code', error);
                    this.showError('code', 'Failed to verify code. Please try again.');
                } finally {
                    this.setLoading(false, 'loginCodeBtn', 'loginCodeBtnText');
                }
            },

            // Send login code via webhook
            async sendLoginCode(email) {
                const code = this.generateCode();
                this.storePendingCode(email, code);

                console.log('🔐 AuthManager: Sending code to', email);

                const response = await fetch(this.webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: email,
                        code: code,
                        app: 'taskflow',
                        timestamp: new Date().toISOString()
                    })
                });

                if (!response.ok) {
                    throw new Error('Webhook request failed: ' + response.status);
                }

                console.log('🔐 AuthManager: Code sent successfully');
                return true;
            },

            // Verify the entered code
            async verifyCode(enteredCode) {
                const pending = this.getPendingCode();

                if (!pending) {
                    console.log('🔐 AuthManager: No pending code found');
                    return false;
                }

                if (pending.code === enteredCode) {
                    console.log('🔐 AuthManager: Code verified successfully');
                    localStorage.removeItem(this.pendingCodeKey);
                    return true;
                }

                console.log('🔐 AuthManager: Code mismatch');
                return false;
            },

            // Resend code
            async resendCode() {
                if (this.resendCooldown || this.isLoading || !this.currentEmail) return;

                const resendLink = document.getElementById('loginResendLink');
                if (resendLink) {
                    resendLink.classList.add('disabled');
                    resendLink.textContent = 'Sending...';
                }

                this.resendCooldown = true;

                try {
                    await this.sendLoginCode(this.currentEmail);
                    this.showSuccess();

                    // 30 second cooldown
                    let countdown = 30;
                    const interval = setInterval(() => {
                        countdown--;
                        if (resendLink) {
                            resendLink.textContent = `Resend (${countdown}s)`;
                        }
                        if (countdown <= 0) {
                            clearInterval(interval);
                            this.resendCooldown = false;
                            if (resendLink) {
                                resendLink.classList.remove('disabled');
                                resendLink.textContent = 'Resend';
                            }
                        }
                    }, 1000);
                } catch (error) {
                    console.error('🔐 AuthManager: Error resending code', error);
                    this.showError('code', 'Failed to resend code');
                    this.resendCooldown = false;
                    if (resendLink) {
                        resendLink.classList.remove('disabled');
                        resendLink.textContent = 'Resend';
                    }
                }
            },

            // Go back to email step
            backToEmail() {
                this.currentEmail = null;
                this.pendingCode = null;
                localStorage.removeItem(this.pendingCodeKey);
                this.showEmailStep();
                document.getElementById('loginEmail').focus();
            },

            // Called when authentication is successful
            onAuthSuccess(email, isNewLogin) {
                console.log('🔐 AuthManager: Auth success for', email);

                // Save session
                if (isNewLogin) {
                    this.saveSession(email);
                }

                // Update SoftrIdentity with the authenticated user
                if (typeof SoftrIdentity !== 'undefined') {
                    SoftrIdentity.setUser({
                        email: email,
                        name: email.split('@')[0],
                        id: 'email_' + email.replace(/[^a-zA-Z0-9]/g, '_'),
                        source: 'email_auth'
                    });
                }

                // Update user menu in header
                this.updateUserMenu(email);

                // Hide login overlay
                this.hideLoginOverlay();

                // Dispatch auth event
                document.dispatchEvent(new CustomEvent('auth:success', {
                    detail: { email: email, isNewLogin: isNewLogin }
                }));
            },

            // Update the user menu in the header
            updateUserMenu(email) {
                const userMenuContainer = document.getElementById('userMenuContainer');
                if (!userMenuContainer) return;

                const initials = email.substring(0, 2).toUpperCase();

                userMenuContainer.innerHTML = `
                    <button class="user-menu-btn" onclick="AuthManager.toggleUserMenu(event)">
                        <div class="user-menu-avatar">${initials}</div>
                        <i class="ph ph-caret-down"></i>
                    </button>
                    <div class="user-menu-dropdown" id="userMenuDropdown">
                        <div class="user-menu-header">
                            <div class="user-menu-email">${this.escapeHtml(email)}</div>
                        </div>
                        <button class="user-menu-item danger" onclick="AuthManager.logout()">
                            <i class="ph ph-sign-out"></i> Sign out
                        </button>
                    </div>
                `;
            },

            // Toggle user menu dropdown
            toggleUserMenu(event) {
                event.stopPropagation();
                const dropdown = document.getElementById('userMenuDropdown');
                if (dropdown) {
                    dropdown.classList.toggle('open');

                    // Close on outside click
                    const closeHandler = (e) => {
                        if (!e.target.closest('.user-menu-container')) {
                            dropdown.classList.remove('open');
                            document.removeEventListener('click', closeHandler);
                        }
                    };
                    document.addEventListener('click', closeHandler);
                }
            },

            // Logout
            logout() {
                this.clearSession();
                this.currentEmail = null;
                this.pendingCode = null;

                // Reset login form
                this.showEmailStep();
                document.getElementById('loginEmail').value = '';

                // Clear user menu
                const userMenuContainer = document.getElementById('userMenuContainer');
                if (userMenuContainer) {
                    userMenuContainer.innerHTML = '';
                }

                // Show login overlay
                this.showLoginOverlay();

                // Dispatch logout event
                document.dispatchEvent(new CustomEvent('auth:logout'));
            },

            // Utility: validate email
            isValidEmail(email) {
                return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
            },

            // Utility: escape HTML
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            // Get current user email
            getCurrentUser() {
                const session = this.getSession();
                return session ? session.email : null;
            }
        };

        // ==========================================
        // SOFTR USER IDENTITY
        // ==========================================

        // Softr Identity Service - detects and tracks user identity when embedded in Softr
        const SoftrIdentity = {
            currentUser: null,
            isInitialized: false,
            isReady: false,
            readyCallbacks: [],
            retryCount: 0,
            maxRetries: 10,

            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;

                console.log('🔐 SoftrIdentity: Initializing...');

                // Method 1: Check window.logged_in_user immediately (Softr's primary method)
                this.checkSoftrGlobalUser();

                // Method 2: Listen for postMessage from Softr parent (enhanced bridge)
                window.addEventListener('message', this.handleMessage.bind(this));

                // Method 3: Check URL parameters (fallback)
                this.checkUrlParams();

                // Method 4: Request user info from Softr parent (if in iframe)
                if (window.parent !== window) {
                    console.log('🔐 SoftrIdentity: Running in iframe, requesting user from parent...');
                    this.requestUserFromParent();
                    // Also try to access parent's logged_in_user after a short delay
                    this.checkParentSoftrUser();
                    // Start retry loop for requesting user from parent
                    this.startParentRetryLoop();
                }

                // Method 5: Check again on window load (Softr may inject user data late)
                window.addEventListener('load', () => {
                    if (!this.currentUser) {
                        console.log('🔐 SoftrIdentity: Window loaded, checking for user again...');
                        if (this.checkSoftrGlobalUser()) {
                            console.log('🔐 SoftrIdentity: Found user on window load');
                        } else if (this.checkParentSoftrUser()) {
                            console.log('🔐 SoftrIdentity: Found user in parent on window load');
                        }
                    }
                    // Signal ready to parent regardless of user detection
                    this.signalReadyToParent();
                });

                // Method 6: Poll for Softr user (it may load async)
                this.startUserPolling();

                // Update UI immediately with current state
                this.updateUI();

                // Signal ready after short delay (for faster initial load)
                setTimeout(() => this.signalReadyToParent(), 500);
            },

            // Retry loop to request user from parent multiple times
            startParentRetryLoop() {
                if (this.currentUser) return;

                const retryInterval = setInterval(() => {
                    this.retryCount++;

                    if (this.currentUser || this.retryCount >= this.maxRetries) {
                        clearInterval(retryInterval);
                        if (!this.currentUser) {
                            console.log('🔐 SoftrIdentity: Max retries reached, no user from parent');
                        }
                        return;
                    }

                    console.log(`🔐 SoftrIdentity: Retry ${this.retryCount}/${this.maxRetries} - requesting user from parent`);
                    this.requestUserFromParent();
                }, 2000); // Retry every 2 seconds
            },

            // Signal to parent frame that app is ready to receive data
            signalReadyToParent() {
                if (this.isReady) return;
                this.isReady = true;

                if (window.parent !== window) {
                    try {
                        const readyMessage = {
                            type: 'taskflow:ready',
                            source: 'taskflow-app',
                            timestamp: Date.now(),
                            hasUser: !!this.currentUser,
                            user: this.currentUser
                        };
                        window.parent.postMessage(readyMessage, '*');
                        console.log('🔐 SoftrIdentity: Sent ready signal to parent', readyMessage);
                    } catch (e) {
                        console.log('🔐 SoftrIdentity: Could not signal ready to parent', e);
                    }
                }

                // Fire ready callbacks
                this.readyCallbacks.forEach(cb => {
                    try { cb(this.currentUser); } catch (e) { console.error(e); }
                });
                this.readyCallbacks = [];
            },

            // Register callback for when ready
            onReady(callback) {
                if (this.isReady) {
                    callback(this.currentUser);
                } else {
                    this.readyCallbacks.push(callback);
                }
            },

            checkSoftrGlobalUser() {
                // Softr exposes logged-in user data on window.logged_in_user
                if (window.logged_in_user) {
                    console.log('🔐 SoftrIdentity: Found window.logged_in_user', window.logged_in_user);
                    this.setUser(window.logged_in_user);
                    return true;
                }
                // Also check alternative Softr global variables
                if (window.softr && window.softr.user) {
                    console.log('🔐 SoftrIdentity: Found window.softr.user', window.softr.user);
                    this.setUser(window.softr.user);
                    return true;
                }
                return false;
            },

            checkParentSoftrUser() {
                // Try to access parent window's logged_in_user (same-origin only)
                try {
                    if (window.parent && window.parent !== window) {
                        if (window.parent.logged_in_user) {
                            console.log('🔐 SoftrIdentity: Found parent.logged_in_user', window.parent.logged_in_user);
                            this.setUser(window.parent.logged_in_user);
                            return true;
                        }
                        if (window.parent.softr && window.parent.softr.user) {
                            console.log('🔐 SoftrIdentity: Found parent.softr.user', window.parent.softr.user);
                            this.setUser(window.parent.softr.user);
                            return true;
                        }
                    }
                } catch (e) {
                    // Cross-origin access blocked - this is expected for cross-origin iframes
                    console.log('🔐 SoftrIdentity: Cannot access parent (cross-origin)', e.message);
                }
                return false;
            },

            startUserPolling() {
                // Softr user data may load asynchronously, poll for it
                // Use fast polling (100ms) like Softr's own detection patterns
                if (this.currentUser) return; // Already have user

                let attempts = 0;
                const maxAttempts = 30; // 30 attempts × 100ms = 3 seconds
                const pollInterval = setInterval(() => {
                    attempts++;

                    if (this.currentUser) {
                        clearInterval(pollInterval);
                        return;
                    }

                    // Check global variables again
                    if (this.checkSoftrGlobalUser()) {
                        console.log(`🔐 SoftrIdentity: Found user after ${attempts} polling attempt(s)`);
                        clearInterval(pollInterval);
                        return;
                    }

                    // Try parent again (same-origin only)
                    if (this.checkParentSoftrUser()) {
                        console.log(`🔐 SoftrIdentity: Found user in parent after ${attempts} polling attempt(s)`);
                        clearInterval(pollInterval);
                        return;
                    }

                    if (attempts >= maxAttempts) {
                        clearInterval(pollInterval);
                        console.log('🔐 SoftrIdentity: User polling complete, no user found after 3 seconds');
                    }
                }, 100); // Check every 100ms (fast polling like Softr's patterns)
            },

            handleMessage(event) {
                // Accept messages from any Softr domain or parent
                const data = event.data;
                if (!data) return;

                // Log all messages for debugging (in debug mode)
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('debug') === 'true') {
                    console.log('🔐 SoftrIdentity: Received postMessage:', data);
                }

                // Handle bridge-specific messages
                if (data.type === 'softr-bridge:user' || data.type === 'bridge:user') {
                    console.log('🔐 SoftrIdentity: Received user from Softr bridge', data);
                    const userData = data.user || data.userData || data;
                    this.setUser(userData);
                    // Acknowledge receipt
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'taskflow:user-received',
                            source: 'taskflow-app',
                            userId: this.currentUser?.id
                        }, '*');
                    }
                    return;
                }

                // Handle Softr user data (various formats Softr might use)
                if (data.type === 'softr:user' || data.type === 'user' || data.softrUser || data.user) {
                    console.log('🔐 SoftrIdentity: Received user data via postMessage', data);
                    const userData = data.user || data.softrUser || data;
                    this.setUser(userData);
                    return;
                }

                // Handle Softr's logged_in_user format
                if (data.logged_in_user) {
                    console.log('🔐 SoftrIdentity: Received logged_in_user via postMessage', data);
                    this.setUser(data.logged_in_user);
                    return;
                }

                // Handle request for status from parent
                if (data.type === 'softr-bridge:request-status' || data.type === 'request:status') {
                    console.log('🔐 SoftrIdentity: Parent requesting status');
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'taskflow:status',
                            source: 'taskflow-app',
                            isReady: this.isReady,
                            hasUser: !!this.currentUser,
                            user: this.currentUser,
                            xanoStatus: typeof xanoConnectionStatus !== 'undefined' ? xanoConnectionStatus : 'unknown'
                        }, '*');
                    }
                    return;
                }
            },

            checkUrlParams() {
                const params = new URLSearchParams(window.location.search);

                // Check for Softr user params
                const userId = params.get('softr_user_id') || params.get('user_id');
                const userEmail = params.get('softr_user_email') || params.get('user_email') || params.get('email');
                const userName = params.get('softr_user_name') || params.get('user_name') || params.get('name');

                if (userId || userEmail || userName) {
                    console.log('🔐 SoftrIdentity: Found user in URL params');
                    this.setUser({
                        id: userId,
                        email: userEmail,
                        name: userName,
                        source: 'url_params'
                    });
                }
            },

            requestUserFromParent() {
                // Ask parent frame for user info (Softr should respond)
                try {
                    window.parent.postMessage({ type: 'request:user', source: 'taskflow-app' }, '*');
                    window.parent.postMessage({ type: 'softr:request-user', source: 'taskflow-app' }, '*');
                } catch (e) {
                    console.log('🔐 SoftrIdentity: Could not request user from parent', e);
                }
            },

            setUser(userData) {
                if (!userData) return;

                // Prioritize Softr's standard fields (softr_user_*) over custom Airtable fields
                // Note: userData.Name may contain role/group info, not the actual user name
                this.currentUser = {
                    id: userData.id || userData.record_id || userData.user_id || userData.airtable_record_id || null,
                    email: userData.softr_user_email || userData.email || userData.Email || null,
                    name: userData.softr_user_full_name || userData.name || userData.full_name || userData.Full_Name || null,
                    role: userData.role || userData.Role || null,
                    // Store all original data for potential future use
                    _raw: userData,
                    _detectedAt: new Date().toISOString()
                };

                console.log('🔐 SoftrIdentity: User set:', this.currentUser);

                // Update UI
                this.updateUI();

                // Dispatch custom event for other parts of app
                document.dispatchEvent(new CustomEvent('softr:user:ready', {
                    detail: this.currentUser
                }));
            },

            updateUI() {
                const indicator = document.getElementById('softrUserIndicator');
                if (!indicator) return;

                // Hide indicator in standalone mode (not embedded in an iframe or no Softr detected)
                const isInIframe = window.parent !== window;
                const hasSoftr = !!(window.logged_in_user || window.softr || (isInIframe && this.currentUser));

                if (!isInIframe && !hasSoftr) {
                    // Running standalone - hide the indicator
                    indicator.style.display = 'none';
                    return;
                }

                // Show indicator when embedded or when Softr is detected
                indicator.style.display = '';

                if (this.currentUser && (this.currentUser.name || this.currentUser.email)) {
                    // User detected - show their info
                    indicator.classList.remove('no-user');

                    const name = this.currentUser.name || 'User';
                    const email = this.currentUser.email || '';
                    const initials = this.getInitials(name, email);

                    indicator.innerHTML = `
                        <div class="user-avatar">${initials}</div>
                        <div class="user-info">
                            <span class="user-name">${this.escapeHtml(name)}</span>
                            ${email ? `<span class="user-email">${this.escapeHtml(email)}</span>` : ''}
                        </div>
                    `;
                } else {
                    // No user detected
                    indicator.classList.add('no-user');
                    indicator.innerHTML = `
                        <div class="user-avatar"><i class="ph ph-user"></i></div>
                        <div class="user-info">
                            <span class="user-name">No user detected</span>
                            <span class="user-email">Embed on Softr to see user</span>
                        </div>
                    `;
                }
            },

            getInitials(name, email) {
                if (name && name !== 'User') {
                    const parts = name.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                    }
                    return name.substring(0, 2).toUpperCase();
                }
                if (email) {
                    return email.substring(0, 2).toUpperCase();
                }
                return '?';
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            getUser() {
                return this.currentUser;
            }
        };

        // ==========================================
        // WORKSPACE MANAGEMENT
        // ==========================================

        // Workspace manager - stores all workspaces
        let workspaces = {};  // { workspaceId: { id, name, entities, relationships, hasSampleData, createdAt, updatedAt } }
        let currentWorkspaceId = null;
        let workspaceModalMode = 'create';  // 'create' or 'rename'
        let workspaceToRename = null;

        function generateWorkspaceId() {
            return 'ws_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function loadWorkspaces() {
            try {
                const saved = localStorage.getItem('holonicWorkspaces');
                if (saved) {
                    const data = JSON.parse(saved);
                    workspaces = data.workspaces || {};
                    currentWorkspaceId = data.currentWorkspaceId || null;

                    // Validate current workspace exists
                    if (currentWorkspaceId && !workspaces[currentWorkspaceId]) {
                        currentWorkspaceId = Object.keys(workspaces)[0] || null;
                    }

                    return Object.keys(workspaces).length > 0;
                }

                // Migration: Check for old single-workspace format
                const oldData = localStorage.getItem('holonicOrgData');
                if (oldData) {
                    const parsed = JSON.parse(oldData);
                    const wsId = generateWorkspaceId();
                    // Ensure all entity types exist for backwards compatibility
                    const migratedEntities = parsed.entities || {};
                    ['unit', 'team', 'role', 'person', 'task', 'product', 'workflow'].forEach(type => {
                        if (!Array.isArray(migratedEntities[type])) {
                            migratedEntities[type] = [];
                        }
                    });
                    workspaces[wsId] = {
                        id: wsId,
                        name: parsed.workspaceName || 'My Organization',
                        entities: migratedEntities,
                        relationships: parsed.relationships || [],
                        hasSampleData: parsed.hasSampleData || false,
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };
                    currentWorkspaceId = wsId;
                    saveWorkspaces();
                    // Remove old format
                    localStorage.removeItem('holonicOrgData');
                    localStorage.removeItem('workspaceName');
                    return true;
                }
            } catch (e) {
                console.error('Failed to load workspaces:', e);
            }
            return false;
        }

        function saveWorkspaces() {
            try {
                // Update current workspace data before saving
                if (currentWorkspaceId && workspaces[currentWorkspaceId]) {
                    workspaces[currentWorkspaceId].entities = JSON.parse(JSON.stringify(entities));
                    workspaces[currentWorkspaceId].relationships = JSON.parse(JSON.stringify(relationships));
                    workspaces[currentWorkspaceId].hasSampleData = hasSampleData;
                    workspaces[currentWorkspaceId].updatedAt = Date.now();

                    // Save workflow system data
                    workspaces[currentWorkspaceId].workflowTemplates = JSON.parse(JSON.stringify(workflowTemplates));
                    workspaces[currentWorkspaceId].workflowInstances = JSON.parse(JSON.stringify(workflowInstances));
                    workspaces[currentWorkspaceId].workflowViolations = JSON.parse(JSON.stringify(workflowViolations));
                    workspaces[currentWorkspaceId].taskLinks = JSON.parse(JSON.stringify(taskLinks));
                }

                const data = {
                    workspaces,
                    currentWorkspaceId
                };
                localStorage.setItem('holonicWorkspaces', JSON.stringify(data));
            } catch (e) {
                console.error('Failed to save workspaces:', e);
            }
        }

        function switchWorkspace(workspaceId) {
            if (!workspaces[workspaceId]) return;

            // Save current workspace first
            saveWorkspaces();

            // Switch to new workspace
            currentWorkspaceId = workspaceId;
            const ws = workspaces[workspaceId];

            // Load workspace data (normalizeEntities ensures backwards compatibility)
            entities = normalizeEntities(JSON.parse(JSON.stringify(ws.entities || {})));
            relationships = JSON.parse(JSON.stringify(ws.relationships || []));
            hasSampleData = ws.hasSampleData || false;

            // Load workflow system data
            workflowTemplates = JSON.parse(JSON.stringify(ws.workflowTemplates || []));
            workflowInstances = JSON.parse(JSON.stringify(ws.workflowInstances || []));
            workflowViolations = JSON.parse(JSON.stringify(ws.workflowViolations || []));
            taskLinks = JSON.parse(JSON.stringify(ws.taskLinks || []));

            // Update UI
            const nameEl = document.getElementById('workspaceNameText');
            nameEl.textContent = ws.name;
            nameEl.title = ws.name;

            // Update sample data button
            const btnText = document.getElementById('sampleDataText');
            if (btnText) {
                btnText.textContent = hasSampleData ? 'Clear Sample Data' : 'Load Sample Data';
            }

            // Load undo history for this workspace
            loadUndoHistory();

            // Re-render everything
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            // Save the switch
            saveWorkspaces();

            // Close dropdown
            closeWorkspaceDropdown();

            console.log('Switched to workspace:', ws.name);
        }

        function createWorkspace(name) {
            const wsId = generateWorkspaceId();
            workspaces[wsId] = {
                id: wsId,
                name: name.trim() || 'New Workspace',
                entities: { unit: [], team: [], role: [], person: [], task: [], product: [], workflow: [] },
                relationships: [],
                hasSampleData: false,
                createdAt: Date.now(),
                updatedAt: Date.now()
            };
            saveWorkspaces();
            switchWorkspace(wsId);
            renderWorkspaceList();
            return wsId;
        }

        function renameWorkspace(workspaceId, newName) {
            if (!workspaces[workspaceId]) return;
            workspaces[workspaceId].name = newName.trim() || workspaces[workspaceId].name;
            workspaces[workspaceId].updatedAt = Date.now();

            // Update display if it's the current workspace
            if (workspaceId === currentWorkspaceId) {
                const nameEl = document.getElementById('workspaceNameText');
                nameEl.textContent = workspaces[workspaceId].name;
                nameEl.title = workspaces[workspaceId].name;
            }

            saveWorkspaces();
            renderWorkspaceList();
        }

        function deleteWorkspace(workspaceId) {
            if (!workspaces[workspaceId]) return;

            const wsName = workspaces[workspaceId].name;
            const wsCount = Object.keys(workspaces).length;

            if (wsCount <= 1) {
                alert('Cannot delete the last workspace. Create a new workspace first.');
                return;
            }

            if (!confirm(`Delete workspace "${wsName}"? This cannot be undone.`)) return;

            delete workspaces[workspaceId];

            // If we deleted the current workspace, switch to another
            if (workspaceId === currentWorkspaceId) {
                const remainingIds = Object.keys(workspaces);
                if (remainingIds.length > 0) {
                    switchWorkspace(remainingIds[0]);
                }
            }

            saveWorkspaces();
            renderWorkspaceList();
        }

        // ==========================================
        // UNDO HISTORY FUNCTIONS
        // ==========================================

        function pushToUndoHistory(action) {
            // Add timestamp if not present
            if (!action.timestamp) {
                action.timestamp = Date.now();
            }

            undoHistory.push(action);

            // Clear redo history - new action invalidates redo stack
            redoHistory = [];

            // Trim history if it exceeds max size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory = undoHistory.slice(-MAX_UNDO_HISTORY);
            }

            // Save history to localStorage
            saveUndoHistory();
            updateUndoButton();
            updateRedoButton();
        }

        function undo() {
            if (undoHistory.length === 0) {
                showUndoNotification('Nothing to undo');
                return;
            }

            const action = undoHistory.pop();

            switch (action.type) {
                case 'create_entity':
                    // Undo entity creation - delete it (but don't add to recycle bin)
                    const entityType = action.entityType;
                    entities[entityType] = entities[entityType].filter(e => e.id !== action.data.id);
                    // Also remove any relationships created with it
                    relationships = relationships.filter(r => r.subject !== action.data.id && r.object !== action.data.id);
                    break;

                case 'delete_entity':
                    // Undo entity deletion - restore it
                    entities[action.entityType].push(action.data);
                    // Restore relationships that were deleted with it
                    if (action.deletedRelationships) {
                        relationships.push(...action.deletedRelationships);
                    }
                    // Remove from recycle bin if present
                    recycleBin = recycleBin.filter(item =>
                        !(item.itemType === 'entity' && item.item.id === action.data.id)
                    );
                    break;

                case 'update_entity':
                    // Undo entity update - restore old values
                    const entity = findEntity(action.data.id);
                    if (entity) {
                        entity.name = action.oldData.name;
                        entity.description = action.oldData.description;
                    }
                    break;

                case 'create_relationship':
                    // Undo relationship creation - delete it
                    relationships = relationships.filter(r => r.id !== action.data.id);
                    break;

                case 'delete_relationship':
                    // Undo relationship deletion - restore it
                    relationships.push(action.data);
                    // Remove from recycle bin if present
                    recycleBin = recycleBin.filter(item =>
                        !(item.itemType === 'relationship' && item.item.id === action.data.id)
                    );
                    break;

                case 'update_relationship':
                    // Undo relationship update - restore old values
                    const rel = relationships.find(r => r.id === action.data.id);
                    if (rel) {
                        rel.subject = action.oldData.subject;
                        rel.predicate = action.oldData.predicate;
                        rel.object = action.oldData.object;
                    }
                    break;
            }

            // Push to redo history for redo functionality
            redoHistory.push(action);
            if (redoHistory.length > MAX_UNDO_HISTORY) {
                redoHistory = redoHistory.slice(-MAX_UNDO_HISTORY);
            }

            saveToLocalStorage();
            saveUndoHistory();
            updateUndoButton();
            updateRedoButton();
            refreshAllViews();

            showUndoNotification(`Undone: ${action.description}`);
        }

        function redo() {
            if (redoHistory.length === 0) {
                showUndoNotification('Nothing to redo');
                return;
            }

            const action = redoHistory.pop();

            switch (action.type) {
                case 'create_entity':
                    // Redo entity creation - recreate it
                    entities[action.entityType].push(action.data);
                    break;

                case 'delete_entity':
                    // Redo entity deletion - delete it again
                    entities[action.entityType] = entities[action.entityType].filter(e => e.id !== action.data.id);
                    // Remove relationships again
                    if (action.deletedRelationships) {
                        const deletedRelIds = action.deletedRelationships.map(r => r.id);
                        relationships = relationships.filter(r => !deletedRelIds.includes(r.id));
                    }
                    // Add back to recycle bin
                    addToRecycleBin(action.data, 'entity', action.entityType, action.deletedRelationships || []);
                    break;

                case 'update_entity':
                    // Redo entity update - apply new values
                    const entity = findEntity(action.data.id);
                    if (entity) {
                        entity.name = action.data.name;
                        entity.description = action.data.description;
                    }
                    break;

                case 'create_relationship':
                    // Redo relationship creation - recreate it
                    relationships.push(action.data);
                    break;

                case 'delete_relationship':
                    // Redo relationship deletion - delete it again
                    relationships = relationships.filter(r => r.id !== action.data.id);
                    // Add back to recycle bin
                    addToRecycleBin(action.data, 'relationship', null, []);
                    break;

                case 'update_relationship':
                    // Redo relationship update - apply new values
                    const rel = relationships.find(r => r.id === action.data.id);
                    if (rel) {
                        rel.subject = action.data.subject;
                        rel.predicate = action.data.predicate;
                        rel.object = action.data.object;
                    }
                    break;
            }

            // Push back to undo history
            undoHistory.push(action);
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory = undoHistory.slice(-MAX_UNDO_HISTORY);
            }

            saveToLocalStorage();
            saveUndoHistory();
            updateUndoButton();
            updateRedoButton();
            refreshAllViews();

            showUndoNotification(`Redone: ${action.description}`);
        }

        function saveUndoHistory() {
            try {
                if (currentWorkspaceId) {
                    localStorage.setItem(`undoHistory_${currentWorkspaceId}`, JSON.stringify(undoHistory));
                    localStorage.setItem(`redoHistory_${currentWorkspaceId}`, JSON.stringify(redoHistory));
                    localStorage.setItem(`recycleBin_${currentWorkspaceId}`, JSON.stringify(recycleBin));
                }
            } catch (e) {
                console.error('Failed to save undo history:', e);
            }
        }

        function loadUndoHistory() {
            try {
                if (currentWorkspaceId) {
                    const savedHistory = localStorage.getItem(`undoHistory_${currentWorkspaceId}`);
                    const savedRedoHistory = localStorage.getItem(`redoHistory_${currentWorkspaceId}`);
                    const savedRecycleBin = localStorage.getItem(`recycleBin_${currentWorkspaceId}`);
                    undoHistory = savedHistory ? JSON.parse(savedHistory) : [];
                    redoHistory = savedRedoHistory ? JSON.parse(savedRedoHistory) : [];
                    recycleBin = savedRecycleBin ? JSON.parse(savedRecycleBin) : [];
                } else {
                    undoHistory = [];
                    redoHistory = [];
                    recycleBin = [];
                }
            } catch (e) {
                console.error('Failed to load undo history:', e);
                undoHistory = [];
                redoHistory = [];
                recycleBin = [];
            }
            updateUndoButton();
            updateRedoButton();
            renderRecycleBin();
        }

        function clearUndoHistory() {
            undoHistory = [];
            redoHistory = [];
            saveUndoHistory();
            updateUndoButton();
            updateRedoButton();
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            const undoCount = document.getElementById('undoCount');
            if (undoBtn) {
                undoBtn.disabled = undoHistory.length === 0;
                undoBtn.title = undoHistory.length > 0
                    ? `Undo: ${undoHistory[undoHistory.length - 1]?.description || 'last action'} (Ctrl+Z)`
                    : 'Nothing to undo';
            }
            if (undoCount) {
                undoCount.textContent = undoHistory.length;
                undoCount.style.display = undoHistory.length > 0 ? 'inline' : 'none';
            }
            // Update activity feed
            if (typeof renderActivityFeed === 'function') {
                renderActivityFeed();
            }
        }

        function updateRedoButton() {
            const redoBtn = document.getElementById('redoBtn');
            const redoCount = document.getElementById('redoCount');
            if (redoBtn) {
                redoBtn.disabled = redoHistory.length === 0;
                redoBtn.title = redoHistory.length > 0
                    ? `Redo: ${redoHistory[redoHistory.length - 1]?.description || 'last action'} (Ctrl+Shift+Z)`
                    : 'Nothing to redo';
            }
            if (redoCount) {
                redoCount.textContent = redoHistory.length;
                redoCount.style.display = redoHistory.length > 0 ? 'inline' : 'none';
            }
        }

        function showUndoNotification(message) {
            // Create or update notification element
            let notification = document.getElementById('undoNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'undoNotification';
                notification.className = 'undo-notification';
                document.body.appendChild(notification);
            }

            notification.textContent = message;
            notification.classList.add('show');

            // Hide after 2 seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        // ==========================================
        // RECYCLE BIN FUNCTIONS
        // ==========================================

        function addToRecycleBin(item, itemType, entityType, deletedRelationships = []) {
            recycleBin.push({
                item: JSON.parse(JSON.stringify(item)),
                itemType,
                entityType,
                deletedAt: Date.now(),
                deletedRelationships: deletedRelationships.map(r => JSON.parse(JSON.stringify(r)))
            });
            saveUndoHistory();
            renderRecycleBin();
        }

        function restoreFromRecycleBin(index) {
            if (index < 0 || index >= recycleBin.length) return;

            const entry = recycleBin[index];

            if (entry.itemType === 'entity') {
                // Restore entity
                entities[entry.entityType].push(entry.item);
                // Restore associated relationships
                if (entry.deletedRelationships) {
                    relationships.push(...entry.deletedRelationships);
                }
            } else if (entry.itemType === 'relationship') {
                // Restore relationship
                relationships.push(entry.item);
            }

            // Remove from recycle bin
            recycleBin.splice(index, 1);

            saveToLocalStorage();
            saveUndoHistory();
            refreshAllViews();
            renderRecycleBin();

            showUndoNotification(`Restored: ${entry.item.name || 'item'}`);
        }

        function permanentlyDelete(index) {
            if (index < 0 || index >= recycleBin.length) return;

            const entry = recycleBin[index];
            const itemName = entry.item.name || 'item';

            if (!confirm(`Permanently delete "${itemName}"? This cannot be undone.`)) return;

            recycleBin.splice(index, 1);
            saveUndoHistory();
            renderRecycleBin();

            showUndoNotification(`Permanently deleted: ${itemName}`);
        }

        function emptyRecycleBin() {
            if (recycleBin.length === 0) {
                showUndoNotification('Recycle bin is empty');
                return;
            }

            if (!confirm(`Permanently delete all ${recycleBin.length} item(s) in recycle bin? This cannot be undone.`)) return;

            recycleBin = [];
            saveUndoHistory();
            renderRecycleBin();

            showUndoNotification('Recycle bin emptied');
        }

        function renderRecycleBin() {
            const container = document.getElementById('recycleBinList');
            if (!container) return;

            const countEl = document.getElementById('recycleBinCount');
            if (countEl) {
                countEl.textContent = recycleBin.length;
                countEl.style.display = recycleBin.length > 0 ? 'inline' : 'none';
            }

            if (recycleBin.length === 0) {
                container.innerHTML = '<div class="recycle-bin-empty"><i class="ph ph-trash"></i><p>Recycle bin is empty</p></div>';
                return;
            }

            container.innerHTML = recycleBin.map((entry, index) => {
                const icon = entry.itemType === 'entity' ? getIcon(entry.entityType) : '<i class="ph ph-link"></i>';
                const name = entry.item.name || `${entry.item.subject} → ${entry.item.object}`;
                const typeLabel = entry.itemType === 'entity' ? entry.entityType : 'connection';
                const timeAgo = getTimeAgo(entry.deletedAt);

                return `
                    <div class="recycle-bin-item">
                        <div class="recycle-bin-item-info">
                            <span class="recycle-bin-icon">${icon}</span>
                            <div class="recycle-bin-details">
                                <span class="recycle-bin-name">${name}</span>
                                <span class="recycle-bin-meta">${typeLabel} • ${timeAgo}</span>
                            </div>
                        </div>
                        <div class="recycle-bin-actions">
                            <button class="btn-icon" onclick="restoreFromRecycleBin(${index})" title="Restore">
                                <i class="ph ph-arrow-counter-clockwise"></i>
                            </button>
                            <button class="btn-icon delete" onclick="permanentlyDelete(${index})" title="Delete permanently">
                                <i class="ph ph-x"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);

            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function refreshAllViews() {
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();
            renderRecycleBin();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            } else if (currentView === 'venn') {
                renderVennView();
            }
        }

        function toggleWorkspaceDropdown(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('workspaceDropdown');
            const isOpen = dropdown.classList.contains('open');

            if (isOpen) {
                closeWorkspaceDropdown();
            } else {
                dropdown.classList.add('open');
                renderWorkspaceList();

                // Close dropdown when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeWorkspaceDropdownOnOutsideClick);
                }, 0);
            }
        }

        function closeWorkspaceDropdown() {
            const dropdown = document.getElementById('workspaceDropdown');
            dropdown.classList.remove('open');
            document.removeEventListener('click', closeWorkspaceDropdownOnOutsideClick);
        }

        function closeWorkspaceDropdownOnOutsideClick(event) {
            const dropdown = document.getElementById('workspaceDropdown');
            const toggle = document.querySelector('.workspace-dropdown-toggle');

            if (!dropdown.contains(event.target) && !toggle.contains(event.target)) {
                closeWorkspaceDropdown();
            }
        }

        function renderWorkspaceList() {
            const listEl = document.getElementById('workspaceList');
            if (!listEl) return;

            const sortedWorkspaces = Object.values(workspaces).sort((a, b) => b.updatedAt - a.updatedAt);

            listEl.innerHTML = sortedWorkspaces.map(ws => `
                <div class="workspace-item ${ws.id === currentWorkspaceId ? 'active' : ''}" onclick="switchWorkspace('${ws.id}')">
                    <div class="workspace-item-name" title="${escapeHtml(ws.name)}">
                        <i class="ph ${ws.id === currentWorkspaceId ? 'ph-check-circle' : 'ph-folder'}"></i>
                        <span>${escapeHtml(ws.name)}</span>
                    </div>
                    <div class="workspace-item-actions">
                        <button class="workspace-action-btn" onclick="event.stopPropagation(); openRenameWorkspaceModal('${ws.id}')" title="Rename">
                            <i class="ph ph-pencil-simple"></i>
                        </button>
                        <button class="workspace-action-btn delete" onclick="event.stopPropagation(); deleteWorkspace('${ws.id}')" title="Delete">
                            <i class="ph ph-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function openNewWorkspaceModal() {
            workspaceModalMode = 'create';
            workspaceToRename = null;
            document.getElementById('workspaceModalTitle').textContent = 'New Workspace';
            document.getElementById('workspaceModalInput').value = '';
            document.getElementById('workspaceModalInput').placeholder = 'Workspace name...';
            document.getElementById('workspaceModal').classList.add('open');
            setTimeout(() => document.getElementById('workspaceModalInput').focus(), 100);
            closeWorkspaceDropdown();
        }

        function openRenameWorkspaceModal(workspaceId) {
            if (!workspaces[workspaceId]) return;
            workspaceModalMode = 'rename';
            workspaceToRename = workspaceId;
            document.getElementById('workspaceModalTitle').textContent = 'Rename Workspace';
            document.getElementById('workspaceModalInput').value = workspaces[workspaceId].name;
            document.getElementById('workspaceModalInput').placeholder = 'Workspace name...';
            document.getElementById('workspaceModal').classList.add('open');
            setTimeout(() => {
                const input = document.getElementById('workspaceModalInput');
                input.focus();
                input.select();
            }, 100);
            closeWorkspaceDropdown();
        }

        function closeWorkspaceModal() {
            document.getElementById('workspaceModal').classList.remove('open');
            workspaceModalMode = 'create';
            workspaceToRename = null;
        }

        function saveWorkspaceFromModal() {
            const name = document.getElementById('workspaceModalInput').value.trim();
            if (!name) {
                alert('Please enter a workspace name.');
                return;
            }

            if (workspaceModalMode === 'create') {
                createWorkspace(name);
            } else if (workspaceModalMode === 'rename' && workspaceToRename) {
                renameWorkspace(workspaceToRename, name);
            }

            closeWorkspaceModal();
        }

        // ==========================================
        // ENTITY DATA STRUCTURE
        // ==========================================

        // Data structure
        // Conceptual model:
        // - Tasks produce Work Products
        // - Tasks follow Workflows
        // - Workflows connect Roles to Work Products (and possibly other roles)
        // - Roles are assigned People
        // - Roles are within Teams
        // - Teams can be within Teams (hierarchical)
        // - Teams are within Units
        let entities = {
            unit: [],
            team: [],
            role: [],
            person: [],
            task: [],
            product: [],
            workflow: []
        };

        let relationships = [];

        // Ensure all required entity types exist (for backwards compatibility with older saved data)
        function normalizeEntities(e) {
            const requiredTypes = ['unit', 'team', 'role', 'person', 'task', 'product', 'workflow'];
            const normalized = e || {};
            requiredTypes.forEach(type => {
                if (!Array.isArray(normalized[type])) {
                    normalized[type] = [];
                }
            });
            return normalized;
        }

        // Modal state - stores current entity being viewed
        let currentModalEntity = null;
        let currentModalEntityType = null;

        // Tree view state - grouping and section expansion
        let treeViewState = {
            peopleGroupBy: 'role', // 'role', 'alphabetical', 'none'
            sectionsExpanded: {
                people: true,
                tasks: true,
                products: true,
                workflows: true,
                unassignedTeams: true,
                unassignedRoles: true
            }
        };

        // EO Operators - Emergence Operators for activity modeling
        // Internal codes used for data store, friendly labels for UI
        // 
        // APPEND-ONLY ACTIVITY TRACKING:
        // Every action creates a new record in Xano activity_store
        // - Creates: INS (Start)
        // - Updates: ALT (Shift) 
        // - Deletes: NUL (Notice)
        // - Nesting: DES (Define) for hierarchical parent-child relationships
        // - Activities: CON (Link), etc. for connections between roles
        // - Structural: SEG (Break), REC (Loop), SYN (Merge)
        // - Oversight: SUP (Hold)
        // Note: INS (Start) is deprecated - people cannot have activities tied to them
        //
        // External (UI) → Internal (Data Store)
        // Notice → NUL | Define → DES
        // Divide → SEG | Link → CON | Shift → ALT
        // Merge → SYN | Balance → SUP | Loop → REC
        const eoOperators = {
            NUL: { 
                code: 'NUL', 
                label: 'Notice', 
                fullLabel: 'NULLIFY',
                color: '#6B5642', 
                description: 'Recognize absence, remove, delete', 
                style: 'solid', 
                weight: 3 
            },
            DES: { 
                code: 'DES', 
                label: 'Define', 
                fullLabel: 'DESIGNATE',
                color: '#C88F4A', 
                description: 'Designate, describe, assign', 
                style: 'solid', 
                weight: 2 
            },
            INS: {
                code: 'INS',
                label: 'Start',
                fullLabel: 'INSERT',
                color: '#8B6F47',
                description: 'Deprecated - people cannot have activities',
                style: 'solid',
                weight: 2,
                deprecated: true
            },
            SEG: { 
                code: 'SEG', 
                label: 'Divide', 
                fullLabel: 'SEGMENT',
                color: '#A89984', 
                description: 'Divide, segment, break down', 
                style: 'dashed', 
                weight: 1 
            },
            CON: { 
                code: 'CON', 
                label: 'Link', 
                fullLabel: 'CONNECT',
                color: '#7B95A3', 
                description: 'Connect, associate, relate', 
                style: 'solid', 
                weight: 1 
            },
            ALT: { 
                code: 'ALT', 
                label: 'Shift', 
                fullLabel: 'ALTER',
                color: '#B87B5B', 
                description: 'Alternate, modify, switch', 
                style: 'solid', 
                weight: 2 
            },
            SYN: { 
                code: 'SYN', 
                label: 'Merge', 
                fullLabel: 'SYNTHESIZE',
                color: '#D4A574', 
                description: 'Synthesize, combine, bring together', 
                style: 'solid', 
                weight: 2 
            },
            SUP: { 
                code: 'SUP', 
                label: 'Balance', 
                fullLabel: 'SUPERSEDE',
                color: '#9B6F47', 
                description: 'Superpose, balance multiple frames, oversee', 
                style: 'solid', 
                weight: 3 
            },
            REC: { 
                code: 'REC', 
                label: 'Loop', 
                fullLabel: 'RECONFIGURE',
                color: '#C8997F', 
                description: 'Recurse, restructure, iterate', 
                style: 'dashed', 
                weight: 2 
            }
        };
        
        // Xano configuration
        const XANO_BASE_URL = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:nrIL-Oi-';
        const APP_ID = 'holonic-org-graph'; // Your app identifier

        // ==========================================
        // EMERGENT WORKFLOW SYSTEM
        // ==========================================
        //
        // Philosophy: Structure can emerge bottom-up OR be imposed top-down
        // - Bottom-up: Tasks → Links → Patterns → Workflows
        // - Top-down: Workflow Templates → Task Instances (with constraints)
        //
        // Task Links: Multiple links between tasks with optional date linking
        // Workflow Templates: Define patterns with roles and constraints
        // Workflow Instances: Bind existing or new tasks to templates
        // Violation Detection: Flag tasks that don't match workflow rules

        // Task Links - extends basic predecessorId with rich linking
        // Stored as array on task entity: linkedTasks[]
        // Each link: { taskId, linkType: 'soft'|'hard', direction: 'blocks'|'blocked_by', createdAt }
        // - soft: logical sequence ("B happens after A")
        // - hard: date dependency ("if A slips, B slips too")

        // Workflow Templates - emergent or defined patterns
        // {
        //   id, name, description, createdBy, status: 'draft'|'active'|'inactive',
        //   taskPatterns: [{ order, namePattern, roleConstraints: [roleId], requiredFields: [] }],
        //   roleRequirements: [{ roleId, permissions: [] }],
        //   approvals: [{ teamId, approvedBy, approvedAt }], // For future approval feature
        //   createdAt, version
        // }

        // Workflow Instances - binds tasks to a template
        // {
        //   id, workflowTemplateId, tasks: [taskId],
        //   status: 'in_progress'|'completed'|'abandoned',
        //   createdAt, templateVersion
        // }

        // Workflow Violations - tracks rule mismatches for reconciliation
        // {
        //   id, taskId, workflowTemplateId, violationType,
        //   status: 'pending'|'resolved'|'exception_granted',
        //   createdBy, resolvedBy, resolvedAt, notes
        // }

        // Storage for workflow system (will be merged into entities structure)
        let workflowTemplates = [];  // Enhanced workflow definitions
        let workflowInstances = [];  // Task groupings bound to templates
        let workflowViolations = []; // Rule mismatches pending reconciliation
        let taskLinks = [];          // Rich task-to-task links with metadata

        // ==========================================
        // FUZZY MATCHING FOR TASK SIMILARITY
        // ==========================================

        // Calculate Levenshtein distance between two strings
        function levenshteinDistance(str1, str2) {
            const m = str1.length;
            const n = str2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

            for (let i = 0; i <= m; i++) dp[i][0] = i;
            for (let j = 0; j <= n; j++) dp[0][j] = j;

            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (str1[i - 1].toLowerCase() === str2[j - 1].toLowerCase()) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
                    }
                }
            }
            return dp[m][n];
        }

        // Calculate similarity score (0-1, higher = more similar)
        function calculateSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;
            const maxLen = Math.max(str1.length, str2.length);
            if (maxLen === 0) return 1;
            const distance = levenshteinDistance(str1, str2);
            return 1 - (distance / maxLen);
        }

        // Tokenize and compare for semantic similarity
        function tokenSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;
            const tokens1 = str1.toLowerCase().split(/\s+/).filter(t => t.length > 2);
            const tokens2 = str2.toLowerCase().split(/\s+/).filter(t => t.length > 2);
            if (tokens1.length === 0 || tokens2.length === 0) return 0;

            let matches = 0;
            for (const t1 of tokens1) {
                for (const t2 of tokens2) {
                    if (t1 === t2 || calculateSimilarity(t1, t2) > 0.8) {
                        matches++;
                        break;
                    }
                }
            }
            return matches / Math.max(tokens1.length, tokens2.length);
        }

        // Find similar tasks (potential duplicates or patterns)
        // Returns array of { task, score, matchType: 'name'|'description'|'both' }
        function findSimilarTasks(targetTask, threshold = 0.6) {
            const similar = [];
            const allTasks = entities.task || [];

            for (const task of allTasks) {
                if (task.id === targetTask.id) continue;

                const nameScore = calculateSimilarity(targetTask.name, task.name);
                const tokenScore = tokenSimilarity(targetTask.name, task.name);
                const descScore = calculateSimilarity(targetTask.description || '', task.description || '');

                // Combined score with weighting
                const combinedNameScore = Math.max(nameScore, tokenScore);

                let matchType = null;
                let finalScore = 0;

                if (combinedNameScore >= threshold && descScore >= threshold) {
                    matchType = 'both';
                    finalScore = (combinedNameScore * 0.6) + (descScore * 0.4);
                } else if (combinedNameScore >= threshold) {
                    matchType = 'name';
                    finalScore = combinedNameScore;
                } else if (descScore >= threshold) {
                    matchType = 'description';
                    finalScore = descScore;
                }

                if (matchType) {
                    similar.push({ task, score: finalScore, matchType });
                }
            }

            return similar.sort((a, b) => b.score - a.score);
        }

        // ==========================================
        // TASK LINKING FUNCTIONS
        // ==========================================

        // Add a link between two tasks
        function addTaskLink(sourceTaskId, targetTaskId, linkType = 'soft', direction = 'blocked_by') {
            // Validate tasks exist
            const sourceTask = entities.task.find(t => t.id === sourceTaskId);
            const targetTask = entities.task.find(t => t.id === targetTaskId);
            if (!sourceTask || !targetTask) return null;

            // Check for existing link
            const existingLink = taskLinks.find(l =>
                (l.sourceTaskId === sourceTaskId && l.targetTaskId === targetTaskId) ||
                (l.sourceTaskId === targetTaskId && l.targetTaskId === sourceTaskId)
            );
            if (existingLink) return existingLink;

            const link = {
                id: 'tlink' + Date.now(),
                sourceTaskId,
                targetTaskId,
                linkType, // 'soft' or 'hard' (date dependency)
                direction, // 'blocks' or 'blocked_by'
                createdAt: new Date().toISOString()
            };

            taskLinks.push(link);
            saveToLocalStorage();

            // Log activity
            logActivityToXano({
                event_verb: 'Link Tasks',
                eo_operator: 'CON',
                object_type: 'task_link',
                object_label: `${sourceTask.name} → ${targetTask.name}`,
                details: JSON.stringify({ linkType, direction })
            });

            // Check for pattern emergence
            checkForPatternEmergence(sourceTaskId);

            return link;
        }

        // Get all links for a task
        function getTaskLinks(taskId) {
            return taskLinks.filter(l => l.sourceTaskId === taskId || l.targetTaskId === taskId);
        }

        // Get linked task chain (follows links recursively)
        function getLinkedTaskChain(taskId, visited = new Set()) {
            if (visited.has(taskId)) return [];
            visited.add(taskId);

            const chain = [taskId];
            const links = getTaskLinks(taskId);

            for (const link of links) {
                const linkedId = link.sourceTaskId === taskId ? link.targetTaskId : link.sourceTaskId;
                chain.push(...getLinkedTaskChain(linkedId, visited));
            }

            return [...new Set(chain)];
        }

        // Propagate date changes for hard-linked tasks
        function propagateDateChange(taskId, newDate, daysDelta) {
            const links = taskLinks.filter(l =>
                l.linkType === 'hard' &&
                (l.sourceTaskId === taskId || l.targetTaskId === taskId)
            );

            for (const link of links) {
                const linkedId = link.sourceTaskId === taskId ? link.targetTaskId : link.sourceTaskId;
                const linkedTask = entities.task.find(t => t.id === linkedId);

                if (linkedTask && linkedTask.dueDate) {
                    const linkedDate = parseLocalDate(linkedTask.dueDate);
                    linkedDate.setDate(linkedDate.getDate() + daysDelta);
                    // Format back to YYYY-MM-DD
                    const year = linkedDate.getFullYear();
                    const month = String(linkedDate.getMonth() + 1).padStart(2, '0');
                    const day = String(linkedDate.getDate()).padStart(2, '0');
                    linkedTask.dueDate = `${year}-${month}-${day}`;

                    // Log the cascading change
                    logActivityToXano({
                        event_verb: 'Cascade Date Change',
                        eo_operator: 'ALT',
                        object_type: 'task',
                        object_id: linkedId,
                        object_label: linkedTask.name,
                        details: `Date cascaded from linked task: ${newDate}`
                    });
                }
            }

            saveToLocalStorage();
        }

        // ==========================================
        // PATTERN DETECTION & WORKFLOW SUGGESTION
        // ==========================================

        // Check if linked tasks or similar tasks form a pattern worth suggesting as workflow
        function checkForPatternEmergence(taskId) {
            const task = entities.task.find(t => t.id === taskId);
            if (!task) return;

            // Check 1: Linked task chain (3+ tasks linked together)
            const chain = getLinkedTaskChain(taskId);
            if (chain.length >= 3) {
                suggestWorkflowFromChain(chain);
                return;
            }

            // Check 2: Similar tasks (fuzzy match)
            const similarTasks = findSimilarTasks(task, 0.65);
            if (similarTasks.length >= 2) {
                suggestWorkflowFromSimilarity(task, similarTasks);
            }
        }

        // Show workflow suggestion modal for a task chain
        function suggestWorkflowFromChain(taskIds) {
            const tasks = taskIds.map(id => entities.task.find(t => t.id === id)).filter(Boolean);
            if (tasks.length < 3) return;

            // Don't suggest if already part of a workflow instance
            const alreadyInWorkflow = workflowInstances.some(wi =>
                taskIds.some(id => wi.tasks.includes(id))
            );
            if (alreadyInWorkflow) return;

            showWorkflowSuggestionModal({
                type: 'chain',
                tasks,
                message: `These ${tasks.length} linked tasks look like a repeating pattern. Would you like to make this a workflow?`
            });
        }

        // Show workflow suggestion modal for similar tasks
        function suggestWorkflowFromSimilarity(task, similarTasks) {
            // Don't suggest if already in a workflow instance
            const allTaskIds = [task.id, ...similarTasks.map(s => s.task.id)];
            const alreadyInWorkflow = workflowInstances.some(wi =>
                allTaskIds.some(id => wi.tasks.includes(id))
            );
            if (alreadyInWorkflow) return;

            showWorkflowSuggestionModal({
                type: 'similarity',
                tasks: [task, ...similarTasks.map(s => s.task)],
                similarityScores: similarTasks,
                message: `Found ${similarTasks.length} similar task(s). Is this a pattern of work?`
            });
        }

        // Track dismissed suggestions to avoid re-showing
        let dismissedWorkflowSuggestions = new Set();

        // Show the workflow suggestion modal
        function showWorkflowSuggestionModal(suggestion) {
            // Generate a key for this suggestion to track dismissals
            const suggestionKey = suggestion.tasks.map(t => t.id).sort().join('-');
            if (dismissedWorkflowSuggestions.has(suggestionKey)) return;

            const overlay = document.getElementById('workflowSuggestionOverlay');
            if (!overlay) return; // UI not ready yet

            const content = document.getElementById('workflowSuggestionContent');
            const taskList = document.getElementById('workflowSuggestionTasks');
            const messageEl = document.getElementById('workflowSuggestionMessage');

            messageEl.textContent = suggestion.message;

            // Render task list
            taskList.innerHTML = suggestion.tasks.map((task, idx) => `
                <div class="workflow-suggestion-task">
                    <span class="suggestion-task-order">${idx + 1}</span>
                    <span class="suggestion-task-name">${task.name}</span>
                    ${suggestion.similarityScores && suggestion.similarityScores[idx - 1] ?
                        `<span class="suggestion-similarity">${Math.round(suggestion.similarityScores[idx - 1].score * 100)}% similar</span>` :
                        ''}
                </div>
            `).join('');

            // Store suggestion data for later use
            overlay.dataset.suggestionKey = suggestionKey;
            overlay.dataset.suggestionData = JSON.stringify({
                type: suggestion.type,
                taskIds: suggestion.tasks.map(t => t.id)
            });

            overlay.classList.add('active');
        }

        // Dismiss workflow suggestion
        function dismissWorkflowSuggestion() {
            const overlay = document.getElementById('workflowSuggestionOverlay');
            const suggestionKey = overlay.dataset.suggestionKey;
            if (suggestionKey) {
                dismissedWorkflowSuggestions.add(suggestionKey);
            }
            overlay.classList.remove('active');
        }

        // Accept workflow suggestion and create workflow
        function acceptWorkflowSuggestion() {
            const overlay = document.getElementById('workflowSuggestionOverlay');
            const suggestionData = JSON.parse(overlay.dataset.suggestionData || '{}');

            if (!suggestionData.taskIds || suggestionData.taskIds.length === 0) {
                overlay.classList.remove('active');
                return;
            }

            const workflowName = document.getElementById('workflowSuggestionName').value.trim();
            if (!workflowName) {
                alert('Please enter a workflow name');
                return;
            }

            // Create workflow template from the pattern
            createWorkflowFromTasks(workflowName, suggestionData.taskIds);

            overlay.classList.remove('active');
        }

        // ==========================================
        // WORKFLOW TEMPLATE MANAGEMENT
        // ==========================================

        // Create a workflow template from existing tasks (emergent workflow)
        function createWorkflowFromTasks(name, taskIds) {
            const tasks = taskIds.map(id => entities.task.find(t => t.id === id)).filter(Boolean);
            if (tasks.length === 0) return null;

            // Extract patterns from the tasks
            const taskPatterns = tasks.map((task, idx) => {
                // Get roles connected to this task
                const connectedRoles = relationships
                    .filter(r => (r.subject === task.id || r.object === task.id) && r.predicate === 'CON')
                    .map(r => {
                        const otherId = r.subject === task.id ? r.object : r.subject;
                        return findEntity(otherId);
                    })
                    .filter(e => e && e.type === 'role')
                    .map(r => r.id);

                return {
                    order: idx + 1,
                    namePattern: task.name,
                    roleConstraints: connectedRoles,
                    requiredFields: task.dueDate ? ['dueDate'] : []
                };
            });

            // Create the workflow template
            const templateId = 'wftemplate' + Date.now();
            const template = {
                id: templateId,
                name,
                description: `Workflow created from ${tasks.length} tasks`,
                createdBy: getCurrentUserId(),
                status: 'active', // Could be 'draft' if approval required
                taskPatterns,
                roleRequirements: [], // Extract unique roles from patterns
                approvals: [], // For future approval feature
                createdAt: new Date().toISOString(),
                version: 1
            };

            // Extract unique roles
            const uniqueRoles = [...new Set(taskPatterns.flatMap(p => p.roleConstraints))];
            template.roleRequirements = uniqueRoles.map(roleId => ({
                roleId,
                permissions: [] // Placeholder for future permissions
            }));

            workflowTemplates.push(template);

            // Also create a basic workflow entity for backwards compatibility
            const workflowId = 'workflow' + Date.now();
            const workflowEntity = {
                id: workflowId,
                name,
                type: 'workflow',
                description: template.description,
                templateId: templateId // Link to the template
            };
            entities.workflow.push(workflowEntity);

            // Create workflow instance binding existing tasks retroactively
            const instance = createWorkflowInstance(templateId, taskIds);

            // Update tasks to reference this workflow
            tasks.forEach(task => {
                task.followsWorkflowId = workflowId;
            });

            saveToLocalStorage();

            // Log activity
            logActivityToXano({
                event_verb: 'Create Workflow Template',
                eo_operator: 'INS',
                object_type: 'workflow_template',
                object_id: templateId,
                object_label: name,
                details: JSON.stringify({ taskCount: tasks.length, fromEmergence: true })
            });

            // Refresh views
            renderEntityList();
            renderCurrentView();
            populateSelects();

            showToast(`Workflow "${name}" created from ${tasks.length} tasks!`, 'success');

            return template;
        }

        // ==========================================
        // WORKFLOW INSTANCE MANAGEMENT
        // ==========================================

        // Create a workflow instance (binds tasks to a template)
        function createWorkflowInstance(templateId, taskIds) {
            const template = workflowTemplates.find(t => t.id === templateId);
            if (!template) return null;

            const instance = {
                id: 'wfinst' + Date.now(),
                workflowTemplateId: templateId,
                tasks: taskIds,
                status: 'in_progress',
                createdAt: new Date().toISOString(),
                templateVersion: template.version
            };

            workflowInstances.push(instance);

            // Check for violations in bound tasks
            taskIds.forEach(taskId => {
                checkTaskViolations(taskId, templateId);
            });

            saveToLocalStorage();

            logActivityToXano({
                event_verb: 'Create Workflow Instance',
                eo_operator: 'CON',
                object_type: 'workflow_instance',
                object_id: instance.id,
                details: JSON.stringify({ templateId, taskCount: taskIds.length })
            });

            return instance;
        }

        // Add task to existing workflow instance
        function addTaskToWorkflowInstance(instanceId, taskId) {
            const instance = workflowInstances.find(i => i.id === instanceId);
            if (!instance || instance.tasks.includes(taskId)) return;

            instance.tasks.push(taskId);

            // Check violations
            checkTaskViolations(taskId, instance.workflowTemplateId);

            // Update task's workflow reference
            const task = entities.task.find(t => t.id === taskId);
            const template = workflowTemplates.find(t => t.id === instance.workflowTemplateId);
            if (task && template) {
                const workflowEntity = entities.workflow.find(w => w.templateId === template.id);
                if (workflowEntity) {
                    task.followsWorkflowId = workflowEntity.id;
                }
            }

            saveToLocalStorage();
        }

        // ==========================================
        // VIOLATION DETECTION & RECONCILIATION
        // ==========================================

        // Check if a task violates workflow template rules
        function checkTaskViolations(taskId, templateId) {
            const task = entities.task.find(t => t.id === taskId);
            const template = workflowTemplates.find(t => t.id === templateId);
            if (!task || !template) return;

            const violations = [];

            // Get task's connected roles
            const taskRoles = relationships
                .filter(r => (r.subject === task.id || r.object === task.id) && r.predicate === 'CON')
                .map(r => {
                    const otherId = r.subject === task.id ? r.object : r.subject;
                    return findEntity(otherId);
                })
                .filter(e => e && e.type === 'role')
                .map(r => r.id);

            // Check role constraints
            const requiredRoles = template.roleRequirements.map(r => r.roleId);
            if (requiredRoles.length > 0) {
                const hasRequiredRole = taskRoles.some(r => requiredRoles.includes(r));
                if (!hasRequiredRole) {
                    violations.push({
                        type: 'missing_role',
                        message: 'Task is not assigned to a role defined in the workflow',
                        requiredRoles
                    });
                }
            }

            // Check if assigned person is in the right team (placeholder for team restriction)
            // This is where team-based assignment rules would be enforced

            // Record violations
            violations.forEach(v => {
                const existingViolation = workflowViolations.find(wv =>
                    wv.taskId === taskId &&
                    wv.workflowTemplateId === templateId &&
                    wv.violationType === v.type &&
                    wv.status === 'pending'
                );

                if (!existingViolation) {
                    workflowViolations.push({
                        id: 'violation' + Date.now() + Math.random().toString(36).substr(2, 5),
                        taskId,
                        workflowTemplateId: templateId,
                        violationType: v.type,
                        message: v.message,
                        details: v,
                        status: 'pending',
                        createdBy: getCurrentUserId(),
                        createdAt: new Date().toISOString(),
                        resolvedBy: null,
                        resolvedAt: null,
                        notes: ''
                    });
                }
            });

            saveToLocalStorage();
            return violations;
        }

        // Get pending violations for a task
        function getTaskViolations(taskId) {
            return workflowViolations.filter(v => v.taskId === taskId && v.status === 'pending');
        }

        // Resolve a violation
        function resolveViolation(violationId, resolution, notes = '') {
            const violation = workflowViolations.find(v => v.id === violationId);
            if (!violation) return;

            violation.status = resolution; // 'resolved' or 'exception_granted'
            violation.resolvedBy = getCurrentUserId();
            violation.resolvedAt = new Date().toISOString();
            violation.notes = notes;

            saveToLocalStorage();

            logActivityToXano({
                event_verb: 'Resolve Workflow Violation',
                eo_operator: 'ALT',
                object_type: 'workflow_violation',
                object_id: violationId,
                details: JSON.stringify({ resolution, notes })
            });
        }

        // Get workflow template creator info
        function getWorkflowOwner(templateId) {
            const template = workflowTemplates.find(t => t.id === templateId);
            if (!template) return null;

            // Try to find the person who created it
            const creatorId = template.createdBy;
            if (creatorId) {
                return entities.person.find(p => p.id === creatorId) || { name: 'Unknown', id: creatorId };
            }
            return null;
        }

        // Helper to get current user ID (from Softr context)
        function getCurrentUserId() {
            return window.loggedInUser?.softr_user_id || 'anonymous';
        }

        // ==========================================
        // SAVE/LOAD WORKFLOW DATA
        // ==========================================

        // Extended save to include workflow system data
        function saveWorkflowData() {
            const workspaceId = currentWorkspaceId;
            if (!workspaceId) return;

            try {
                localStorage.setItem(`workflowTemplates_${workspaceId}`, JSON.stringify(workflowTemplates));
                localStorage.setItem(`workflowInstances_${workspaceId}`, JSON.stringify(workflowInstances));
                localStorage.setItem(`workflowViolations_${workspaceId}`, JSON.stringify(workflowViolations));
                localStorage.setItem(`taskLinks_${workspaceId}`, JSON.stringify(taskLinks));
            } catch (e) {
                console.error('Error saving workflow data:', e);
            }
        }

        // Extended load to include workflow system data
        function loadWorkflowData() {
            const workspaceId = currentWorkspaceId;
            if (!workspaceId) return;

            try {
                workflowTemplates = JSON.parse(localStorage.getItem(`workflowTemplates_${workspaceId}`)) || [];
                workflowInstances = JSON.parse(localStorage.getItem(`workflowInstances_${workspaceId}`)) || [];
                workflowViolations = JSON.parse(localStorage.getItem(`workflowViolations_${workspaceId}`)) || [];
                taskLinks = JSON.parse(localStorage.getItem(`taskLinks_${workspaceId}`)) || [];
            } catch (e) {
                console.error('Error loading workflow data:', e);
                workflowTemplates = [];
                workflowInstances = [];
                workflowViolations = [];
                taskLinks = [];
            }
        }

        // ==========================================
        // TASK LINK MODAL FUNCTIONS
        // ==========================================

        let currentLinkSourceTaskId = null;

        // Open task link modal
        function openTaskLinkModal(sourceTaskId) {
            currentLinkSourceTaskId = sourceTaskId;
            const sourceTask = entities.task.find(t => t.id === sourceTaskId);
            if (!sourceTask) return;

            // Populate target task select
            const select = document.getElementById('taskLinkTargetSelect');
            select.innerHTML = '<option value="">Select a task...</option>';

            // Get tasks that aren't already linked to this one
            const existingLinks = getTaskLinks(sourceTaskId);
            const linkedIds = new Set(existingLinks.map(l =>
                l.sourceTaskId === sourceTaskId ? l.targetTaskId : l.sourceTaskId
            ));

            entities.task
                .filter(t => t.id !== sourceTaskId && !linkedIds.has(t.id))
                .forEach(task => {
                    const option = document.createElement('option');
                    option.value = task.id;
                    option.textContent = task.name;
                    select.appendChild(option);
                });

            // Reset form
            document.getElementById('linkTypeSoft').checked = true;
            updateLinkTypeSelection('soft');

            // Show modal
            document.getElementById('taskLinkOverlay').classList.add('active');
        }

        // Close task link modal
        function closeTaskLinkModal() {
            document.getElementById('taskLinkOverlay').classList.remove('active');
            currentLinkSourceTaskId = null;
        }

        // Select link type (soft or hard)
        function selectLinkType(type) {
            document.getElementById('linkTypeSoft').checked = (type === 'soft');
            document.getElementById('linkTypeHard').checked = (type === 'hard');
            updateLinkTypeSelection(type);
        }

        function updateLinkTypeSelection(type) {
            document.querySelectorAll('.task-link-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            const selectedRadio = document.querySelector(`input[name="linkType"][value="${type}"]`);
            if (selectedRadio) {
                selectedRadio.closest('.task-link-option').classList.add('selected');
            }
        }

        // Submit task link
        function submitTaskLink() {
            const targetTaskId = document.getElementById('taskLinkTargetSelect').value;
            if (!targetTaskId || !currentLinkSourceTaskId) {
                showToast('Please select a task to link to', 'error');
                return;
            }

            const linkType = document.querySelector('input[name="linkType"]:checked').value;

            const link = addTaskLink(currentLinkSourceTaskId, targetTaskId, linkType, 'blocked_by');

            if (link) {
                showToast('Tasks linked successfully!', 'success');
                closeTaskLinkModal();

                // Refresh task modal if open
                if (currentModalEntity && currentModalEntityType === 'task') {
                    openEntityModal(currentModalEntity.id, 'task');
                }

                // Refresh views
                if (currentView === 'tasks') {
                    renderTaskBoardView();
                }
            }
        }

        // ==========================================
        // TOAST NOTIFICATION SYSTEM
        // ==========================================

        function showToast(message, type = 'info') {
            const toast = document.getElementById('toastNotification');
            if (!toast) return;

            // Set content and type
            const iconMap = {
                success: 'ph-check-circle',
                error: 'ph-x-circle',
                info: 'ph-info'
            };

            toast.innerHTML = `
                <i class="ph ${iconMap[type] || iconMap.info}"></i>
                <span>${message}</span>
            `;

            // Set type class
            toast.className = 'toast-notification show';
            if (type === 'success') toast.classList.add('success');
            else if (type === 'error') toast.classList.add('error');

            // Auto-hide after 2.5 seconds
            clearTimeout(toast._hideTimeout);
            toast._hideTimeout = setTimeout(() => {
                toast.classList.remove('show');
            }, 2500);
        }

        // ==========================================
        // HELPER: Render current view
        // ==========================================

        function renderCurrentView() {
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card' || currentView === 'cards') {
                renderCardView();
            } else if (currentView === 'venn') {
                renderVennView();
            } else if (currentView === 'orgchart') {
                renderOrgChartView();
            } else if (currentView === 'tasks') {
                renderTaskBoardView();
            } else if (currentView === 'flow') {
                renderFlowView();
            } else if (currentView === 'shape') {
                renderShapeView();
            } else if (currentView === 'kanban') {
                renderKanbanBoard();
            } else if (currentView === 'table') {
                renderTaskTable();
            } else if (currentView === 'timeline') {
                renderTimeline();
            } else if (currentView === 'gantt') {
                renderGanttView();
            } else if (currentView === 'calendar') {
                renderCalendarView();
            }
        }

        let selectedEntityType = 'role';
        let selectedPredicate = 'DES'; // Default to Define operator
        let focusedNode = null;
        let currentView = 'kanban';

        // ==========================================
        // UNDO HISTORY & RECYCLE BIN
        // ==========================================

        // Undo history stack - stores all changes for undo functionality
        // Each entry: { type: 'create'|'update'|'delete', entityType, data, timestamp, description }
        let undoHistory = [];
        let redoHistory = []; // Redo history stack - stores undone actions for redo
        const MAX_UNDO_HISTORY = 100; // Maximum number of undo steps to keep

        // Recycle bin - stores deleted entities and relationships
        // Each entry: { item, itemType: 'entity'|'relationship', entityType, deletedAt, deletedRelationships }
        let recycleBin = [];

        // Mobile detection helper
        function isMobile() {
            return window.innerWidth <= 640;
        }

        // Graph visualization variables
        let width = 800;
        let height = 600;
        let graphSimulation, graphLink, graphNode, graphLinkText;

        // Venn diagram state
        let vennCurrentLevel = 0; // 0: units, 1: teams, 2: roles, 3: people
        const vennLevels = ['unit', 'team', 'role', 'person'];
        const vennLevelLabels = ['Units', 'Teams', 'Roles', 'People'];
        let vennFocusedEntity = null; // When drilling down into a specific entity
        let vennBreadcrumb = []; // Track navigation path

        // View switching
        function switchView(view) {
            currentView = view;

            // Update both old view-toggle-btn and new view-tab classes
            document.querySelectorAll('.view-toggle-btn, .view-tab').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.view === view) {
                    btn.classList.add('active');
                }
            });

            // Hide all views
            document.getElementById('treeView').classList.remove('active');
            document.getElementById('cardView').classList.remove('active');
            document.getElementById('graphView').classList.remove('active');
            document.getElementById('vennView').classList.remove('active');
            document.getElementById('orgchartView').classList.remove('active');
            document.getElementById('taskBoardView').classList.remove('active');
            document.getElementById('flowView').classList.remove('active');
            document.getElementById('shapeView').classList.remove('active');
            document.getElementById('ganttView').classList.remove('active');
            document.getElementById('calendarView').classList.remove('active');

            if (view === 'tree') {
                document.getElementById('treeView').classList.add('active');
                renderTreeView();
            } else if (view === 'card' || view === 'cards') {
                document.getElementById('cardView').classList.add('active');
                renderCardView();
            } else if (view === 'venn') {
                document.getElementById('vennView').classList.add('active');
                setTimeout(() => renderVennView(), 100);
            } else if (view === 'orgchart') {
                document.getElementById('orgchartView').classList.add('active');
                renderOrgChartView();
            } else if (view === 'tasks') {
                document.getElementById('taskBoardView').classList.add('active');
                renderTaskBoardView();
            } else if (view === 'kanban') {
                document.getElementById('taskBoardView').classList.add('active');
                renderKanbanBoard();
            } else if (view === 'table') {
                document.getElementById('taskBoardView').classList.add('active');
                renderTaskTable();
            } else if (view === 'timeline') {
                document.getElementById('taskBoardView').classList.add('active');
                renderTimeline();
            } else if (view === 'flow') {
                document.getElementById('flowView').classList.add('active');
                renderFlowView();
            } else if (view === 'shape') {
                document.getElementById('shapeView').classList.add('active');
                renderShapeView();
            } else if (view === 'gantt') {
                document.getElementById('ganttView').classList.add('active');
                renderGanttView();
            } else if (view === 'calendar') {
                document.getElementById('calendarView').classList.add('active');
                renderCalendarView();
            } else {
                document.getElementById('graphView').classList.add('active');
                setTimeout(() => updateGraph(), 100);
            }

        }

        // More views dropdown toggle
        function toggleMoreViews(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('viewToggleDropdown');
            dropdown.classList.toggle('open');
        }

        function closeMoreViews() {
            const dropdown = document.getElementById('viewToggleDropdown');
            if (dropdown) dropdown.classList.remove('open');
        }

        // View filter state
        let viewFilters = {
            role: true,
            person: true,
            team: true,
            unit: true
        };

        function toggleViewFilter(event) {
            event.stopPropagation();
            const menu = document.getElementById('viewFilterMenu');
            menu.classList.toggle('open');
        }

        function closeViewFilter() {
            const menu = document.getElementById('viewFilterMenu');
            if (menu) menu.classList.remove('open');
        }

        function applyViewFilters() {
            viewFilters.role = document.getElementById('viewFilterRole').checked;
            viewFilters.person = document.getElementById('viewFilterPerson').checked;
            viewFilters.team = document.getElementById('viewFilterTeam').checked;
            viewFilters.unit = document.getElementById('viewFilterUnit').checked;

            // Update badge visibility
            const badge = document.getElementById('viewFilterBadge');
            const allChecked = viewFilters.role && viewFilters.person && viewFilters.team && viewFilters.unit;
            badge.style.display = allChecked ? 'none' : 'block';

            // Re-render current view with filters
            if (currentView === 'kanban') {
                renderKanbanBoard();
            } else if (currentView === 'table') {
                renderTaskTable();
            } else if (currentView === 'timeline') {
                renderTimeline();
            } else if (currentView === 'gantt') {
                renderGanttView();
            } else if (currentView === 'calendar') {
                renderCalendarView();
            }
        }

        function selectAllViewFilters() {
            document.getElementById('viewFilterRole').checked = true;
            document.getElementById('viewFilterPerson').checked = true;
            document.getElementById('viewFilterTeam').checked = true;
            document.getElementById('viewFilterUnit').checked = true;
            applyViewFilters();
        }

        function clearViewFilters() {
            document.getElementById('viewFilterRole').checked = false;
            document.getElementById('viewFilterPerson').checked = false;
            document.getElementById('viewFilterTeam').checked = false;
            document.getElementById('viewFilterUnit').checked = false;
            applyViewFilters();
        }

        function getFilteredTasks() {
            let filteredTasks = [...(entities.task || [])];

            // If all filters are enabled, return all tasks
            if (viewFilters.role && viewFilters.person && viewFilters.team && viewFilters.unit) {
                return filteredTasks;
            }

            // Filter tasks based on their assignments
            return filteredTasks.filter(task => {
                // Get task's role assignment
                const taskRoleRel = relationships.find(r => r.object === task.id && r.predicate === 'CON' && r.subject.startsWith('r'));
                const taskRole = taskRoleRel ? (entities.role || []).find(e => e.id === taskRoleRel.subject) : null;

                // Get person assigned to role
                const personRel = taskRole ? relationships.find(r => r.object === taskRole.id && r.predicate === 'INS' && r.subject.startsWith('p')) : null;
                const person = personRel ? (entities.person || []).find(e => e.id === personRel.subject) : null;

                // Get team containing role
                const teamRel = taskRole ? relationships.find(r => r.object === taskRole.id && r.predicate === 'DES' && r.subject.startsWith('t')) : null;
                const team = teamRel ? (entities.team || []).find(e => e.id === teamRel.subject) : null;

                // Get unit containing team
                const unitRel = team ? relationships.find(r => r.object === team.id && r.predicate === 'DES' && r.subject.startsWith('u')) : null;
                const unit = unitRel ? (entities.unit || []).find(e => e.id === unitRel.subject) : null;

                // Check filter criteria
                if (viewFilters.role && taskRole) return true;
                if (viewFilters.person && person) return true;
                if (viewFilters.team && team) return true;
                if (viewFilters.unit && unit) return true;

                // If no filters match but task has no assignments, show it
                if (!taskRole && !person && !team && !unit) return true;

                return false;
            });
        }

        // ==========================================
        // ADVANCED FILTERING SYSTEM
        // ==========================================

        // Advanced filter state
        let advancedFilters = {
            status: ['pending', 'in_progress', 'completed'],
            priority: ['high', 'medium', 'low'],
            dateFrom: null,
            dateTo: null,
            datePreset: null,
            assignees: [], // Array of person IDs
            entities: ['unit', 'team', 'role', 'person'],
            tags: []
        };

        // Time travel state
        let timeTravelState = {
            active: false,
            targetDate: null,
            activities: [],
            originalEntities: null,
            originalRelationships: null,
            activityTimestamps: []
        };

        function openAdvancedFilterPanel() {
            document.getElementById('advancedFilterPanel').classList.add('open');
            document.getElementById('filterPanelOverlay').classList.add('open');
            populateAssigneeList();
            populateTagsFilter();
            updateFilterActiveCount();
        }

        function closeAdvancedFilterPanel() {
            document.getElementById('advancedFilterPanel').classList.remove('open');
            document.getElementById('filterPanelOverlay').classList.remove('open');
        }

        function toggleFilterChip(chip) {
            chip.classList.toggle('active');

            const filterType = chip.dataset.filter;
            const filterValue = chip.dataset.value;

            if (filterType === 'status') {
                if (chip.classList.contains('active')) {
                    if (!advancedFilters.status.includes(filterValue)) {
                        advancedFilters.status.push(filterValue);
                    }
                } else {
                    advancedFilters.status = advancedFilters.status.filter(s => s !== filterValue);
                }
            } else if (filterType === 'priority') {
                if (chip.classList.contains('active')) {
                    if (!advancedFilters.priority.includes(filterValue)) {
                        advancedFilters.priority.push(filterValue);
                    }
                } else {
                    advancedFilters.priority = advancedFilters.priority.filter(p => p !== filterValue);
                }
            } else if (filterType === 'entity') {
                if (chip.classList.contains('active')) {
                    if (!advancedFilters.entities.includes(filterValue)) {
                        advancedFilters.entities.push(filterValue);
                    }
                } else {
                    advancedFilters.entities = advancedFilters.entities.filter(e => e !== filterValue);
                }
                // Sync with legacy viewFilters
                viewFilters[filterValue] = chip.classList.contains('active');
            } else if (filterType === 'tag') {
                if (chip.classList.contains('active')) {
                    if (!advancedFilters.tags.includes(filterValue)) {
                        advancedFilters.tags.push(filterValue);
                    }
                } else {
                    advancedFilters.tags = advancedFilters.tags.filter(t => t !== filterValue);
                }
            }

            updateFilterActiveCount();
            updateInlineFilterUI();
            applyAdvancedFilters();
        }

        // Inline status filter toggle (syncs with advanced filters)
        function toggleInlineStatusFilter(status) {
            const btn = document.querySelector(`.inline-filter-btn[data-status="${status}"]`);
            if (!btn) return;

            btn.classList.toggle('active');
            const isActive = btn.classList.contains('active');

            // Update advancedFilters
            if (isActive) {
                if (!advancedFilters.status.includes(status)) {
                    advancedFilters.status.push(status);
                }
            } else {
                advancedFilters.status = advancedFilters.status.filter(s => s !== status);
            }

            // Sync with advanced filter panel chips
            const panelChip = document.querySelector(`.filter-chip[data-filter="status"][data-value="${status}"]`);
            if (panelChip) {
                if (isActive) {
                    panelChip.classList.add('active');
                } else {
                    panelChip.classList.remove('active');
                }
            }

            updateFilterActiveCount();
            updateInlineFilterUI();
            applyAdvancedFilters();
        }

        // Update inline filter buttons to match advancedFilters state
        function updateInlineFilterUI() {
            // Update status buttons
            ['pending', 'in_progress', 'completed'].forEach(status => {
                const btn = document.querySelector(`.inline-filter-btn[data-status="${status}"]`);
                if (btn) {
                    if (advancedFilters.status.includes(status)) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });

            // Count non-status active filters for badge
            let additionalFilters = 0;
            if (advancedFilters.priority.length < 3) additionalFilters++;
            if (advancedFilters.dateFrom || advancedFilters.dateTo || advancedFilters.datePreset) additionalFilters++;
            if (advancedFilters.assignees.length > 0) additionalFilters++;
            if (advancedFilters.tags.length > 0) additionalFilters++;

            const badge = document.getElementById('inlineFilterBadge');
            const moreBtn = document.getElementById('inlineFilterMoreBtn');
            if (badge && moreBtn) {
                if (additionalFilters > 0) {
                    badge.textContent = additionalFilters;
                    badge.style.display = 'inline';
                    moreBtn.classList.add('has-filters');
                } else {
                    badge.style.display = 'none';
                    moreBtn.classList.remove('has-filters');
                }
            }
        }

        // Get count of active non-status filters for badges
        function getActiveAdvancedFilterCount() {
            let count = 0;
            if (advancedFilters.priority.length < 3) count++;
            if (advancedFilters.dateFrom || advancedFilters.dateTo || advancedFilters.datePreset) count++;
            if (advancedFilters.assignees.length > 0) count++;
            if (advancedFilters.tags.length > 0) count++;
            return count;
        }

        function setDatePreset(preset) {
            // Clear all preset active states
            document.querySelectorAll('.filter-date-preset').forEach(btn => btn.classList.remove('active'));

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let fromDate = null;
            let toDate = null;

            switch (preset) {
                case 'overdue':
                    toDate = new Date(today);
                    toDate.setDate(toDate.getDate() - 1);
                    advancedFilters.datePreset = 'overdue';
                    break;
                case 'today':
                    fromDate = today;
                    toDate = today;
                    advancedFilters.datePreset = 'today';
                    break;
                case 'week':
                    fromDate = today;
                    toDate = new Date(today);
                    toDate.setDate(toDate.getDate() + 7);
                    advancedFilters.datePreset = 'week';
                    break;
                case 'month':
                    fromDate = today;
                    toDate = new Date(today);
                    toDate.setMonth(toDate.getMonth() + 1);
                    advancedFilters.datePreset = 'month';
                    break;
                case 'nodate':
                    advancedFilters.datePreset = 'nodate';
                    break;
                default:
                    advancedFilters.datePreset = null;
            }

            advancedFilters.dateFrom = fromDate;
            advancedFilters.dateTo = toDate;

            // Update input fields
            document.getElementById('filterDateFrom').value = fromDate ? formatDateForInput(fromDate) : '';
            document.getElementById('filterDateTo').value = toDate ? formatDateForInput(toDate) : '';

            // Mark the selected preset as active
            const selectedBtn = document.querySelector(`.filter-date-preset[data-preset="${preset}"]`);
            if (selectedBtn) selectedBtn.classList.add('active');

            updateFilterActiveCount();
            applyAdvancedFilters();
        }

        function formatDateForInput(date) {
            return date.toISOString().split('T')[0];
        }

        function populateAssigneeList() {
            const container = document.getElementById('filterAssigneeList');
            const people = entities.person || [];

            if (people.length === 0) {
                container.innerHTML = '<div style="padding: 0.75rem; color: #8B6F47; font-size: 0.8rem;">No people found</div>';
                return;
            }

            container.innerHTML = people.map(person => `
                <label class="filter-assignee-item ${advancedFilters.assignees.includes(person.id) ? 'selected' : ''}">
                    <input type="checkbox"
                           ${advancedFilters.assignees.includes(person.id) ? 'checked' : ''}
                           onchange="toggleAssigneeFilter('${person.id}')">
                    <i class="ph ph-user" style="color: #8B6F47;"></i>
                    <span>${person.name}</span>
                </label>
            `).join('');
        }

        function toggleAssigneeFilter(personId) {
            const idx = advancedFilters.assignees.indexOf(personId);
            if (idx === -1) {
                advancedFilters.assignees.push(personId);
            } else {
                advancedFilters.assignees.splice(idx, 1);
            }
            populateAssigneeList();
            updateFilterActiveCount();
            applyAdvancedFilters();
        }

        function filterAssigneeList() {
            const searchTerm = document.getElementById('filterAssigneeSearch').value.toLowerCase();
            const items = document.querySelectorAll('.filter-assignee-item');

            items.forEach(item => {
                const name = item.querySelector('span').textContent.toLowerCase();
                item.style.display = name.includes(searchTerm) ? 'flex' : 'none';
            });
        }

        function populateTagsFilter() {
            const container = document.getElementById('filterTagsChips');

            // Collect all unique tags from tasks
            const allTags = new Set();
            (entities.task || []).forEach(task => {
                if (task.tags && Array.isArray(task.tags)) {
                    task.tags.forEach(tag => allTags.add(tag));
                }
            });

            if (allTags.size === 0) {
                container.innerHTML = '<div style="color: #8B6F47; font-size: 0.8rem;">No tags found</div>';
                return;
            }

            container.innerHTML = Array.from(allTags).map(tag => `
                <div class="filter-chip ${advancedFilters.tags.includes(tag) ? 'active' : ''}"
                     data-filter="tag" data-value="${tag}" onclick="toggleFilterChip(this)">
                    <i class="ph ph-tag"></i> ${tag}
                </div>
            `).join('');
        }

        function updateFilterActiveCount() {
            let count = 0;

            // Count non-default filters
            if (advancedFilters.status.length < 3) count++;
            if (advancedFilters.priority.length < 3) count++;
            if (advancedFilters.dateFrom || advancedFilters.dateTo || advancedFilters.datePreset) count++;
            if (advancedFilters.assignees.length > 0) count++;
            if (advancedFilters.entities.length < 4) count++;
            if (advancedFilters.tags.length > 0) count++;

            const badge = document.getElementById('filterActiveCount');
            const viewBadge = document.getElementById('viewFilterBadge');

            if (count > 0) {
                badge.textContent = count;
                badge.style.display = 'inline';
                if (viewBadge) viewBadge.style.display = 'block';
            } else {
                badge.style.display = 'none';
                if (viewBadge) viewBadge.style.display = 'none';
            }
        }

        function clearAllFilters() {
            // Reset to defaults
            advancedFilters = {
                status: ['pending', 'in_progress', 'completed'],
                priority: ['high', 'medium', 'low'],
                dateFrom: null,
                dateTo: null,
                datePreset: null,
                assignees: [],
                entities: ['unit', 'team', 'role', 'person'],
                tags: []
            };

            // Reset UI
            document.querySelectorAll('.filter-chip').forEach(chip => {
                const filterType = chip.dataset.filter;
                if (filterType === 'tag') {
                    chip.classList.remove('active');
                } else {
                    chip.classList.add('active');
                }
            });

            document.querySelectorAll('.filter-date-preset').forEach(btn => btn.classList.remove('active'));
            document.getElementById('filterDateFrom').value = '';
            document.getElementById('filterDateTo').value = '';

            // Sync with legacy
            viewFilters = { role: true, person: true, team: true, unit: true };

            populateAssigneeList();
            updateFilterActiveCount();
            updateInlineFilterUI();
            applyAdvancedFilters();
        }

        function applyAdvancedFilters() {
            // Update date filters from inputs
            const dateFrom = document.getElementById('filterDateFrom').value;
            const dateTo = document.getElementById('filterDateTo').value;

            if (dateFrom) advancedFilters.dateFrom = new Date(dateFrom);
            if (dateTo) advancedFilters.dateTo = new Date(dateTo);

            // Update inline filter UI to stay in sync
            updateInlineFilterUI();

            // Re-render current view with filters
            if (currentView === 'kanban') {
                renderKanbanBoard();
            } else if (currentView === 'table') {
                renderTaskTable();
            } else if (currentView === 'timeline') {
                renderTimeline();
            } else if (currentView === 'gantt') {
                renderGanttView();
            } else if (currentView === 'calendar') {
                renderCalendarView();
            }

            // Also update sidebar entity list
            renderEntityList();
            renderPeopleList();
        }

        // Enhanced getFilteredTasks with advanced filters
        function getAdvancedFilteredTasks() {
            let tasks = [...(entities.task || [])];

            // Filter by status
            if (advancedFilters.status.length < 3) {
                tasks = tasks.filter(task => {
                    const status = task.status || 'pending';
                    return advancedFilters.status.includes(status);
                });
            }

            // Filter by priority
            if (advancedFilters.priority.length < 3) {
                tasks = tasks.filter(task => {
                    const priority = task.priority || 'medium';
                    return advancedFilters.priority.includes(priority);
                });
            }

            // Filter by due date
            if (advancedFilters.datePreset === 'nodate') {
                tasks = tasks.filter(task => !task.dueDate);
            } else if (advancedFilters.datePreset === 'overdue') {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                tasks = tasks.filter(task => {
                    if (!task.dueDate) return false;
                    const dueDate = new Date(task.dueDate);
                    return dueDate < today && task.status !== 'completed';
                });
            } else if (advancedFilters.dateFrom || advancedFilters.dateTo) {
                tasks = tasks.filter(task => {
                    if (!task.dueDate) return false;
                    const dueDate = new Date(task.dueDate);

                    if (advancedFilters.dateFrom && dueDate < advancedFilters.dateFrom) return false;
                    if (advancedFilters.dateTo) {
                        const toDate = new Date(advancedFilters.dateTo);
                        toDate.setHours(23, 59, 59, 999);
                        if (dueDate > toDate) return false;
                    }

                    return true;
                });
            }

            // Filter by assignees
            if (advancedFilters.assignees.length > 0) {
                tasks = tasks.filter(task => {
                    // Find role assigned to task
                    const taskRoleRel = relationships.find(r =>
                        r.object === task.id && r.predicate === 'CON' && r.subject.startsWith('r')
                    );
                    if (!taskRoleRel) return false;

                    // Find person in that role
                    const personRel = relationships.find(r =>
                        r.object === taskRoleRel.subject && r.predicate === 'INS' && r.subject.startsWith('p')
                    );
                    if (!personRel) return false;

                    return advancedFilters.assignees.includes(personRel.subject);
                });
            }

            // Filter by tags
            if (advancedFilters.tags.length > 0) {
                tasks = tasks.filter(task => {
                    if (!task.tags || !Array.isArray(task.tags)) return false;
                    return advancedFilters.tags.some(tag => task.tags.includes(tag));
                });
            }

            return tasks;
        }

        // ==========================================
        // TIME TRAVEL SYSTEM
        // ==========================================

        async function activateTimeTravel() {
            const dateInput = document.getElementById('timeTravelDateInput');
            if (!dateInput.value) {
                showActivityToast('warning', 'Select Date', 'Please select a date to travel to');
                return;
            }

            const targetDate = new Date(dateInput.value);

            // Store current state for restoration
            timeTravelState.originalEntities = JSON.parse(JSON.stringify(entities));
            timeTravelState.originalRelationships = JSON.parse(JSON.stringify(relationships));

            // Show loading
            const loadingStatus = document.getElementById('loadingStatus');
            if (loadingStatus) {
                loadingStatus.style.display = 'block';
                loadingStatus.innerHTML = '<i class="ph ph-spinner"></i> Loading historical data...';
            }

            try {
                // Fetch all activities from Xano
                const activities = await getActivitiesFromXano();

                if (!activities || activities.length === 0) {
                    showActivityToast('warning', 'No History', 'No historical data available');
                    if (loadingStatus) loadingStatus.style.display = 'none';
                    return;
                }

                timeTravelState.activities = activities;
                timeTravelState.targetDate = targetDate;
                timeTravelState.active = true;

                // Build list of unique timestamps for the slider
                const timestamps = [...new Set(activities.map(a => new Date(a.created_at).getTime()))].sort((a, b) => a - b);
                timeTravelState.activityTimestamps = timestamps;

                // Reconstruct state at target date
                reconstructStateAtDate(targetDate);

                // Update UI
                updateTimeTravelUI();
                closeAdvancedFilterPanel();

                showActivityToast('info', 'Time Travel Active', `Viewing state as of ${formatTimeTravelDate(targetDate)}`);

            } catch (error) {
                console.error('Time travel error:', error);
                showActivityToast('error', 'Error', 'Failed to load historical data');
            }

            if (loadingStatus) loadingStatus.style.display = 'none';
        }

        function reconstructStateAtDate(targetDate) {
            const activities = timeTravelState.activities;

            // Filter activities up to the target date
            const relevantActivities = activities.filter(a => {
                const activityDate = new Date(a.created_at);
                return activityDate <= targetDate;
            });

            // Use the existing reconstruction function
            const reconstructed = reconstructEntitiesFromActivities(relevantActivities);

            // Apply reconstructed state
            entities = reconstructed.entities;
            relationships = reconstructed.relationships;

            // Re-render all views
            renderEntityList();
            renderPeopleList();
            renderCurrentView();
        }

        function updateTimeTravelUI() {
            const bar = document.getElementById('timeTravelBar');
            const indicator = document.getElementById('timeTravelIndicator');
            const timeTravelBtn = document.getElementById('timeTravelBtn');
            const mainContainer = document.getElementById('mainContainer');

            if (timeTravelState.active) {
                bar.classList.add('active');
                indicator.classList.add('active');
                if (timeTravelBtn) timeTravelBtn.style.color = '#FFD93D';
                if (mainContainer) mainContainer.classList.add('time-travel-active');

                // Update date displays
                const dateText = formatTimeTravelDate(timeTravelState.targetDate);
                document.getElementById('timeTravelDateText').textContent = dateText;
                document.getElementById('timeTravelIndicatorDate').textContent = dateText;

                // Update slider
                updateTimeTravelSlider();
            } else {
                bar.classList.remove('active');
                indicator.classList.remove('active');
                if (timeTravelBtn) timeTravelBtn.style.color = '';
                if (mainContainer) mainContainer.classList.remove('time-travel-active');
            }
        }

        function updateTimeTravelSlider() {
            const slider = document.getElementById('timeTravelSlider');
            const timestamps = timeTravelState.activityTimestamps;

            if (timestamps.length < 2) return;

            const minTime = timestamps[0];
            const maxTime = timestamps[timestamps.length - 1];
            const currentTime = timeTravelState.targetDate.getTime();

            // Calculate slider position
            const position = ((currentTime - minTime) / (maxTime - minTime)) * 100;
            slider.value = Math.max(0, Math.min(100, position));

            // Update labels
            document.getElementById('timeTravelStartLabel').textContent = formatShortDate(new Date(minTime));
            document.getElementById('timeTravelEndLabel').textContent = 'Now';
        }

        function onTimeTravelSliderChange() {
            const slider = document.getElementById('timeTravelSlider');
            const timestamps = timeTravelState.activityTimestamps;

            if (timestamps.length < 2) return;

            const minTime = timestamps[0];
            const maxTime = timestamps[timestamps.length - 1];
            const position = slider.value / 100;

            const targetTime = minTime + (maxTime - minTime) * position;
            const targetDate = new Date(targetTime);

            timeTravelState.targetDate = targetDate;
            reconstructStateAtDate(targetDate);

            // Update date displays
            const dateText = formatTimeTravelDate(targetDate);
            document.getElementById('timeTravelDateText').textContent = dateText;
            document.getElementById('timeTravelIndicatorDate').textContent = dateText;
        }

        function stepTimeTravel(direction) {
            const timestamps = timeTravelState.activityTimestamps;
            if (timestamps.length === 0) return;

            const currentTime = timeTravelState.targetDate.getTime();
            let newTime;

            if (direction < 0) {
                // Find previous timestamp
                const prevTimestamps = timestamps.filter(t => t < currentTime);
                if (prevTimestamps.length === 0) return;
                newTime = prevTimestamps[prevTimestamps.length - 1];
            } else {
                // Find next timestamp
                const nextTimestamps = timestamps.filter(t => t > currentTime);
                if (nextTimestamps.length === 0) return;
                newTime = nextTimestamps[0];
            }

            timeTravelState.targetDate = new Date(newTime);
            reconstructStateAtDate(timeTravelState.targetDate);
            updateTimeTravelUI();
        }

        function openTimeTravelDatePicker() {
            // Create a temporary date input for the picker
            const input = document.createElement('input');
            input.type = 'datetime-local';
            input.style.position = 'absolute';
            input.style.opacity = '0';
            input.value = timeTravelState.targetDate ?
                timeTravelState.targetDate.toISOString().slice(0, 16) :
                new Date().toISOString().slice(0, 16);

            document.body.appendChild(input);

            input.addEventListener('change', () => {
                if (input.value) {
                    timeTravelState.targetDate = new Date(input.value);
                    reconstructStateAtDate(timeTravelState.targetDate);
                    updateTimeTravelUI();
                }
                document.body.removeChild(input);
            });

            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (document.body.contains(input)) {
                        document.body.removeChild(input);
                    }
                }, 100);
            });

            input.click();
        }

        function exitTimeTravel() {
            if (!timeTravelState.active) return;

            // Restore original state
            if (timeTravelState.originalEntities) {
                entities = timeTravelState.originalEntities;
            }
            if (timeTravelState.originalRelationships) {
                relationships = timeTravelState.originalRelationships;
            }

            // Reset time travel state
            timeTravelState = {
                active: false,
                targetDate: null,
                activities: [],
                originalEntities: null,
                originalRelationships: null,
                activityTimestamps: []
            };

            // Update UI
            updateTimeTravelUI();

            // Re-render all views
            renderEntityList();
            renderPeopleList();
            renderCurrentView();

            showActivityToast('info', 'Returned to Present', 'Now viewing current data');
        }

        function formatTimeTravelDate(date) {
            return date.toLocaleDateString('en-US', {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function formatShortDate(date) {
            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.view-toggle-more')) {
                closeMoreViews();
            }
            if (!e.target.closest('.header-more-menu')) {
                closeHeaderMenu();
            }
            if (!e.target.closest('.header-actions-menu')) {
                closeActionsMenu();
            }
            if (!e.target.closest('.view-filter-dropdown')) {
                closeViewFilter();
            }
        });

        // Header menu dropdown toggle
        function toggleHeaderMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('headerDropdown');
            dropdown.classList.toggle('open');
        }

        function closeHeaderMenu() {
            const dropdown = document.getElementById('headerDropdown');
            dropdown.classList.remove('open');
        }

        // Actions Menu (new consolidated menu)
        function toggleActionsMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('actionsDropdown');
            dropdown.classList.toggle('open');
            // Update auto-refresh menu text
            updateAutoRefreshMenuText();
        }

        function closeActionsMenu() {
            const dropdown = document.getElementById('actionsDropdown');
            if (dropdown) dropdown.classList.remove('open');
        }

        function updateAutoRefreshMenuText() {
            const menuText = document.getElementById('autoRefreshMenuText');
            if (menuText) {
                const isActive = autoRefreshInterval !== null;
                menuText.textContent = isActive ? 'Disable Auto-Refresh' : 'Enable Auto-Refresh';
            }
        }

        // Command Palette (Cmd+K)
        let commandPaletteSelectedIndex = 0;

        function openCommandPalette() {
            document.getElementById('commandPalette').classList.add('open');
            const input = document.getElementById('commandPaletteInput');
            input.value = '';
            input.focus();
            filterCommandPaletteItems();
            commandPaletteSelectedIndex = 0;
            updateCommandPaletteSelection();
        }

        function closeCommandPalette() {
            document.getElementById('commandPalette').classList.remove('open');
        }

        function filterCommandPaletteItems() {
            const query = document.getElementById('commandPaletteInput').value.toLowerCase();
            const items = document.querySelectorAll('.command-palette-item');
            let visibleCount = 0;

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                const matches = query === '' || text.includes(query);
                item.classList.toggle('hidden', !matches);
                if (matches) visibleCount++;
            });

            // Reset selection
            commandPaletteSelectedIndex = 0;
            updateCommandPaletteSelection();
        }

        function updateCommandPaletteSelection() {
            const items = document.querySelectorAll('.command-palette-item:not(.hidden)');
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === commandPaletteSelectedIndex);
            });
        }

        function executeCommand(action) {
            closeCommandPalette();

            switch(action) {
                case 'create-task':
                    openHeroTaskModal();
                    break;
                case 'create-role':
                    // Simple inline creation
                    const roleName = prompt('Enter role name:');
                    if (roleName && roleName.trim()) {
                        createEntity('role', roleName.trim());
                    }
                    break;
                case 'create-person':
                    const personName = prompt('Enter person name:');
                    if (personName && personName.trim()) {
                        createEntity('person', personName.trim());
                    }
                    break;
                case 'view-work':
                    switchView('tasks');
                    break;
                case 'view-flow':
                    switchView('flow');
                    break;
                case 'view-shape':
                    switchView('shape');
                    break;
                case 'view-graph':
                    switchView('graph');
                    break;
                case 'export':
                    exportData();
                    break;
                case 'import':
                    importData();
                    break;
                case 'restore':
                    restoreFromXano();
                    break;
            }
        }

        // Helper to create entity
        function createEntity(type, name) {
            const id = generateId(type);
            const entity = { id, name, type, description: '' };

            if (!entities[type]) entities[type] = [];
            entities[type].push(entity);

            saveToLocalStorage();
            refreshAllViews();
            addToHistory({
                type: 'create',
                entityType: type,
                entityId: id,
                description: `Create ${type}: ${name}`
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ignore if user is typing in an input/textarea
            const isTyping = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable;

            // Cmd+K or Ctrl+K - Command palette
            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                e.preventDefault();
                openCommandPalette();
                return;
            }

            // Handle command palette navigation
            if (document.getElementById('commandPalette').classList.contains('open')) {
                const items = document.querySelectorAll('.command-palette-item:not(.hidden)');

                if (e.key === 'Escape') {
                    closeCommandPalette();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    commandPaletteSelectedIndex = Math.min(commandPaletteSelectedIndex + 1, items.length - 1);
                    updateCommandPaletteSelection();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    commandPaletteSelectedIndex = Math.max(commandPaletteSelectedIndex - 1, 0);
                    updateCommandPaletteSelection();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    const selectedItem = items[commandPaletteSelectedIndex];
                    if (selectedItem) {
                        const action = selectedItem.dataset.action;
                        executeCommand(action);
                    }
                }
                return;
            }

            // Skip shortcuts if typing
            if (isTyping) return;

            // Check if any modal is open
            const modalOpen = document.querySelector('.modal-overlay.open, .entity-edit-modal-overlay.open, .delete-confirm-overlay.open');
            if (modalOpen) return;

            // Allow browser shortcuts with modifier keys (like Ctrl+R for refresh)
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            // Global shortcuts (when not typing)
            switch(e.key.toLowerCase()) {
                case 't':
                    e.preventDefault();
                    openHeroTaskModal();
                    break;
                case 'r':
                    e.preventDefault();
                    const roleName = prompt('Enter role name:');
                    if (roleName && roleName.trim()) {
                        createEntity('role', roleName.trim());
                    }
                    break;
                case 'p':
                    e.preventDefault();
                    const personName = prompt('Enter person name:');
                    if (personName && personName.trim()) {
                        createEntity('person', personName.trim());
                    }
                    break;
                case '1':
                    e.preventDefault();
                    switchView('tasks');
                    break;
                case '2':
                    e.preventDefault();
                    switchView('flow');
                    break;
                case '3':
                    e.preventDefault();
                    switchView('shape');
                    break;
                case '4':
                    e.preventDefault();
                    switchView('graph');
                    break;
                case '?':
                    e.preventDefault();
                    showKeyboardShortcuts();
                    break;
                case '/':
                    e.preventDefault();
                    const quickAddInput = document.getElementById('quickAddInput');
                    if (quickAddInput) {
                        quickAddInput.focus();
                        quickAddInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                    break;
            }
        });

        // Show keyboard shortcuts help
        function showKeyboardShortcuts() {
            alert(`Keyboard Shortcuts:

/ - Focus task input
T - Create new task
R - Create new role
P - Create new person

1 - Work view
2 - Flow view
3 - Shape view
4 - Graph view

Cmd/Ctrl + K - Command palette
? - Show this help`);
        }

        // How It Works modal
        function showHowItWorks() {
            document.getElementById('howItWorksOverlay').classList.add('active');
        }

        function closeHowItWorks() {
            document.getElementById('howItWorksOverlay').classList.remove('active');
        }

        // Activity Feed functions
        function toggleActivityFeed() {
            const section = document.getElementById('activityFeedSection');
            section.classList.toggle('collapsed');
        }

        function renderActivityFeed() {
            const list = document.getElementById('activityFeedList');
            const countEl = document.getElementById('activityFeedCount');

            // Get recent history items (last 10)
            const recentActions = undoHistory.slice(-10).reverse();

            if (recentActions.length === 0) {
                list.innerHTML = '<div class="activity-feed-empty"><p>No recent activity</p></div>';
                countEl.textContent = '0';
                return;
            }

            countEl.textContent = recentActions.length;

            let html = '';
            recentActions.forEach(action => {
                const icon = getActivityIcon(action.type);
                const timeAgo = action.timestamp ? formatTimeAgo(action.timestamp) : 'just now';

                html += `
                    <div class="activity-feed-item">
                        <i class="ph ${icon}"></i>
                        <div class="activity-feed-item-content">
                            <div class="activity-feed-item-text">${action.description || 'Action performed'}</div>
                            <div class="activity-feed-item-time">${timeAgo}</div>
                        </div>
                    </div>
                `;
            });

            list.innerHTML = html;
        }

        function getActivityIcon(actionType) {
            const icons = {
                'create': 'ph-plus-circle',
                'delete': 'ph-trash',
                'update': 'ph-pencil-simple',
                'connect': 'ph-link',
                'disconnect': 'ph-link-break',
                'nest': 'ph-tree-structure',
                'unnest': 'ph-arrow-up',
                'assign': 'ph-user-plus',
                'unassign': 'ph-user-minus'
            };
            return icons[actionType] || 'ph-clock-counter-clockwise';
        }

        function formatTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);

            if (seconds < 60) return 'just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return new Date(timestamp).toLocaleDateString();
        }

        // Open task modal - wrapper for Gantt and Calendar views
        function openTaskModal(taskId) {
            showEntityDetails(taskId);
        }

        // Show entity details - helper function to open entity modal without knowing the type
        function showEntityDetails(entityId) {
            // Determine entity type from ID prefix or by searching
            const typeMap = [
                { prefix: 'task', type: 'task' },
                { prefix: 'prod', type: 'product' },
                { prefix: 'workflow', type: 'workflow' },
                { prefix: 'wf', type: 'workflow' },
                { prefix: 'role', type: 'role' },
                { prefix: 'u', type: 'unit' },
                { prefix: 't', type: 'team' },
                { prefix: 'p', type: 'person' },
                { prefix: 'o', type: 'product' } // Legacy: old 'o' prefix objects become products
            ];

            let entityType = null;
            let entity = null;

            // Try to find by prefix
            for (const mapping of typeMap) {
                if (entityId.startsWith(mapping.prefix)) {
                    entity = entities[mapping.type]?.find(e => e.id === entityId);
                    if (entity) {
                        entityType = mapping.type;
                        break;
                    }
                }
            }

            // If not found by prefix, search all types
            if (!entity) {
                for (const type of ['unit', 'team', 'role', 'person', 'task', 'product', 'workflow']) {
                    entity = entities[type]?.find(e => e.id === entityId);
                    if (entity) {
                        entityType = type;
                        break;
                    }
                }
            }

            if (entity && entityType) {
                openEntityModal(entityId, entityType);
            }
        }

        // Entity Modal
        function openEntityModal(entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Store entity data for edit function
            currentModalEntity = entity;
            currentModalEntityType = entityType;

            // Set header content
            document.getElementById('modalEntityIcon').innerHTML = getIcon(entityType);
            document.getElementById('modalEntityName').textContent = entity.name;

            // Reset inline editing state for title
            const titleDisplay = document.getElementById('modalTitleDisplay');
            titleDisplay.style.display = 'flex';
            titleDisplay.style.pointerEvents = 'auto';
            titleDisplay.querySelector('.edit-hint').style.display = '';
            document.getElementById('modalTitleEditForm').classList.remove('active');

            // For roles, show team context in the type badge for disambiguation
            let typeBadgeContent = `${getIcon(entityType)} ${entityType.toUpperCase()}`;
            if (entityType === 'role') {
                const parentTeam = getRoleParentTeam(entityId);
                if (parentTeam) {
                    typeBadgeContent = `${getIcon(entityType)} ROLE in ${getIcon(parentTeam.type)} ${parentTeam.name}`;
                }
            }
            document.getElementById('modalEntityType').innerHTML = typeBadgeContent;

            // Render parent badge in header for entities that can have parents
            renderModalHeaderParent(entityId, entityType);

            // Show edit and delete buttons for entities
            document.getElementById('modalEditButton').style.display = 'inline-flex';
            document.getElementById('modalDeleteButton').style.display = 'inline-flex';

            // Show "View from" button only for entity types that can be grouped by (unit, team, role)
            const canViewFrom = ['unit', 'team', 'role'].includes(entityType);
            document.getElementById('modalViewFromButton').style.display = canViewFrom ? 'inline-flex' : 'none';

            // Display description with inline editing support
            const descriptionEl = document.getElementById('modalDescription');
            const descContent = entity.description && entity.description.trim() ? entity.description : '';
            const descCharCount = descContent.length;

            // Hide description section for tasks (simplified modal has its own)
            if (entityType === 'task') {
                descriptionEl.innerHTML = '';
                descriptionEl.style.display = 'none';
            } else {
                descriptionEl.innerHTML = `
                    <div class="modal-section-title"><i class="ph ph-text-align-left"></i> Description</div>
                    <div class="modal-description-display ${descContent ? 'modal-description-text' : 'modal-description-empty'}"
                         id="modalDescriptionDisplay" onclick="startInlineDescEdit()">
                        ${descContent || 'No description yet. Click to add one.'}
                        <span class="edit-hint-desc"><i class="ph ph-pencil-simple"></i> edit</span>
                    </div>
                    <div class="modal-description-edit-form" id="modalDescriptionEditForm">
                        <textarea id="inlineDescInput" maxlength="240" placeholder="Add a description..."
                                  oninput="updateInlineDescCharCount()">${descContent}</textarea>
                        <div class="desc-edit-footer">
                            <span class="char-count"><span id="inlineDescCharCount">${descCharCount}</span>/240</span>
                            <div class="desc-edit-actions">
                                <button class="desc-edit-btn cancel" onclick="cancelInlineDescEdit()">
                                    <i class="ph ph-x"></i> Cancel
                                </button>
                                <button class="desc-edit-btn save" onclick="saveInlineDesc()">
                                    <i class="ph ph-check"></i> Save
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                descriptionEl.style.display = '';
            }

            // Role Assignment Section - show roles the person is assigned to
            const roleAssignmentEl = document.getElementById('modalRoleAssignment');
            if (entityType === 'person') {
                // Get INS relationships where this person is the subject
                const roleAssignments = relationships
                    .filter(r => r.predicate === 'INS' && r.subject === entityId)
                    .map(r => ({ relationship: r, role: findEntity(r.object) }))
                    .filter(a => a.role !== null);

                // Get available roles (not already assigned)
                const assignedRoleIds = roleAssignments.map(a => a.role.id);
                const availableRoles = entities.role.filter(r => !assignedRoleIds.includes(r.id));

                const addFormHtml = availableRoles.length > 0 ? `
                    <div id="inlineRoleAssignForm" class="role-assignment-add-form hidden">
                        ${generateRoleDropdownHTML(availableRoles)}
                        <button class="role-assignment-add-btn" onclick="assignPersonToRoleFromModal()">
                            <i class="ph ph-plus"></i> Assign
                        </button>
                    </div>
                ` : '';

                if (roleAssignments.length > 0) {
                    roleAssignmentEl.innerHTML = `
                        <div class="role-assignment-header">
                            <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-identification-badge"></i> Assigned Roles</div>
                            ${availableRoles.length > 0 ? `<button class="section-add-btn" onclick="toggleInlineRoleAssignForm()" title="Assign to role"><i class="ph ph-plus"></i></button>` : ''}
                        </div>
                        <div class="role-assignment-list">
                            ${roleAssignments.map(a => {
                                const parentTeam = getRoleParentTeam(a.role.id);
                                const teamLabel = parentTeam ? `<span class="chip-team-label">${parentTeam.name}</span>` : '';
                                return `
                                <div class="role-assignment-chip" onclick="openEntityModal('${a.role.id}', 'role')">
                                    <i class="ph ph-briefcase"></i>
                                    <span class="chip-role-name">${a.role.name}</span>
                                    ${teamLabel}
                                    <button class="chip-remove-btn" onclick="event.stopPropagation(); removeRoleAssignment('${a.relationship.id}')" title="Remove assignment">
                                        <i class="ph ph-x"></i>
                                    </button>
                                </div>
                            `}).join('')}
                        </div>
                        ${addFormHtml}
                    `;
                } else {
                    roleAssignmentEl.innerHTML = `
                        <div class="role-assignment-header">
                            <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-identification-badge"></i> Assigned Roles</div>
                            ${availableRoles.length > 0 ? `<button class="section-add-btn" onclick="toggleInlineRoleAssignForm()" title="Assign to role"><i class="ph ph-plus"></i></button>` : ''}
                        </div>
                        <div class="role-assignment-empty">
                            Not assigned to any roles
                        </div>
                        ${addFormHtml}
                    `;
                }
            } else if (entityType === 'task') {
                // Task-specific info section
                roleAssignmentEl.innerHTML = renderTaskModalInfo(entity);
            } else {
                roleAssignmentEl.innerHTML = '';
            }

            // Separate relationships into Nesting (DES) and Activities (non-DES)
            const nestedRelationships = relationships.filter(r =>
                r.predicate === 'DES' && (r.subject === entityId || r.object === entityId)
            );

            // Persons cannot have activities - only show activities for other entity types
            const activityRelationships = entityType === 'person'
                ? []
                : relationships.filter(r =>
                    r.predicate !== 'DES' && (r.subject === entityId || r.object === entityId)
                );

            // Get nested entities (DES relationships - hierarchical)
            const nestedEntities = [];
            nestedRelationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !nestedEntities.find(c => c.id === conn.id)) {
                        nestedEntities.push({ ...conn, direction: 'child' }); // This entity defines/contains the connected one
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !nestedEntities.find(c => c.id === conn.id)) {
                        nestedEntities.push({ ...conn, direction: 'parent' }); // The connected entity defines/contains this one
                    }
                }
            });

            // Get activity entities (non-DES relationships)
            // Persons cannot have activities
            const activityEntities = [];
            activityRelationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !activityEntities.find(c => c.id === conn.id)) {
                        activityEntities.push(conn);
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !activityEntities.find(c => c.id === conn.id)) {
                        activityEntities.push(conn);
                    }
                }
            });

            // Persons cannot have activities - no activity section for them
            const isPerson = entityType === 'person';
            const sectionTitle = 'Activities';
            const sectionIcon = 'ph-arrows-left-right';
            const emptyStateText = 'No activities yet';

            // Render Nested section (DES relationships - hierarchical structure)
            const nestedEl = document.getElementById('modalNested');
            const useMobileView = isMobile();

            // Check if entity can have nested items
            const canHaveNested = ['unit', 'team'].includes(entityType);

            if (nestedEntities.length > 0) {
                // Create header with view toggle and inline add button
                nestedEl.innerHTML = `
                    <div class="connections-header">
                        <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-tree-structure"></i> Nested</div>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            ${canHaveNested ? `<button class="section-add-btn" onclick="toggleInlineNestedForm()" title="Add nested"><i class="ph ph-plus"></i></button>` : ''}
                            <div class="view-toggle">
                                <button class="view-toggle-btn" data-view="orbital" onclick="switchNestedView('orbital', '${entityId}', '${entityType}')" title="Orbital view">
                                    <i class="ph ph-planet"></i>
                                </button>
                                <button class="view-toggle-btn" data-view="embedded" onclick="switchNestedView('embedded', '${entityId}', '${entityType}')" title="Embedded cards">
                                    <i class="ph ph-stack"></i>
                                </button>
                                <button class="view-toggle-btn active" data-view="list" onclick="switchNestedView('list', '${entityId}', '${entityType}')" title="List view">
                                    <i class="ph ph-list"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    ${canHaveNested ? `
                    <div id="inlineNestedForm" class="inline-add-form hidden">
                        <div class="inline-add-row">
                            <select id="inlineNestedSelect">
                                <option value="">Select entity to nest...</option>
                                ${getAllEntitiesForNesting(entityId, entityType)}
                            </select>
                            <button class="inline-add-btn" onclick="addNestedFromInline()"><i class="ph ph-plus"></i> Add</button>
                        </div>
                    </div>
                    ` : ''}
                `;

                // Container for the view content
                const viewContainer = document.createElement('div');
                viewContainer.id = 'nestedViewContainer';
                nestedEl.appendChild(viewContainer);

                // Default to list view for all devices
                renderGroupedConnections(viewContainer, nestedEntities, entityId);
            } else {
                // Empty state - show add form if entity can have nested items
                if (canHaveNested) {
                    nestedEl.innerHTML = `
                        <div class="connections-header">
                            <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-tree-structure"></i> Nested</div>
                            <button class="section-add-btn" onclick="toggleInlineNestedForm()" title="Add nested"><i class="ph ph-plus"></i></button>
                        </div>
                        <div id="inlineNestedForm" class="inline-add-form hidden">
                            <div class="inline-add-row">
                                <select id="inlineNestedSelect">
                                    <option value="">Select entity to nest...</option>
                                    ${getAllEntitiesForNesting(entityId, entityType)}
                                </select>
                                <button class="inline-add-btn" onclick="addNestedFromInline()"><i class="ph ph-plus"></i> Add</button>
                            </div>
                        </div>
                        <div class="modal-empty-state">
                            <i class="ph ph-tree-structure"></i>
                            <div>No nested items</div>
                        </div>
                    `;
                } else {
                    nestedEl.innerHTML = '';
                }
            }

            // Hide the separate Add Nested section - functionality is now inline
            const addNestedEl = document.getElementById('modalAddNested');
            addNestedEl.innerHTML = '';

            // Parent UI - shows what this entity is nested inside
            const nestUnderEl = document.getElementById('modalNestUnder');
            // Show for entity types that can have parents (units can nest under units, teams under units/teams, roles under units/teams)
            const parentOptions = getParentOptionsForNesting(entityId, entityType);

            // Find current parent(s) for this entity
            const currentParents = relationships
                .filter(r => r.predicate === 'DES' && r.subject === entityId)
                .map(r => findEntity(r.object))
                .filter(Boolean);

            if (['unit', 'team', 'role'].includes(entityType)) {
                nestUnderEl.innerHTML = `
                    <div class="connections-header">
                        <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ph-arrow-bend-up-left"></i> Parent</div>
                        <button class="section-add-btn" onclick="toggleInlineParentForm()" title="Set parent"><i class="ph ph-plus"></i></button>
                    </div>
                    ${currentParents.length > 0 ? `
                        <div class="nested-chips-container" style="margin-bottom: 0.75rem;">
                            ${currentParents.map(parent => `
                                <span class="entity-chip ${parent.type}" onclick="openEntityModal('${parent.id}', '${parent.type}')" style="cursor: pointer;">
                                    <i class="ph ${getEntityIcon(parent.type)}"></i>
                                    ${parent.name}
                                    <button class="chip-remove-btn" onclick="event.stopPropagation(); removeParentRelationship('${entityId}', '${parent.id}')" title="Remove parent">
                                        <i class="ph ph-x"></i>
                                    </button>
                                </span>
                            `).join('')}
                        </div>
                    ` : ''}
                    <div id="inlineParentForm" class="inline-add-form hidden">
                        <div class="inline-add-row">
                            <select id="modalNestUnderSelect">
                                <option value="">Select parent...</option>
                                ${parentOptions || ''}
                            </select>
                            <button class="inline-add-btn" onclick="nestUnderFromModal()"><i class="ph ph-plus"></i> Add</button>
                        </div>
                    </div>
                    ${currentParents.length === 0 ? `
                        <div class="modal-empty-state">
                            <i class="ph ph-arrow-bend-up-left"></i>
                            <div>No parent</div>
                        </div>
                    ` : ''}
                `;
            } else {
                nestUnderEl.innerHTML = '';
            }

            // Render Activities section (non-DES relationships) - hidden for persons
            const activitiesEl = document.getElementById('modalActivities');
            const isTask = entityType === 'task';

            // Persons cannot have activities - hide the section entirely
            const isRole = entityType === 'role';
            if (isPerson) {
                activitiesEl.innerHTML = '';
            } else if (isRole) {
                // Roles: show work-focused dashboard with people, tasks, and workflows
                activitiesEl.innerHTML = renderRoleWorkContent(entityId);
            } else if (isTask) {
                // Tasks: show simplified connected entities view
                const connectedRoles = activityEntities.filter(e => e.type === 'role');
                const otherConnections = activityEntities.filter(e => e.type !== 'role');

                if (activityEntities.length > 0) {
                    activitiesEl.innerHTML = `
                        <div class="modal-section-title" style="margin-bottom: 0.75rem;">
                            <i class="ph ph-link"></i> Connected
                        </div>
                        <div class="task-connected-list">
                            ${connectedRoles.map(role => `
                                <div class="task-connected-item" onclick="openEntityModal('${role.id}', 'role')">
                                    <i class="ph ph-briefcase"></i>
                                    <span>${role.name}</span>
                                </div>
                            `).join('')}
                            ${otherConnections.map(conn => `
                                <div class="task-connected-item" onclick="openEntityModal('${conn.id}', '${conn.type}')">
                                    ${getIcon(conn.type)}
                                    <span>${conn.name}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else {
                    activitiesEl.innerHTML = `
                        <div class="modal-section-title" style="margin-bottom: 0.75rem;">
                            <i class="ph ph-link"></i> Connected
                        </div>
                        <div class="task-dep-empty">
                            No connections yet. Use the Add tab to connect roles.
                        </div>
                    `;
                }
            } else {
                const inlineActivityFormHtml = `
                    <div id="inlineActivityForm" class="inline-add-form hidden">
                        <div class="inline-add-row">
                            <select id="inlineOperatorSelect">
                                <option value="">Type...</option>
                                ${Object.entries(eoOperators)
                                    .filter(([code]) => code !== 'DES' && code !== 'INS')
                                    .map(([code, op]) => `<option value="${code}">${op.label}</option>`)
                                    .join('')}
                            </select>
                            <select id="inlineTargetSelect">
                                <option value="">Connect to...</option>
                                ${getAllEntitiesForModal(entityId)}
                            </select>
                            <button class="inline-add-btn" onclick="addActivityFromInline()"><i class="ph ph-plus"></i> Add</button>
                        </div>
                    </div>
                `;

                if (activityEntities.length > 0) {
                    // Create header with view toggle and inline add button
                    activitiesEl.innerHTML = `
                        <div class="connections-header">
                            <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ${sectionIcon}"></i> ${sectionTitle}</div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <button class="section-add-btn" onclick="toggleInlineActivityForm()" title="Add activity"><i class="ph ph-plus"></i></button>
                                <div class="view-toggle">
                                    <button class="view-toggle-btn" data-view="orbital" onclick="switchActivitiesView('orbital', '${entityId}', '${entityType}')">
                                        <i class="ph ph-planet"></i>
                                    </button>
                                    <button class="view-toggle-btn active" data-view="list" onclick="switchActivitiesView('list', '${entityId}', '${entityType}')">
                                        <i class="ph ph-list"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        ${inlineActivityFormHtml}
                    `;

                    // Container for the view content
                    const viewContainer = document.createElement('div');
                    viewContainer.id = 'activitiesViewContainer';
                    activitiesEl.appendChild(viewContainer);

                    renderGroupedConnections(viewContainer, activityEntities, entityId);
                } else {
                    activitiesEl.innerHTML = `
                        <div class="connections-header">
                            <div class="modal-section-title" style="margin-bottom: 0;"><i class="ph ${sectionIcon}"></i> ${sectionTitle}</div>
                            <button class="section-add-btn" onclick="toggleInlineActivityForm()" title="Add activity"><i class="ph ph-plus"></i></button>
                        </div>
                        ${inlineActivityFormHtml}
                        <div class="modal-empty-state">
                            <i class="ph ${sectionIcon}"></i>
                            <div>${emptyStateText}</div>
                        </div>
                    `;
                }
            }

            // Add activity UI - now uses the new Create Connection panel
            const addActivityEl = document.getElementById('modalAddActivity');

            if (isPerson) {
                // Persons can only be assigned to roles
                addActivityEl.innerHTML = `
                    <div class="modal-section-title"><i class="ph ph-user-circle-plus"></i> Assign to Role</div>
                    <div class="modal-add-connection">
                        <div class="modal-add-connection-row">
                            <select id="modalRoleSelect">
                                <option value="">Select role...</option>
                                ${entities.role.map(role => `<option value="${role.id}">${role.name}</option>`).join('')}
                            </select>
                            <button class="modal-add-connection-btn" onclick="assignPersonToRoleFromModal()">
                                <i class="ph ph-plus"></i> Assign
                            </button>
                        </div>
                    </div>
                `;
            } else if (entityType === 'task') {
                // Tasks: show simplified quick actions
                addActivityEl.innerHTML = renderTaskQuickActions(entityId);
            } else {
                // Use the new Create Connection panel for non-person entities
                addActivityEl.innerHTML = renderCreateConnectionPanel(entityId, entityType);
            }

            // Update tabs visibility based on entity type
            updateModalTabsForEntityType(entityType);

            // Render history section (collapsible, loads on expand)
            const historyEl = document.getElementById('modalHistory');
            historyEl.innerHTML = renderEntityHistorySection(entityId);

            document.getElementById('entityModal').classList.add('active');
        }

        function closeEntityModal() {
            document.getElementById('entityModal').classList.remove('active');
            // Close any open dropdowns
            closeModalParentDropdown();
        }

        // Switch modal tabs
        function switchModalTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.modal-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Update tab content
            document.querySelectorAll('.modal-tab-content').forEach(content => {
                content.classList.remove('active');
            });

            const tabMap = {
                'connections': 'tabConnections',
                'structure': 'tabStructure',
                'connect': 'tabConnect'
            };

            const targetContent = document.getElementById(tabMap[tabName]);
            if (targetContent) {
                targetContent.classList.add('active');
            }
        }

        // Update tabs visibility and default based on entity type
        // WORK-FIRST: Always default to work/connections tab
        function updateModalTabsForEntityType(entityType) {
            const tabsContainer = document.getElementById('modalTabs');
            const isPerson = entityType === 'person';

            // Get tab buttons
            const structureTab = tabsContainer.querySelector('[data-tab="structure"]');
            const connectionsTab = tabsContainer.querySelector('[data-tab="connections"]');
            const connectTab = tabsContainer.querySelector('[data-tab="connect"]');

            // Get tab labels
            const structureLabel = structureTab?.querySelector('.tab-label');
            const connectionsLabel = connectionsTab?.querySelector('.tab-label');
            const connectionsIcon = connectionsTab?.querySelector('i');

            if (isPerson) {
                // Hide tabs for persons - they only have role assignment
                tabsContainer.style.display = 'none';
                document.querySelectorAll('.modal-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                // Show the Connect tab content for "Assign to Role" form
                document.getElementById('tabConnect').classList.add('active');
            } else {
                // Show tabs for other entity types
                tabsContainer.style.display = 'flex';

                // WORK-FIRST: Set tab labels based on entity type
                if (entityType === 'role') {
                    // Roles: Work tab shows tasks, Structure shows hierarchy
                    if (structureTab) structureTab.style.display = '';
                    if (connectionsLabel) connectionsLabel.textContent = 'Work';
                    if (connectionsIcon) connectionsIcon.className = 'ph ph-briefcase';
                    // Default to Work tab
                    switchModalTab('connections');
                } else if (entityType === 'unit' || entityType === 'team') {
                    // Teams/Units: Work tab shows what work involves them
                    if (structureTab) structureTab.style.display = '';
                    if (connectionsLabel) connectionsLabel.textContent = 'Activity';
                    if (connectionsIcon) connectionsIcon.className = 'ph ph-pulse';
                    // Default to Activity (work-focused) tab
                    switchModalTab('connections');
                } else if (entityType === 'workflow') {
                    // Workflows: hide structure, show Process
                    if (structureTab) structureTab.style.display = 'none';
                    if (connectionsLabel) connectionsLabel.textContent = 'Process';
                    if (connectionsIcon) connectionsIcon.className = 'ph ph-flow-arrow';
                    switchModalTab('connections');
                } else if (entityType === 'task') {
                    // Tasks: hide all tabs - simplified modal has everything inline
                    tabsContainer.style.display = 'none';
                    document.querySelectorAll('.modal-tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                } else if (entityType === 'product') {
                    // Products: hide structure, show Usage
                    if (structureTab) structureTab.style.display = 'none';
                    if (connectionsLabel) connectionsLabel.textContent = 'Usage';
                    if (connectionsIcon) connectionsIcon.className = 'ph ph-chart-bar';
                    switchModalTab('connections');
                } else {
                    // Default: show both, default to work
                    if (structureTab) structureTab.style.display = '';
                    switchModalTab('connections');
                }
            }
        }

        // Reset modal tabs to default state - WORK-FIRST
        function resetModalTabs() {
            switchModalTab('connections');
        }

        // ========================================
        // Modal Header Parent Badge Functions
        // ========================================

        // State for Create Connection UI
        let createConnectionState = {
            operator: null,
            targetId: null,
            notes: '',
            workProductId: null,
            advancedOperatorsVisible: false,
            notesExpanded: false
        };

        function renderModalHeaderParent(entityId, entityType) {
            const headerParentEl = document.getElementById('modalHeaderParent');
            if (!headerParentEl) return;

            // Only show for entity types that can have parents
            if (!['unit', 'team', 'role'].includes(entityType)) {
                headerParentEl.innerHTML = '';
                return;
            }

            // Find current parent (entity that has DES relationship with this as object)
            const parentRelationship = relationships.find(r =>
                r.predicate === 'DES' && r.object === entityId
            );
            const parent = parentRelationship ? findEntity(parentRelationship.subject) : null;

            // Get available parent options
            const parentOptions = getParentOptionsForNestingArray(entityId, entityType);

            if (parent) {
                // Show parent badge with dropdown
                headerParentEl.innerHTML = `
                    <div style="position: relative; display: inline-block;">
                        <div class="modal-parent-badge" id="modalParentBadge" onclick="toggleModalParentDropdown(event)">
                            <i class="ph ${getEntityIcon(parent.type)} parent-type-icon"></i>
                            <span class="parent-name">${parent.name}</span>
                            <i class="ph ph-caret-down dropdown-arrow"></i>
                        </div>
                        <div class="modal-parent-dropdown" id="modalParentDropdown">
                            <div class="modal-parent-dropdown-header">Change Parent</div>
                            <div class="modal-parent-dropdown-list">
                                ${parentOptions.map(opt => `
                                    <div class="modal-parent-dropdown-item ${opt.id === parent.id ? 'current' : ''}"
                                         onclick="changeModalParent('${opt.id}')">
                                        <i class="ph ${getEntityIcon(opt.type)} item-icon"></i>
                                        <span>${opt.name}</span>
                                    </div>
                                `).join('')}
                                <div class="modal-parent-dropdown-item remove-parent" onclick="removeModalParent()">
                                    <i class="ph ph-x-circle item-icon"></i>
                                    <span>Remove parent</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Show empty state with option to add parent
                headerParentEl.innerHTML = `
                    <div style="position: relative; display: inline-block;">
                        <div class="modal-parent-badge-empty" id="modalParentBadge" onclick="toggleModalParentDropdown(event)">
                            <i class="ph ph-plus"></i>
                            <span>Add parent</span>
                        </div>
                        <div class="modal-parent-dropdown" id="modalParentDropdown">
                            <div class="modal-parent-dropdown-header">Set Parent</div>
                            <div class="modal-parent-dropdown-list">
                                ${parentOptions.length > 0 ? parentOptions.map(opt => `
                                    <div class="modal-parent-dropdown-item" onclick="changeModalParent('${opt.id}')">
                                        <i class="ph ${getEntityIcon(opt.type)} item-icon"></i>
                                        <span>${opt.name}</span>
                                    </div>
                                `).join('') : '<div class="modal-parent-dropdown-item" style="color: #A89984; cursor: default;">No available parents</div>'}
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        function getParentOptionsForNestingArray(entityId, entityType) {
            const options = [];

            // Units can be nested under other units
            if (entityType === 'unit') {
                entities.unit.forEach(unit => {
                    if (unit.id !== entityId && !wouldCreateCircularReference(unit.id, entityId)) {
                        options.push({ id: unit.id, name: unit.name, type: 'unit' });
                    }
                });
            }

            // Teams can be nested under units or other teams
            if (entityType === 'team') {
                entities.unit.forEach(unit => {
                    options.push({ id: unit.id, name: unit.name, type: 'unit' });
                });
                entities.team.forEach(team => {
                    if (team.id !== entityId && !wouldCreateCircularReference(team.id, entityId)) {
                        options.push({ id: team.id, name: team.name, type: 'team' });
                    }
                });
            }

            // Roles can be nested under units or teams
            if (entityType === 'role') {
                entities.unit.forEach(unit => {
                    options.push({ id: unit.id, name: unit.name, type: 'unit' });
                });
                entities.team.forEach(team => {
                    options.push({ id: team.id, name: team.name, type: 'team' });
                });
            }

            return options;
        }

        function wouldCreateCircularReference(potentialParentId, entityId) {
            // Check if making potentialParentId the parent of entityId would create a cycle
            const visited = new Set();
            let current = potentialParentId;

            while (current) {
                if (current === entityId) return true;
                if (visited.has(current)) return false;
                visited.add(current);

                // Find parent of current
                const parentRel = relationships.find(r => r.predicate === 'DES' && r.object === current);
                current = parentRel ? parentRel.subject : null;
            }

            return false;
        }

        function toggleModalParentDropdown(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('modalParentDropdown');
            const badge = document.getElementById('modalParentBadge');

            if (dropdown.classList.contains('visible')) {
                closeModalParentDropdown();
            } else {
                dropdown.classList.add('visible');
                badge.classList.add('dropdown-open');

                // Close dropdown when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeModalParentDropdownOnOutsideClick);
                }, 0);
            }
        }

        function closeModalParentDropdownOnOutsideClick(event) {
            const dropdown = document.getElementById('modalParentDropdown');
            if (dropdown && !dropdown.contains(event.target)) {
                closeModalParentDropdown();
            }
        }

        function closeModalParentDropdown() {
            const dropdown = document.getElementById('modalParentDropdown');
            const badge = document.getElementById('modalParentBadge');
            if (dropdown) dropdown.classList.remove('visible');
            if (badge) badge.classList.remove('dropdown-open');
            document.removeEventListener('click', closeModalParentDropdownOnOutsideClick);
        }

        function changeModalParent(newParentId) {
            if (!currentModalEntity || !currentModalEntityType) return;

            const entityId = currentModalEntity.id;
            const newParent = findEntity(newParentId);
            if (!newParent) return;

            // Remove existing parent relationship if any
            const existingParentIdx = relationships.findIndex(r =>
                r.predicate === 'DES' && r.object === entityId
            );

            if (existingParentIdx >= 0) {
                const oldRel = relationships[existingParentIdx];
                relationships.splice(existingParentIdx, 1);

                // Log removal
                logActivityToXano({
                    event_verb: 'Remove Parent',
                    eo_operator: 'NUL',
                    object_type: 'relationship',
                    object_id: oldRel.id,
                    object_label: `Removed parent from ${currentModalEntity.name}`,
                    data_json: {
                        entity_id: entityId,
                        entity_name: currentModalEntity.name,
                        old_parent_id: oldRel.subject
                    }
                });
            }

            // Create new parent relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: newParentId,
                predicate: 'DES',
                object: entityId,
                description: ''
            };

            relationships.push(relationship);

            // Log to Xano
            logActivityToXano({
                event_verb: 'Set Parent',
                eo_operator: 'DES',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} nested under ${newParent.name}`,
                data_json: {
                    subject_id: newParentId,
                    subject_name: newParent.name,
                    subject_type: newParent.type,
                    object_id: entityId,
                    object_name: currentModalEntity.name,
                    object_type: currentModalEntityType
                }
            });

            saveToLocalStorage();
            closeModalParentDropdown();

            // Refresh modal
            openEntityModal(entityId, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') updateGraph();
            else if (currentView === 'tree') renderTreeView();
            else if (currentView === 'card') renderCardView();
        }

        function removeModalParent() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const entityId = currentModalEntity.id;

            // Find and remove parent relationship
            const parentIdx = relationships.findIndex(r =>
                r.predicate === 'DES' && r.object === entityId
            );

            if (parentIdx >= 0) {
                const oldRel = relationships[parentIdx];
                const oldParent = findEntity(oldRel.subject);
                relationships.splice(parentIdx, 1);

                // Log removal
                logActivityToXano({
                    event_verb: 'Remove Parent',
                    eo_operator: 'NUL',
                    object_type: 'relationship',
                    object_id: oldRel.id,
                    object_label: `Removed ${currentModalEntity.name} from ${oldParent?.name || 'parent'}`,
                    data_json: {
                        entity_id: entityId,
                        entity_name: currentModalEntity.name,
                        old_parent_id: oldRel.subject,
                        old_parent_name: oldParent?.name
                    }
                });

                saveToLocalStorage();
                closeModalParentDropdown();

                // Refresh modal
                openEntityModal(entityId, currentModalEntityType);

                // Refresh views
                if (currentView === 'graph') updateGraph();
                else if (currentView === 'tree') renderTreeView();
                else if (currentView === 'card') renderCardView();
            }
        }

        // ========================================
        // Create Connection Panel Functions
        // ========================================

        function renderCreateConnectionPanel(entityId, entityType) {
            // Reset state
            createConnectionState = {
                operator: null,
                targetId: null,
                notes: '',
                workProductId: null,
                advancedOperatorsVisible: false,
                notesExpanded: false
            };

            const entity = findEntity(entityId);
            if (!entity) return '';

            const canLinkWorkProduct = entityType === 'role' || entityType === 'team';

            return `
                <div class="create-connection-panel">
                    <div class="create-connection-header">
                        <i class="ph ph-git-branch"></i>
                        Create Connection
                    </div>
                    <div class="create-connection-body">
                        <!-- Primary Operator Buttons -->
                        <div class="operator-buttons-row">
                            <button class="operator-button" data-operator="DES" onclick="selectConnectionOperator('DES', this)">
                                <i class="ph ph-tree-structure operator-button-icon"></i>
                                <span class="operator-button-label">Define</span>
                                <span class="operator-button-sublabel">contains</span>
                            </button>
                            <button class="operator-button" data-operator="CON" onclick="selectConnectionOperator('CON', this)">
                                <i class="ph ph-link operator-button-icon"></i>
                                <span class="operator-button-label">Link</span>
                                <span class="operator-button-sublabel">connects</span>
                            </button>
                            <button class="operator-button" data-operator="ALT" onclick="selectConnectionOperator('ALT', this)">
                                <i class="ph ph-arrows-left-right operator-button-icon"></i>
                                <span class="operator-button-label">Shift</span>
                                <span class="operator-button-sublabel">alternates</span>
                            </button>
                        </div>

                        <!-- More Operators Toggle -->
                        <div class="more-operators-toggle" id="moreOperatorsToggle" onclick="toggleAdvancedOperatorsPanel()">
                            <span>More operators</span>
                            <i class="ph ph-caret-down"></i>
                        </div>

                        <!-- Advanced Operators Grid -->
                        <div class="advanced-operators-grid" id="advancedOperatorsGrid">
                            <button class="advanced-operator-btn" data-operator="SEG" onclick="selectConnectionOperator('SEG', this)">
                                <i class="ph ph-scissors"></i>
                                <span>Divide</span>
                            </button>
                            <button class="advanced-operator-btn" data-operator="SYN" onclick="selectConnectionOperator('SYN', this)">
                                <i class="ph ph-arrows-merge"></i>
                                <span>Merge</span>
                            </button>
                            <button class="advanced-operator-btn" data-operator="SUP" onclick="selectConnectionOperator('SUP', this)">
                                <i class="ph ph-scales"></i>
                                <span>Balance</span>
                            </button>
                            <button class="advanced-operator-btn" data-operator="REC" onclick="selectConnectionOperator('REC', this)">
                                <i class="ph ph-arrow-clockwise"></i>
                                <span>Loop</span>
                            </button>
                            <button class="advanced-operator-btn" data-operator="NUL" onclick="selectConnectionOperator('NUL', this)">
                                <i class="ph ph-eye"></i>
                                <span>Notice</span>
                            </button>
                        </div>

                        <!-- Target Entity Selector -->
                        <div class="target-entity-section">
                            <div class="target-entity-label">Connect to</div>
                            <select class="target-entity-select" id="connectionTargetSelect" onchange="updateConnectionSentencePreview()">
                                <option value="">Select an entity...</option>
                                ${getAllEntitiesForModal(entityId, false)}
                            </select>
                        </div>

                        <!-- Sentence Preview -->
                        <div class="connection-sentence-preview" id="connectionSentencePreview">
                            <span class="sentence-placeholder">Select an operator and target to preview connection</span>
                        </div>

                        <!-- Collapsible Notes Section -->
                        <div class="notes-section">
                            <div class="notes-section-toggle" id="notesToggle" onclick="toggleConnectionNotes()">
                                <i class="ph ph-caret-right toggle-icon"></i>
                                <i class="ph ph-note-pencil"></i>
                                <span>Add notes or details</span>
                            </div>
                            <div class="notes-section-content" id="notesContent">
                                <textarea class="notes-textarea" id="connectionNotes"
                                    placeholder="Add any additional notes about this connection..."
                                    maxlength="500"
                                    oninput="updateConnectionNotesState()"></textarea>
                                <div class="notes-char-count"><span id="notesCharCount">0</span>/500</div>
                            </div>
                        </div>

                        ${canLinkWorkProduct ? `
                        <!-- Work Product Section -->
                        <div class="work-product-section">
                            <div class="work-product-section-header">
                                <i class="ph ph-package"></i>
                                <span>Or link to Work Product</span>
                            </div>
                            <button class="work-product-selector-btn" id="connectionWorkProductBtn" onclick="openWorkProductSelectorForConnection()">
                                <i class="ph ph-package package-icon"></i>
                                <span id="connectionWorkProductText">Select work product...</span>
                            </button>
                            <input type="hidden" id="connectionSelectedWorkProductId" value="">
                            <button class="quick-create-btn" onclick="quickCreateWorkProduct()">
                                <i class="ph ph-plus-circle"></i>
                                <span>Quick create new work product</span>
                            </button>
                        </div>
                        ` : ''}

                        <!-- Create Button -->
                        <div class="create-connection-actions">
                            <button class="create-connection-btn" id="createConnectionBtn" onclick="createConnectionFromPanel()" disabled>
                                <i class="ph ph-plus-circle"></i>
                                <span>Create Connection</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function selectConnectionOperator(operatorCode, btn) {
            // Clear all active states
            document.querySelectorAll('.operator-button, .advanced-operator-btn').forEach(b => {
                b.classList.remove('active');
            });

            // Set active state
            btn.classList.add('active');
            createConnectionState.operator = operatorCode;

            // Update sentence preview
            updateConnectionSentencePreview();
            updateCreateConnectionButtonState();
        }

        function toggleAdvancedOperatorsPanel() {
            const grid = document.getElementById('advancedOperatorsGrid');
            const toggle = document.getElementById('moreOperatorsToggle');

            createConnectionState.advancedOperatorsVisible = !createConnectionState.advancedOperatorsVisible;

            if (createConnectionState.advancedOperatorsVisible) {
                grid.classList.add('visible');
                toggle.classList.add('expanded');
            } else {
                grid.classList.remove('visible');
                toggle.classList.remove('expanded');
            }
        }

        function updateConnectionSentencePreview() {
            const preview = document.getElementById('connectionSentencePreview');
            if (!preview) return;

            const targetSelect = document.getElementById('connectionTargetSelect');
            const targetId = targetSelect?.value;

            createConnectionState.targetId = targetId || null;

            if (!createConnectionState.operator || !targetId) {
                preview.innerHTML = '<span class="sentence-placeholder">Select an operator and target to preview connection</span>';
                preview.classList.remove('has-content');
                return;
            }

            const target = findEntity(targetId);
            if (!target || !currentModalEntity) return;

            const operatorData = eoOperators[createConnectionState.operator];

            preview.innerHTML = `
                <span class="sentence-subject">
                    <i class="ph ${getEntityIcon(currentModalEntityType)}"></i>
                    ${currentModalEntity.name}
                </span>
                <span class="sentence-operator" style="--sentence-op-color: ${operatorData.color}">
                    ${operatorData.label}
                </span>
                <span class="sentence-object ${target.type === 'work_product' ? 'work-product' : ''}">
                    <i class="ph ${getEntityIcon(target.type)}"></i>
                    ${target.name}
                </span>
            `;
            preview.classList.add('has-content');

            updateCreateConnectionButtonState();
        }

        function toggleConnectionNotes() {
            const toggle = document.getElementById('notesToggle');
            const content = document.getElementById('notesContent');

            createConnectionState.notesExpanded = !createConnectionState.notesExpanded;

            if (createConnectionState.notesExpanded) {
                toggle.classList.add('expanded');
                content.classList.add('visible');
            } else {
                toggle.classList.remove('expanded');
                content.classList.remove('visible');
            }
        }

        function updateConnectionNotesState() {
            const textarea = document.getElementById('connectionNotes');
            const charCount = document.getElementById('notesCharCount');
            const toggle = document.getElementById('notesToggle');

            if (textarea && charCount) {
                const len = textarea.value.length;
                charCount.textContent = len;
                createConnectionState.notes = textarea.value;

                // Update toggle visual state
                if (toggle) {
                    if (len > 0) {
                        toggle.classList.add('has-content');
                    } else {
                        toggle.classList.remove('has-content');
                    }
                }
            }
        }

        function updateCreateConnectionButtonState() {
            const btn = document.getElementById('createConnectionBtn');
            if (!btn) return;

            const hasOperator = !!createConnectionState.operator;
            const hasTarget = !!createConnectionState.targetId;

            btn.disabled = !(hasOperator && hasTarget);
        }

        function openWorkProductSelectorForConnection() {
            // Open the work product selector with callback for connection panel
            openWorkProductSelectorModal((workProduct) => {
                if (workProduct) {
                    // Update the connection panel work product button
                    const btn = document.getElementById('connectionWorkProductBtn');
                    const text = document.getElementById('connectionWorkProductText');
                    const hiddenInput = document.getElementById('connectionSelectedWorkProductId');

                    if (btn && text && hiddenInput) {
                        btn.classList.add('selected');
                        text.textContent = workProduct.name;
                        hiddenInput.value = workProduct.id;
                        createConnectionState.workProductId = workProduct.id;
                    }
                }
            });
        }

        function quickCreateWorkProduct() {
            const name = prompt('Enter work product name:');
            if (!name || !name.trim()) return;

            const newWorkProduct = {
                id: 'work_product' + Date.now(),
                name: name.trim(),
                description: '',
                type: 'work_product'
            };

            entities.work_product.push(newWorkProduct);

            // Log to Xano
            logActivityToXano({
                event_verb: 'Quick Create',
                eo_operator: 'DES',
                object_type: 'work_product',
                object_id: newWorkProduct.id,
                object_label: newWorkProduct.name,
                data_json: {
                    entity_type: 'work_product',
                    entity_name: newWorkProduct.name,
                    created_from: 'connection_panel'
                }
            });

            saveToLocalStorage();

            // Update the work product button
            const btn = document.getElementById('connectionWorkProductBtn');
            const text = document.getElementById('connectionWorkProductText');
            const hiddenInput = document.getElementById('connectionSelectedWorkProductId');

            if (btn && text && hiddenInput) {
                btn.classList.add('selected');
                text.textContent = newWorkProduct.name;
                hiddenInput.value = newWorkProduct.id;
                createConnectionState.workProductId = newWorkProduct.id;
            }
        }

        function createConnectionFromPanel() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = createConnectionState.operator;
            const targetId = createConnectionState.targetId;
            const notes = createConnectionState.notes;

            if (!operatorCode || !targetId) {
                alert('Please select both an operator and target entity');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Create the relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: targetId,
                description: notes
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[operatorCode];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${currentModalEntity.name} → ${targetEntity.name}`
            });

            // Log to Xano
            logActivityToXano({
                event_verb: 'Create Connection',
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name,
                    notes: notes
                }
            });

            saveToLocalStorage();

            // Refresh modal
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') updateGraph();
            else if (currentView === 'tree') renderTreeView();
            else if (currentView === 'card') renderCardView();

            renderActivityList();
        }

        // Orbital visualization for connections
        // connectionType: 'nested' for DES relationships, 'activity' for non-DES, undefined for all
        function renderOrbitalConnections(container, centerEntity, connections, connectionType) {
            // Guard against invalid container
            if (!container) return;

            // Get dimensions with better fallback
            const containerRect = container.getBoundingClientRect();
            const width = containerRect.width > 0 ? containerRect.width : (container.clientWidth || 400);
            const height = 300;
            const centerX = width / 2;
            const centerY = height / 2;

            // Clear container thoroughly - remove any existing SVG first
            d3.select(container).selectAll('svg').remove();
            container.innerHTML = '';

            // Determine ring color based on connection type
            const ringColor = connectionType === 'nested' ? '#C88F4A' :
                              connectionType === 'activity' ? '#7B95A3' : '#A89984';

            // Group connections by type for better organization
            const groupedConnections = {};
            const typeOrder = ['team', 'unit', 'role', 'person', 'object'];

            connections.forEach(conn => {
                if (!groupedConnections[conn.type]) {
                    groupedConnections[conn.type] = [];
                }
                groupedConnections[conn.type].push(conn);
            });

            // Flatten maintaining type grouping
            const sortedConnections = [];
            typeOrder.forEach(type => {
                if (groupedConnections[type]) {
                    sortedConnections.push(...groupedConnections[type]);
                }
            });

            // Get nested connections for each item (items that THEY connect to)
            const nestedMap = new Map();
            sortedConnections.forEach(conn => {
                const nested = [];
                relationships.forEach(r => {
                    // For nested view, only show DES relationships from the connected items
                    // For activity view, only show non-DES relationships
                    const shouldInclude = connectionType === 'nested' ? r.predicate === 'DES' :
                                          connectionType === 'activity' ? r.predicate !== 'DES' : true;
                    if (shouldInclude && (r.subject === conn.id || r.object === conn.id)) {
                        const otherId = r.subject === conn.id ? r.object : r.subject;
                        if (otherId !== centerEntity.id) {
                            const otherEntity = findEntity(otherId);
                            if (otherEntity && !nested.find(n => n.id === otherEntity.id)) {
                                nested.push(otherEntity);
                            }
                        }
                    }
                });
                nestedMap.set(conn.id, nested);
            });

            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('class', 'orbital-svg')
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            // Draw orbital rings
            const maxConnections = sortedConnections.length;
            const innerRadius = 70;
            const outerRadius = Math.min(width, height) / 2 - 40;

            // Primary orbit ring with color based on connection type
            svg.append('circle')
                .attr('class', 'orbital-ring')
                .attr('cx', centerX)
                .attr('cy', centerY)
                .attr('r', innerRadius)
                .style('stroke', ringColor);

            // Secondary orbit ring (for nested items preview)
            if (Array.from(nestedMap.values()).some(arr => arr.length > 0)) {
                svg.append('circle')
                    .attr('class', 'orbital-ring')
                    .attr('cx', centerX)
                    .attr('cy', centerY)
                    .attr('r', outerRadius)
                    .style('stroke', ringColor)
                    .style('opacity', 0.5);
            }

            // Calculate positions for orbital nodes
            const angleStep = (2 * Math.PI) / Math.max(sortedConnections.length, 1);
            const startAngle = -Math.PI / 2; // Start from top

            // Draw connections lines first (behind nodes)
            sortedConnections.forEach((conn, i) => {
                const angle = startAngle + (i * angleStep);
                const x = centerX + innerRadius * Math.cos(angle);
                const y = centerY + innerRadius * Math.sin(angle);

                svg.append('line')
                    .attr('class', 'orbital-link')
                    .attr('x1', centerX)
                    .attr('y1', centerY)
                    .attr('x2', x)
                    .attr('y2', y)
                    .style('stroke', ringColor);

                // Draw lines to nested items (faded)
                const nested = nestedMap.get(conn.id) || [];
                if (nested.length > 0) {
                    // Show up to 3 nested preview dots
                    const previewCount = Math.min(nested.length, 3);
                    const nestedAngleSpread = Math.PI / 6;

                    for (let j = 0; j < previewCount; j++) {
                        const nestedAngle = angle + (j - (previewCount - 1) / 2) * (nestedAngleSpread / previewCount);
                        const nestedX = centerX + outerRadius * Math.cos(nestedAngle);
                        const nestedY = centerY + outerRadius * Math.sin(nestedAngle);

                        svg.append('line')
                            .attr('class', 'orbital-link')
                            .attr('x1', x)
                            .attr('y1', y)
                            .attr('x2', nestedX)
                            .attr('y2', nestedY)
                            .style('stroke', '#E5DDD1')
                            .style('stroke-width', 1)
                            .style('opacity', 0.5);

                        // Small preview dot for nested item
                        const nestedEntity = nested[j];
                        const previewGroup = svg.append('g')
                            .attr('class', 'orbital-node')
                            .attr('transform', `translate(${nestedX}, ${nestedY})`)
                            .style('cursor', 'pointer')
                            .on('click', () => openEntityModal(nestedEntity.id, nestedEntity.type));

                        previewGroup.append('circle')
                            .attr('r', 12)
                            .attr('class', 'orbital-node-circle')
                            .style('fill', getNodeColor(nestedEntity.type))
                            .style('opacity', 0.7);

                        // Add tiny icon
                        previewGroup.append('text')
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'central')
                            .attr('font-size', '10px')
                            .attr('fill', 'white')
                            .text(getIconChar(nestedEntity.type));
                    }

                    // If more nested items, show count
                    if (nested.length > 3) {
                        const countAngle = angle;
                        const countX = centerX + (outerRadius + 15) * Math.cos(countAngle);
                        const countY = centerY + (outerRadius + 15) * Math.sin(countAngle);

                        svg.append('text')
                            .attr('x', countX)
                            .attr('y', countY)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'central')
                            .attr('font-size', '9px')
                            .attr('fill', '#8B6F47')
                            .text(`+${nested.length - 3}`);
                    }
                }
            });

            // Draw center node
            const centerGroup = svg.append('g')
                .attr('class', 'orbital-center')
                .attr('transform', `translate(${centerX}, ${centerY})`);

            centerGroup.append('circle')
                .attr('r', 32)
                .attr('class', 'orbital-center-circle');

            // Center icon (using text for simplicity with Phosphor)
            centerGroup.append('text')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'central')
                .attr('font-size', '20px')
                .attr('fill', 'white')
                .text(getIconChar(centerEntity.type));

            // Draw orbital nodes
            sortedConnections.forEach((conn, i) => {
                const angle = startAngle + (i * angleStep);
                const x = centerX + innerRadius * Math.cos(angle);
                const y = centerY + innerRadius * Math.sin(angle);
                const nested = nestedMap.get(conn.id) || [];
                const hasNested = nested.length > 0;

                const nodeGroup = svg.append('g')
                    .attr('class', 'orbital-node')
                    .attr('transform', `translate(${x}, ${y})`)
                    .style('cursor', 'pointer')
                    .on('click', () => openEntityModal(conn.id, conn.type));

                // Node circle
                nodeGroup.append('circle')
                    .attr('r', 22)
                    .attr('class', 'orbital-node-circle')
                    .style('fill', getNodeColor(conn.type));

                // Nested indicator ring
                if (hasNested) {
                    nodeGroup.append('circle')
                        .attr('r', 26)
                        .style('fill', 'none')
                        .style('stroke', '#C88F4A')
                        .style('stroke-width', 2)
                        .style('stroke-dasharray', '3,2');
                }

                // Icon
                nodeGroup.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('font-size', '14px')
                    .attr('fill', 'white')
                    .text(getIconChar(conn.type));

                // Label - position radially based on angle
                const labelRadius = 40; // Distance from node center

                // Normalize angle to 0-2π range
                const normalizedAngle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

                // Determine label position based on quadrant
                // Right side: 315° to 45° (labels go right)
                // Left side: 135° to 225° (labels go left)
                // Top: 45° to 135° (labels go up)
                // Bottom: 225° to 315° (labels go down)

                const isRight = normalizedAngle < Math.PI / 4 || normalizedAngle > 7 * Math.PI / 4;
                const isLeft = normalizedAngle > 3 * Math.PI / 4 && normalizedAngle < 5 * Math.PI / 4;
                const isTop = normalizedAngle >= Math.PI / 4 && normalizedAngle <= 3 * Math.PI / 4;
                const isBottom = normalizedAngle >= 5 * Math.PI / 4 && normalizedAngle <= 7 * Math.PI / 4;

                let labelX = 0;
                let labelY = 0;
                let textAnchor = 'middle';

                if (isRight) {
                    labelX = labelRadius;
                    labelY = 4;
                    textAnchor = 'start';
                } else if (isLeft) {
                    labelX = -labelRadius;
                    labelY = 4;
                    textAnchor = 'end';
                } else if (isTop) {
                    labelX = 0;
                    labelY = -labelRadius + 4;
                    textAnchor = 'middle';
                } else if (isBottom) {
                    labelX = 0;
                    labelY = labelRadius + 4;
                    textAnchor = 'middle';
                } else {
                    // Diagonal positions - push outward at angle
                    labelX = Math.cos(angle) * labelRadius;
                    labelY = Math.sin(angle) * labelRadius + 4;
                    textAnchor = Math.cos(angle) > 0 ? 'start' : 'end';
                }

                // Smarter truncation - longer limit for side labels
                const maxChars = (isRight || isLeft) ? 18 : 14;
                const labelText = conn.name.length > maxChars ? conn.name.substring(0, maxChars - 2) + '…' : conn.name;

                nodeGroup.append('text')
                    .attr('class', 'orbital-node-label')
                    .attr('x', labelX)
                    .attr('y', labelY)
                    .attr('text-anchor', textAnchor)
                    .text(labelText);

                // Nested count badge
                if (hasNested) {
                    nodeGroup.append('circle')
                        .attr('cx', 16)
                        .attr('cy', -16)
                        .attr('r', 9)
                        .style('fill', '#C88F4A')
                        .style('stroke', 'white')
                        .style('stroke-width', 2);

                    nodeGroup.append('text')
                        .attr('x', 16)
                        .attr('y', -16)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'central')
                        .attr('font-size', '9px')
                        .attr('font-weight', '600')
                        .attr('fill', 'white')
                        .text(nested.length);
                }
            });
        }

        // Helper to get icon character for SVG text
        function getIconChar(type) {
            const icons = {
                unit: '🏢',
                team: '👥',
                role: '💼',
                person: '👤',
                object: '📦'
            };
            return icons[type] || '•';
        }

        // Switch between orbital and list views for connections
        function switchConnectionsView(view, entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Get connections
            const connections = [];
            relationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !connections.find(c => c.id === conn.id)) {
                        connections.push(conn);
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !connections.find(c => c.id === conn.id)) {
                        connections.push(conn);
                    }
                }
            });

            // Update toggle buttons
            document.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Get container and clear it
            const viewContainer = document.getElementById('connectionsViewContainer');
            if (!viewContainer) return;
            viewContainer.innerHTML = '';

            if (view === 'orbital') {
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'orbital-container';
                viewContainer.appendChild(orbitalContainer);
                setTimeout(() => {
                    renderOrbitalConnections(orbitalContainer, entity, connections);
                }, 0);
            } else {
                renderGroupedConnections(viewContainer, connections, entityId);
            }
        }

        // Switch between orbital and list views for nested items
        function switchNestedView(view, entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Get nested entities (DES relationships only)
            const nestedRelationships = relationships.filter(r =>
                r.predicate === 'DES' && (r.subject === entityId || r.object === entityId)
            );
            const nestedEntities = [];
            nestedRelationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !nestedEntities.find(c => c.id === conn.id)) {
                        nestedEntities.push({ ...conn, direction: 'child' });
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !nestedEntities.find(c => c.id === conn.id)) {
                        nestedEntities.push({ ...conn, direction: 'parent' });
                    }
                }
            });

            // Update toggle buttons in nested section
            const nestedEl = document.getElementById('modalNested');
            nestedEl.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Get container and clear it
            const viewContainer = document.getElementById('nestedViewContainer');
            if (!viewContainer) return;
            viewContainer.innerHTML = '';

            if (view === 'orbital') {
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'orbital-container';
                viewContainer.appendChild(orbitalContainer);
                setTimeout(() => {
                    renderOrbitalConnections(orbitalContainer, entity, nestedEntities, 'nested');
                }, 0);
            } else if (view === 'embedded') {
                renderEmbeddedUnits(viewContainer, nestedEntities, entityId);
            } else {
                renderGroupedConnections(viewContainer, nestedEntities, entityId);
            }
        }

        // Render embedded unit cards with expandable details
        function renderEmbeddedUnits(container, connections, parentEntityId) {
            const wrapper = document.createElement('div');
            wrapper.className = 'embedded-units-container';

            connections.forEach(conn => {
                // Get nested entities for this connection
                const nestedRels = relationships.filter(r =>
                    r.predicate === 'DES' && r.subject === conn.id
                );
                const nestedChildren = nestedRels.map(r => findEntity(r.object)).filter(Boolean);

                // Count all relationships for this entity
                const allRels = relationships.filter(r =>
                    r.subject === conn.id || r.object === conn.id
                );

                const card = document.createElement('div');
                card.className = `embedded-unit-card ${conn.type}`;
                card.dataset.entityId = conn.id;

                // Build nested preview chips (show up to 3)
                const previewChips = nestedChildren.slice(0, 3).map(child =>
                    `<span class="embedded-nested-chip" onclick="event.stopPropagation(); openEntityModal('${child.id}', '${child.type}')">
                        <i class="ph ${getEntityIcon(child.type)}"></i>
                        ${child.name}
                    </span>`
                ).join('');

                const moreCount = nestedChildren.length - 3;
                const moreChip = moreCount > 0 ? `<span class="embedded-nested-chip embedded-nested-more">+${moreCount} more</span>` : '';

                card.innerHTML = `
                    <div class="embedded-unit-header">
                        <div class="embedded-unit-icon">
                            <i class="ph ${getEntityIcon(conn.type)}"></i>
                        </div>
                        <div class="embedded-unit-info">
                            <div class="embedded-unit-name">${conn.name}</div>
                            <div class="embedded-unit-type">${conn.type}</div>
                        </div>
                        <div class="embedded-unit-actions">
                            <button class="embedded-unit-btn expand-btn" onclick="event.stopPropagation(); toggleEmbeddedCard(this)" title="Expand details">
                                <i class="ph ph-caret-down"></i>
                            </button>
                            <button class="embedded-unit-btn" onclick="event.stopPropagation(); openEntityModal('${conn.id}', '${conn.type}')" title="Open full modal">
                                <i class="ph ph-arrow-square-out"></i>
                            </button>
                        </div>
                    </div>
                    <div class="embedded-unit-content">
                        ${conn.description ? `<div class="embedded-unit-description">${conn.description}</div>` : ''}
                        <div class="embedded-unit-meta">
                            ${nestedChildren.length > 0 ? `<span class="embedded-unit-stat"><i class="ph ph-tree-structure"></i> ${nestedChildren.length} nested</span>` : ''}
                            ${allRels.length > 0 ? `<span class="embedded-unit-stat"><i class="ph ph-arrows-left-right"></i> ${allRels.length} connections</span>` : ''}
                        </div>
                        ${nestedChildren.length > 0 ? `
                            <div class="embedded-unit-nested-preview">
                                <div class="embedded-nested-label"><i class="ph ph-tree-structure"></i> Contains:</div>
                                <div class="embedded-nested-chips">
                                    ${previewChips}
                                    ${moreChip}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;

                // Click on card header to expand
                card.querySelector('.embedded-unit-header').addEventListener('click', (e) => {
                    if (!e.target.closest('.embedded-unit-btn')) {
                        toggleEmbeddedCard(card.querySelector('.expand-btn'));
                    }
                });

                wrapper.appendChild(card);
            });

            container.appendChild(wrapper);
        }

        // Toggle embedded card expansion
        function toggleEmbeddedCard(btn) {
            const card = btn.closest('.embedded-unit-card');
            card.classList.toggle('expanded');
            const icon = btn.querySelector('i');
            if (card.classList.contains('expanded')) {
                icon.className = 'ph ph-caret-up';
            } else {
                icon.className = 'ph ph-caret-down';
            }
        }

        // Switch between orbital and list views for activities
        function switchActivitiesView(view, entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Get activity entities (non-DES relationships only)
            const activityRelationships = relationships.filter(r =>
                r.predicate !== 'DES' && (r.subject === entityId || r.object === entityId)
            );
            const activityEntities = [];
            activityRelationships.forEach(r => {
                if (r.subject === entityId) {
                    const conn = findEntity(r.object);
                    if (conn && !activityEntities.find(c => c.id === conn.id)) {
                        activityEntities.push(conn);
                    }
                } else if (r.object === entityId) {
                    const conn = findEntity(r.subject);
                    if (conn && !activityEntities.find(c => c.id === conn.id)) {
                        activityEntities.push(conn);
                    }
                }
            });

            // Update toggle buttons in activities section
            const activitiesEl = document.getElementById('modalActivities');
            activitiesEl.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Get container and clear it
            const viewContainer = document.getElementById('activitiesViewContainer');
            if (!viewContainer) return;
            viewContainer.innerHTML = '';

            if (view === 'orbital') {
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'orbital-container';
                viewContainer.appendChild(orbitalContainer);
                setTimeout(() => {
                    renderOrbitalConnections(orbitalContainer, entity, activityEntities, 'activity');
                }, 0);
            } else {
                renderGroupedConnections(viewContainer, activityEntities, entityId);
            }
        }

        // Helper function to get nested children of an entity (DES relationships)
        function getNestedChildren(parentId) {
            return relationships
                .filter(r => r.predicate === 'DES' && r.subject === parentId)
                .map(r => findEntity(r.object))
                .filter(e => e !== null);
        }

        // Render a unit with its nested children recursively
        function renderNestedUnitItem(unit, centerEntityId, depth = 0, visited = new Set()) {
            const itemWrapper = document.createElement('div');
            itemWrapper.className = 'nested-unit-item';
            itemWrapper.style.marginLeft = depth > 0 ? `${depth * 1.25}rem` : '0';

            // Cycle detection: if we've already visited this unit, don't recurse further
            if (visited.has(unit.id)) {
                const badge = document.createElement('div');
                badge.className = 'connection-badge unit-badge';
                badge.innerHTML = `${getIcon(unit.type)} ${unit.name} (circular)`;
                badge.onclick = () => openEntityModal(unit.id, unit.type);
                itemWrapper.appendChild(badge);
                return itemWrapper;
            }

            // Mark this unit as visited
            visited.add(unit.id);

            // Main badge for the unit
            const badge = document.createElement('div');
            badge.className = 'connection-badge unit-badge';
            badge.innerHTML = `${getIcon(unit.type)} ${unit.name}`;
            badge.onclick = () => openEntityModal(unit.id, unit.type);
            itemWrapper.appendChild(badge);

            // Get nested children of this unit
            const children = getNestedChildren(unit.id);

            if (children.length > 0) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'nested-children';

                // Group children by type
                const childUnits = children.filter(c => c.type === 'unit');
                const childTeams = children.filter(c => c.type === 'team');
                const childRoles = children.filter(c => c.type === 'role');

                // Render child units recursively
                childUnits.forEach(childUnit => {
                    childrenContainer.appendChild(renderNestedUnitItem(childUnit, centerEntityId, depth + 1, visited));
                });

                // Render child teams
                childTeams.forEach(team => {
                    const teamItem = document.createElement('div');
                    teamItem.className = 'nested-unit-item';
                    teamItem.style.marginLeft = `${(depth + 1) * 1.25}rem`;

                    const teamBadge = document.createElement('div');
                    teamBadge.className = 'connection-badge team-badge';
                    teamBadge.innerHTML = `${getIcon(team.type)} ${team.name}`;
                    teamBadge.onclick = () => openEntityModal(team.id, team.type);
                    teamItem.appendChild(teamBadge);

                    // Get roles under the team
                    const teamRoles = getNestedChildren(team.id).filter(c => c.type === 'role');
                    if (teamRoles.length > 0) {
                        const teamRolesContainer = document.createElement('div');
                        teamRolesContainer.className = 'nested-children';
                        teamRoles.forEach(role => {
                            const roleItem = document.createElement('div');
                            roleItem.className = 'nested-unit-item';
                            roleItem.style.marginLeft = `${(depth + 2) * 1.25}rem`;

                            const roleBadge = document.createElement('div');
                            roleBadge.className = 'connection-badge role-badge';
                            roleBadge.innerHTML = `${getIcon(role.type)} ${role.name}`;
                            roleBadge.onclick = () => openEntityModal(role.id, role.type);
                            roleItem.appendChild(roleBadge);
                            teamRolesContainer.appendChild(roleItem);
                        });
                        teamItem.appendChild(teamRolesContainer);
                    }

                    childrenContainer.appendChild(teamItem);
                });

                // Render direct child roles (not under a team)
                childRoles.forEach(role => {
                    const roleItem = document.createElement('div');
                    roleItem.className = 'nested-unit-item';
                    roleItem.style.marginLeft = `${(depth + 1) * 1.25}rem`;

                    const roleBadge = document.createElement('div');
                    roleBadge.className = 'connection-badge role-badge';
                    roleBadge.innerHTML = `${getIcon(role.type)} ${role.name}`;
                    roleBadge.onclick = () => openEntityModal(role.id, role.type);
                    roleItem.appendChild(roleBadge);
                    childrenContainer.appendChild(roleItem);
                });

                itemWrapper.appendChild(childrenContainer);
            }

            return itemWrapper;
        }

        // Render grouped connections (fallback for many items)
        function renderGroupedConnections(container, connections, centerEntityId) {
            const typeLabels = {
                unit: { label: 'Units', icon: 'ph-buildings' },
                team: { label: 'Teams', icon: 'ph-users-three' },
                role: { label: 'Roles', icon: 'ph-briefcase' },
                person: { label: 'People', icon: 'ph-user' },
                object: { label: 'Work Products', icon: 'ph-package' }
            };

            // Group by type
            const grouped = {};
            connections.forEach(conn => {
                if (!grouped[conn.type]) grouped[conn.type] = [];
                grouped[conn.type].push(conn);
            });

            const wrapper = document.createElement('div');
            wrapper.className = 'connections-grouped';

            Object.keys(typeLabels).forEach(type => {
                if (grouped[type] && grouped[type].length > 0) {
                    const group = document.createElement('div');
                    group.className = 'connection-group';

                    const title = document.createElement('div');
                    title.className = 'connection-group-title';
                    title.innerHTML = `<i class="ph ${typeLabels[type].icon}"></i> ${typeLabels[type].label}`;
                    group.appendChild(title);

                    const items = document.createElement('div');
                    items.className = 'connection-group-items';

                    // For units, render hierarchically with nested children
                    if (type === 'unit') {
                        items.className = 'connection-group-items nested-hierarchy';
                        grouped[type].forEach(conn => {
                            items.appendChild(renderNestedUnitItem(conn, centerEntityId, 0));
                        });
                    } else {
                        // For other types, render as flat badges with remove button
                        grouped[type].forEach(conn => {
                            const badge = document.createElement('div');
                            badge.className = 'connection-badge';

                            const badgeContent = document.createElement('span');
                            badgeContent.className = 'connection-badge-content';
                            badgeContent.innerHTML = `${getIcon(conn.type)} ${conn.name}`;
                            badgeContent.onclick = () => openEntityModal(conn.id, conn.type);
                            badge.appendChild(badgeContent);

                            const removeBtn = document.createElement('button');
                            removeBtn.className = 'connection-remove-btn';
                            removeBtn.innerHTML = '<i class="ph ph-x"></i>';
                            removeBtn.title = 'Remove connection';
                            removeBtn.onclick = (e) => {
                                e.stopPropagation();
                                removeActivityConnection(centerEntityId, conn.id);
                            };
                            badge.appendChild(removeBtn);

                            items.appendChild(badge);
                        });
                    }

                    group.appendChild(items);
                    wrapper.appendChild(group);
                }
            });

            container.appendChild(wrapper);
        }

        // Helper function to get all entities for modal dropdown (excluding current entity)
        // excludeWorkProducts: if true, work products won't be shown (e.g., for person entities)
        function getAllEntitiesForModal(excludeId, excludeWorkProducts = false) {
            let options = '';
            let entityTypes = ['unit', 'team', 'role', 'person', 'object'];

            // Exclude work products if specified (e.g., for person entities)
            if (excludeWorkProducts) {
                entityTypes = entityTypes.filter(t => t !== 'object');
            }

            const typeLabels = {
                unit: 'Units',
                team: 'Teams',
                role: 'Roles',
                person: 'People',
                object: 'Work Products'
            };

            entityTypes.forEach(type => {
                const typeEntities = entities[type].filter(e => e.id !== excludeId);
                if (typeEntities.length > 0) {
                    options += `<optgroup label="${typeLabels[type]}">`;
                    typeEntities.forEach(e => {
                        // For roles, add team context for disambiguation
                        let displayName = e.name;
                        if (type === 'role') {
                            const parentTeam = getRoleParentTeam(e.id);
                            if (parentTeam) {
                                displayName = `${e.name} (${parentTeam.name})`;
                            }
                        }
                        options += `<option value="${e.id}">${displayName}</option>`;
                    });
                    options += '</optgroup>';
                }
            });

            return options;
        }

        // Add connection from modal
        function addConnectionFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = document.getElementById('modalOperatorSelect').value;
            const targetId = document.getElementById('modalTargetSelect').value;

            if (!operatorCode || !targetId) {
                alert('Please select both an operator and a target entity');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Validate connection
            const validationError = validateConnection(currentModalEntity, targetEntity, operatorCode);
            if (validationError) {
                alert(validationError);
                return;
            }

            // Create the relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[operatorCode];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${currentModalEntity.name} → ${targetEntity.name}`
            });

            // Log to Xano
            logActivityToXano({
                event_verb: `${operatorData.label} Connection`,
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new connection
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Helper function to get entities that can be nested under the current entity
        function getAllEntitiesForNesting(excludeId, entityType) {
            let options = '';
            // Define what can be nested under each entity type
            const nestableTypes = {
                unit: ['unit', 'team', 'role'], // Units can contain sub-units, teams, and roles
                team: ['team', 'role'],          // Teams can contain sub-teams and roles
                role: [],                         // Roles cannot contain other entities
                person: [],                       // People cannot contain other entities
                object: []                        // Objects cannot contain other entities
            };

            const typeLabels = {
                unit: 'Units',
                team: 'Teams',
                role: 'Roles'
            };

            const allowedTypes = nestableTypes[entityType] || [];

            allowedTypes.forEach(type => {
                const typeEntities = entities[type].filter(e => {
                    // Exclude the current entity
                    if (e.id === excludeId) return false;
                    // Exclude entities already nested under this one
                    const alreadyNested = relationships.some(r =>
                        r.predicate === 'DES' && r.subject === excludeId && r.object === e.id
                    );
                    return !alreadyNested;
                });
                if (typeEntities.length > 0) {
                    options += `<optgroup label="${typeLabels[type]}">`;
                    typeEntities.forEach(e => {
                        // For roles, add team context for disambiguation
                        let displayName = e.name;
                        if (type === 'role') {
                            const parentTeam = getRoleParentTeam(e.id);
                            if (parentTeam) {
                                displayName = `${e.name} (${parentTeam.name})`;
                            }
                        }
                        options += `<option value="${e.id}">${displayName}</option>`;
                    });
                    options += '</optgroup>';
                }
            });

            return options;
        }

        // Get valid parent entities that this entity can be nested under
        function getParentOptionsForNesting(entityId, entityType) {
            let options = '';
            // Define what can contain each entity type (inverse of nestableTypes)
            const parentTypes = {
                unit: ['unit'],          // Units can be nested under other units
                team: ['unit', 'team'],  // Teams can be nested under units or other teams
                role: ['unit', 'team'],  // Roles can be nested under units or teams
                person: [],              // People don't get nested
                object: []               // Objects don't get nested
            };

            const typeLabels = {
                unit: 'Units',
                team: 'Teams'
            };

            const allowedTypes = parentTypes[entityType] || [];

            allowedTypes.forEach(type => {
                const typeEntities = entities[type].filter(e => {
                    // Exclude the current entity
                    if (e.id === entityId) return false;
                    // Exclude entities that this is already nested under
                    const alreadyNestedUnder = relationships.some(r =>
                        r.predicate === 'DES' && r.subject === e.id && r.object === entityId
                    );
                    return !alreadyNestedUnder;
                });
                if (typeEntities.length > 0) {
                    options += `<optgroup label="${typeLabels[type]}">`;
                    typeEntities.forEach(e => {
                        options += `<option value="${e.id}">${e.name}</option>`;
                    });
                    options += '</optgroup>';
                }
            });

            return options;
        }

        // Nest this entity under a parent (creates DES relationship with parent as subject)
        function nestUnderFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const parentId = document.getElementById('modalNestUnderSelect').value;

            if (!parentId) {
                alert('Please select a parent to nest under');
                return;
            }

            const parentEntity = findEntity(parentId);
            if (!parentEntity) {
                alert('Parent entity not found');
                return;
            }

            // Create the DES relationship (parent defines/contains this entity)
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: parentId,
                predicate: 'DES',
                object: currentModalEntity.id,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Nest ${currentModalEntity.name} under ${parentEntity.name}`
            });

            // Log to Xano
            const operatorData = eoOperators['DES'];
            logActivityToXano({
                event_verb: 'Nest Entity',
                eo_operator: 'DES',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${parentEntity.name} contains ${currentModalEntity.name}`,
                data_json: {
                    subject_id: parentId,
                    subject_type: parentEntity.type,
                    subject_name: parentEntity.name,
                    predicate: 'DES',
                    predicate_label: operatorData.label,
                    object_id: currentModalEntity.id,
                    object_type: currentModalEntityType,
                    object_name: currentModalEntity.name,
                    connection_type: 'nesting'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new nesting
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Add nested entity from modal (creates DES relationship)
        // Toggle inline nested form visibility
        function toggleInlineNestedForm() {
            const form = document.getElementById('inlineNestedForm');
            if (form) {
                form.classList.toggle('hidden');
            }
        }

        // Toggle inline activity form visibility
        function toggleInlineActivityForm() {
            const form = document.getElementById('inlineActivityForm');
            if (form) {
                form.classList.toggle('hidden');
            }
        }

        // Toggle inline parent form visibility
        function toggleInlineParentForm() {
            const form = document.getElementById('inlineParentForm');
            if (form) {
                form.classList.toggle('hidden');
            }
        }

        // Toggle inline role assignment form visibility
        function toggleInlineRoleAssignForm() {
            const form = document.getElementById('inlineRoleAssignForm');
            if (form) {
                form.classList.toggle('hidden');
            }
        }

        // Remove parent relationship (unlink from parent)
        function removeParentRelationship(childId, parentId) {
            // Find and remove the DES relationship where child is subject and parent is object
            const relIndex = relationships.findIndex(r =>
                r.predicate === 'DES' && r.subject === childId && r.object === parentId
            );

            if (relIndex !== -1) {
                const removedRel = relationships.splice(relIndex, 1)[0];

                // Log to Xano
                logToXano({ action: 'delete_relationship', data: removedRel });

                // Refresh views
                render();
                // Use currentModalEntityType since this is called from the modal context
                openEntityModal(childId, currentModalEntityType);
            }
        }

        // Remove an activity connection (non-DES relationship) between two entities
        function removeActivityConnection(entityId, connectedId) {
            // Find the non-DES relationship between these entities (in either direction)
            const relIndex = relationships.findIndex(r =>
                r.predicate !== 'DES' && (
                    (r.subject === entityId && r.object === connectedId) ||
                    (r.subject === connectedId && r.object === entityId)
                )
            );

            if (relIndex !== -1) {
                const removedRel = relationships.splice(relIndex, 1)[0];

                // Log to Xano
                logToXano({ action: 'delete_relationship', data: removedRel });

                // Refresh views
                render();
                // Refresh the modal to show updated connections
                openEntityModal(entityId, currentModalEntityType);
            }
        }

        // Add nested from inline form (mobile)
        function addNestedFromInline() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const targetId = document.getElementById('inlineNestedSelect')?.value;
            if (!targetId) {
                alert('Please select an entity to nest');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Create the DES relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: 'DES',
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Nest ${targetEntity.name} under ${currentModalEntity.name}`
            });

            // Log to Xano
            const operatorData = eoOperators['DES'];
            logActivityToXano({
                event_verb: 'Nest Entity',
                eo_operator: 'DES',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} contains ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: 'DES',
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name,
                    connection_type: 'nesting'
                }
            });

            saveToLocalStorage();
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            }
        }

        // Add activity from inline form (mobile)
        function addActivityFromInline() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = document.getElementById('inlineOperatorSelect')?.value;
            const targetId = document.getElementById('inlineTargetSelect')?.value;

            if (!operatorCode || !targetId) {
                alert('Please select both a type and target');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[operatorCode];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${currentModalEntity.name} → ${targetEntity.name}`
            });

            logActivityToXano({
                event_verb: 'Create Relationship',
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name
                }
            });

            saveToLocalStorage();
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            if (currentView === 'graph') {
                updateGraph();
            }
        }

        function addNestedFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const targetId = document.getElementById('modalNestedTargetSelect').value;

            if (!targetId) {
                alert('Please select an entity to nest');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Create the DES relationship (current entity defines/contains the target)
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: 'DES',
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Nest ${targetEntity.name} under ${currentModalEntity.name}`
            });

            // Log to Xano
            const operatorData = eoOperators['DES'];
            logActivityToXano({
                event_verb: 'Nest Entity',
                eo_operator: 'DES',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} contains ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: 'DES',
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name,
                    connection_type: 'nesting'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new nesting
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Add activity from modal (creates non-DES relationship)
        function addActivityFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = document.getElementById('modalOperatorSelect').value;
            const targetId = document.getElementById('modalTargetSelect').value;

            if (!operatorCode || !targetId) {
                alert('Please select both an activity type and a target entity');
                return;
            }

            // DES should not be used here - it's for nesting
            if (operatorCode === 'DES') {
                alert('Use "Add Nested" for hierarchical relationships');
                return;
            }

            const targetEntity = findEntity(targetId);
            if (!targetEntity) {
                alert('Target entity not found');
                return;
            }

            // Validate connection
            const validationError = validateConnection(currentModalEntity, targetEntity, operatorCode);
            if (validationError) {
                alert(validationError);
                return;
            }

            // Create the relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: targetId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[operatorCode];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${currentModalEntity.name} → ${targetEntity.name}`
            });

            // Log to Xano
            logActivityToXano({
                event_verb: `${operatorData.label} Activity`,
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${targetEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: targetId,
                    object_type: targetEntity.type,
                    object_name: targetEntity.name,
                    connection_type: 'activity'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new activity
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Get the parent team of a role (via DES relationship)
        function getRoleParentTeam(roleId) {
            const desRelationship = relationships.find(r =>
                r.predicate === 'DES' && r.object === roleId
            );
            if (!desRelationship) return null;
            const parent = findEntity(desRelationship.subject);
            if (parent && (parent.type === 'team' || parent.type === 'unit')) {
                return parent;
            }
            return null;
        }

        // Group roles by their parent team
        function groupRolesByTeam(roles) {
            const groups = {};
            const unassigned = [];

            roles.forEach(role => {
                const parent = getRoleParentTeam(role.id);
                if (parent) {
                    if (!groups[parent.id]) {
                        groups[parent.id] = {
                            team: parent,
                            roles: []
                        };
                    }
                    groups[parent.id].roles.push(role);
                } else {
                    unassigned.push(role);
                }
            });

            return { groups: Object.values(groups), unassigned };
        }

        // Generate custom role dropdown HTML with team groupings
        function generateRoleDropdownHTML(availableRoles) {
            const { groups, unassigned } = groupRolesByTeam(availableRoles);

            let menuHtml = '';

            // Sort groups by team name
            groups.sort((a, b) => a.team.name.localeCompare(b.team.name));

            groups.forEach(group => {
                const teamIcon = group.team.type === 'unit' ? 'ph-buildings' : 'ph-users-three';
                menuHtml += `
                    <div class="role-dropdown-team">
                        <div class="role-dropdown-team-header">
                            <i class="ph ${teamIcon}"></i> ${group.team.name}
                        </div>
                        ${group.roles.map(role => `
                            <div class="role-dropdown-item" data-role-id="${role.id}" onclick="selectRoleFromDropdown('${role.id}', '${role.name.replace(/'/g, "\\'")}')">
                                <i class="ph ph-briefcase"></i> ${role.name}
                            </div>
                        `).join('')}
                    </div>
                `;
            });

            // Add unassigned roles if any
            if (unassigned.length > 0) {
                menuHtml += `
                    <div class="role-dropdown-team role-dropdown-unassigned">
                        <div class="role-dropdown-team-header">
                            <i class="ph ph-briefcase"></i> Other Roles
                        </div>
                        ${unassigned.map(role => `
                            <div class="role-dropdown-item" data-role-id="${role.id}" onclick="selectRoleFromDropdown('${role.id}', '${role.name.replace(/'/g, "\\'")}')">
                                <i class="ph ph-briefcase"></i> ${role.name}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            return `
                <div class="role-dropdown-container">
                    <input type="hidden" id="inlineRoleSelect" value="">
                    <div class="role-dropdown-trigger" onclick="toggleRoleDropdown(event)">
                        <span class="trigger-text">
                            <i class="ph ph-briefcase"></i> Select role...
                        </span>
                        <i class="ph ph-caret-down trigger-arrow"></i>
                    </div>
                    <div class="role-dropdown-menu" id="roleDropdownMenu">
                        ${menuHtml}
                    </div>
                </div>
            `;
        }

        // Toggle the role dropdown open/close
        function toggleRoleDropdown(event) {
            event.stopPropagation();
            const trigger = event.currentTarget;
            const menu = document.getElementById('roleDropdownMenu');
            const isOpen = trigger.classList.contains('open');

            // Close any other open dropdowns first
            document.querySelectorAll('.role-dropdown-trigger.open').forEach(t => {
                t.classList.remove('open');
            });
            document.querySelectorAll('.role-dropdown-menu.open').forEach(m => {
                m.classList.remove('open');
            });

            if (!isOpen) {
                trigger.classList.add('open');
                menu.classList.add('open');

                // Close on outside click
                setTimeout(() => {
                    document.addEventListener('click', closeRoleDropdownOnOutsideClick);
                }, 0);
            }
        }

        // Close dropdown when clicking outside
        function closeRoleDropdownOnOutsideClick(event) {
            const container = event.target.closest('.role-dropdown-container');
            if (!container) {
                document.querySelectorAll('.role-dropdown-trigger.open').forEach(t => {
                    t.classList.remove('open');
                });
                document.querySelectorAll('.role-dropdown-menu.open').forEach(m => {
                    m.classList.remove('open');
                });
                document.removeEventListener('click', closeRoleDropdownOnOutsideClick);
            }
        }

        // Select a role from the dropdown
        function selectRoleFromDropdown(roleId, roleName) {
            // Update hidden input
            document.getElementById('inlineRoleSelect').value = roleId;

            // Update trigger text
            const trigger = document.querySelector('.role-dropdown-trigger');
            const triggerText = trigger.querySelector('.trigger-text');
            triggerText.innerHTML = `<i class="ph ph-briefcase"></i> ${roleName}`;
            triggerText.classList.add('has-selection');

            // Close dropdown
            trigger.classList.remove('open');
            document.getElementById('roleDropdownMenu').classList.remove('open');
            document.removeEventListener('click', closeRoleDropdownOnOutsideClick);
        }

        // Assign person to role from modal (creates INS relationship)
        function assignPersonToRoleFromModal() {
            if (!currentModalEntity || currentModalEntityType !== 'person') return;

            // Try inline select first, fall back to tab select
            const inlineSelect = document.getElementById('inlineRoleSelect');
            const tabSelect = document.getElementById('modalRoleSelect');
            const roleId = (inlineSelect && inlineSelect.value) || (tabSelect && tabSelect.value);

            if (!roleId) {
                alert('Please select a role to assign');
                return;
            }

            const roleEntity = findEntity(roleId);
            if (!roleEntity) {
                alert('Role not found');
                return;
            }

            // Check if already assigned to this role
            const alreadyAssigned = relationships.some(r =>
                r.predicate === 'INS' && r.subject === currentModalEntity.id && r.object === roleId
            );
            if (alreadyAssigned) {
                alert('This person is already assigned to this role');
                return;
            }

            // Create the INS relationship (person assigned to role)
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: 'INS',
                object: roleId,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Assigned: ${currentModalEntity.name} → ${roleEntity.name}`
            });

            // Log to Xano
            logActivityToXano({
                event_verb: 'Assign to Role',
                eo_operator: 'INS',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} assigned to ${roleEntity.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: 'person',
                    subject_name: currentModalEntity.name,
                    predicate: 'INS',
                    predicate_label: 'Assign',
                    object_id: roleId,
                    object_type: 'role',
                    object_name: roleEntity.name,
                    connection_type: 'role_assignment'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new assignment
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            } else if (currentView === 'orgchart') {
                renderOrgChartView();
            }

            renderActivityList();
        }

        // Remove role assignment from person
        function removeRoleAssignment(relationshipId) {
            const relationship = relationships.find(r => r.id === relationshipId);
            if (!relationship) return;

            const person = findEntity(relationship.subject);
            const role = findEntity(relationship.object);

            // Remove the relationship
            const index = relationships.findIndex(r => r.id === relationshipId);
            if (index !== -1) {
                relationships.splice(index, 1);
            }

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Unassigned: ${person?.name || 'Person'} from ${role?.name || 'Role'}`
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal if still open
            if (currentModalEntity && currentModalEntityType === 'person') {
                openEntityModal(currentModalEntity.id, currentModalEntityType);
            }

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            } else if (currentView === 'orgchart') {
                renderOrgChartView();
            }

            renderActivityList();
        }

        // Assign person to role from role modal (creates INS relationship)
        function assignPersonToRoleFromRoleModal() {
            if (!currentModalEntity || currentModalEntityType !== 'role') return;

            const personId = document.getElementById('roleModalPersonSelect').value;

            if (!personId) {
                alert('Please select a person to assign');
                return;
            }

            const personEntity = findEntity(personId);
            if (!personEntity) {
                alert('Person not found');
                return;
            }

            // Check if already assigned to this role
            const alreadyAssigned = relationships.some(r =>
                r.predicate === 'INS' && r.subject === personId && r.object === currentModalEntity.id
            );
            if (alreadyAssigned) {
                alert('This person is already assigned to this role');
                return;
            }

            // Create the INS relationship (person assigned to role)
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: personId,
                predicate: 'INS',
                object: currentModalEntity.id,
                description: ''
            };

            relationships.push(relationship);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Assigned: ${personEntity.name} → ${currentModalEntity.name}`
            });

            // Log to Xano
            logActivityToXano({
                event_verb: 'Assign to Role',
                eo_operator: 'INS',
                object_type: 'relationship',
                object_id: relId,
                object_label: `${personEntity.name} assigned to ${currentModalEntity.name}`,
                data_json: {
                    subject_id: personId,
                    subject_type: 'person',
                    subject_name: personEntity.name,
                    predicate: 'INS',
                    predicate_label: 'Assign',
                    object_id: currentModalEntity.id,
                    object_type: 'role',
                    object_name: currentModalEntity.name,
                    connection_type: 'role_assignment'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new assignment
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            } else if (currentView === 'orgchart') {
                renderOrgChartView();
            }

            renderActivityList();
        }

        // Remove person from role (called from role modal)
        function removePersonFromRole(relationshipId, event) {
            if (event) {
                event.stopPropagation();
            }

            const relationship = relationships.find(r => r.id === relationshipId);
            if (!relationship) return;

            const person = findEntity(relationship.subject);
            const role = findEntity(relationship.object);

            // Remove the relationship
            const index = relationships.findIndex(r => r.id === relationshipId);
            if (index !== -1) {
                relationships.splice(index, 1);
            }

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Unassigned: ${person?.name || 'Person'} from ${role?.name || 'Role'}`
            });

            // Log to Xano
            logActivityToXano({
                event_verb: 'Remove from Role',
                eo_operator: 'INS',
                object_type: 'relationship',
                object_id: relationshipId,
                object_label: `${person?.name || 'Person'} removed from ${role?.name || 'Role'}`,
                data_json: {
                    subject_id: relationship.subject,
                    subject_type: 'person',
                    subject_name: person?.name,
                    predicate: 'INS',
                    predicate_label: 'Remove',
                    object_id: relationship.object,
                    object_type: 'role',
                    object_name: role?.name,
                    connection_type: 'role_assignment_removal'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal if still open
            if (currentModalEntity && currentModalEntityType === 'role') {
                openEntityModal(currentModalEntity.id, currentModalEntityType);
            }

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            } else if (currentView === 'orgchart') {
                renderOrgChartView();
            }

            renderActivityList();
        }

        // Inline Editing Functions for Modal Fields
        function startInlineNameEdit() {
            if (!currentModalEntity) return;
            document.getElementById('modalTitleDisplay').style.display = 'none';
            document.getElementById('modalTitleEditForm').classList.add('active');
            const input = document.getElementById('inlineNameInput');
            input.value = currentModalEntity.name;
            setTimeout(() => {
                input.focus();
                input.select();
            }, 50);
        }

        function cancelInlineNameEdit() {
            document.getElementById('modalTitleDisplay').style.display = 'flex';
            document.getElementById('modalTitleEditForm').classList.remove('active');
        }

        function handleInlineNameKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                saveInlineName();
            } else if (event.key === 'Escape') {
                cancelInlineNameEdit();
            }
        }

        function saveInlineName() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const newName = document.getElementById('inlineNameInput').value.trim();
            if (!newName) {
                cancelInlineNameEdit();
                return;
            }

            const nameChanged = newName !== currentModalEntity.name;
            if (!nameChanged) {
                cancelInlineNameEdit();
                return;
            }

            const currentName = currentModalEntity.name;

            // Track in undo history
            pushToUndoHistory({
                type: 'update_entity',
                entityType: currentModalEntityType,
                data: { id: currentModalEntity.id },
                oldData: { name: currentName, description: currentModalEntity.description || '' },
                description: `Rename ${currentModalEntityType}: ${currentName} → ${newName}`
            });

            // Update entity
            currentModalEntity.name = newName;

            // Log to Xano
            logActivityToXano({
                event_verb: 'Shift Entity',
                eo_operator: 'ALT',
                object_type: currentModalEntityType,
                object_id: currentModalEntity.id,
                object_label: `${currentName} → ${newName}`,
                data_json: {
                    old_name: currentName,
                    new_name: newName,
                    entity_type: currentModalEntityType
                }
            });

            // Update display
            document.getElementById('modalEntityName').textContent = newName;
            cancelInlineNameEdit();

            // Save and refresh views
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function startInlineDescEdit() {
            if (!currentModalEntity) return;
            document.getElementById('modalDescriptionDisplay').style.display = 'none';
            document.getElementById('modalDescriptionEditForm').classList.add('active');
            const textarea = document.getElementById('inlineDescInput');
            textarea.value = currentModalEntity.description || '';
            updateInlineDescCharCount();
            setTimeout(() => {
                textarea.focus();
            }, 50);
        }

        function cancelInlineDescEdit() {
            document.getElementById('modalDescriptionDisplay').style.display = 'block';
            document.getElementById('modalDescriptionEditForm').classList.remove('active');
        }

        function updateInlineDescCharCount() {
            const textarea = document.getElementById('inlineDescInput');
            const count = document.getElementById('inlineDescCharCount');
            if (textarea && count) {
                count.textContent = textarea.value.length;
            }
        }

        function saveInlineDesc() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const newDesc = document.getElementById('inlineDescInput').value.trim();
            const currentDesc = currentModalEntity.description || '';
            const descChanged = newDesc !== currentDesc;

            if (!descChanged) {
                cancelInlineDescEdit();
                return;
            }

            // Track in undo history
            pushToUndoHistory({
                type: 'update_entity',
                entityType: currentModalEntityType,
                data: { id: currentModalEntity.id },
                oldData: { name: currentModalEntity.name, description: currentDesc },
                description: `Update description for ${currentModalEntityType}: ${currentModalEntity.name}`
            });

            // Update entity
            currentModalEntity.description = newDesc;

            // Log to Xano
            logActivityToXano({
                event_verb: 'Shift Description',
                eo_operator: 'ALT',
                object_type: currentModalEntityType,
                object_id: currentModalEntity.id,
                object_label: `Updated description for ${currentModalEntity.name}`,
                data_json: {
                    entity_name: currentModalEntity.name,
                    old_description: currentDesc,
                    new_description: newDesc,
                    entity_type: currentModalEntityType
                }
            });

            // Update display
            const displayEl = document.getElementById('modalDescriptionDisplay');
            if (newDesc) {
                displayEl.className = 'modal-description-display modal-description-text';
                displayEl.innerHTML = `
                    ${newDesc}
                    <span class="edit-hint-desc"><i class="ph ph-pencil-simple"></i> edit</span>
                `;
            } else {
                displayEl.className = 'modal-description-display modal-description-empty';
                displayEl.innerHTML = `
                    No description yet. Click to add one.
                    <span class="edit-hint-desc"><i class="ph ph-pencil-simple"></i> edit</span>
                `;
            }
            cancelInlineDescEdit();

            // Save and refresh views
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        // Entity Edit Modal Functions
        function openEntityEditModal() {
            if (!currentModalEntity) return;

            document.getElementById('entityEditNameInput').value = currentModalEntity.name;
            document.getElementById('entityEditDescInput').value = currentModalEntity.description || '';
            updateEditDescCharCount();
            document.getElementById('entityEditModal').classList.add('open');

            // Focus and select the input
            setTimeout(() => {
                const input = document.getElementById('entityEditNameInput');
                input.focus();
                input.select();
            }, 100);
        }

        function updateEditDescCharCount() {
            const textarea = document.getElementById('entityEditDescInput');
            const count = document.getElementById('editDescCharCount');
            if (textarea && count) {
                count.textContent = textarea.value.length;
            }
        }

        function closeEntityEditModal() {
            document.getElementById('entityEditModal').classList.remove('open');
        }

        function saveEntityEdit() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const newName = document.getElementById('entityEditNameInput').value.trim();
            const newDesc = document.getElementById('entityEditDescInput').value.trim();

            if (!newName) {
                closeEntityEditModal();
                return;
            }

            const nameChanged = newName !== currentModalEntity.name;
            const descChanged = newDesc !== (currentModalEntity.description || '');

            if (!nameChanged && !descChanged) {
                closeEntityEditModal();
                return;
            }

            const currentName = currentModalEntity.name;
            const currentDesc = currentModalEntity.description || '';

            // Track in undo history before making changes
            pushToUndoHistory({
                type: 'update_entity',
                entityType: currentModalEntityType,
                data: { id: currentModalEntity.id },
                oldData: { name: currentName, description: currentDesc },
                description: `Edit ${currentModalEntityType}: ${currentName}${nameChanged ? ` → ${newName}` : ''}`
            });

            // Update entity
            currentModalEntity.name = newName;
            currentModalEntity.description = newDesc;

            // Log to Xano with consistent field tracking
            if (nameChanged) {
                logActivityToXano({
                    event_verb: 'Update Name',
                    eo_operator: 'ALT',
                    object_type: currentModalEntityType,
                    object_id: currentModalEntity.id,
                    object_label: newName,
                    data_json: {
                        field: 'name',
                        old_value: currentName,
                        new_value: newName
                    }
                });
            }

            if (descChanged) {
                logActivityToXano({
                    event_verb: 'Update Description',
                    eo_operator: 'ALT',
                    object_type: currentModalEntityType,
                    object_id: currentModalEntity.id,
                    object_label: newName,
                    data_json: {
                        field: 'description',
                        old_value: currentDesc,
                        new_value: newDesc
                    }
                });
            }

            // Close edit modal and update main modal
            closeEntityEditModal();
            document.getElementById('modalEntityName').textContent = newName;

            // Update description display in modal with inline editing support
            const descriptionEl = document.getElementById('modalDescription');
            const descCharCount = newDesc.length;
            descriptionEl.innerHTML = `
                <div class="modal-section-title"><i class="ph ph-text-align-left"></i> Description</div>
                <div class="modal-description-display ${newDesc ? 'modal-description-text' : 'modal-description-empty'}"
                     id="modalDescriptionDisplay" onclick="startInlineDescEdit()">
                    ${newDesc || 'No description yet. Click to add one.'}
                    <span class="edit-hint-desc"><i class="ph ph-pencil-simple"></i> edit</span>
                </div>
                <div class="modal-description-edit-form" id="modalDescriptionEditForm">
                    <textarea id="inlineDescInput" maxlength="240" placeholder="Add a description..."
                              oninput="updateInlineDescCharCount()">${newDesc}</textarea>
                    <div class="desc-edit-footer">
                        <span class="char-count"><span id="inlineDescCharCount">${descCharCount}</span>/240</span>
                        <div class="desc-edit-actions">
                            <button class="desc-edit-btn cancel" onclick="cancelInlineDescEdit()">
                                <i class="ph ph-x"></i> Cancel
                            </button>
                            <button class="desc-edit-btn save" onclick="saveInlineDesc()">
                                <i class="ph ph-check"></i> Save
                            </button>
                        </div>
                    </div>
                </div>
            `;

            // Save and refresh views
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+Z or Cmd+Z for undo (without Shift)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                // Don't trigger undo if user is typing in an input field
                const activeElement = document.activeElement;
                const isInputField = activeElement.tagName === 'INPUT' ||
                                   activeElement.tagName === 'TEXTAREA' ||
                                   activeElement.isContentEditable;
                if (!isInputField) {
                    e.preventDefault();
                    undo();
                }
            }

            // Ctrl+Shift+Z or Cmd+Shift+Z for redo (also Ctrl+Y / Cmd+Y)
            if (((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) ||
                ((e.ctrlKey || e.metaKey) && e.key === 'y')) {
                // Don't trigger redo if user is typing in an input field
                const activeElement = document.activeElement;
                const isInputField = activeElement.tagName === 'INPUT' ||
                                   activeElement.tagName === 'TEXTAREA' ||
                                   activeElement.isContentEditable;
                if (!isInputField) {
                    e.preventDefault();
                    redo();
                }
            }

            // Enter key for edit modal
            if (e.key === 'Enter' && document.getElementById('entityEditModal').classList.contains('open')) {
                saveEntityEdit();
            }

            // Escape key for closing modals
            if (e.key === 'Escape') {
                if (document.getElementById('deleteConfirmModal').classList.contains('open')) {
                    closeDeleteConfirmModal();
                } else if (document.getElementById('entityEditModal').classList.contains('open')) {
                    closeEntityEditModal();
                } else if (document.getElementById('entityModal').classList.contains('active')) {
                    closeEntityModal();
                }
            }
        });

        // Delete Confirmation Modal Functions
        function openDeleteConfirmModal() {
            if (!currentModalEntity) return;

            document.getElementById('deleteConfirmTitle').textContent = 'Delete Entity?';
            document.getElementById('deleteConfirmText').textContent =
                `This will permanently remove "${currentModalEntity.name}" and all its nested items and activities.`;
            document.getElementById('deleteConfirmModal').classList.add('open');
        }

        function closeDeleteConfirmModal() {
            document.getElementById('deleteConfirmModal').classList.remove('open');
            relationshipToDelete = null;
        }

        function confirmDelete() {
            // Check if we're deleting a relationship or entity
            if (relationshipToDelete) {
                confirmDeleteRelationship();
            } else if (currentModalEntity) {
                confirmDeleteEntity();
            }
        }

        function confirmDeleteEntity() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const entityId = currentModalEntity.id;
            const entityName = currentModalEntity.name;
            const entityType = currentModalEntityType;

            // Capture entity data before deletion
            const entityData = JSON.parse(JSON.stringify(currentModalEntity));

            // Remove related relationships
            const removedRelationships = relationships.filter(r =>
                r.subject === entityId || r.object === entityId
            );

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_entity',
                entityType: entityType,
                data: entityData,
                deletedRelationships: removedRelationships.map(r => JSON.parse(JSON.stringify(r))),
                description: `Delete ${entityType}: ${entityName}`
            });

            // Add to recycle bin
            addToRecycleBin(entityData, 'entity', entityType, removedRelationships);

            // Remove from entities
            entities[entityType] = entities[entityType].filter(e => e.id !== entityId);

            relationships = relationships.filter(r =>
                r.subject !== entityId && r.object !== entityId
            );

            // Log to Xano
            logActivityToXano({
                event_verb: 'Nullify Entity',
                eo_operator: 'NUL',
                object_type: entityType,
                object_id: entityId,
                object_label: entityName,
                data_json: {
                    entity_name: entityName,
                    entity_type: entityType,
                    removed_relationships: removedRelationships.length
                }
            });

            // Close modals and refresh
            closeDeleteConfirmModal();
            closeEntityModal();
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            renderActivityList();

            // Refresh current view (handles all view types including kanban, table, etc.)
            renderCurrentView();
        }

        // Legacy function - redirect to new modal
        function editEntityFromModal() {
            openEntityEditModal();
        }

        // Store current relationship being edited
        let currentEditingRelationship = null;

        function openRelationshipModal(relationshipData) {
            // Get the actual relationship object from the data
            const rel = relationships.find(r => r.id === relationshipData.id);
            if (!rel) return;

            // Store for editing
            currentEditingRelationship = rel;

            // Clear entity data - this is a relationship, not an entity
            currentModalEntity = null;
            currentModalEntityType = null;

            // Hide entity-specific buttons and inline editing for relationships
            document.getElementById('modalEditButton').style.display = 'none';
            document.getElementById('modalDeleteButton').style.display = 'none';
            // Hide inline editing for title since relationships aren't editable this way
            document.getElementById('modalTitleDisplay').style.pointerEvents = 'none';
            document.getElementById('modalTitleDisplay').querySelector('.edit-hint').style.display = 'none';

            const subject = findEntity(rel.subject);
            const object = findEntity(rel.object);
            const operator = eoOperators[rel.predicate];

            const modal = document.getElementById('entityModal');

            // Set header icon for connection
            document.getElementById('modalEntityIcon').innerHTML = '<i class="ph ph-arrows-left-right"></i>';
            document.getElementById('modalEntityName').innerHTML = `
                ${subject?.name}
                <span style="color: ${operator.color}; font-weight: 600;">${operator.label}</span>
                ${object?.name}
            `;
            document.getElementById('modalEntityType').innerHTML = '<i class="ph ph-link"></i> CONNECTION';

            // Clear description section (relationships don't have descriptions)
            document.getElementById('modalDescription').innerHTML = '';
            document.getElementById('modalNested').innerHTML = '';
            document.getElementById('modalAddNested').innerHTML = '';
            document.getElementById('modalNestUnder').innerHTML = '';

            // Build entity options for dropdowns
            const allEntities = [];
            ['unit', 'team', 'role', 'object'].forEach(type => {
                entities[type].forEach(e => allEntities.push({ ...e, type }));
            });

            const entityOptions = allEntities.map(e =>
                `<option value="${e.id}" ${e.id === rel.subject ? 'selected' : ''}>${e.name} (${e.type})</option>`
            ).join('');

            const entityOptionsTarget = allEntities.map(e =>
                `<option value="${e.id}" ${e.id === rel.object ? 'selected' : ''}>${e.name} (${e.type})</option>`
            ).join('');

            // Build operator options
            const operatorOptions = Object.entries(eoOperators).map(([code, op]) =>
                `<option value="${code}" ${code === rel.predicate ? 'selected' : ''} style="color: ${op.color};">
                    ${op.label} (${code})
                </option>`
            ).join('');

            // Show connection editing form
            const connectionsEl = document.getElementById('modalConnections');
            connectionsEl.innerHTML = `
                <div class="modal-section-title"><i class="ph ph-pencil-simple"></i> Edit Connection</div>
                <div style="background: #FAF7F5; padding: 1rem; border-radius: 8px; border-left: 3px solid ${operator.color};" id="relationshipEditForm">
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: #3D2E1F;">
                            <i class="ph ph-arrow-right"></i> From (Source)
                        </label>
                        <select id="relEditSubject" style="width: 100%; padding: 0.5rem; border: 1px solid #E5DDD1; border-radius: 6px; font-size: 0.9rem;">
                            ${entityOptions}
                        </select>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: #3D2E1F;">
                            <i class="ph ph-flow-arrow"></i> Relationship Type
                        </label>
                        <select id="relEditPredicate" style="width: 100%; padding: 0.5rem; border: 1px solid #E5DDD1; border-radius: 6px; font-size: 0.9rem;" onchange="updateRelEditPreview()">
                            ${operatorOptions}
                        </select>
                        <div id="relEditOperatorDesc" style="margin-top: 0.5rem; font-size: 0.85rem; color: #6B5642;">
                            ${operator.description}
                        </div>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: #3D2E1F;">
                            <i class="ph ph-arrow-left"></i> To (Target)
                        </label>
                        <select id="relEditObject" style="width: 100%; padding: 0.5rem; border: 1px solid #E5DDD1; border-radius: 6px; font-size: 0.9rem;">
                            ${entityOptionsTarget}
                        </select>
                    </div>
                    <button class="modal-action-btn" onclick="saveRelationshipEdit()" style="width: 100%; background: #C88F4A; color: white; margin-top: 0.5rem;">
                        <i class="ph ph-check"></i> Save Changes
                    </button>
                </div>
            `;

            // Show delete action in activities section
            const activitiesEl = document.getElementById('modalActivities');
            activitiesEl.innerHTML = `
                <div class="modal-section-title"><i class="ph ph-gear"></i> Actions</div>
                <button class="modal-action-btn danger" onclick="deleteRelationship('${rel.id}')" style="width: 100%;">
                    <i class="ph ph-trash"></i>
                    Delete Connection
                </button>
            `;

            modal.classList.add('active');
        }

        function updateRelEditPreview() {
            const predicateSelect = document.getElementById('relEditPredicate');
            const descEl = document.getElementById('relEditOperatorDesc');
            if (predicateSelect && descEl) {
                const selectedOp = eoOperators[predicateSelect.value];
                if (selectedOp) {
                    descEl.textContent = selectedOp.description;
                    descEl.style.color = selectedOp.color;
                }
            }
        }

        function saveRelationshipEdit() {
            if (!currentEditingRelationship) return;

            const newSubject = document.getElementById('relEditSubject').value;
            const newPredicate = document.getElementById('relEditPredicate').value;
            const newObject = document.getElementById('relEditObject').value;

            // Validate - can't connect to self
            if (newSubject === newObject) {
                alert('Cannot connect an entity to itself.');
                return;
            }

            // Check for duplicate relationship
            const duplicate = relationships.find(r =>
                r.id !== currentEditingRelationship.id &&
                r.subject === newSubject &&
                r.predicate === newPredicate &&
                r.object === newObject
            );

            if (duplicate) {
                alert('This exact connection already exists.');
                return;
            }

            // Track changes for logging
            const oldSubject = currentEditingRelationship.subject;
            const oldPredicate = currentEditingRelationship.predicate;
            const oldObject = currentEditingRelationship.object;

            const hasChanges = newSubject !== oldSubject ||
                               newPredicate !== oldPredicate ||
                               newObject !== oldObject;

            if (!hasChanges) {
                closeEntityModal();
                return;
            }

            // Track in undo history before making changes
            const oldSubjectEntity = findEntity(oldSubject);
            const oldObjectEntity = findEntity(oldObject);
            const newSubjectEntity = findEntity(newSubject);
            const newObjectEntity = findEntity(newObject);

            pushToUndoHistory({
                type: 'update_relationship',
                data: {
                    id: currentEditingRelationship.id,
                    subject: newSubject,
                    predicate: newPredicate,
                    object: newObject
                },
                oldData: {
                    subject: oldSubject,
                    predicate: oldPredicate,
                    object: oldObject
                },
                description: `Update connection: ${oldSubjectEntity?.name || 'Entity'} → ${newSubjectEntity?.name || 'Entity'}`
            });

            // Apply changes
            currentEditingRelationship.subject = newSubject;
            currentEditingRelationship.predicate = newPredicate;
            currentEditingRelationship.object = newObject;

            // Log to Xano
            logActivityToXano({
                event_verb: 'Shift Connection',
                eo_operator: 'ALT',
                object_type: 'relationship',
                object_id: currentEditingRelationship.id,
                object_label: `${newSubjectEntity?.name} ${newPredicate} ${newObjectEntity?.name}`,
                data_json: {
                    old_subject: oldSubject,
                    new_subject: newSubject,
                    old_predicate: oldPredicate,
                    new_predicate: newPredicate,
                    old_object: oldObject,
                    new_object: newObject
                }
            });

            // Save and refresh
            saveToLocalStorage();
            closeEntityModal();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        let relationshipToDelete = null;

        function deleteRelationship(relId) {
            // Store relationship for confirmation
            relationshipToDelete = relId;
            const rel = relationships.find(r => r.id === relId);
            if (rel) {
                const subject = findEntity(rel.subject);
                const object = findEntity(rel.object);
                document.getElementById('deleteConfirmTitle').textContent = 'Delete Connection?';
                document.getElementById('deleteConfirmText').textContent =
                    `This will permanently remove the connection between "${subject?.name}" and "${object?.name}".`;
            }
            document.getElementById('deleteConfirmModal').classList.add('open');
        }

        function confirmDeleteRelationship() {
            if (!relationshipToDelete) return;

            const rel = relationships.find(r => r.id === relationshipToDelete);
            if (!rel) {
                relationshipToDelete = null;
                closeDeleteConfirmModal();
                return;
            }

            const subject = findEntity(rel.subject);
            const object = findEntity(rel.object);
            const operatorData = eoOperators[rel.predicate];

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_relationship',
                data: JSON.parse(JSON.stringify(rel)),
                description: `Delete ${operatorData?.label || rel.predicate}: ${subject?.name || rel.subject} → ${object?.name || rel.object}`
            });

            // Add to recycle bin
            addToRecycleBin(rel, 'relationship', null);

            relationships = relationships.filter(r => r.id !== relationshipToDelete);

            // Log deletion to Xano
            logActivityToXano({
                event_verb: 'Notice Removal',
                eo_operator: 'NUL',
                object_type: 'relationship',
                object_id: relationshipToDelete,
                object_label: `${subject?.name} → ${object?.name}`,
                data_json: {
                    relationship_deleted: true,
                    subject_id: rel.subject,
                    object_id: rel.object,
                    predicate: rel.predicate
                }
            });

            relationshipToDelete = null;
            closeDeleteConfirmModal();
            closeEntityModal();
            saveToLocalStorage();
            renderActivityList();

            // Refresh current view (handles all view types including kanban, table, etc.)
            renderCurrentView();
        }

        // Sentence Preview
        function updateSentencePreview() {
            const subjectId = document.getElementById('subjectSelect')?.value;
            const orgEntityId = document.getElementById('orgEntitySelect')?.value;
            const objectId = document.getElementById('objectSelect')?.value;
            const preview = document.getElementById('sentencePreview');

            if (!preview) return; // Safety check

            // Show/hide Assign button based on whether subject is a person
            const assignBtn = document.getElementById('assignOperatorBtn');
            const defineBtn = document.querySelector('.operator-btn[data-predicate="DES"]');
            const linkBtn = document.querySelector('.operator-btn[data-predicate="CON"]');
            const orgEntitySelect = document.getElementById('orgEntitySelect');

            if (assignBtn && subjectId) {
                const subject = findEntity(subjectId);
                if (subject && subject.type === 'person') {
                    // Person selected: show Assign, hide Define/Link
                    assignBtn.style.display = '';
                    if (defineBtn) defineBtn.style.display = 'none';
                    if (linkBtn) linkBtn.style.display = 'none';
                    // Auto-select Assign if nothing selected or invalid for person
                    if (selectedPredicate !== 'INS') {
                        selectSimplifiedPredicate('INS', assignBtn);
                    }
                    // Update org entity dropdown to only show roles
                    if (orgEntitySelect) {
                        const currentValue = orgEntitySelect.value;
                        orgEntitySelect.innerHTML = '<option value="">Select role...</option>';
                        entities.role.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = role.name;
                            if (role.id === currentValue) option.selected = true;
                            orgEntitySelect.appendChild(option);
                        });
                    }
                } else {
                    // Not a person: hide Assign, show Define/Link
                    assignBtn.style.display = 'none';
                    if (defineBtn) defineBtn.style.display = '';
                    if (linkBtn) linkBtn.style.display = '';
                    // Switch away from INS if currently selected
                    if (selectedPredicate === 'INS' && defineBtn) {
                        selectSimplifiedPredicate('DES', defineBtn);
                    }
                    // Restore org entity dropdown to show all org types
                    if (orgEntitySelect) {
                        const currentValue = orgEntitySelect.value;
                        orgEntitySelect.innerHTML = '<option value="">Select entity...</option>';
                        ['unit', 'team', 'role'].forEach(type => {
                            entities[type].forEach(entity => {
                                const option = document.createElement('option');
                                option.value = entity.id;
                                option.textContent = `${entity.name} (${type})`;
                                if (entity.id === currentValue) option.selected = true;
                                orgEntitySelect.appendChild(option);
                            });
                        });
                    }
                }
            } else if (assignBtn) {
                // No subject selected: default state
                assignBtn.style.display = 'none';
                if (defineBtn) defineBtn.style.display = '';
                if (linkBtn) linkBtn.style.display = '';
            }

            // Determine which object was selected (org entity or work object)
            const selectedObjectId = objectId || orgEntityId;

            if (!subjectId || !selectedObjectId) {
                preview.innerHTML = '<em style="color: #8B6F47;">Select entities to preview connection...</em>';
                return;
            }

            const subject = findEntity(subjectId);
            const object = findEntity(selectedObjectId);

            if (!subject || !object) {
                preview.innerHTML = '<em style="color: #8B6F47;">Select entities to preview connection...</em>';
                return;
            }

            const operatorLabel = eoOperators[selectedPredicate]?.label || selectedPredicate;
            const operatorColor = eoOperators[selectedPredicate]?.color || '#8B6F47';

            // Get friendly description for the connection type
            const friendlyDescriptions = {
                'DES': 'Creates a hierarchical relationship',
                'INS': 'Assigns or starts a new role/responsibility',
                'CON': 'Connects work or responsibilities',
                'SEG': 'Divides or breaks down into parts',
                'NUL': 'Removes or recognizes absence',
                'ALT': 'Modifies or shifts responsibility',
                'SYN': 'Combines or merges elements',
                'SUP': 'Oversees or balances multiple areas',
                'REC': 'Creates a recurring or iterative process'
            };

            preview.innerHTML = `
                <strong>${subject.name}</strong>
                <span style="color: ${operatorColor}; font-weight: 600;">${operatorLabel}</span>
                <strong>${object.name}</strong>
                <div class="help-text" style="margin-top: 0.5rem;">
                    ${friendlyDescriptions[selectedPredicate] || eoOperators[selectedPredicate]?.description || ''}
                </div>
            `;
        }

        // Handle mutual exclusivity: when org entity is selected, clear work object
        function handleOrgEntityChange() {
            if (document.getElementById('orgEntitySelect').value) {
                document.getElementById('objectSelect').value = '';
            }
            updateSentencePreview();
        }

        // Handle mutual exclusivity: when work object is selected, clear org entity
        function handleWorkObjectChange() {
            if (document.getElementById('objectSelect').value) {
                document.getElementById('orgEntitySelect').value = '';
            }
            updateSentencePreview();
        }

        // Auto-detect connection type based on entity types - removes need for operator selection
        function autoDetectConnectionType() {
            const subjectId = document.getElementById('subjectSelect')?.value;
            const objectId = document.getElementById('orgEntitySelect')?.value;
            const hintDiv = document.getElementById('connectionTypeHint');
            const hintText = document.getElementById('connectionTypeText');
            const predicateInput = document.getElementById('selectedPredicate');

            if (!subjectId || !objectId) {
                if (hintDiv) hintDiv.style.display = 'none';
                return;
            }

            const subject = findEntity(subjectId);
            const object = findEntity(objectId);

            if (!subject || !object) {
                if (hintDiv) hintDiv.style.display = 'none';
                return;
            }

            // Auto-determine relationship type based on entity types
            let predicate = 'CON'; // Default to link
            let hintMessage = 'This will link them together';

            // Person -> Role: Assign (INS)
            if (subject.type === 'person' && object.type === 'role') {
                predicate = 'INS';
                hintMessage = `${subject.name} will be assigned to ${object.name}`;
            }
            // Unit/Team -> Team/Role: Nest (DES)
            else if ((subject.type === 'unit' || subject.type === 'team') &&
                     (object.type === 'team' || object.type === 'role')) {
                predicate = 'DES';
                hintMessage = `${object.name} will be part of ${subject.name}`;
            }
            // Team -> Unit: Nest (DES)
            else if (subject.type === 'team' && object.type === 'unit') {
                predicate = 'DES';
                hintMessage = `${subject.name} will be part of ${object.name}`;
            }
            // Role -> Task: Assign work (CON)
            else if (subject.type === 'role' && object.type === 'task') {
                predicate = 'CON';
                hintMessage = `${subject.name} will handle ${object.name}`;
            }
            // Task -> Role: Assign work (CON)
            else if (subject.type === 'task' && object.type === 'role') {
                predicate = 'CON';
                hintMessage = `${object.name} will handle ${subject.name}`;
            }
            // Role -> Role: Oversight (SUP)
            else if (subject.type === 'role' && object.type === 'role') {
                predicate = 'SUP';
                hintMessage = `${subject.name} will oversee ${object.name}`;
            }
            // Workflow -> Role/Product: Connect (CON)
            else if (subject.type === 'workflow') {
                predicate = 'CON';
                hintMessage = `${object.name} will be part of ${subject.name}`;
            }
            // Default: Link (CON)
            else {
                predicate = 'CON';
                hintMessage = `${subject.name} will be linked to ${object.name}`;
            }

            // Set the hidden predicate
            if (predicateInput) {
                predicateInput.value = predicate;
            }
            // Also set the global selectedPredicate for compatibility
            selectedPredicate = predicate;

            // Show hint
            if (hintDiv && hintText) {
                hintDiv.style.display = 'flex';
                hintDiv.style.alignItems = 'center';
                hintDiv.style.gap = '0.5rem';
                hintText.textContent = hintMessage;
            }
        }

        // Xano Activity Store Integration

        // Xano connection status tracking
        let xanoConnectionStatus = 'checking'; // 'connected', 'disconnected', 'checking'
        let xanoActivityUploadCount = 0;
        let xanoLastSuccessfulConnection = null;

        // Agent registry - stores user details once, activities only reference agent_id
        const declaredAgents = new Map(); // Map<agent_id, {name, email, declaredAt}>
        let agentDeclarationInProgress = null; // Promise to prevent duplicate declarations

        // Update Xano status indicator UI
        function updateXanoStatusIndicator(status, activityCount = null) {
            const indicator = document.getElementById('xanoStatusIndicator');
            const statusText = indicator?.querySelector('.status-text');
            const activityCountEl = document.getElementById('xanoActivityCount');

            if (!indicator) return;

            // Remove all status classes
            indicator.classList.remove('connected', 'disconnected', 'checking');
            indicator.classList.add(status);

            xanoConnectionStatus = status;

            // Update status text
            if (statusText) {
                switch (status) {
                    case 'connected':
                        statusText.textContent = 'Xano Connected';
                        indicator.title = `Connected to Xano database. Last sync: ${new Date().toLocaleTimeString()}`;
                        break;
                    case 'disconnected':
                        statusText.textContent = 'Xano Offline';
                        indicator.title = 'Unable to connect to Xano database. Changes saved locally only.';
                        break;
                    case 'checking':
                        statusText.textContent = 'Checking...';
                        indicator.title = 'Checking Xano database connection...';
                        break;
                }
            }

            // Update activity count if provided
            if (activityCount !== null && activityCountEl) {
                xanoActivityUploadCount = activityCount;
                activityCountEl.textContent = activityCount;
                activityCountEl.style.display = activityCount > 0 ? 'inline' : 'none';
            }
        }

        // Show activity upload toast notification
        function showActivityToast(type, title, detail = '') {
            // Remove any existing toast
            const existingToast = document.getElementById('activityToast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.id = 'activityToast';
            toast.className = `activity-toast ${type}`;

            let icon = '';
            switch (type) {
                case 'success':
                    icon = '<i class="ph ph-check-circle"></i>';
                    break;
                case 'error':
                    icon = '<i class="ph ph-warning-circle"></i>';
                    break;
                case 'syncing':
                    icon = '<i class="ph ph-cloud-arrow-up" style="animation: pulse 1s ease-in-out infinite;"></i>';
                    break;
            }

            toast.innerHTML = `
                ${icon}
                <div class="toast-content">
                    <span class="toast-title">${title}</span>
                    ${detail ? `<span class="toast-detail">${detail}</span>` : ''}
                </div>
            `;

            document.body.appendChild(toast);

            // Trigger show animation
            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            // Auto-hide after delay (longer for errors)
            const hideDelay = type === 'error' ? 4000 : 2500;
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, hideDelay);
        }

        // Retry helper with exponential backoff
        async function fetchWithRetry(url, options = {}, maxRetries = 3, baseDelay = 1000) {
            let lastError;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        return response;
                    }
                    // If response is not ok but not a network error, don't retry
                    if (response.status >= 400 && response.status < 500) {
                        return response;
                    }
                    lastError = new Error(`HTTP ${response.status}`);
                } catch (error) {
                    lastError = error;
                }

                if (attempt < maxRetries - 1) {
                    const delay = baseDelay * Math.pow(2, attempt);
                    console.log(`⏳ Xano retry ${attempt + 1}/${maxRetries} in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            throw lastError;
        }

        // Check Xano connection health with retry
        async function checkXanoConnection() {
            updateXanoStatusIndicator('checking');

            try {
                const response = await fetchWithRetry(`${XANO_BASE_URL}/activity_store?limit=1`, {
                    method: 'GET',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                }, 3, 1000);

                if (response.ok) {
                    xanoLastSuccessfulConnection = new Date();
                    updateXanoStatusIndicator('connected', xanoActivityUploadCount);
                    console.log('✅ Xano connection verified');
                    // Notify parent frame of Xano status
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'taskflow:xano-status',
                            source: 'taskflow-app',
                            status: 'connected',
                            timestamp: Date.now()
                        }, '*');
                    }
                    return true;
                } else {
                    updateXanoStatusIndicator('disconnected');
                    console.warn('⚠️ Xano connection failed:', response.status);
                    return false;
                }
            } catch (error) {
                updateXanoStatusIndicator('disconnected');
                console.error('❌ Xano connection error after retries:', error.message);
                return false;
            }
        }

        // Initialize Xano connection check
        function initXanoConnectionCheck() {
            // Initial check
            checkXanoConnection();

            // Periodic health check every 60 seconds
            setInterval(() => {
                if (xanoConnectionStatus !== 'checking') {
                    checkXanoConnection();
                }
            }, 60000);
        }

        // ============================================
        // AUTO-REFRESH FUNCTIONALITY
        // ============================================
        let autoRefreshEnabled = false;
        let autoRefreshInterval = null;
        let autoRefreshIntervalMs = 10000; // 10 seconds
        let lastActivityCount = 0;
        let isTabVisible = true;
        let autoRefreshInProgress = false;

        // Toggle auto-refresh on/off
        function toggleAutoRefresh() {
            autoRefreshEnabled = !autoRefreshEnabled;
            const toggle = document.getElementById('autoRefreshToggle');
            const status = document.getElementById('autoRefreshStatus');

            if (autoRefreshEnabled) {
                toggle.classList.add('active');
                status.textContent = 'On';
                toggle.title = 'Auto-refresh: ON - Syncing every 10 seconds';
                startAutoRefresh();
                console.log('🔄 Auto-refresh enabled');
            } else {
                toggle.classList.remove('active');
                status.textContent = 'Off';
                toggle.title = 'Auto-refresh: Click to enable automatic syncing of new data';
                stopAutoRefresh();
                console.log('⏹️ Auto-refresh disabled');
            }

            // Save preference to localStorage
            try {
                localStorage.setItem('autoRefreshEnabled', autoRefreshEnabled);
            } catch (e) {
                console.warn('Could not save auto-refresh preference');
            }
        }

        // Start the auto-refresh polling
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }

            // Do an immediate refresh
            performAutoRefresh();

            // Set up interval
            autoRefreshInterval = setInterval(() => {
                if (isTabVisible && !autoRefreshInProgress) {
                    performAutoRefresh();
                }
            }, autoRefreshIntervalMs);
        }

        // Stop auto-refresh polling
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        // Perform the actual refresh - fetch from Xano and update if changed
        async function performAutoRefresh() {
            if (autoRefreshInProgress) return;
            autoRefreshInProgress = true;

            const toggle = document.getElementById('autoRefreshToggle');
            toggle.classList.add('refreshing');

            try {
                const activities = await getActivitiesFromXano();

                if (activities && activities.length > 0) {
                    // Check if there are new activities
                    if (activities.length !== lastActivityCount) {
                        console.log('🔄 Auto-refresh: Detected change (' + lastActivityCount + ' -> ' + activities.length + ' activities)');
                        lastActivityCount = activities.length;

                        // Reconstruct entities from activities
                        const reconstructed = reconstructEntitiesFromActivities(activities);
                        const totalEntities = Object.values(reconstructed.entities).reduce(
                            (sum, arr) => sum + arr.length, 0
                        );

                        if (totalEntities > 0) {
                            // Update current workspace with new data
                            entities = normalizeEntities(JSON.parse(JSON.stringify(reconstructed.entities)));
                            relationships = JSON.parse(JSON.stringify(reconstructed.relationships));

                            // Update workspace
                            if (currentWorkspaceId && workspaces[currentWorkspaceId]) {
                                workspaces[currentWorkspaceId].entities = JSON.parse(JSON.stringify(entities));
                                workspaces[currentWorkspaceId].relationships = JSON.parse(JSON.stringify(relationships));
                                workspaces[currentWorkspaceId].updatedAt = Date.now();
                            }

                            // Save to localStorage
                            saveWorkspaces();

                            // Refresh all views
                            refreshAllViews();
                            updateFilterStatus();
                            updateTaskCountBadge();

                            console.log('✅ Auto-refresh: Updated with ' + totalEntities + ' entities');
                        }
                    }
                }
            } catch (error) {
                console.error('❌ Auto-refresh error:', error);
            } finally {
                autoRefreshInProgress = false;
                toggle.classList.remove('refreshing');
            }
        }

        // Handle tab visibility changes - pause refresh when tab is not visible
        function initVisibilityDetection() {
            document.addEventListener('visibilitychange', () => {
                isTabVisible = !document.hidden;

                if (isTabVisible && autoRefreshEnabled) {
                    console.log('👁️ Tab visible - resuming auto-refresh');
                    // Immediate refresh when tab becomes visible
                    performAutoRefresh();
                } else if (!isTabVisible) {
                    console.log('👁️ Tab hidden - pausing auto-refresh');
                }
            });
        }

        // Restore auto-refresh preference from localStorage
        function restoreAutoRefreshPreference() {
            try {
                const savedPref = localStorage.getItem('autoRefreshEnabled');
                if (savedPref === 'true') {
                    // Restore the enabled state
                    autoRefreshEnabled = true;
                    const toggle = document.getElementById('autoRefreshToggle');
                    const status = document.getElementById('autoRefreshStatus');
                    if (toggle && status) {
                        toggle.classList.add('active');
                        status.textContent = 'On';
                        toggle.title = 'Auto-refresh: ON - Syncing every 10 seconds';
                        startAutoRefresh();
                        console.log('🔄 Auto-refresh restored from preferences');
                    }
                }
            } catch (e) {
                console.warn('Could not restore auto-refresh preference');
            }
        }

        // Initialize auto-refresh system
        function initAutoRefresh() {
            initVisibilityDetection();
            restoreAutoRefreshPreference();
        }
        // ============================================
        // END AUTO-REFRESH FUNCTIONALITY
        // ============================================

        // ============================================
        // XANO UPDATE POLLING FUNCTIONALITY
        // ============================================
        let updatePollingEnabled = false;
        let updatePollingInterval = null;
        let updatePollingIntervalMs = 0; // 0 = disabled, 30000 = 30s, 60000 = 1min
        let lastUpdateTimestamp = null;
        let updatePollingInProgress = false;

        // Fetch updates from the Xano activity_store_updates endpoint
        async function fetchUpdatesFromXano() {
            try {
                const params = new URLSearchParams({
                    app_id: APP_ID
                });

                // If we have a last timestamp, only get updates since then
                if (lastUpdateTimestamp) {
                    params.append('since', lastUpdateTimestamp);
                }

                console.log('🔄 Checking for updates from Xano...');
                const response = await fetchWithRetry(
                    `${XANO_BASE_URL}/activity_store_updates?${params.toString()}`,
                    {
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    },
                    2, // fewer retries for polling
                    500
                );

                if (!response.ok) {
                    console.warn('⚠️ Failed to fetch updates:', response.status);
                    return null;
                }

                const data = await response.json();
                console.log('📥 Updates received:', data);

                // Update the last timestamp if we got data
                if (data && data.length > 0) {
                    // Find the most recent timestamp from the updates
                    const timestamps = data.map(u => u.created_at || u.timestamp).filter(Boolean);
                    if (timestamps.length > 0) {
                        lastUpdateTimestamp = Math.max(...timestamps.map(t => new Date(t).getTime()));
                    }
                }

                return data;
            } catch (error) {
                console.error('❌ Error fetching updates:', error);
                return null;
            }
        }

        // Process updates and apply them to the local state
        async function processUpdates(updates) {
            if (!updates || updates.length === 0) {
                console.log('✓ No new updates');
                return false;
            }

            console.log(`📥 Processing ${updates.length} update(s)...`);

            try {
                // Get full activity list to reconstruct state
                const activities = await getActivitiesFromXano();

                if (activities && activities.length > 0) {
                    // Reconstruct entities from activities
                    const reconstructed = reconstructEntitiesFromActivities(activities);
                    const totalEntities = Object.values(reconstructed.entities).reduce(
                        (sum, arr) => sum + arr.length, 0
                    );

                    if (totalEntities > 0) {
                        // Update current workspace with new data
                        entities = normalizeEntities(JSON.parse(JSON.stringify(reconstructed.entities)));
                        relationships = JSON.parse(JSON.stringify(reconstructed.relationships));

                        // Update workspace
                        if (currentWorkspaceId && workspaces[currentWorkspaceId]) {
                            workspaces[currentWorkspaceId].entities = JSON.parse(JSON.stringify(entities));
                            workspaces[currentWorkspaceId].relationships = JSON.parse(JSON.stringify(relationships));
                            workspaces[currentWorkspaceId].updatedAt = Date.now();
                        }

                        // Save to localStorage
                        saveWorkspaces();

                        // Refresh all views
                        refreshAllViews();
                        updateFilterStatus();
                        updateTaskCountBadge();

                        console.log(`✅ Applied ${updates.length} update(s), now have ${totalEntities} entities`);
                        showActivityToast('success', 'Updates Applied', `${updates.length} change(s) synced`);
                        return true;
                    }
                }
            } catch (error) {
                console.error('❌ Error processing updates:', error);
            }

            return false;
        }

        // Perform a single update check
        async function performUpdateCheck() {
            if (updatePollingInProgress) return;
            updatePollingInProgress = true;

            const statusIndicator = document.getElementById('updateStatusIndicator');
            const statusText = document.getElementById('updateStatusText');

            try {
                if (statusText) {
                    statusText.textContent = 'Checking...';
                }

                const updates = await fetchUpdatesFromXano();
                await processUpdates(updates);

                // Update status text
                if (statusText && updatePollingIntervalMs > 0) {
                    const intervalLabel = updatePollingIntervalMs === 30000 ? '30s' : '1min';
                    statusText.textContent = `Active (every ${intervalLabel})`;
                }
            } catch (error) {
                console.error('❌ Update check error:', error);
                if (statusText) {
                    statusText.textContent = 'Error checking updates';
                }
            } finally {
                updatePollingInProgress = false;
            }
        }

        // Check for updates immediately (manual trigger)
        async function checkForUpdatesNow() {
            showActivityToast('syncing', 'Checking for Updates', 'Contacting Xano...');
            await performUpdateCheck();
        }

        // Set the update interval
        function setUpdateInterval(intervalMs) {
            updatePollingIntervalMs = intervalMs;

            // Stop any existing interval
            if (updatePollingInterval) {
                clearInterval(updatePollingInterval);
                updatePollingInterval = null;
            }

            // Update UI to show selected option
            const options = ['updateIntervalOff', 'updateInterval30s', 'updateInterval60s'];
            options.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.remove('active');
            });

            const statusIndicator = document.getElementById('updateStatusIndicator');
            const statusText = document.getElementById('updateStatusText');

            if (intervalMs === 0) {
                document.getElementById('updateIntervalOff')?.classList.add('active');
                updatePollingEnabled = false;
                if (statusIndicator) statusIndicator.classList.remove('active');
                if (statusText) statusText.textContent = 'Updates disabled';
                console.log('⏹️ Update polling disabled');
            } else {
                updatePollingEnabled = true;
                if (statusIndicator) statusIndicator.classList.add('active');

                if (intervalMs === 30000) {
                    document.getElementById('updateInterval30s')?.classList.add('active');
                    if (statusText) statusText.textContent = 'Active (every 30s)';
                } else if (intervalMs === 60000) {
                    document.getElementById('updateInterval60s')?.classList.add('active');
                    if (statusText) statusText.textContent = 'Active (every 1min)';
                }

                // Do an immediate check
                performUpdateCheck();

                // Start interval
                updatePollingInterval = setInterval(() => {
                    if (isTabVisible && !updatePollingInProgress) {
                        performUpdateCheck();
                    }
                }, intervalMs);

                console.log(`🔄 Update polling enabled: every ${intervalMs / 1000}s`);
            }

            // Save preference to localStorage
            try {
                localStorage.setItem('updatePollingIntervalMs', intervalMs);
            } catch (e) {
                console.warn('Could not save update interval preference');
            }
        }

        // Restore update polling preference from localStorage
        function restoreUpdatePollingPreference() {
            try {
                const savedInterval = localStorage.getItem('updatePollingIntervalMs');
                if (savedInterval !== null) {
                    const intervalMs = parseInt(savedInterval, 10);
                    if ([0, 30000, 60000].includes(intervalMs)) {
                        setUpdateInterval(intervalMs);
                        console.log('🔄 Update polling preference restored:', intervalMs);
                    }
                } else {
                    // Default to off
                    setUpdateInterval(0);
                }
            } catch (e) {
                console.warn('Could not restore update polling preference');
                setUpdateInterval(0);
            }
        }

        // Initialize update polling system
        function initUpdatePolling() {
            restoreUpdatePollingPreference();
        }
        // ============================================
        // END XANO UPDATE POLLING FUNCTIONALITY
        // ============================================

        // Ensure agent is declared in the activity store (user details stored once)
        async function ensureAgentDeclared(softrUser, agentId, agentName, agentEmail) {
            // Skip if already declared or anonymous
            if (declaredAgents.has(agentId) || agentId.startsWith('anon_')) {
                return;
            }

            // Prevent duplicate declarations if one is in progress
            if (agentDeclarationInProgress) {
                await agentDeclarationInProgress;
                if (declaredAgents.has(agentId)) return;
            }

            // Mark declaration in progress
            agentDeclarationInProgress = (async () => {
                try {
                    const payload = {
                        app_id: APP_ID,
                        entity_id: agentId,
                        event_type: 'AGENT_DECLARED',
                        data: {
                            event_verb: 'Declare Agent',
                            eo_operator: 'AGENT_DECLARED',
                            agent_type: softrUser ? 'softr_user' : 'anonymous',
                            agent_id: agentId,
                            agent_name: agentName,
                            agent_email: agentEmail,
                            object_type: 'agent',
                            object_id: agentId,
                            object_label: agentName
                        }
                    };

                    console.log('📝 Declaring agent to Xano:', agentId, agentName);

                    const response = await fetch(`${XANO_BASE_URL}/activity_store`, {
                        method: 'POST',
                        mode: 'cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        declaredAgents.set(agentId, {
                            name: agentName,
                            email: agentEmail,
                            declaredAt: new Date().toISOString()
                        });
                        console.log('✅ Agent declared:', agentId);
                        xanoActivityUploadCount++;
                        updateXanoStatusIndicator('connected', xanoActivityUploadCount);
                    }
                } catch (error) {
                    console.error('❌ Error declaring agent:', error);
                }
            })();

            await agentDeclarationInProgress;
            agentDeclarationInProgress = null;
        }

        async function logActivityToXano(activity, showToast = true) {
            const activityLabel = activity.object_label || activity.object_type || 'item';
            const eventType = activity.eo_operator || activity.event_verb || 'action';

            // Get Softr user info if available
            const softrUser = SoftrIdentity.getUser();
            const agentId = softrUser?.id || softrUser?.email || ('anon_' + Date.now());
            const agentName = softrUser?.name || softrUser?.email || 'Anonymous User';
            const agentEmail = softrUser?.email || null;

            try {
                // Ensure agent is declared (user details stored once, not repeated in every activity)
                await ensureAgentDeclared(softrUser, agentId, agentName, agentEmail);

                // Determine agent type based on authentication source
                let agentType = 'anonymous';
                if (softrUser) {
                    if (softrUser.source === 'email_auth') {
                        agentType = 'email_auth_user';
                    } else {
                        agentType = 'softr_user';
                    }
                }

                // New schema: app_id, data (json), entity_id, event_type
                // Only include agent_id - user details are in AGENT_DECLARED activity
                const payload = {
                    app_id: APP_ID,
                    entity_id: activity.object_id || '',
                    event_type: eventType,
                    data: {
                        event_verb: activity.event_verb,
                        eo_operator: activity.eo_operator,
                        agent_type: agentType,
                        agent_id: agentId,
                        agent_email: agentEmail,
                        object_type: activity.object_type,
                        object_id: activity.object_id,
                        object_label: activity.object_label,
                        ...(activity.data_json || {})
                    }
                };

                console.log('📝 Logging activity to Xano:', payload);

                const response = await fetch(`${XANO_BASE_URL}/activity_store`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    console.error('❌ Failed to log activity:', response.statusText);
                    updateXanoStatusIndicator('disconnected');
                    if (showToast) {
                        showActivityToast('error', 'Sync Failed', `Could not save "${activityLabel}" to Xano`);
                    }
                    return null;
                }

                const result = await response.json();
                console.log('✅ Activity logged:', result);

                // Update status and count on success
                xanoActivityUploadCount++;
                updateXanoStatusIndicator('connected', xanoActivityUploadCount);

                if (showToast) {
                    showActivityToast('success', 'Saved to Xano', `${eventType}: ${activityLabel}`);
                }

                return result;
            } catch (error) {
                console.error('❌ Error logging activity to Xano:', error);
                updateXanoStatusIndicator('disconnected');
                if (showToast) {
                    showActivityToast('error', 'Connection Error', `Failed to sync "${activityLabel}"`);
                }
                return null;
            }
        }

        async function getActivitiesFromXano() {
            try {
                console.log('🔄 Fetching activities from Xano...');
                const response = await fetchWithRetry(`${XANO_BASE_URL}/activity_store`, {
                    method: 'GET',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                }, 3, 1000);

                if (!response.ok) {
                    console.error('❌ Failed to fetch activities:', response.statusText, response.status);
                    updateXanoStatusIndicator('disconnected');
                    return [];
                }

                const activities = await response.json();
                console.log('📥 Fetched activities from Xano:', activities.length, 'records');

                // Update connection status on successful fetch
                updateXanoStatusIndicator('connected', xanoActivityUploadCount);

                // Filter by app_id and parse data
                const parsedActivities = activities
                    .filter(a => a.app_id === APP_ID)
                    .map(a => {
                        // Parse data if it's a string (Xano returns JSON as stringified text)
                        let dataObj = a.data;
                        if (typeof a.data === 'string') {
                            try {
                                dataObj = JSON.parse(a.data);
                            } catch (e) {
                                console.warn('Failed to parse activity data:', a.id, e);
                                dataObj = {};
                            }
                        } else if (!dataObj || typeof dataObj !== 'object') {
                            dataObj = {};
                        }

                        return {
                            id: a.id,
                            created_at: a.created_at,
                            app_id: a.app_id,
                            entity_id: a.entity_id,
                            event_type: a.event_type,
                            // Flatten data fields for easier access
                            ...dataObj,
                            // Keep original data object for reference
                            _raw: a
                        };
                    });

                // Build agent registry from AGENT_DECLARED activities
                for (const activity of parsedActivities) {
                    if (activity.eo_operator === 'AGENT_DECLARED' || activity.event_type === 'AGENT_DECLARED') {
                        const agentId = activity.agent_id;
                        if (agentId && !declaredAgents.has(agentId)) {
                            declaredAgents.set(agentId, {
                                name: activity.agent_name,
                                email: activity.agent_email,
                                declaredAt: activity.created_at
                            });
                        }
                    }
                }

                console.log('📋 Loaded', declaredAgents.size, 'agents from activity history');

                // Enrich activities with agent info from registry (for display purposes)
                return parsedActivities.map(a => {
                    if (a.agent_id && declaredAgents.has(a.agent_id)) {
                        const agentInfo = declaredAgents.get(a.agent_id);
                        return {
                            ...a,
                            agent_name: a.agent_name || agentInfo.name,
                            agent_email: a.agent_email || agentInfo.email
                        };
                    }
                    return a;
                });
            } catch (error) {
                console.error('Error fetching activities from Xano:', error);
                updateXanoStatusIndicator('disconnected');
                return [];
            }
        }

        // Get history for a specific entity
        async function getEntityHistory(entityId) {
            try {
                const activities = await getActivitiesFromXano();
                // Filter for activities that affect this entity
                const entityHistory = activities
                    .filter(a => a.entity_id === entityId || a.object_id === entityId)
                    .filter(a => a.eo_operator !== 'AGENT_DECLARED') // Exclude agent declarations
                    .sort((a, b) => new Date(b.created_at) - new Date(a.created_at)); // Most recent first

                return entityHistory;
            } catch (error) {
                console.error('Error fetching entity history:', error);
                return [];
            }
        }

        // Render entity history section
        function renderEntityHistorySection(entityId) {
            return `
                <div class="entity-history-section collapsed" id="entityHistorySection">
                    <div class="entity-history-header" onclick="toggleEntityHistory('${entityId}')">
                        <div class="entity-history-title">
                            <i class="ph ph-clock-counter-clockwise"></i>
                            <span>Change History</span>
                        </div>
                        <span class="entity-history-toggle"><i class="ph ph-caret-down"></i></span>
                    </div>
                    <div class="entity-history-list" id="entityHistoryList">
                        <div class="entity-history-loading">
                            <i class="ph ph-spinner"></i> Loading history...
                        </div>
                    </div>
                </div>
            `;
        }

        // Toggle entity history section and load if needed
        async function toggleEntityHistory(entityId) {
            const section = document.getElementById('entityHistorySection');
            const list = document.getElementById('entityHistoryList');

            if (!section || !list) return;

            const wasCollapsed = section.classList.contains('collapsed');
            section.classList.toggle('collapsed');

            // If opening and we haven't loaded yet, fetch the history
            if (wasCollapsed && list.innerHTML.includes('Loading history')) {
                const history = await getEntityHistory(entityId);
                renderEntityHistoryList(history, list);
            }
        }

        // Render the history list items
        function renderEntityHistoryList(history, container) {
            if (!history || history.length === 0) {
                container.innerHTML = `
                    <div class="entity-history-empty">
                        <i class="ph ph-clock-counter-clockwise"></i>
                        <div>No change history available</div>
                    </div>
                `;
                return;
            }

            const items = history.map(h => {
                const operator = (h.eo_operator || '').toLowerCase();
                const iconClass = ['alt', 'des', 'con', 'nul'].includes(operator) ? operator : 'alt';
                const icon = getHistoryIcon(h.event_verb || h.event_type);
                const action = formatHistoryAction(h);
                const changeHtml = formatHistoryChange(h);
                const user = h.agent_name || h.agent_email || 'Unknown user';
                const time = formatTimeAgo(h.created_at);

                return `
                    <div class="entity-history-item">
                        <div class="entity-history-icon ${iconClass}">
                            <i class="ph ph-${icon}"></i>
                        </div>
                        <div class="entity-history-content">
                            <div class="entity-history-action">${action}</div>
                            ${changeHtml}
                            <div class="entity-history-meta">
                                <div class="entity-history-user">
                                    <i class="ph ph-user"></i>
                                    ${user}
                                </div>
                                <span class="entity-history-time">${time}</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = items;
        }

        // Get icon for history action type
        function getHistoryIcon(eventVerb) {
            const iconMap = {
                'Update Due Date': 'calendar',
                'Update Priority': 'flag',
                'Update Status': 'check-circle',
                'Update Description': 'text-align-left',
                'Update Name': 'pencil',
                'Add Entity': 'plus-circle',
                'Delete Entity': 'trash',
                'Link Tasks': 'link',
                'Cascade Date Change': 'arrows-clockwise'
            };
            return iconMap[eventVerb] || 'arrow-clockwise';
        }

        // Format the action text for history
        function formatHistoryAction(h) {
            const verb = h.event_verb || h.event_type || 'Changed';
            return verb;
        }

        // Format the change details (old → new value)
        function formatHistoryChange(h) {
            const data = h.data_json || h;
            const field = data.field;
            let oldVal = data.old_value || data.old_display;
            let newVal = data.new_value || data.new_display;

            if (!oldVal && !newVal) return '';

            // Format display values
            if (field === 'dueDate') {
                oldVal = oldVal || 'No date';
                newVal = newVal || 'No date';
            } else if (field === 'description') {
                // Truncate long descriptions
                oldVal = oldVal ? (oldVal.length > 50 ? oldVal.substring(0, 50) + '...' : oldVal) : 'No description';
                newVal = newVal ? (newVal.length > 50 ? newVal.substring(0, 50) + '...' : newVal) : 'No description';
            }

            return `
                <div class="entity-history-change">
                    <span class="entity-history-change-old">${oldVal || '(empty)'}</span>
                    <span class="entity-history-change-arrow">→</span>
                    <span class="entity-history-change-new">${newVal || '(empty)'}</span>
                </div>
            `;
        }

        // Format time ago for history items
        function formatTimeAgo(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // Reconstruct entities from Xano activity history
        // This enables data recovery when localStorage is empty or cleared
        function reconstructEntitiesFromActivities(activities) {
            console.log('🔄 Reconstructing entities from', activities.length, 'activities...');

            const reconstructedEntities = {
                unit: [],
                team: [],
                role: [],
                person: [],
                task: [],
                product: [],
                workflow: []
            };
            const reconstructedRelationships = [];
            const deletedEntityIds = new Set();
            const deletedRelationshipIds = new Set();
            const entityMap = new Map(); // Track entities by ID for updates
            const relationshipMap = new Map(); // Track relationships by ID

            // Sort activities by created_at to process in chronological order
            const sortedActivities = [...activities].sort((a, b) => {
                const dateA = new Date(a.created_at || 0);
                const dateB = new Date(b.created_at || 0);
                return dateA - dateB;
            });

            for (const activity of sortedActivities) {
                const operator = activity.eo_operator || activity.event_type;
                const objectType = activity.object_type;
                const objectId = activity.object_id || activity.entity_id;
                const objectLabel = activity.object_label;

                // Skip if missing essential data
                if (!objectType || !objectId) continue;

                // Handle entity creation (INS operator)
                if (operator === 'INS' && objectType !== 'relationship') {
                    // Check if this entity type is valid
                    if (!reconstructedEntities[objectType]) continue;

                    // Skip if already deleted
                    if (deletedEntityIds.has(objectId)) continue;

                    // Check if entity already exists (update it)
                    if (entityMap.has(objectId)) {
                        const existing = entityMap.get(objectId);
                        if (objectLabel) existing.name = objectLabel;
                        continue;
                    }

                    // Create new entity
                    const entity = {
                        id: objectId,
                        name: objectLabel || activity.entity_name || 'Untitled',
                        type: objectType,
                        description: activity.description || '',
                        createdAt: activity.created_at
                    };

                    // Copy additional fields from activity data (for tasks especially)
                    if (activity.dueDate) entity.dueDate = activity.dueDate;
                    if (activity.status) entity.status = activity.status;
                    if (activity.predecessorId) entity.predecessorId = activity.predecessorId;
                    if (activity.priority) entity.priority = activity.priority;
                    if (activity.tags) entity.tags = activity.tags;
                    if (activity.collaborators) entity.collaborators = activity.collaborators;
                    if (activity.recurring) entity.recurring = activity.recurring;
                    if (activity.followsWorkflowId) entity.followsWorkflowId = activity.followsWorkflowId;

                    reconstructedEntities[objectType].push(entity);
                    entityMap.set(objectId, entity);
                }

                // Handle entity deletion (NUL operator)
                else if (operator === 'NUL') {
                    if (objectType === 'relationship') {
                        deletedRelationshipIds.add(objectId);
                        relationshipMap.delete(objectId);
                    } else {
                        deletedEntityIds.add(objectId);
                        entityMap.delete(objectId);
                    }
                }

                // Handle relationship creation (DES, CON, etc.)
                else if (objectType === 'relationship' && (operator === 'DES' || operator === 'CON')) {
                    // Skip if already deleted
                    if (deletedRelationshipIds.has(objectId)) continue;

                    const subjectId = activity.subject_id;
                    const predicate = activity.predicate || operator;
                    const relObjectId = activity.object_id !== objectId ? activity.object_id : activity.target_id;

                    if (!subjectId) continue;

                    // Check if relationship already exists
                    if (relationshipMap.has(objectId)) continue;

                    const relationship = {
                        id: objectId,
                        subject: subjectId,
                        predicate: predicate,
                        object: relObjectId || activity.entity_id,
                        description: activity.description || ''
                    };

                    reconstructedRelationships.push(relationship);
                    relationshipMap.set(objectId, relationship);
                }

                // Handle entity updates (ALT operator)
                else if (operator === 'ALT' && objectType !== 'relationship') {
                    if (entityMap.has(objectId)) {
                        const existing = entityMap.get(objectId);

                        // Handle name changes (from object_label or new_name)
                        if (activity.new_name) {
                            existing.name = activity.new_name;
                        } else if (objectLabel && objectLabel.includes('→')) {
                            // Extract new name from "old → new" format
                            const parts = objectLabel.split('→').map(s => s.trim());
                            if (parts.length === 2) existing.name = parts[1];
                        }

                        // Handle field-specific updates (uses field + new_value pattern)
                        if (activity.field && activity.new_value !== undefined) {
                            existing[activity.field] = activity.new_value;
                        }

                        // Handle direct field updates (from data_json flattening)
                        if (activity.new_description !== undefined) existing.description = activity.new_description;
                        if (activity.new_status !== undefined) existing.status = activity.new_status;
                        if (activity.new_dueDate !== undefined) existing.dueDate = activity.new_dueDate;
                        if (activity.new_priority !== undefined) existing.priority = activity.new_priority;
                        if (activity.new_predecessorId !== undefined) existing.predecessorId = activity.new_predecessorId;

                        // Also check direct fields (for backwards compatibility)
                        if (activity.description && !activity.old_description) existing.description = activity.description;
                        if (activity.status && !activity.old_status) existing.status = activity.status;
                        if (activity.dueDate && !activity.old_dueDate) existing.dueDate = activity.dueDate;
                        if (activity.priority && !activity.old_priority) existing.priority = activity.priority;
                    }
                }
            }

            // Remove deleted entities from reconstructed lists
            for (const type of Object.keys(reconstructedEntities)) {
                reconstructedEntities[type] = reconstructedEntities[type].filter(
                    e => !deletedEntityIds.has(e.id)
                );
            }

            // Remove deleted relationships
            const finalRelationships = reconstructedRelationships.filter(
                r => !deletedRelationshipIds.has(r.id)
            );

            const totalEntities = Object.values(reconstructedEntities).reduce(
                (sum, arr) => sum + arr.length, 0
            );

            console.log('✅ Reconstructed', totalEntities, 'entities and', finalRelationships.length, 'relationships from Xano activities');

            return {
                entities: reconstructedEntities,
                relationships: finalRelationships
            };
        }

        // Restore data from Xano activities (user-initiated)
        async function restoreFromXano() {
            const loadingStatus = document.getElementById('loadingStatus');
            if (loadingStatus) {
                loadingStatus.style.display = 'block';
                loadingStatus.innerHTML = '<i class="ph ph-spinner"></i> Restoring from Xano...';
                loadingStatus.style.background = 'rgba(200, 143, 74, 0.3)';
            }

            try {
                const xanoActivities = await getActivitiesFromXano();

                if (!xanoActivities || xanoActivities.length === 0) {
                    showActivityToast('warning', 'No Data Found', 'No activities found in Xano to restore');
                    if (loadingStatus) {
                        loadingStatus.innerHTML = '<i class="ph ph-warning-circle"></i> No data to restore';
                        loadingStatus.style.background = 'rgba(244, 67, 54, 0.3)';
                    }
                    return false;
                }

                const reconstructed = reconstructEntitiesFromActivities(xanoActivities);

                const totalEntities = Object.values(reconstructed.entities).reduce(
                    (sum, arr) => sum + arr.length, 0
                );

                if (totalEntities === 0) {
                    showActivityToast('warning', 'No Entities Found', 'Activities found but no entities could be reconstructed');
                    if (loadingStatus) {
                        loadingStatus.innerHTML = '<i class="ph ph-warning-circle"></i> No entities to restore';
                        loadingStatus.style.background = 'rgba(244, 67, 54, 0.3)';
                    }
                    return false;
                }

                // Create a new workspace with restored data
                const wsId = generateWorkspaceId();
                const timestamp = new Date().toLocaleString();

                workspaces[wsId] = {
                    id: wsId,
                    name: `Restored from Xano (${timestamp})`,
                    entities: reconstructed.entities,
                    relationships: reconstructed.relationships,
                    hasSampleData: false,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                };

                // Switch to the new workspace
                currentWorkspaceId = wsId;
                entities = normalizeEntities(JSON.parse(JSON.stringify(reconstructed.entities)));
                relationships = JSON.parse(JSON.stringify(reconstructed.relationships));
                hasSampleData = false;

                saveWorkspaces();

                // Update UI
                const nameEl = document.getElementById('workspaceNameText');
                if (nameEl) {
                    nameEl.textContent = workspaces[wsId].name;
                    nameEl.title = workspaces[wsId].name;
                }

                renderEntityList();
                updateSelects();
                updateParentOptions();
                renderActivityList();
                updateFilterStatus();
                updateTaskCountBadge();
                renderWorkspaceList();

                if (currentView === 'graph') updateGraph();
                else if (currentView === 'tree') renderTreeView();
                else if (currentView === 'card') renderCardView();
                else if (currentView === 'tasks') renderTasksView();

                showActivityToast('success', 'Data Restored', `Restored ${totalEntities} entities from Xano`);

                if (loadingStatus) {
                    loadingStatus.innerHTML = `<i class="ph ph-check-circle"></i> Restored ${totalEntities} entities`;
                    loadingStatus.style.background = 'rgba(76, 175, 80, 0.3)';
                    setTimeout(() => { loadingStatus.style.display = 'none'; }, 3000);
                }

                return true;
            } catch (error) {
                console.error('Error restoring from Xano:', error);
                showActivityToast('error', 'Restore Failed', 'Could not restore data from Xano');
                if (loadingStatus) {
                    loadingStatus.innerHTML = '<i class="ph ph-warning-circle"></i> Restore failed';
                    loadingStatus.style.background = 'rgba(244, 67, 54, 0.3)';
                }
                return false;
            }
        }

        async function updateActivityInXano(activityId, updates) {
            try {
                // Build payload conforming to new schema: app_id, data (json), entity_id, event_type
                const payload = {};

                // Only include fields that are being updated
                if (updates.app_id !== undefined) payload.app_id = updates.app_id;
                if (updates.entity_id !== undefined) payload.entity_id = updates.entity_id;
                if (updates.event_type !== undefined) payload.event_type = updates.event_type;

                // If updates contain data-level fields, wrap them in data object
                if (updates.data !== undefined) {
                    payload.data = updates.data;
                } else {
                    // Check for individual data fields and merge them
                    const dataFields = ['event_verb', 'eo_operator', 'agent_type', 'agent_id',
                                       'agent_name', 'object_type', 'object_id', 'object_label'];
                    const dataUpdates = {};
                    let hasDataUpdates = false;

                    dataFields.forEach(field => {
                        if (updates[field] !== undefined) {
                            dataUpdates[field] = updates[field];
                            hasDataUpdates = true;
                        }
                    });

                    if (hasDataUpdates) {
                        payload.data = dataUpdates;
                    }
                }

                console.log('📝 Updating activity in Xano:', activityId, payload);

                const response = await fetch(`${XANO_BASE_URL}/activity_store/${activityId}`, {
                    method: 'PUT',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    console.error('Failed to update activity:', response.statusText);
                    updateXanoStatusIndicator('disconnected');
                    return null;
                }

                const result = await response.json();
                console.log('✅ Activity updated:', result);
                updateXanoStatusIndicator('connected', xanoActivityUploadCount);
                return result;
            } catch (error) {
                console.error('Error updating activity in Xano:', error);
                updateXanoStatusIndicator('disconnected');
                return null;
            }
        }

        function initSampleData() {
            // WORK-FIRST SAMPLE DATA - Marketing Agency Example
            // This example shows how work drives structure:
            // 1. First, we have work (tasks) that need to get done
            // 2. Roles emerge to handle that work
            // 3. People fill those roles
            // 4. Structure (teams/units) can emerge later as patterns become clear

            const today = new Date();
            const tomorrow = new Date(today.getTime() + 1 * 24 * 60 * 60 * 1000);
            const in3Days = new Date(today.getTime() + 3 * 24 * 60 * 60 * 1000);
            const nextWeek = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
            const in2Weeks = new Date(today.getTime() + 14 * 24 * 60 * 60 * 1000);

            // STEP 1: THE WORK - What needs to get done for a client campaign?
            entities.task.push({
                id: 'task1',
                name: 'Create client brand guidelines document',
                type: 'task',
                description: 'Define brand colors, typography, voice, and visual standards for Acme Corp campaign.',
                dueDate: today.toISOString().split('T')[0],
                status: 'pending',
                createdAt: new Date().toISOString()
            });
            entities.task.push({
                id: 'task2',
                name: 'Design social media campaign assets',
                type: 'task',
                description: 'Create graphics for Instagram, LinkedIn, and Twitter posts based on brand guidelines.',
                dueDate: tomorrow.toISOString().split('T')[0],
                predecessorId: 'task1',
                status: 'pending',
                createdAt: new Date().toISOString()
            });
            entities.task.push({
                id: 'task3',
                name: 'Write blog post series',
                type: 'task',
                description: 'Draft 4 SEO-optimized blog posts for the Q1 content calendar.',
                dueDate: in3Days.toISOString().split('T')[0],
                status: 'pending',
                createdAt: new Date().toISOString()
            });
            entities.task.push({
                id: 'task4',
                name: 'Schedule and publish content',
                type: 'task',
                description: 'Use scheduling tools to queue all social posts and blog articles.',
                dueDate: nextWeek.toISOString().split('T')[0],
                predecessorId: 'task2',
                status: 'pending',
                createdAt: new Date().toISOString()
            });
            entities.task.push({
                id: 'task5',
                name: 'Analyze campaign performance metrics',
                type: 'task',
                description: 'Pull data from analytics platforms and compile engagement and conversion metrics.',
                dueDate: in2Weeks.toISOString().split('T')[0],
                predecessorId: 'task4',
                status: 'pending',
                createdAt: new Date().toISOString()
            });
            entities.task.push({
                id: 'task6',
                name: 'Prepare monthly client report',
                type: 'task',
                description: 'Create presentation summarizing campaign results, insights, and recommendations.',
                dueDate: in2Weeks.toISOString().split('T')[0],
                predecessorId: 'task5',
                status: 'pending',
                createdAt: new Date().toISOString()
            });

            // STEP 2: WHO DOES THE WORK - Roles emerge from task needs
            entities.role.push({ id: 'r1', name: 'Creative Director', type: 'role', description: 'Leads visual direction and brand strategy for client campaigns.' });
            entities.role.push({ id: 'r2', name: 'Content Strategist', type: 'role', description: 'Plans and creates written content, manages editorial calendar.' });
            entities.role.push({ id: 'r3', name: 'Account Manager', type: 'role', description: 'Coordinates with clients, manages timelines, and delivers reports.' });

            // STEP 3: CONNECT WORK TO ROLES - Who handles what?
            relationships.push({ subject: 'r1', predicate: 'CON', object: 'task1', id: 'rel1' }); // Creative Director creates brand guidelines
            relationships.push({ subject: 'r1', predicate: 'CON', object: 'task2', id: 'rel2' }); // Creative Director designs assets
            relationships.push({ subject: 'r2', predicate: 'CON', object: 'task3', id: 'rel3' }); // Content Strategist writes blog posts
            relationships.push({ subject: 'r2', predicate: 'CON', object: 'task4', id: 'rel4' }); // Content Strategist schedules content
            relationships.push({ subject: 'r3', predicate: 'CON', object: 'task5', id: 'rel5' }); // Account Manager analyzes metrics
            relationships.push({ subject: 'r3', predicate: 'CON', object: 'task6', id: 'rel6' }); // Account Manager prepares reports

            // STEP 4: PEOPLE - Real humans fill roles
            entities.person.push({ id: 'p1', name: 'Sarah Mitchell', type: 'person', description: 'Creative Director with 10 years in branding and design.' });
            entities.person.push({ id: 'p2', name: 'David Park', type: 'person', description: 'Content Strategist specializing in B2B marketing.' });
            entities.person.push({ id: 'p3', name: 'Emma Thompson', type: 'person', description: 'Account Manager, expert in client relations and analytics.' });

            // Assign people to roles
            relationships.push({ subject: 'p1', predicate: 'INS', object: 'r1', id: 'rel_p1' }); // Sarah is the Creative Director
            relationships.push({ subject: 'p2', predicate: 'INS', object: 'r2', id: 'rel_p2' }); // David is the Content Strategist
            relationships.push({ subject: 'p3', predicate: 'INS', object: 'r3', id: 'rel_p3' }); // Emma is the Account Manager

            // NOTE: No teams or units created!
            // In the Shape view, users will see roles have emerged.
            // If they notice patterns (these 3 roles work together), they can
            // THEN create a team to group them. Structure emerges from work.
        }

        // Load sample data into current workspace (called from welcome banner)
        function loadSampleData() {
            initSampleData();
            hasSampleData = true;

            const btnText = document.getElementById('sampleDataText');
            if (btnText) {
                btnText.textContent = 'Clear Sample Data';
            }

            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            dismissWelcomeBanner();
        }

        // Entity management
        function selectEntityType(type) {
            selectedEntityType = type;
            document.querySelectorAll('.entity-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
            updateParentOptions();

            // Update add button text based on type
            const addBtn = document.getElementById('addEntityBtn');
            if (addBtn) {
                const typeLabels = { unit: 'Unit', team: 'Team', role: 'Role', person: 'Person', task: 'Task', product: 'Product', workflow: 'Workflow' };
                addBtn.innerHTML = `<i class="ph ph-plus-circle" style="color: white; font-size: 1.25rem;"></i> Add ${typeLabels[type] || 'Entity'}`;
            }
        }

        function updateParentOptions() {
            const parentSelectGroup = document.getElementById('parentSelectGroup');
            const parentSelect = document.getElementById('parentEntitySelect');

            // Guard against missing DOM elements during initialization
            if (!parentSelectGroup || !parentSelect) {
                return;
            }

            // Persons cannot have parents
            if (selectedEntityType === 'person') {
                parentSelectGroup.style.display = 'none';
                return;
            }

            parentSelectGroup.style.display = 'block';
            parentSelect.innerHTML = '<option value="">None - Top Level</option>';

            // Determine valid parent types based on selected entity type
            let validParentTypes = [];
            if (selectedEntityType === 'team') {
                validParentTypes = ['unit', 'team']; // Teams can be under units or other teams
            } else if (selectedEntityType === 'role') {
                validParentTypes = ['unit', 'team']; // Roles can be under units or teams
            } else if (selectedEntityType === 'product') {
                validParentTypes = ['role', 'workflow']; // Products can be under roles or workflows
            } else if (selectedEntityType === 'task') {
                validParentTypes = ['role', 'workflow']; // Tasks can be under roles or workflows
            } else if (selectedEntityType === 'workflow') {
                validParentTypes = ['role', 'team']; // Workflows can be under roles or teams
            } else if (selectedEntityType === 'unit') {
                validParentTypes = ['unit']; // Units can be under other units
            }

            // Populate with valid parent entities
            validParentTypes.forEach(type => {
                entities[type].forEach(entity => {
                    const option = document.createElement('option');
                    option.value = entity.id;
                    option.innerHTML = `${getIcon(type)} ${entity.name}`;
                    parentSelect.appendChild(option);
                });
            });
        }

        function addEntity() {
            const name = document.getElementById('entityName').value.trim();
            if (!name) return;

            const id = selectedEntityType[0] + Date.now();
            const entity = {
                id,
                name,
                type: selectedEntityType,
                description: ''
            };

            entities[selectedEntityType].push(entity);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_entity',
                entityType: selectedEntityType,
                data: JSON.parse(JSON.stringify(entity)),
                description: `Create ${selectedEntityType}: ${name}`
            });

            // Log to Xano activity store
            logActivityToXano({
                event_verb: 'Start Entity',
                eo_operator: 'INS',
                object_type: selectedEntityType,
                object_id: id,
                object_label: name,
                data_json: {
                    entity_type: selectedEntityType,
                    entity_name: name
                }
            });

            // If parent is selected, create the parent relationship (persons cannot have parents)
            const parentId = document.getElementById('parentEntitySelect').value;

            if (parentId && selectedEntityType !== 'person') {
                const relId = 'rel' + Date.now();
                const parentEntity = findEntity(parentId);

                const relationship = {
                    id: relId,
                    subject: parentId,
                    predicate: 'DES', // Define relationship for hierarchy
                    object: id
                };

                relationships.push(relationship);

                // Track relationship creation in undo history
                pushToUndoHistory({
                    type: 'create_relationship',
                    data: JSON.parse(JSON.stringify(relationship)),
                    description: `Nest ${name} under ${parentEntity?.name}`
                });

                // Log parent relationship to Xano
                logActivityToXano({
                    event_verb: 'Define Connection',
                    eo_operator: 'DES',
                    object_type: 'relationship',
                    object_id: relId,
                    object_label: `${parentEntity?.name} Define ${name}`,
                    data_json: {
                        subject_id: parentId,
                        subject_type: parentEntity?.type,
                        subject_name: parentEntity?.name,
                        predicate: 'DES',
                        predicate_label: 'Define',
                        object_id: id,
                        object_type: selectedEntityType,
                        object_name: name,
                        connection_target: 'hierarchy'
                    }
                });
            }

            document.getElementById('entityName').value = '';
            document.getElementById('parentEntitySelect').value = '';

            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            updateStructureSectionVisibility();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        // Add structure entity (team/unit) - separate from regular entity creation
        function addStructureEntity() {
            const name = document.getElementById('structureName').value.trim();
            if (!name) return;

            // Get currently selected structure type (team or unit)
            const typeBtn = document.querySelector('#structureSection .entity-type-btn.active');
            const structureType = typeBtn ? typeBtn.dataset.type : 'team';

            const id = structureType[0] + Date.now();
            const entity = {
                id,
                name,
                type: structureType,
                description: ''
            };

            entities[structureType].push(entity);

            // Track in undo history
            pushToUndoHistory({
                type: 'create_entity',
                entityType: structureType,
                data: JSON.parse(JSON.stringify(entity)),
                description: `Create ${structureType}: ${name}`
            });

            // If parent is selected, create the parent relationship
            const parentId = document.getElementById('parentEntitySelect').value;
            if (parentId) {
                const relId = 'rel' + Date.now();
                const parentEntity = findEntity(parentId);

                const relationship = {
                    id: relId,
                    subject: id,
                    predicate: 'DES',
                    object: parentId
                };

                relationships.push(relationship);

                pushToUndoHistory({
                    type: 'create_relationship',
                    data: JSON.parse(JSON.stringify(relationship)),
                    description: `Nest ${name} under ${parentEntity?.name}`
                });
            }

            document.getElementById('structureName').value = '';
            document.getElementById('parentEntitySelect').value = '';

            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            } else if (currentView === 'shape') {
                renderShapeView();
            }
        }

        // Show/hide structure section based on whether roles exist
        function updateStructureSectionVisibility() {
            const structureSection = document.getElementById('structureSection');
            if (!structureSection) return;

            const roleCount = (entities.role || []).length;
            // Show structure section only after 2+ roles exist
            if (roleCount >= 2) {
                structureSection.style.display = '';
            } else {
                structureSection.style.display = 'none';
            }
        }

        function quickAddChild(parentId, parentType) {
            const parent = findEntity(parentId);
            if (!parent) return;

            // Determine appropriate child type
            let childType = 'team'; // Default
            if (parentType === 'team') {
                childType = 'role';
            }

            // Set the entity type
            selectEntityType(childType);

            // Set the parent
            document.getElementById('parentEntitySelect').value = parentId;

            // Focus on name input
            document.getElementById('entityName').focus();

            // Scroll to the add entity form
            document.querySelector('.panel-left').scrollTop = 0;
        }

        function deleteEntity(id, type) {
            if (!confirm('Delete this entity? This will also remove related relationships.')) return;

            const entity = entities[type].find(e => e.id === id);
            if (!entity) return;

            // Capture related relationships before deleting
            const deletedRelationships = relationships.filter(r => r.subject === id || r.object === id);

            // Remove entity and relationships
            entities[type] = entities[type].filter(e => e.id !== id);
            relationships = relationships.filter(r => r.subject !== id && r.object !== id);

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_entity',
                entityType: type,
                data: JSON.parse(JSON.stringify(entity)),
                deletedRelationships: deletedRelationships.map(r => JSON.parse(JSON.stringify(r))),
                description: `Delete ${type}: ${entity.name}`
            });

            // Add to recycle bin
            addToRecycleBin(entity, 'entity', type, deletedRelationships);

            // Log to Xano activity store
            logActivityToXano({
                event_verb: 'Notice Removal', // NUL = Notice
                eo_operator: 'NUL',
                object_type: type,
                object_id: id,
                object_label: entity.name,
                data_json: {
                    entity_type: type,
                    entity_name: entity.name,
                    action: 'deleted'
                }
            });

            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            renderActivityList();

            // Refresh current view (handles all view types including kanban, table, etc.)
            renderCurrentView();
        }

        function renderEntityList() {
            const list = document.getElementById('entityList');
            if (!list) return; // Safety check

            const searchTerm = document.getElementById('entitySearch')?.value.toLowerCase() || '';
            list.innerHTML = '';

            // Helper to get people assigned to a role (via INS relationship)
            function getPeopleInRole(roleId) {
                return relationships
                    .filter(r => r.predicate === 'INS' && r.object === roleId)
                    .map(r => findEntity(r.subject))
                    .filter(e => e !== null && e.type === 'person');
            }

            // Helper to render people badges for a role
            function renderPeopleBadges(roleId) {
                const peopleInRole = getPeopleInRole(roleId);
                if (peopleInRole.length === 0) return '';
                return `<div style="display: flex; gap: 0.25rem; flex-wrap: wrap; margin-top: 0.25rem; margin-left: 1.5rem;">
                    ${peopleInRole.map(person =>
                        `<span style="font-size: 0.65rem; padding: 0.125rem 0.375rem; background: rgba(139, 111, 71, 0.1); color: #8B6F47; border-radius: 10px; cursor: pointer;" onclick="event.stopPropagation(); openEntityModal('${person.id}', 'person')"><i class="ph ph-user"></i> ${person.name}</span>`
                    ).join('')}
                   </div>`;
            }

            // Helper to render a role node with people badges
            function renderRoleNode(role, depth = 0) {
                const container = document.createElement('div');
                const node = document.createElement('div');
                node.className = 'tree-node-item role';
                node.style.marginLeft = `${depth}rem`;
                node.style.cursor = 'pointer';
                node.onclick = (e) => {
                    if (!e.target.closest('.btn-icon')) {
                        openEntityModal(role.id, 'role');
                    }
                };

                const peopleBadges = renderPeopleBadges(role.id);
                node.innerHTML = `
                    <span class="tree-expand-icon" style="visibility: hidden;">▶</span>
                    <span class="tree-node-icon"><i class="ph ph-briefcase"></i></span>
                    <div class="tree-node-content">
                        <div class="tree-node-name" title="${role.name}">${role.name}</div>
                    </div>
                    <div class="tree-node-actions">
                        <button class="btn-icon add" onclick="event.stopPropagation(); openHeroTaskModal('${role.id}')" title="Create task for this role"><i class="ph ph-plus"></i></button>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${role.id}', 'role')" title="Delete"><i class="ph ph-x"></i></button>
                    </div>
                `;
                container.appendChild(node);

                // Add people badges below the role
                if (peopleBadges) {
                    const badgesDiv = document.createElement('div');
                    badgesDiv.innerHTML = peopleBadges;
                    badgesDiv.style.marginLeft = `${depth}rem`;
                    container.appendChild(badgesDiv);
                }

                return container;
            }

            // Helper to render a team node with its roles
            function renderTeamNode(team, depth = 0, searchTerm = '') {
                const rolesInTeam = getConnectedEntities(team.id, 'role');

                // Filter roles if searching
                const filteredRoles = searchTerm
                    ? rolesInTeam.filter(r => r.name.toLowerCase().includes(searchTerm) || team.name.toLowerCase().includes(searchTerm))
                    : rolesInTeam;

                const container = document.createElement('div');
                const node = document.createElement('div');
                node.className = 'tree-node-item team';
                node.style.marginLeft = `${depth}rem`;
                node.style.cursor = 'pointer';
                node.onclick = (e) => {
                    if (!e.target.closest('.btn-icon') && !e.target.closest('.tree-expand-icon')) {
                        openEntityModal(team.id, 'team');
                    }
                };

                const hasRoles = filteredRoles.length > 0;
                node.innerHTML = `
                    <span class="tree-expand-icon ${hasRoles ? 'expanded' : ''}" style="${hasRoles ? '' : 'visibility: hidden;'}">▶</span>
                    <span class="tree-node-icon"><i class="ph ph-users-three"></i></span>
                    <div class="tree-node-content">
                        <div class="tree-node-name" title="${team.name}">${team.name}</div>
                    </div>
                    <div class="tree-node-actions">
                        <button class="btn-icon add" onclick="event.stopPropagation(); quickAddChild('${team.id}', 'team')" title="Add role"><i class="ph ph-plus"></i></button>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${team.id}', 'team')" title="Delete"><i class="ph ph-x"></i></button>
                    </div>
                `;
                container.appendChild(node);

                if (hasRoles) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'tree-children expanded';

                    filteredRoles.forEach(role => {
                        const roleNode = renderRoleNode(role, depth + 1);
                        childrenContainer.appendChild(roleNode);
                    });

                    container.appendChild(childrenContainer);

                    const expandIcon = node.querySelector('.tree-expand-icon');
                    if (expandIcon) {
                        expandIcon.onclick = (e) => {
                            e.stopPropagation();
                            childrenContainer.classList.toggle('expanded');
                            expandIcon.classList.toggle('expanded');
                        };
                    }
                }

                return container;
            }

            // Helper to render a unit node with its teams and roles
            function renderUnitNode(unit, depth = 0, searchTerm = '', visited = new Set()) {
                if (visited.has(unit.id)) return null;
                visited.add(unit.id);

                const teamsInUnit = getConnectedEntities(unit.id, 'team');
                const rolesInUnit = getConnectedEntities(unit.id, 'role');
                const subUnits = getConnectedEntities(unit.id, 'unit');

                // Filter based on search
                const matchesSearch = (entity) => entity.name.toLowerCase().includes(searchTerm);
                const filteredTeams = searchTerm
                    ? teamsInUnit.filter(t => matchesSearch(t) || getConnectedEntities(t.id, 'role').some(matchesSearch) || matchesSearch(unit))
                    : teamsInUnit;
                const filteredRoles = searchTerm
                    ? rolesInUnit.filter(r => matchesSearch(r) || matchesSearch(unit))
                    : rolesInUnit;
                const filteredSubUnits = searchTerm
                    ? subUnits.filter(u => matchesSearch(u) || findMatchingChildren(u.id, searchTerm))
                    : subUnits;

                const container = document.createElement('div');
                const node = document.createElement('div');
                node.className = 'tree-node-item unit';
                node.style.marginLeft = `${depth}rem`;
                node.style.cursor = 'pointer';
                node.onclick = (e) => {
                    if (!e.target.closest('.btn-icon') && !e.target.closest('.tree-expand-icon')) {
                        openEntityModal(unit.id, 'unit');
                    }
                };

                const hasChildren = filteredTeams.length > 0 || filteredRoles.length > 0 || filteredSubUnits.length > 0;
                node.innerHTML = `
                    <span class="tree-expand-icon ${hasChildren ? 'expanded' : ''}" style="${hasChildren ? '' : 'visibility: hidden;'}">▶</span>
                    <span class="tree-node-icon"><i class="ph ph-buildings"></i></span>
                    <div class="tree-node-content">
                        <div class="tree-node-name" title="${unit.name}">${unit.name}</div>
                    </div>
                    <div class="tree-node-actions">
                        <button class="btn-icon add" onclick="event.stopPropagation(); quickAddChild('${unit.id}', 'unit')" title="Add team/role"><i class="ph ph-plus"></i></button>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${unit.id}', 'unit')" title="Delete"><i class="ph ph-x"></i></button>
                    </div>
                `;
                container.appendChild(node);

                if (hasChildren) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'tree-children expanded';

                    // Render sub-units first
                    filteredSubUnits.forEach(subUnit => {
                        const subUnitNode = renderUnitNode(subUnit, depth + 1, searchTerm, visited);
                        if (subUnitNode) childrenContainer.appendChild(subUnitNode);
                    });

                    // Then teams
                    filteredTeams.forEach(team => {
                        const teamNode = renderTeamNode(team, depth + 1, searchTerm);
                        childrenContainer.appendChild(teamNode);
                    });

                    // Then direct roles (roles not in a team)
                    filteredRoles.forEach(role => {
                        const roleNode = renderRoleNode(role, depth + 1);
                        childrenContainer.appendChild(roleNode);
                    });

                    container.appendChild(childrenContainer);

                    const expandIcon = node.querySelector('.tree-expand-icon');
                    if (expandIcon) {
                        expandIcon.onclick = (e) => {
                            e.stopPropagation();
                            childrenContainer.classList.toggle('expanded');
                            expandIcon.classList.toggle('expanded');
                        };
                    }
                }

                return container;
            }

            // Track which entities are rendered in the hierarchy
            const renderedTeamIds = new Set();
            const renderedRoleIds = new Set();

            // 1. UNITS - The organizational hierarchy: Units > Teams > Roles (with people tagged)
            if (entities.unit.length > 0) {
                // Find top-level units (not contained by any other unit)
                const topLevelUnits = entities.unit.filter(unit => {
                    return !relationships.some(r =>
                        r.object === unit.id && entities.unit.some(u => u.id === r.subject)
                    );
                });

                // Filter for search
                const filteredUnits = searchTerm
                    ? topLevelUnits.filter(u => u.name.toLowerCase().includes(searchTerm) || findMatchingChildren(u.id, searchTerm))
                    : topLevelUnits;

                if (filteredUnits.length > 0) {
                    const section = document.createElement('div');
                    section.className = 'entity-section';
                    const header = document.createElement('div');
                    header.className = 'entity-section-header';
                    header.innerHTML = '<i class="ph ph-buildings" style="margin-right: 0.25rem;"></i> Units';
                    section.appendChild(header);

                    filteredUnits.forEach(unit => {
                        const unitNode = renderUnitNode(unit, 0, searchTerm);
                        if (unitNode) {
                            section.appendChild(unitNode);
                            // Track teams and roles rendered under this unit
                            getConnectedEntities(unit.id, 'team').forEach(t => {
                                renderedTeamIds.add(t.id);
                                getConnectedEntities(t.id, 'role').forEach(r => renderedRoleIds.add(r.id));
                            });
                            getConnectedEntities(unit.id, 'role').forEach(r => renderedRoleIds.add(r.id));
                        }
                    });

                    if (section.children.length > 1) {
                        list.appendChild(section);
                    }
                }
            }

            // 2. ORPHANED TEAMS - Teams not under any unit
            const orphanedTeams = entities.team.filter(team => !renderedTeamIds.has(team.id));
            if (orphanedTeams.length > 0) {
                const filteredTeams = searchTerm
                    ? orphanedTeams.filter(t => t.name.toLowerCase().includes(searchTerm) ||
                        getConnectedEntities(t.id, 'role').some(r => r.name.toLowerCase().includes(searchTerm)))
                    : orphanedTeams;

                if (filteredTeams.length > 0) {
                    const section = document.createElement('div');
                    section.className = 'entity-section';
                    const header = document.createElement('div');
                    header.className = 'entity-section-header';
                    header.innerHTML = '<i class="ph ph-users-three" style="margin-right: 0.25rem;"></i> Teams';
                    section.appendChild(header);

                    filteredTeams.forEach(team => {
                        const teamNode = renderTeamNode(team, 0, searchTerm);
                        section.appendChild(teamNode);
                        // Track roles rendered under this team
                        getConnectedEntities(team.id, 'role').forEach(r => renderedRoleIds.add(r.id));
                    });

                    if (section.children.length > 1) {
                        list.appendChild(section);
                    }
                }
            }

            // 3. ORPHANED ROLES - Roles not under any team or unit
            const orphanedRoles = entities.role.filter(role => !renderedRoleIds.has(role.id));
            if (orphanedRoles.length > 0) {
                const filteredRoles = searchTerm
                    ? orphanedRoles.filter(r => r.name.toLowerCase().includes(searchTerm))
                    : orphanedRoles;

                if (filteredRoles.length > 0) {
                    const section = document.createElement('div');
                    section.className = 'entity-section';
                    const header = document.createElement('div');
                    header.className = 'entity-section-header';
                    header.innerHTML = '<i class="ph ph-briefcase" style="margin-right: 0.25rem;"></i> Roles';
                    section.appendChild(header);

                    filteredRoles.forEach(role => {
                        const roleNode = renderRoleNode(role, 0);
                        section.appendChild(roleNode);
                    });

                    if (section.children.length > 1) {
                        list.appendChild(section);
                    }
                }
            }

            // 4. WORK PRODUCTS
            if (entities.product.length > 0 && (!searchTerm || entities.product.some(o => o.name.toLowerCase().includes(searchTerm)))) {
                const section = document.createElement('div');
                section.className = 'entity-section';
                const header = document.createElement('div');
                header.className = 'entity-section-header';
                header.innerHTML = '<i class="ph ph-package" style="margin-right: 0.25rem;"></i> Work Products';
                section.appendChild(header);

                entities.product.forEach(obj => {
                    if (searchTerm && !obj.name.toLowerCase().includes(searchTerm)) return;

                    const node = document.createElement('div');
                    node.className = 'entity-item product';
                    node.style.cursor = 'pointer';
                    node.onclick = (e) => {
                        if (!e.target.closest('.btn-icon')) {
                            openEntityModal(obj.id, 'product');
                        }
                    };

                    node.innerHTML = `
                        <div style="flex: 1;">
                            <div class="entity-name"><i class="ph ph-package"></i> ${obj.name}</div>
                        </div>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${obj.id}', 'product')"><i class="ph ph-x"></i></button>
                    `;
                    section.appendChild(node);
                });

                if (section.children.length > 1) {
                    list.appendChild(section);
                }
            }

            // People are now in their own tab - removed from Org tab

            if (list.children.length === 0) {
                list.innerHTML = '<div class="tab-empty-state"><i class="ph ph-tree-structure"></i><p>No units, teams, or roles yet</p></div>';
            }

            // Also update People tab if it exists
            if (typeof renderPeopleList === 'function' && currentSidebarTab === 'people') {
                renderPeopleList();
            }
        }

        function getConnectedEntities(entityId, targetType) {
            const connected = [];
            relationships.forEach(rel => {
                if (rel.subject === entityId) {
                    // If targetType is specified, look only for that type
                    if (targetType) {
                        const entity = entities[targetType]?.find(e => e.id === rel.object);
                        if (entity && !connected.find(c => c.id === entity.id)) {
                            connected.push(entity);
                        }
                    } else {
                        // If no targetType, find any connected entity
                        const entity = findEntity(rel.object);
                        if (entity && !connected.find(c => c.id === entity.id)) {
                            connected.push(entity);
                        }
                    }
                } else if (rel.object === entityId) {
                    if (targetType) {
                        const entity = entities[targetType]?.find(e => e.id === rel.subject);
                        if (entity && !connected.find(c => c.id === entity.id)) {
                            connected.push(entity);
                        }
                    } else {
                        const entity = findEntity(rel.subject);
                        if (entity && !connected.find(c => c.id === entity.id)) {
                            connected.push(entity);
                        }
                    }
                }
            });
            return connected;
        }

        function findMatchingChildren(entityId, searchTerm) {
            // Check if any children match the search term
            const connectedTeams = getConnectedEntities(entityId, 'team');
            for (let team of connectedTeams) {
                if (team.name.toLowerCase().includes(searchTerm)) return true;
                const connectedRoles = getConnectedEntities(team.id, 'role');
                for (let role of connectedRoles) {
                    if (role.name.toLowerCase().includes(searchTerm)) return true;
                }
            }
            const connectedRoles = getConnectedEntities(entityId, 'role');
            for (let role of connectedRoles) {
                if (role.name.toLowerCase().includes(searchTerm)) return true;
            }
            return false;
        }

        function filterEntities() {
            renderEntityList();
        }

        // ========== Sidebar Tabs Functions ==========
        let currentSidebarTab = 'org';

        function switchSidebarTab(tabName) {
            currentSidebarTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.sidebar-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Update tab content
            document.querySelectorAll('.sidebar-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1))?.classList.add('active');

            // Update search placeholder
            const searchInput = document.getElementById('entitySearch');
            if (searchInput) {
                const placeholders = {
                    'org': 'Search units, teams, roles...',
                    'people': 'Search people...',
                    'recent': 'Search activity...'
                };
                searchInput.placeholder = placeholders[tabName] || 'Search...';
            }

            // Update add button text
            updateSidebarAddButton();

            // Render tab content
            if (tabName === 'people') {
                renderPeopleList();
            } else if (tabName === 'org') {
                renderEntityList();
            }

            // Clear search when switching tabs
            if (searchInput) {
                searchInput.value = '';
            }
        }

        function filterSidebarContent() {
            if (currentSidebarTab === 'org') {
                renderEntityList();
            } else if (currentSidebarTab === 'people') {
                renderPeopleList();
            }
            // Recent tab filtering could be added here
        }

        function renderPeopleList() {
            const list = document.getElementById('peopleList');
            if (!list) return;

            const searchTerm = document.getElementById('entitySearch')?.value.toLowerCase() || '';
            list.innerHTML = '';

            // Get all people
            const people = entities.person || [];

            // Filter by search
            const filteredPeople = searchTerm
                ? people.filter(p => p.name.toLowerCase().includes(searchTerm))
                : people;

            if (filteredPeople.length === 0) {
                list.innerHTML = `
                    <div class="tab-empty-state">
                        <i class="ph ph-users"></i>
                        <p>${searchTerm ? 'No people found' : 'No people added yet'}</p>
                    </div>
                `;
                return;
            }

            // Render each person
            filteredPeople.forEach(person => {
                // Get roles this person fills (via INS relationship)
                const rolesForPerson = relationships
                    .filter(r => r.predicate === 'INS' && r.subject === person.id)
                    .map(r => findEntity(r.object))
                    .filter(e => e && e.type === 'role')
                    .map(r => r.name);

                const card = document.createElement('div');
                card.className = 'person-card';
                card.onclick = () => openEntityModal(person.id, 'person');

                // Get initials for avatar
                const initials = person.name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);

                const rolesText = rolesForPerson.length > 0 ? rolesForPerson.join(', ') : 'No roles assigned';
                card.innerHTML = `
                    <div class="person-avatar">${initials}</div>
                    <div class="person-info">
                        <div class="person-name" title="${person.name}">${person.name}</div>
                        <div class="person-roles" title="${rolesText}">${rolesText}</div>
                    </div>
                    <div class="person-actions">
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteEntity('${person.id}', 'person')" title="Delete">
                            <i class="ph ph-x"></i>
                        </button>
                    </div>
                `;

                list.appendChild(card);
            });
        }

        function updateSidebarAddButton() {
            const btnText = document.getElementById('sidebarAddBtnText');
            const btn = document.getElementById('sidebarAddBtn');
            if (!btnText || !btn) return;

            const config = {
                'org': { text: 'Add Unit', icon: 'ph-buildings' },
                'people': { text: 'Add Person', icon: 'ph-user-plus' },
                'recent': { text: 'View All Activity', icon: 'ph-clock-counter-clockwise' }
            };

            const current = config[currentSidebarTab] || config['org'];
            btnText.textContent = current.text;

            // Update icon
            const iconEl = btn.querySelector('i');
            if (iconEl) {
                iconEl.className = 'ph ' + (currentSidebarTab === 'recent' ? current.icon : 'ph-plus');
            }

            // Hide button on Recent tab (or make it do something else)
            btn.style.display = currentSidebarTab === 'recent' ? 'none' : 'flex';
        }

        function handleSidebarAdd() {
            if (currentSidebarTab === 'org') {
                // Open command palette with unit creation
                openCommandPalette();
                setTimeout(() => {
                    const input = document.getElementById('commandPaletteInput');
                    if (input) input.value = 'add unit ';
                }, 100);
            } else if (currentSidebarTab === 'people') {
                // Open command palette with person creation
                openCommandPalette();
                setTimeout(() => {
                    const input = document.getElementById('commandPaletteInput');
                    if (input) input.value = 'add person ';
                }, 100);
            }
        }

        // Initialize sidebar on load
        function initSidebar() {
            updateSidebarAddButton();
            renderPeopleList();
        }

        function applyFilters() {
            updateFilterStatus();
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'cards') {
                renderCardView();
            }
        }

        function updateFilterStatus() {
            const filters = getActiveFilters();
            const statusEl = document.getElementById('filterStatus');
            if (!statusEl) return;

            // Count active filters (9 operators, 5 entity types)
            const activeRelTypes = Object.values(filters.relationships).filter(v => v).length;
            const activeEntityTypes = Object.values(filters.entities).filter(v => v).length;
            
            if (activeRelTypes === 9 && activeEntityTypes === 5) {
                statusEl.textContent = 'Showing all';
            } else if (activeRelTypes === 0 || activeEntityTypes === 0) {
                statusEl.textContent = 'No filters active';
            } else {
                statusEl.textContent = `Filtered: ${activeRelTypes}/9 operators, ${activeEntityTypes}/5 entities`;
            }
        }

        function clearFilters() {
            // Uncheck all operator filters
            Object.keys(eoOperators).forEach(op => {
                const el = document.getElementById(`filter${op}`);
                if (el) el.checked = false;
            });
            // Uncheck entity filters
            document.getElementById('filterUnit').checked = false;
            document.getElementById('filterTeam').checked = false;
            document.getElementById('filterRole').checked = false;
            document.getElementById('filterPerson').checked = false;
            document.getElementById('filterTask').checked = false;
            document.getElementById('filterProduct').checked = false;
            document.getElementById('filterWorkflow').checked = false;
            applyFilters();
        }

        function selectAllFilters() {
            // Check all operator filters
            Object.keys(eoOperators).forEach(op => {
                const el = document.getElementById(`filter${op}`);
                if (el) el.checked = true;
            });
            // Check entity filters
            document.getElementById('filterUnit').checked = true;
            document.getElementById('filterTeam').checked = true;
            document.getElementById('filterRole').checked = true;
            document.getElementById('filterPerson').checked = true;
            document.getElementById('filterTask').checked = true;
            document.getElementById('filterProduct').checked = true;
            document.getElementById('filterWorkflow').checked = true;
            applyFilters();
        }

        function toggleAllFilters() {
            const filters = getActiveFilters();
            // Check if any operator or entity filters are unchecked
            const anyRelUnchecked = Object.values(filters.relationships).some(v => !v);
            const anyEntityUnchecked = Object.values(filters.entities).some(v => !v);
            
            if (anyRelUnchecked || anyEntityUnchecked) {
                selectAllFilters();
            } else {
                clearFilters();
            }
        }

        function getActiveFilters() {
            // Build relationships filter from all EO operators
            const relationshipsFilter = {};
            Object.keys(eoOperators).forEach(op => {
                relationshipsFilter[op] = document.getElementById(`filter${op}`)?.checked !== false;
            });

            return {
                relationships: relationshipsFilter,
                entities: {
                    unit: document.getElementById('filterUnit')?.checked !== false,
                    team: document.getElementById('filterTeam')?.checked !== false,
                    role: document.getElementById('filterRole')?.checked !== false,
                    person: document.getElementById('filterPerson')?.checked !== false,
                    task: document.getElementById('filterTask')?.checked !== false,
                    product: document.getElementById('filterProduct')?.checked !== false,
                    workflow: document.getElementById('filterWorkflow')?.checked !== false
                }
            };
        }

        // Relationship management
        function selectPredicate(predicate) {
            selectedPredicate = predicate;
            // Clear all predicate buttons (advanced)
            document.querySelectorAll('.predicate-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // Clear all quick operator buttons (simplified)
            document.querySelectorAll('.quick-operator-selector .operator-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // Find and activate the button matching this predicate
            // Check advanced operators first
            const advancedBtn = document.querySelector(`.predicate-btn.${predicate}`);
            if (advancedBtn) {
                advancedBtn.classList.add('active');
            }
            // Check quick operator buttons
            const quickBtn = document.querySelector(`.quick-operator-selector .operator-btn[data-predicate="${predicate}"]`);
            if (quickBtn) {
                quickBtn.classList.add('active');
            }
            updateSentencePreview(); // Update preview when operator changes
        }

        function addActivity() {
            const subject = document.getElementById('subjectSelect').value;
            const orgEntity = document.getElementById('orgEntitySelect').value;
            const workObject = document.getElementById('objectSelect').value;

            // Determine which object was selected
            const object = workObject || orgEntity;

            if (!subject || !object) {
                alert('Please select subject and either an organizational entity or work object');
                return;
            }

            const subjectEntity = findEntity(subject);
            const objectEntity = findEntity(object);
            
            // Validate connection rules based on entity types and operators
            const validationError = validateConnection(subjectEntity, objectEntity, selectedPredicate);
            if (validationError) {
                alert(validationError);
                return;
            }

            const id = 'rel' + Date.now();
            const description = document.getElementById('activityDescription').value.trim();
            
            const relationship = {
                id,
                subject,
                predicate: selectedPredicate,
                object,
                description
            };

            relationships.push(relationship);

            // Track in undo history
            const operatorData = eoOperators[selectedPredicate];
            pushToUndoHistory({
                type: 'create_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `${operatorData.label}: ${subjectEntity?.name} → ${objectEntity?.name}`
            });

            // Log to Xano activity store (append-only)
            logActivityToXano({
                event_verb: `${operatorData.label} Connection`, // e.g., "Define Connection"
                eo_operator: selectedPredicate, // Store EO code (DES, INS, etc)
                object_type: 'relationship',
                object_id: id,
                object_label: `${subjectEntity?.name} ${operatorData.label} ${objectEntity?.name}`,
                data_json: {
                    subject_id: subject,
                    subject_type: subjectEntity?.type,
                    subject_name: subjectEntity?.name,
                    predicate: selectedPredicate,
                    predicate_label: operatorData.label,
                    object_id: object,
                    object_type: objectEntity?.type,
                    object_name: objectEntity?.name,
                    connection_target: workObject ? 'work_object' : 'org_entity',
                    description: description
                }
            });

            document.getElementById('subjectSelect').value = '';
            document.getElementById('orgEntitySelect').value = '';
            document.getElementById('objectSelect').value = '';
            document.getElementById('activityDescription').value = '';
            document.getElementById('charCount').textContent = '0';

            saveToLocalStorage();
            renderActivityList();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function validateConnection(subject, object, predicate) {
            if (!subject || !object) return 'Invalid entities selected';

            // INS operator: assign person to role
            if (predicate === 'INS') {
                if (subject.type === 'person' && object.type === 'role') {
                    return null; // Valid: person assigned to role
                }
                return 'Start operator is only for assigning people to roles';
            }

            // Persons cannot have other activities or relationships (except INS handled above)
            if (subject.type === 'person') {
                return 'People can only be assigned to roles (use Start operator)';
            }
            if (object.type === 'person') {
                return 'Activities cannot target people';
            }

            // Define operator: hierarchical relationships
            if (predicate === 'DES') {
                // Units can Define units, teams, or roles
                if (subject.type === 'unit' && !['unit', 'team', 'role'].includes(object.type)) {
                    return 'Units can only Define other units, teams, or roles';
                }
                // Teams can Define teams or roles
                if (subject.type === 'team' && !['team', 'role'].includes(object.type)) {
                    return 'Teams can only Define other teams or roles';
                }
                // Roles cannot Define
                if (subject.type === 'role') {
                    return 'Roles cannot use Define operator (use Link or other operators)';
                }
            }

            // Link operator: connecting work
            if (predicate === 'CON') {
                // Roles Link to objects
                if (subject.type === 'role' && object.type !== 'object') {
                    return 'Roles should Link to work objects';
                }
            }

            // Work products (objects) can only be linked to roles and teams
            if (object.type === 'object') {
                if (subject.type === 'unit') {
                    return 'Work products should be linked to roles or teams, not units directly';
                }
            }

            // Prevent nonsensical connections
            if (subject.type === 'object' && object.type === 'unit') {
                return 'Work objects cannot connect upward to organizational units';
            }

            return null; // Valid connection
        }

        function deleteActivity(id) {
            const relationship = relationships.find(r => r.id === id);
            if (!relationship) return;

            const subjectEntity = findEntity(relationship.subject);
            const objectEntity = findEntity(relationship.object);
            const operatorData = eoOperators[relationship.predicate];

            // Track in undo history
            pushToUndoHistory({
                type: 'delete_relationship',
                data: JSON.parse(JSON.stringify(relationship)),
                description: `Delete ${operatorData?.label || relationship.predicate}: ${subjectEntity?.name || relationship.subject} → ${objectEntity?.name || relationship.object}`
            });

            // Add to recycle bin
            addToRecycleBin(relationship, 'relationship', null);

            relationships = relationships.filter(r => r.id !== id);
            saveToLocalStorage();
            renderActivityList();

            // Refresh current view (handles all view types including kanban, table, etc.)
            renderCurrentView();
        }

        function renderActivityList() {
            const list = document.getElementById('activityList');
            const searchTerm = document.getElementById('activitySearch')?.value.toLowerCase() || '';
            
            if (!list) return; // Safety check
            
            list.innerHTML = '';

            if (relationships.length === 0) {
                list.innerHTML = '<div style="color: #8B6F47; font-size: 0.85rem; text-align: center; padding: 1rem;">No activities yet</div>';
                return;
            }

            // Filter out DES (Define) relationships - those are for nesting/hierarchy, not activities
            const filtered = relationships.filter(rel => {
                if (rel.predicate === 'DES') return false; // Exclude nesting relationships
                const subjectEntity = findEntity(rel.subject);
                const objectEntity = findEntity(rel.object);
                const searchText = `${subjectEntity?.name || ''} ${rel.predicate} ${objectEntity?.name || ''}`.toLowerCase();
                return searchText.includes(searchTerm);
            });

            if (filtered.length === 0) {
                list.innerHTML = '<div style="color: #8B6F47; font-size: 0.85rem; text-align: center; padding: 1rem;">No matching activities</div>';
                return;
            }

            filtered.forEach(rel => {
                const subjectEntity = findEntity(rel.subject);
                const objectEntity = findEntity(rel.object);
                const operator = eoOperators[rel.predicate];

                const item = document.createElement('div');
                item.className = `relationship-item ${rel.predicate}`;
                item.innerHTML = `
                    <div class="relationship-text">
                        <strong>${subjectEntity?.name || rel.subject}</strong>
                        <span style="color: ${operator.color}; margin: 0 0.25rem; font-weight: 600;">${operator.label}</span>
                        <strong>${objectEntity?.name || rel.object}</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="relationship-meta">${subjectEntity?.type} → ${objectEntity?.type}</div>
                        <button class="btn-icon" onclick="deleteActivity('${rel.id}')">✕</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function updateSelects() {
            const subjectSelect = document.getElementById('subjectSelect');
            const orgEntitySelect = document.getElementById('orgEntitySelect');
            const objectSelect = document.getElementById('objectSelect');

            subjectSelect.innerHTML = '<option value="">Select entity...</option>';
            orgEntitySelect.innerHTML = '<option value="">Select entity...</option>';
            objectSelect.innerHTML = '<option value="">Select work product...</option>';

            // Subject: all entity types
            const types = ['unit', 'team', 'role', 'person', 'task', 'product', 'workflow'];
            types.forEach(type => {
                entities[type].forEach(entity => {
                    const option = document.createElement('option');
                    option.value = entity.id;
                    option.textContent = `${entity.name} (${type})`;
                    subjectSelect.appendChild(option);
                });
            });

            // Org Entity: only units, teams, roles
            const orgTypes = ['unit', 'team', 'role'];
            orgTypes.forEach(type => {
                entities[type].forEach(entity => {
                    const option = document.createElement('option');
                    option.value = entity.id;
                    option.textContent = `${entity.name} (${type})`;
                    orgEntitySelect.appendChild(option);
                });
            });

            // Work Products: only products
            entities.product.forEach(entity => {
                const option = document.createElement('option');
                option.value = entity.id;
                option.textContent = entity.name;
                objectSelect.appendChild(option);
            });
        }

        // Quick create for work products only
        function toggleQuickCreateObject() {
            const quickCreate = document.getElementById('quickCreateObject');
            quickCreate.style.display = quickCreate.style.display === 'none' ? 'block' : 'none';
            if (quickCreate.style.display === 'block') {
                document.getElementById('quickObjectName').focus();
            }
        }

        function createQuickObject() {
            const name = document.getElementById('quickObjectName').value.trim();

            if (!name) {
                alert('Please enter a name for the work product');
                return;
            }

            const id = 'prod' + Date.now();
            const entity = { id, name, type: 'product', description: '' };
            entities.product.push(entity);

            // Log to Xano
            logActivityToXano({
                event_verb: 'Start Entity',
                eo_operator: 'INS',
                object_type: 'product',
                object_id: id,
                object_label: name,
                data_json: {
                    entity_type: 'product',
                    entity_name: name,
                    created_from: 'quick_create_product'
                }
            });

            // Update UI
            updateSelects();
            renderEntityList();
            
            // Select the new object
            document.getElementById('objectSelect').value = id;
            
            // Hide quick create and clear
            document.getElementById('quickCreateObject').style.display = 'none';
            document.getElementById('quickObjectName').value = '';
            
            updateSentencePreview();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            }
        }

        // ==========================================
        // WORK PRODUCT SELECTOR MODAL
        // ==========================================

        let selectedWorkProductId = null;
        let workProductSelectorCallback = null;

        function openWorkProductSelectorModal(callback) {
            workProductSelectorCallback = callback;
            selectedWorkProductId = null;

            // Clear search
            document.getElementById('workProductSearchInput').value = '';
            document.getElementById('newWorkProductName').value = '';

            // Populate work products
            renderWorkProductList();

            // Update selection button
            document.getElementById('confirmWorkProductSelection').disabled = true;

            // Show modal
            document.getElementById('workProductSelectorModal').classList.add('active');

            // Focus search
            setTimeout(() => {
                document.getElementById('workProductSearchInput').focus();
            }, 100);
        }

        function closeWorkProductSelectorModal() {
            document.getElementById('workProductSelectorModal').classList.remove('active');
            selectedWorkProductId = null;
            workProductSelectorCallback = null;
        }

        function renderWorkProductList(searchTerm = '') {
            const content = document.getElementById('workProductSelectorContent');
            const workProducts = entities.product || [];

            // Filter by search term
            const filteredProducts = workProducts.filter(wp =>
                wp.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                (wp.description && wp.description.toLowerCase().includes(searchTerm.toLowerCase()))
            );

            if (filteredProducts.length === 0 && !searchTerm) {
                content.innerHTML = `
                    <div class="modal-empty-state">
                        <i class="ph ph-package"></i>
                        <div>No work products yet</div>
                        <div style="font-size: 0.85rem; margin-top: 0.5rem;">Create one below to get started</div>
                    </div>
                `;
                return;
            }

            if (filteredProducts.length === 0 && searchTerm) {
                content.innerHTML = `
                    <div class="modal-empty-state">
                        <i class="ph ph-magnifying-glass"></i>
                        <div>No matching work products</div>
                        <div style="font-size: 0.85rem; margin-top: 0.5rem;">Try a different search or create a new one</div>
                    </div>
                `;
                return;
            }

            // Group work products by their parent (connected via relationships)
            const groupedProducts = groupWorkProductsByParent(filteredProducts);

            let html = '';

            // Render grouped work products
            Object.entries(groupedProducts).forEach(([parentName, products]) => {
                if (parentName !== 'Uncategorized' || Object.keys(groupedProducts).length === 1) {
                    // Only show category headers if there are multiple categories
                    if (Object.keys(groupedProducts).length > 1) {
                        html += `
                            <div class="work-product-category">
                                <div class="work-product-category-header" onclick="toggleWorkProductCategory(this)">
                                    <i class="ph ph-caret-down category-toggle"></i>
                                    <i class="ph ph-folder"></i>
                                    <span>${parentName}</span>
                                    <span style="margin-left: auto; font-size: 0.8rem; opacity: 0.7;">${products.length}</span>
                                </div>
                                <div class="work-product-category-items">
                        `;
                    }

                    products.forEach(wp => {
                        const isSelected = selectedWorkProductId === wp.id;
                        html += `
                            <div class="work-product-item ${isSelected ? 'selected' : ''}"
                                 onclick="selectWorkProductItem('${wp.id}')"
                                 data-id="${wp.id}">
                                <div class="work-product-item-icon">
                                    <i class="ph ph-file-text"></i>
                                </div>
                                <div class="work-product-item-content">
                                    <div class="work-product-item-name">${wp.name}</div>
                                    ${wp.description ? `<div class="work-product-item-desc">${wp.description}</div>` : ''}
                                </div>
                            </div>
                        `;
                    });

                    if (Object.keys(groupedProducts).length > 1) {
                        html += `
                                </div>
                            </div>
                        `;
                    }
                }
            });

            content.innerHTML = html;
        }

        function groupWorkProductsByParent(workProducts) {
            const grouped = {};

            workProducts.forEach(wp => {
                // Find if this work product is connected to any role/team
                let parentName = 'Uncategorized';

                const connection = relationships.find(r =>
                    r.object === wp.id && r.predicate !== 'DES'
                );

                if (connection) {
                    const parent = findEntity(connection.subject);
                    if (parent) {
                        parentName = `${parent.name} (${parent.type})`;
                    }
                }

                if (!grouped[parentName]) {
                    grouped[parentName] = [];
                }
                grouped[parentName].push(wp);
            });

            // Sort to put Uncategorized last
            const sortedGrouped = {};
            Object.keys(grouped).sort((a, b) => {
                if (a === 'Uncategorized') return 1;
                if (b === 'Uncategorized') return -1;
                return a.localeCompare(b);
            }).forEach(key => {
                sortedGrouped[key] = grouped[key];
            });

            return sortedGrouped;
        }

        function toggleWorkProductCategory(header) {
            header.classList.toggle('collapsed');
            const items = header.nextElementSibling;
            items.classList.toggle('collapsed');
        }

        function selectWorkProductItem(id) {
            // Clear previous selection
            document.querySelectorAll('.work-product-item').forEach(item => {
                item.classList.remove('selected');
            });

            // Set new selection
            selectedWorkProductId = id;
            const selectedItem = document.querySelector(`.work-product-item[data-id="${id}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }

            // Enable confirm button
            document.getElementById('confirmWorkProductSelection').disabled = false;
        }

        function filterWorkProducts() {
            const searchTerm = document.getElementById('workProductSearchInput').value;
            renderWorkProductList(searchTerm);
        }

        function createWorkProductFromModal() {
            const name = document.getElementById('newWorkProductName').value.trim();

            if (!name) {
                alert('Please enter a name for the work product');
                return;
            }

            const id = 'prod' + Date.now();
            const entity = { id, name, type: 'product', description: '' };
            entities.product.push(entity);

            // Log to Xano
            logActivityToXano({
                event_verb: 'Start Entity',
                eo_operator: 'INS',
                object_type: 'product',
                object_id: id,
                object_label: name,
                data_json: {
                    entity_type: 'product',
                    entity_name: name,
                    created_from: 'work_product_modal'
                }
            });

            // Update UI
            updateSelects();
            renderEntityList();

            // Save
            saveToLocalStorage();

            // Clear input
            document.getElementById('newWorkProductName').value = '';

            // Refresh the list and select the new item
            renderWorkProductList(document.getElementById('workProductSearchInput').value);
            selectWorkProductItem(id);

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function confirmWorkProductSelection() {
            if (selectedWorkProductId && workProductSelectorCallback) {
                const workProduct = findEntity(selectedWorkProductId);
                workProductSelectorCallback(workProduct);
            }
            closeWorkProductSelectorModal();
        }

        // Open work product selector from the entity modal
        function openWorkProductSelectorForModal() {
            openWorkProductSelectorModal((workProduct) => {
                if (workProduct) {
                    // Update the hidden input and button text
                    document.getElementById('modalSelectedWorkProductId').value = workProduct.id;
                    document.getElementById('modalWorkProductBtnText').textContent = workProduct.name;
                    document.getElementById('modalWorkProductBtn').classList.add('has-selection');
                }
            });
        }

        // Add work product activity from modal
        function addWorkProductActivityFromModal() {
            if (!currentModalEntity || !currentModalEntityType) return;

            const operatorCode = document.getElementById('modalWorkProductOperatorSelect').value;
            const workProductId = document.getElementById('modalSelectedWorkProductId').value;

            if (!operatorCode || !workProductId) {
                alert('Please select both an activity type and a work product');
                return;
            }

            // DES should not be used here - it's for nesting
            if (operatorCode === 'DES') {
                alert('Use "Add Nested" for hierarchical relationships');
                return;
            }

            const workProduct = findEntity(workProductId);
            if (!workProduct) {
                alert('Work product not found');
                return;
            }

            // Validate: Work products can only be linked to roles and teams
            if (currentModalEntityType !== 'role' && currentModalEntityType !== 'team') {
                alert('Work products can only be linked to roles and teams');
                return;
            }

            // Create the relationship
            const relId = 'rel' + Date.now();
            const relationship = {
                id: relId,
                subject: currentModalEntity.id,
                predicate: operatorCode,
                object: workProductId,
                description: ''
            };

            relationships.push(relationship);

            // Log to Xano
            const operatorData = eoOperators[operatorCode];
            logActivityToXano({
                event_verb: `${operatorData.label} Activity`,
                eo_operator: operatorCode,
                object_type: 'relationship',
                object_id: relId,
                object_label: `${currentModalEntity.name} ${operatorData.label} ${workProduct.name}`,
                data_json: {
                    subject_id: currentModalEntity.id,
                    subject_type: currentModalEntityType,
                    subject_name: currentModalEntity.name,
                    predicate: operatorCode,
                    predicate_label: operatorData.label,
                    object_id: workProductId,
                    object_type: 'object',
                    object_name: workProduct.name,
                    connection_type: 'work_product_activity'
                }
            });

            // Save and refresh
            saveToLocalStorage();

            // Refresh the modal to show new activity
            openEntityModal(currentModalEntity.id, currentModalEntityType);

            // Refresh views
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            renderActivityList();
        }

        // Handler for modal operator change (optional - for future use)
        function handleModalOperatorChange() {
            // Could be used to filter targets based on operator type
        }

        function findEntity(id) {
            const types = ['unit', 'team', 'role', 'person', 'task', 'product', 'workflow'];
            for (let type of types) {
                const entity = entities[type]?.find(e => e.id === id);
                if (entity) return entity;
            }
            return null;
        }

        // ==========================================
        // VENN DIAGRAM VIEW
        // ==========================================

        // Get children entities of a specific entity (entities connected via DES)
        function getVennChildren(parentId, childType) {
            const children = [];
            relationships.forEach(r => {
                if (r.predicate === 'DES') {
                    if (r.subject === parentId) {
                        const child = entities[childType]?.find(e => e.id === r.object);
                        if (child) children.push(child);
                    }
                    if (r.object === parentId) {
                        const child = entities[childType]?.find(e => e.id === r.subject);
                        if (child) children.push(child);
                    }
                }
            });
            return children;
        }

        // Get all sub-entities nested under an entity (recursive)
        function getAllNestedEntities(entityId, includeTypes = ['team', 'role', 'person']) {
            const nested = [];
            const visited = new Set();

            function traverse(id) {
                if (visited.has(id)) return;
                visited.add(id);

                relationships.forEach(r => {
                    if (r.predicate === 'DES' || r.predicate === 'INS') {
                        let childId = null;
                        if (r.subject === id) childId = r.object;
                        else if (r.object === id) childId = r.subject;

                        if (childId && !visited.has(childId)) {
                            const child = findEntity(childId);
                            if (child && includeTypes.includes(child.type)) {
                                nested.push(child);
                                traverse(childId);
                            }
                        }
                    }
                });
            }

            traverse(entityId);
            return nested;
        }

        // Find shared connections between two entities (through their nested children)
        function getSharedConnections(entity1Id, entity2Id) {
            const nested1 = getAllNestedEntities(entity1Id);
            const nested2 = getAllNestedEntities(entity2Id);
            const nested1Ids = new Set([entity1Id, ...nested1.map(e => e.id)]);
            const nested2Ids = new Set([entity2Id, ...nested2.map(e => e.id)]);

            const shared = [];

            // Find relationships that connect entities from both groups
            relationships.forEach(r => {
                const subjectIn1 = nested1Ids.has(r.subject);
                const subjectIn2 = nested2Ids.has(r.subject);
                const objectIn1 = nested1Ids.has(r.object);
                const objectIn2 = nested2Ids.has(r.object);

                // Connection bridges the two groups
                if ((subjectIn1 && objectIn2) || (subjectIn2 && objectIn1)) {
                    const subjectEntity = findEntity(r.subject);
                    const objectEntity = findEntity(r.object);
                    if (subjectEntity && objectEntity) {
                        shared.push({
                            relationship: r,
                            from: subjectEntity,
                            to: objectEntity
                        });
                    }
                }
            });

            return shared;
        }

        // Calculate overlap weight between two entities
        function getOverlapWeight(entity1Id, entity2Id) {
            return getSharedConnections(entity1Id, entity2Id).length;
        }

        // Get entities at current level, optionally filtered by focused parent
        function getVennEntitiesAtLevel() {
            const levelType = vennLevels[vennCurrentLevel];
            let entitiesAtLevel = entities[levelType] || [];

            // If we have a focused entity, only show its children
            if (vennFocusedEntity) {
                const childType = vennLevels[vennCurrentLevel];
                entitiesAtLevel = getVennChildren(vennFocusedEntity.id, childType);

                // Also include entities connected via other relationships
                relationships.forEach(r => {
                    if (r.subject === vennFocusedEntity.id || r.object === vennFocusedEntity.id) {
                        const otherId = r.subject === vennFocusedEntity.id ? r.object : r.subject;
                        const otherEntity = entities[childType]?.find(e => e.id === otherId);
                        if (otherEntity && !entitiesAtLevel.find(e => e.id === otherEntity.id)) {
                            entitiesAtLevel.push(otherEntity);
                        }
                    }
                });
            }

            return entitiesAtLevel;
        }

        // Render the Org Chart view - Traditional Entity Hierarchy
        function renderOrgChartView() {
            const container = document.getElementById('orgchartView');
            if (!container) return;

            container.innerHTML = '';

            // Build hierarchy tree
            const hierarchy = buildHierarchyTree();

            // Check if there's any data to display
            const hasUnits = hierarchy.units && hierarchy.units.length > 0;
            const hasOrphanTeams = hierarchy.orphanTeams && hierarchy.orphanTeams.length > 0;
            const hasOrphanRoles = hierarchy.orphanRoles && hierarchy.orphanRoles.length > 0;
            const hasOrphanPeople = hierarchy.orphanPeople && hierarchy.orphanPeople.length > 0;
            const hasOrphanObjects = hierarchy.orphanObjects && hierarchy.orphanObjects.length > 0;

            if (!hasUnits && !hasOrphanTeams && !hasOrphanRoles && !hasOrphanPeople && !hasOrphanObjects) {
                container.innerHTML = `
                    <div class="entity-orgchart-empty">
                        <i class="ph ph-flow-arrow"></i>
                        <h3>No Organization Structure</h3>
                        <p>Add units, teams, and roles to build your entity org chart</p>
                    </div>
                `;
                return;
            }

            const chartContainer = document.createElement('div');
            chartContainer.className = 'entity-orgchart';

            const wrapper = document.createElement('div');
            wrapper.className = 'entity-orgchart-wrapper';

            // Render main hierarchy (units with nested structure)
            if (hasUnits) {
                const unitsLevel = document.createElement('div');
                unitsLevel.className = 'orgchart-level';
                unitsLevel.style.cssText = 'padding-top: 0;';

                hierarchy.units.forEach(unitNode => {
                    const unitEl = renderOrgChartUnit(unitNode);
                    unitsLevel.appendChild(unitEl);
                });

                wrapper.appendChild(unitsLevel);
            }

            chartContainer.appendChild(wrapper);

            // Render orphan sections
            if (hasOrphanTeams) {
                const orphanSection = document.createElement('div');
                orphanSection.className = 'orgchart-orphan-section';
                orphanSection.innerHTML = `
                    <div class="orgchart-orphan-header">
                        <i class="ph ph-users-three"></i>
                        <span class="orgchart-orphan-title">Unassigned Teams</span>
                    </div>
                `;
                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'orgchart-orphan-items';

                hierarchy.orphanTeams.forEach(team => {
                    const teamEl = document.createElement('div');
                    teamEl.className = 'orgchart-orphan-team';
                    teamEl.onclick = () => openEntityModal(team.id, 'team');
                    teamEl.innerHTML = `
                        <div class="orgchart-orphan-icon team-icon">
                            <i class="ph ph-users-three"></i>
                        </div>
                        <span class="orgchart-orphan-name">${team.name}</span>
                    `;
                    itemsContainer.appendChild(teamEl);
                });

                orphanSection.appendChild(itemsContainer);
                chartContainer.appendChild(orphanSection);
            }

            if (hasOrphanRoles) {
                const orphanSection = document.createElement('div');
                orphanSection.className = 'orgchart-orphan-section';
                orphanSection.innerHTML = `
                    <div class="orgchart-orphan-header">
                        <i class="ph ph-identification-badge"></i>
                        <span class="orgchart-orphan-title">Unassigned Roles</span>
                    </div>
                `;
                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'orgchart-orphan-items';

                hierarchy.orphanRoles.forEach(role => {
                    const roleEl = document.createElement('div');
                    roleEl.className = 'orgchart-orphan-role';
                    roleEl.onclick = () => openEntityModal(role.id, 'role');

                    const people = getPeopleInRoleForOrgChart(role.id);
                    roleEl.innerHTML = `
                        <div class="orgchart-orphan-icon role-icon">
                            <i class="ph ph-identification-badge"></i>
                        </div>
                        <span class="orgchart-orphan-name">${role.name}</span>
                        ${people.length > 0 ? `<span class="orgchart-role-vacancy" style="background:#E8F0F4;color:#4B6B8E;border-color:#D0DDE3;">${people.length} assigned</span>` : ''}
                    `;
                    itemsContainer.appendChild(roleEl);
                });

                orphanSection.appendChild(itemsContainer);
                chartContainer.appendChild(orphanSection);
            }

            if (hasOrphanPeople) {
                const orphanSection = document.createElement('div');
                orphanSection.className = 'orgchart-orphan-section';
                orphanSection.innerHTML = `
                    <div class="orgchart-orphan-header">
                        <i class="ph ph-user"></i>
                        <span class="orgchart-orphan-title">Unassigned People</span>
                    </div>
                `;
                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'orgchart-orphan-items';

                hierarchy.orphanPeople.forEach(person => {
                    const personEl = document.createElement('div');
                    personEl.className = 'orgchart-orphan-person';
                    personEl.onclick = () => openEntityModal(person.id, 'person');
                    personEl.innerHTML = `
                        <div class="orgchart-orphan-icon person-icon">
                            ${getInitials(person.name)}
                        </div>
                        <span class="orgchart-orphan-name">${person.name}</span>
                    `;
                    itemsContainer.appendChild(personEl);
                });

                orphanSection.appendChild(itemsContainer);
                chartContainer.appendChild(orphanSection);
            }

            if (hasOrphanObjects) {
                const orphanSection = document.createElement('div');
                orphanSection.className = 'orgchart-orphan-section';
                orphanSection.innerHTML = `
                    <div class="orgchart-orphan-header">
                        <i class="ph ph-cube"></i>
                        <span class="orgchart-orphan-title">Unassigned Work Products</span>
                    </div>
                `;
                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'orgchart-orphan-items';

                hierarchy.orphanObjects.forEach(obj => {
                    const objEl = document.createElement('div');
                    objEl.className = 'orgchart-orphan-object';
                    objEl.onclick = () => openEntityModal(obj.id, 'object');
                    objEl.innerHTML = `
                        <div class="orgchart-orphan-icon object-icon">
                            <i class="ph ph-cube"></i>
                        </div>
                        <span class="orgchart-orphan-name">${obj.name}</span>
                    `;
                    itemsContainer.appendChild(objEl);
                });

                orphanSection.appendChild(itemsContainer);
                chartContainer.appendChild(orphanSection);
            }

            container.appendChild(chartContainer);
        }

        // Get initials from a name
        function getInitials(name) {
            return name.split(' ')
                .map(word => word.charAt(0))
                .slice(0, 2)
                .join('')
                .toUpperCase();
        }

        // Count total people in a unit (including nested teams)
        function countPeopleInUnit(unitNode) {
            let count = 0;

            // Count people in direct roles
            if (unitNode.roles) {
                unitNode.roles.forEach(role => {
                    count += role.people ? role.people.length : 0;
                });
            }

            // Count people in teams
            if (unitNode.teams) {
                unitNode.teams.forEach(team => {
                    if (team.roles) {
                        team.roles.forEach(role => {
                            count += role.people ? role.people.length : 0;
                        });
                    }
                });
            }

            // Count people in sub-units
            if (unitNode.units) {
                unitNode.units.forEach(subUnit => {
                    count += countPeopleInUnit(subUnit);
                });
            }

            return count;
        }

        // Render a unit node in the org chart (traditional hierarchy)
        function renderOrgChartUnit(unitNode) {
            const node = document.createElement('div');
            node.className = 'orgchart-unit-node orgchart-node';

            const hasChildren = (unitNode.units && unitNode.units.length > 0) ||
                               (unitNode.teams && unitNode.teams.length > 0) ||
                               (unitNode.roles && unitNode.roles.length > 0) ||
                               (unitNode.objects && unitNode.objects.length > 0);

            // Unit card
            const card = document.createElement('div');
            card.className = 'orgchart-unit-card';
            card.onclick = (e) => {
                if (!e.target.closest('.orgchart-collapse-btn')) {
                    openEntityModal(unitNode.entity.id, 'unit');
                }
            };

            card.innerHTML = `
                <div class="orgchart-icon">
                    <i class="ph ph-buildings"></i>
                </div>
                <div class="orgchart-name">${unitNode.entity.name}</div>
                ${unitNode.entity.description ? `<div class="orgchart-meta">${unitNode.entity.description}</div>` : ''}
                ${hasChildren ? `<div class="orgchart-collapse-btn" onclick="event.stopPropagation(); this.closest('.orgchart-node').classList.toggle('collapsed');"><i class="ph ph-caret-down"></i></div>` : ''}
            `;
            node.appendChild(card);

            // Children container - always show to display empty state if needed
            const children = document.createElement('div');
            const childCount = (unitNode.units ? unitNode.units.length : 0) +
                               (unitNode.teams ? unitNode.teams.length : 0) +
                               (unitNode.roles && !unitNode.teams?.length ? 1 : 0) +
                               (unitNode.objects ? unitNode.objects.length : 0);
            children.className = 'orgchart-children' + (childCount > 1 ? ' multiple' : '');

            if (hasChildren) {
                // Sub-units
                if (unitNode.units && unitNode.units.length > 0) {
                    unitNode.units.forEach(subUnit => {
                        const subUnitEl = renderOrgChartUnit(subUnit);
                        children.appendChild(subUnitEl);
                    });
                }

                // Teams
                if (unitNode.teams && unitNode.teams.length > 0) {
                    unitNode.teams.forEach(teamData => {
                        const teamEl = renderOrgChartTeam(teamData);
                        children.appendChild(teamEl);
                    });
                }

                // Direct roles (not in a team) - grouped in a container
                if (unitNode.roles && unitNode.roles.length > 0 && (!unitNode.teams || unitNode.teams.length === 0)) {
                    const rolesContainer = document.createElement('div');
                    rolesContainer.className = 'orgchart-roles-row';
                    unitNode.roles.forEach(roleData => {
                        const roleEl = renderOrgChartRole(roleData);
                        rolesContainer.appendChild(roleEl);
                    });
                    children.appendChild(rolesContainer);
                } else if (unitNode.roles && unitNode.roles.length > 0) {
                    // If there are teams AND direct roles, show direct roles separately
                    const directRolesSection = document.createElement('div');
                    directRolesSection.className = 'orgchart-direct-roles';
                    directRolesSection.innerHTML = `<div class="orgchart-direct-roles-label">Direct Roles</div>`;
                    const rolesRow = document.createElement('div');
                    rolesRow.className = 'orgchart-roles-row';
                    unitNode.roles.forEach(roleData => {
                        const roleEl = renderOrgChartRole(roleData);
                        rolesRow.appendChild(roleEl);
                    });
                    directRolesSection.appendChild(rolesRow);
                    children.appendChild(directRolesSection);
                }

                // Objects directly under unit
                if (unitNode.objects && unitNode.objects.length > 0) {
                    const objectsSection = document.createElement('div');
                    objectsSection.className = 'orgchart-unit-objects';
                    objectsSection.innerHTML = `<div class="orgchart-objects-label">Work Products</div>`;
                    const objectsContainer = document.createElement('div');
                    objectsContainer.className = 'orgchart-objects-container';
                    unitNode.objects.forEach(obj => {
                        const objEl = document.createElement('div');
                        objEl.className = 'orgchart-object-item';
                        objEl.onclick = (e) => {
                            e.stopPropagation();
                            openEntityModal(obj.id, 'object');
                        };
                        objEl.innerHTML = `
                            <div class="orgchart-object-icon"><i class="ph ph-cube"></i></div>
                            <span class="orgchart-object-name">${obj.name}</span>
                        `;
                        objectsContainer.appendChild(objEl);
                    });
                    objectsSection.appendChild(objectsContainer);
                    children.appendChild(objectsSection);
                }
            } else {
                // Show empty state for units with no children
                const emptyState = document.createElement('div');
                emptyState.className = 'orgchart-empty-state';
                emptyState.innerHTML = `<span>No teams or roles</span>`;
                children.appendChild(emptyState);
            }

            node.appendChild(children);

            return node;
        }

        // Render a team node in the org chart
        function renderOrgChartTeam(teamData) {
            const node = document.createElement('div');
            node.className = 'orgchart-team-node orgchart-node';

            const hasRoles = teamData.roles && teamData.roles.length > 0;
            const hasObjects = teamData.objects && teamData.objects.length > 0;
            const hasChildren = hasRoles || hasObjects;
            const peopleCount = teamData.roles ?
                teamData.roles.reduce((sum, r) => sum + (r.people ? r.people.length : 0), 0) : 0;

            // Team card
            const card = document.createElement('div');
            card.className = 'orgchart-team-card';
            card.onclick = (e) => {
                if (!e.target.closest('.orgchart-collapse-btn')) {
                    openEntityModal(teamData.entity.id, 'team');
                }
            };

            card.innerHTML = `
                <div class="orgchart-icon">
                    <i class="ph ph-users-three"></i>
                </div>
                <div class="orgchart-name">${teamData.entity.name}</div>
                <div class="orgchart-meta">${peopleCount} member${peopleCount !== 1 ? 's' : ''}</div>
                ${hasChildren ? `<div class="orgchart-collapse-btn" onclick="event.stopPropagation(); this.closest('.orgchart-node').classList.toggle('collapsed');"><i class="ph ph-caret-down"></i></div>` : ''}
            `;
            node.appendChild(card);

            // Children container - always show to display empty state if needed
            const children = document.createElement('div');
            children.className = 'orgchart-children' + ((teamData.roles && teamData.roles.length > 1) || hasObjects ? ' multiple' : '');

            if (hasRoles) {
                teamData.roles.forEach(roleData => {
                    const roleEl = renderOrgChartRole(roleData);
                    children.appendChild(roleEl);
                });
            }

            // Objects directly under team
            if (hasObjects) {
                const objectsSection = document.createElement('div');
                objectsSection.className = 'orgchart-team-objects';
                teamData.objects.forEach(obj => {
                    const objEl = document.createElement('div');
                    objEl.className = 'orgchart-object-item';
                    objEl.onclick = (e) => {
                        e.stopPropagation();
                        openEntityModal(obj.id, 'object');
                    };
                    objEl.innerHTML = `
                        <div class="orgchart-object-icon"><i class="ph ph-cube"></i></div>
                        <span class="orgchart-object-name">${obj.name}</span>
                    `;
                    objectsSection.appendChild(objEl);
                });
                children.appendChild(objectsSection);
            }

            if (!hasRoles && !hasObjects) {
                // Show empty state for teams with no roles or objects
                const emptyState = document.createElement('div');
                emptyState.className = 'orgchart-empty-state';
                emptyState.innerHTML = `<span>No roles defined</span>`;
                children.appendChild(emptyState);
            }

            node.appendChild(children);

            return node;
        }

        // Render a role node with people and objects nested inside
        function renderOrgChartRole(roleData) {
            const node = document.createElement('div');
            node.className = 'orgchart-role-node';

            const hasPeople = roleData.people && roleData.people.length > 0;
            const hasObjects = roleData.objects && roleData.objects.length > 0;

            // Role card
            const card = document.createElement('div');
            card.className = 'orgchart-role-card';

            // Role header
            const header = document.createElement('div');
            header.className = 'orgchart-role-header';
            header.onclick = () => openEntityModal(roleData.entity.id, 'role');
            header.innerHTML = `
                <div class="orgchart-icon">
                    <i class="ph ph-identification-badge"></i>
                </div>
                <div class="orgchart-name">${roleData.entity.name}</div>
                ${!hasPeople ? '<span class="orgchart-role-vacancy">Vacant</span>' : ''}
            `;
            card.appendChild(header);

            // People nested inside the role card
            if (hasPeople) {
                const peopleContainer = document.createElement('div');
                peopleContainer.className = 'orgchart-role-people';

                roleData.people.forEach(person => {
                    const personRow = document.createElement('div');
                    personRow.className = 'orgchart-person-row';
                    personRow.onclick = (e) => {
                        e.stopPropagation();
                        openEntityModal(person.id, 'person');
                    };
                    personRow.innerHTML = `
                        <div class="orgchart-person-avatar">${getInitials(person.name)}</div>
                        <span class="orgchart-person-name">${person.name}</span>
                    `;
                    peopleContainer.appendChild(personRow);
                });

                card.appendChild(peopleContainer);
            }

            // Objects (work products) nested inside the role card
            if (hasObjects) {
                const objectsContainer = document.createElement('div');
                objectsContainer.className = 'orgchart-role-objects';

                roleData.objects.forEach(obj => {
                    const objRow = document.createElement('div');
                    objRow.className = 'orgchart-object-row';
                    objRow.onclick = (e) => {
                        e.stopPropagation();
                        openEntityModal(obj.id, 'object');
                    };
                    objRow.innerHTML = `
                        <div class="orgchart-object-icon"><i class="ph ph-cube"></i></div>
                        <span class="orgchart-object-name">${obj.name}</span>
                    `;
                    objectsContainer.appendChild(objRow);
                });

                card.appendChild(objectsContainer);
            }

            node.appendChild(card);
            return node;
        }

        // Helper function to get people who fill a role (for org chart)
        function getPeopleInRoleForOrgChart(roleId) {
            return relationships
                .filter(r => r.predicate === 'INS' && r.object === roleId)
                .map(r => findEntity(r.subject))
                .filter(e => e !== null && e.type === 'person');
        }

        // Render the Venn diagram
        function renderVennView() {
            const container = document.getElementById('vennView');
            const svg = d3.select('#vennDiagram');

            if (!container || !svg.node()) return;

            // Clear previous content
            svg.selectAll('*').remove();
            closeOverlapPanel();

            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            const centerX = width / 2;
            const centerY = height / 2;

            svg.attr('viewBox', `0 0 ${width} ${height}`)
               .attr('preserveAspectRatio', 'xMidYMid meet');

            // Update level controls
            updateVennLevelControls();

            // Get entities at current level
            const entitiesAtLevel = getVennEntitiesAtLevel();

            if (entitiesAtLevel.length === 0) {
                // Show empty state
                svg.append('text')
                    .attr('x', centerX)
                    .attr('y', centerY)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#8B6F47')
                    .attr('font-size', '16px')
                    .text(`No ${vennLevelLabels[vennCurrentLevel].toLowerCase()} to display`);
                return;
            }

            // Calculate circle positions and sizes based on number of entities
            const circles = calculateVennCircles(entitiesAtLevel, width, height, centerX, centerY);

            // Calculate overlaps between circles
            const overlaps = calculateVennOverlaps(circles);

            // Draw overlaps first (underneath circles)
            overlaps.forEach(overlap => {
                if (overlap.weight > 0) {
                    drawOverlapRegion(svg, overlap, circles);
                }
            });

            // Draw circles
            circles.forEach(circle => {
                drawVennCircle(svg, circle);
            });

            // Add zoom hint
            showVennZoomHint();
        }

        // Calculate positions for Venn circles using force simulation
        function calculateVennCircles(entitiesAtLevel, width, height, centerX, centerY) {
            const n = entitiesAtLevel.length;
            const maxRadius = Math.min(width, height) * 0.35;
            const minRadius = 60;

            // Calculate radius based on nested entities count
            const circles = entitiesAtLevel.map((entity, i) => {
                const nested = getAllNestedEntities(entity.id);
                const nestedCount = nested.length + 1; // Include self
                const baseRadius = Math.max(minRadius, Math.min(maxRadius, 40 + nestedCount * 8));

                // Initial position in a circle - spread entities further apart
                const angle = (2 * Math.PI * i) / n - Math.PI / 2;
                const spread = Math.min(width, height) * 0.3;

                return {
                    entity: entity,
                    id: entity.id,
                    x: centerX + spread * Math.cos(angle),
                    y: centerY + spread * Math.sin(angle),
                    radius: baseRadius,
                    nestedCount: nestedCount,
                    color: getNodeColor(entity.type)
                };
            });

            // Apply force simulation to position circles with overlaps
            if (n > 1) {
                // Create links for circles that should overlap
                const links = [];
                for (let i = 0; i < circles.length; i++) {
                    for (let j = i + 1; j < circles.length; j++) {
                        const weight = getOverlapWeight(circles[i].id, circles[j].id);
                        if (weight > 0) {
                            // Stronger connection = closer circles, but maintain minimum distance
                            const minDistance = (circles[i].radius + circles[j].radius) * 0.6;
                            const distance = Math.max(minDistance, circles[i].radius + circles[j].radius - Math.min(30, weight * 8));
                            links.push({
                                source: i,
                                target: j,
                                distance: distance
                            });
                        }
                    }
                }

                // Simple force-based positioning with stronger separation
                const simulation = d3.forceSimulation(circles)
                    .force('center', d3.forceCenter(centerX, centerY))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('collision', d3.forceCollide().radius(d => d.radius * 0.9).strength(0.8))
                    .force('link', d3.forceLink(links).distance(d => d.distance).strength(0.3))
                    .stop();

                // Run simulation
                for (let i = 0; i < 100; i++) simulation.tick();

                // Keep circles within bounds
                circles.forEach(c => {
                    c.x = Math.max(c.radius + 10, Math.min(width - c.radius - 10, c.x));
                    c.y = Math.max(c.radius + 60, Math.min(height - c.radius - 10, c.y));
                });
            }

            return circles;
        }

        // Calculate overlaps between all circle pairs
        function calculateVennOverlaps(circles) {
            const overlaps = [];

            for (let i = 0; i < circles.length; i++) {
                for (let j = i + 1; j < circles.length; j++) {
                    const c1 = circles[i];
                    const c2 = circles[j];
                    const dx = c2.x - c1.x;
                    const dy = c2.y - c1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Check if circles overlap
                    if (distance < c1.radius + c2.radius) {
                        const weight = getOverlapWeight(c1.id, c2.id);
                        const sharedConnections = getSharedConnections(c1.id, c2.id);

                        overlaps.push({
                            circle1: c1,
                            circle2: c2,
                            weight: weight,
                            sharedConnections: sharedConnections,
                            distance: distance
                        });
                    }
                }
            }

            return overlaps;
        }

        // Draw a single Venn circle
        function drawVennCircle(svg, circle) {
            const group = svg.append('g')
                .attr('class', 'venn-circle-group')
                .style('cursor', 'pointer');

            // Main circle
            group.append('circle')
                .attr('class', 'venn-circle')
                .attr('cx', circle.x)
                .attr('cy', circle.y)
                .attr('r', circle.radius)
                .attr('fill', circle.color)
                .attr('fill-opacity', 0.25)
                .attr('stroke', circle.color)
                .attr('stroke-width', 3)
                .on('click', () => handleVennCircleClick(circle))
                .on('dblclick', () => drillIntoEntity(circle.entity))
                .on('mouseenter', (event) => showVennTooltip(event, circle))
                .on('mouseleave', hideVennTooltip);

            // Entity name label
            const labelText = circle.entity.name.length > 20
                ? circle.entity.name.substring(0, 17) + '...'
                : circle.entity.name;

            group.append('text')
                .attr('class', 'venn-circle-label')
                .attr('x', circle.x)
                .attr('y', circle.y - 8)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .text(labelText);

            // Count label
            group.append('text')
                .attr('class', 'venn-circle-count')
                .attr('x', circle.x)
                .attr('y', circle.y + 12)
                .attr('text-anchor', 'middle')
                .text(`${circle.nestedCount} nested`);

            // Icon
            group.append('text')
                .attr('x', circle.x)
                .attr('y', circle.y - circle.radius + 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('fill', circle.color)
                .text(getIconChar(circle.entity.type));
        }

        // Draw overlap region between two circles
        function drawOverlapRegion(svg, overlap, circles) {
            const { circle1, circle2, sharedConnections } = overlap;

            // Calculate intersection path
            const path = calculateIntersectionPath(circle1, circle2);
            if (!path) return;

            // Create gradient for overlap
            const gradientId = `overlap-gradient-${circle1.id}-${circle2.id}`;
            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', gradientId)
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '100%').attr('y2', '0%');

            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', circle1.color)
                .attr('stop-opacity', 0.4);
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', circle2.color)
                .attr('stop-opacity', 0.4);

            // Draw overlap area
            const overlapGroup = svg.append('g')
                .attr('class', 'venn-overlap')
                .style('cursor', 'pointer')
                .on('click', () => showOverlapDetails(circle1.entity, circle2.entity, sharedConnections));

            overlapGroup.append('path')
                .attr('d', path)
                .attr('fill', `url(#${gradientId})`)
                .attr('stroke', '#C88F4A')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '4,2');

            // Add connection count indicator in overlap center
            if (sharedConnections.length > 0) {
                const midX = (circle1.x + circle2.x) / 2;
                const midY = (circle1.y + circle2.y) / 2;

                overlapGroup.append('circle')
                    .attr('cx', midX)
                    .attr('cy', midY)
                    .attr('r', 16)
                    .attr('fill', '#C88F4A')
                    .attr('class', 'venn-overlap-indicator');

                overlapGroup.append('text')
                    .attr('x', midX)
                    .attr('y', midY)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('fill', 'white')
                    .attr('font-size', '12px')
                    .attr('font-weight', '600')
                    .attr('class', 'venn-overlap-indicator')
                    .text(sharedConnections.length);
            }
        }

        // Calculate SVG path for circle intersection (lens shape)
        function calculateIntersectionPath(c1, c2) {
            const dx = c2.x - c1.x;
            const dy = c2.y - c1.y;
            const d = Math.sqrt(dx * dx + dy * dy);

            if (d >= c1.radius + c2.radius || d === 0) return null;

            // Calculate intersection points
            const a = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, c1.radius * c1.radius - a * a));

            const px = c1.x + a * dx / d;
            const py = c1.y + a * dy / d;

            const p1x = px + h * dy / d;
            const p1y = py - h * dx / d;
            const p2x = px - h * dy / d;
            const p2y = py + h * dx / d;

            // Create lens-shaped path using arcs
            const largeArc1 = c1.radius > d / 2 ? 1 : 0;
            const largeArc2 = c2.radius > d / 2 ? 1 : 0;

            return `M ${p1x} ${p1y}
                    A ${c1.radius} ${c1.radius} 0 ${largeArc1} 1 ${p2x} ${p2y}
                    A ${c2.radius} ${c2.radius} 0 ${largeArc2} 1 ${p1x} ${p1y}`;
        }

        // Handle click on a Venn circle
        function handleVennCircleClick(circle) {
            openEntityModal(circle.entity.id, circle.entity.type);
        }

        // Drill into an entity to see its children
        function drillIntoEntity(entity) {
            const nextLevel = vennCurrentLevel + 1;
            if (nextLevel >= vennLevels.length) return;

            // Check if entity has children at next level
            const childType = vennLevels[nextLevel];
            const children = getVennChildren(entity.id, childType);

            if (children.length === 0) {
                // Show hint that there's nothing to drill into
                showVennZoomHint(`No ${vennLevelLabels[nextLevel].toLowerCase()} under ${entity.name}`);
                return;
            }

            // Update state and re-render
            vennBreadcrumb.push({ entity: vennFocusedEntity, level: vennCurrentLevel });
            vennFocusedEntity = entity;
            vennCurrentLevel = nextLevel;
            renderVennView();
        }

        // Change hierarchy level
        function changeVennLevel(direction) {
            const newLevel = vennCurrentLevel + direction;

            if (newLevel < 0 || newLevel >= vennLevels.length) return;

            // If going up, clear focus
            if (direction < 0) {
                if (vennBreadcrumb.length > 0) {
                    const prev = vennBreadcrumb.pop();
                    vennFocusedEntity = prev.entity;
                } else {
                    vennFocusedEntity = null;
                }
            }

            vennCurrentLevel = newLevel;
            renderVennView();
        }

        // Update level navigation controls
        function updateVennLevelControls() {
            const upBtn = document.getElementById('vennLevelUp');
            const downBtn = document.getElementById('vennLevelDown');
            const label = document.getElementById('vennLevelLabel');
            const breadcrumb = document.getElementById('vennBreadcrumb');

            if (upBtn) upBtn.disabled = vennCurrentLevel === 0;
            if (downBtn) downBtn.disabled = vennCurrentLevel >= vennLevels.length - 1;
            if (label) label.textContent = vennLevelLabels[vennCurrentLevel];

            // Update breadcrumb
            if (breadcrumb) {
                let html = '';
                vennBreadcrumb.forEach((item, i) => {
                    if (item.entity) {
                        html += `<span class="venn-breadcrumb-item" onclick="navigateVennBreadcrumb(${i})">${item.entity.name}</span>`;
                        html += '<span class="venn-breadcrumb-separator">›</span>';
                    }
                });
                if (vennFocusedEntity) {
                    html += `<span class="venn-breadcrumb-item active">${vennFocusedEntity.name}</span>`;
                }
                breadcrumb.innerHTML = html;
            }
        }

        // Navigate via breadcrumb
        function navigateVennBreadcrumb(index) {
            if (index < vennBreadcrumb.length) {
                const target = vennBreadcrumb[index];
                vennBreadcrumb = vennBreadcrumb.slice(0, index);
                vennFocusedEntity = target.entity;
                vennCurrentLevel = target.level;
                renderVennView();
            }
        }

        // Show overlap details panel
        function showOverlapDetails(entity1, entity2, sharedConnections) {
            const panel = document.getElementById('vennOverlapPanel');
            const title = document.getElementById('vennOverlapTitle');
            const content = document.getElementById('vennOverlapContent');

            if (!panel || !content) return;

            title.textContent = `${entity1.name} ↔ ${entity2.name}`;

            let html = '';

            if (sharedConnections.length === 0) {
                html = '<div style="color: #8B6F47; text-align: center; padding: 1rem;">No shared connections</div>';
            } else {
                html += `<div class="venn-shared-label">
                    <i class="ph ph-link"></i> Shared Connections
                    <span class="venn-shared-count">${sharedConnections.length}</span>
                </div>`;

                // Group by relationship type
                const grouped = {};
                sharedConnections.forEach(conn => {
                    const op = eoOperators[conn.relationship.predicate];
                    const key = op ? op.label : conn.relationship.predicate;
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(conn);
                });

                Object.keys(grouped).forEach(key => {
                    html += `<div class="venn-entity-section">
                        <div class="venn-entity-header">
                            <i class="ph ph-arrow-right"></i> ${key}
                        </div>`;

                    grouped[key].forEach(conn => {
                        html += `
                            <div class="venn-connection-item" onclick="openEntityModal('${conn.from.id}', '${conn.from.type}')">
                                <div class="venn-connection-icon" style="background: ${getNodeColor(conn.from.type)}">
                                    ${getIcon(conn.from.type)}
                                </div>
                                <div class="venn-connection-info">
                                    <div class="venn-connection-name">${conn.from.name}</div>
                                    <div class="venn-connection-type">${conn.from.type}</div>
                                </div>
                            </div>
                            <div style="text-align: center; color: #C88F4A; margin: 0.25rem 0;">
                                <i class="ph ph-arrow-down"></i>
                            </div>
                            <div class="venn-connection-item" onclick="openEntityModal('${conn.to.id}', '${conn.to.type}')">
                                <div class="venn-connection-icon" style="background: ${getNodeColor(conn.to.type)}">
                                    ${getIcon(conn.to.type)}
                                </div>
                                <div class="venn-connection-info">
                                    <div class="venn-connection-name">${conn.to.name}</div>
                                    <div class="venn-connection-type">${conn.to.type}</div>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                });
            }

            content.innerHTML = html;
            panel.classList.add('visible');
        }

        // Close overlap details panel
        function closeOverlapPanel() {
            const panel = document.getElementById('vennOverlapPanel');
            if (panel) panel.classList.remove('visible');
        }

        // Show tooltip on hover
        function showVennTooltip(event, circle) {
            const tooltip = document.getElementById('vennTooltip');
            if (!tooltip) return;

            const nested = getAllNestedEntities(circle.entity.id);
            const nestedByType = {};
            nested.forEach(e => {
                if (!nestedByType[e.type]) nestedByType[e.type] = 0;
                nestedByType[e.type]++;
            });

            let nestedText = Object.keys(nestedByType)
                .map(type => `${nestedByType[type]} ${type}${nestedByType[type] > 1 ? 's' : ''}`)
                .join(', ');

            tooltip.innerHTML = `
                <div class="venn-tooltip-title">${circle.entity.name}</div>
                <div class="venn-tooltip-desc">
                    ${circle.entity.description || 'No description'}<br>
                    <strong>Contains:</strong> ${nestedText || 'Nothing nested'}
                </div>
            `;

            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
            tooltip.classList.add('visible');
        }

        // Hide tooltip
        function hideVennTooltip() {
            const tooltip = document.getElementById('vennTooltip');
            if (tooltip) tooltip.classList.remove('visible');
        }

        // Show temporary hint
        function showVennZoomHint(message) {
            const hint = document.querySelector('.venn-zoom-hint');
            if (!hint) {
                // Create hint element
                const vennView = document.getElementById('vennView');
                if (vennView) {
                    const hintEl = document.createElement('div');
                    hintEl.className = 'venn-zoom-hint';
                    hintEl.textContent = message || 'Double-click to drill down';
                    vennView.appendChild(hintEl);
                    setTimeout(() => hintEl.classList.add('visible'), 10);
                    setTimeout(() => {
                        hintEl.classList.remove('visible');
                        setTimeout(() => hintEl.remove(), 300);
                    }, 2000);
                }
            }
        }

        // Card View State
        let cardViewSearchTerm = '';
        let cardViewSortOption = 'name-asc';
        let cardViewTypeFilters = {
            unit: true,
            team: true,
            role: true,
            person: true,
            task: true,
            product: true,
            workflow: true,
            activity: true
        };
        let cardViewHierarchical = true; // Default to hierarchical view
        let cardViewGroupBy = 'none'; // Group by: 'none', 'unit', 'team', 'role'
        let cardViewFirstColumnEntity = null; // Entity to show as first column when grouping

        function toggleCardViewMode(isHierarchical) {
            cardViewHierarchical = isHierarchical;
            renderCardView();
        }

        // Build hierarchy tree from DES relationships
        function buildHierarchyTree() {
            // Find all DES relationships (parent defines child)
            const desRelationships = relationships.filter(r => r.predicate === 'DES');

            // Track which entities have parents
            const entitiesWithParents = new Set(desRelationships.map(r => r.object));

            // Get children for a given parent entity
            function getChildren(parentId) {
                return desRelationships
                    .filter(r => r.subject === parentId)
                    .map(r => findEntity(r.object))
                    .filter(e => e !== null);
            }

            // Get people who fill a role (via INS relationships)
            function getPeopleInRole(roleId) {
                return relationships
                    .filter(r => r.predicate === 'INS' && r.object === roleId)
                    .map(r => findEntity(r.subject))
                    .filter(e => e !== null && e.type === 'person');
            }

            // Get objects (work products) under an entity (via DES relationships)
            function getObjectsUnder(parentId) {
                return getChildren(parentId).filter(e => e.type === 'object');
            }

            // Recursively build unit node with nested units, teams, and roles
            function buildUnitNode(unit) {
                const directTeams = getChildren(unit.id).filter(e => e.type === 'team');
                const directRoles = getChildren(unit.id).filter(e => e.type === 'role');
                const directObjects = getObjectsUnder(unit.id);
                const childUnits = getChildren(unit.id).filter(e => e.type === 'unit');

                return {
                    entity: unit,
                    units: childUnits.map(childUnit => buildUnitNode(childUnit)),
                    teams: directTeams.map(team => {
                        const teamRoles = getChildren(team.id).filter(e => e.type === 'role');
                        const teamObjects = getObjectsUnder(team.id);
                        return {
                            entity: team,
                            roles: teamRoles.map(role => ({
                                entity: role,
                                people: getPeopleInRole(role.id),
                                objects: getObjectsUnder(role.id)
                            })),
                            objects: teamObjects
                        };
                    }),
                    roles: directRoles.map(role => ({
                        entity: role,
                        people: getPeopleInRole(role.id),
                        objects: getObjectsUnder(role.id)
                    })),
                    objects: directObjects
                };
            }

            // Find top-level units (units that don't have a parent unit)
            const topLevelUnits = entities.unit.filter(unit => {
                return !desRelationships.some(r =>
                    r.object === unit.id && entities.unit.some(u => u.id === r.subject)
                );
            });

            // Build tree structure starting from top-level units only
            const hierarchyTree = topLevelUnits.map(unit => buildUnitNode(unit));

            // Find orphan entities (no DES parent)
            const orphanTeams = entities.team.filter(t => !entitiesWithParents.has(t.id));
            const orphanRoles = entities.role.filter(r => !entitiesWithParents.has(r.id));
            const orphanTasks = entities.task.filter(t => !entitiesWithParents.has(t.id));
            const orphanProducts = entities.product.filter(p => !entitiesWithParents.has(p.id));
            const orphanWorkflows = entities.workflow.filter(w => !entitiesWithParents.has(w.id));
            // People not assigned to any role (via INS relationship)
            const peopleWithRoles = new Set(
                relationships.filter(r => r.predicate === 'INS').map(r => r.subject)
            );
            const orphanPeople = entities.person.filter(p => !peopleWithRoles.has(p.id));

            return {
                units: hierarchyTree,
                orphanTeams,
                orphanRoles,
                orphanPeople,
                orphanTasks,
                orphanProducts,
                orphanWorkflows
            };
        }

        // Get non-DES activities for an entity
        function getEntityActivities(entityId) {
            return relationships.filter(r =>
                (r.subject === entityId || r.object === entityId) && r.predicate !== 'DES' && r.predicate !== 'INS'
            );
        }

        // Card View Filtering and Sorting Functions
        function filterEntitiesBySearch(entitiesArray, searchTerm) {
            if (!searchTerm) return entitiesArray;
            const term = searchTerm.toLowerCase();
            return entitiesArray.filter(entity =>
                entity.name.toLowerCase().includes(term) ||
                (entity.description && entity.description.toLowerCase().includes(term))
            );
        }

        function sortEntities(entitiesArray, sortOption) {
            const sorted = [...entitiesArray];
            switch (sortOption) {
                case 'name-asc':
                    return sorted.sort((a, b) => a.name.localeCompare(b.name));
                case 'name-desc':
                    return sorted.sort((a, b) => b.name.localeCompare(a.name));
                case 'connections-desc':
                    return sorted.sort((a, b) => {
                        const aConnections = relationships.filter(r => r.subject === a.id || r.object === a.id).length;
                        const bConnections = relationships.filter(r => r.subject === b.id || r.object === b.id).length;
                        return bConnections - aConnections;
                    });
                case 'connections-asc':
                    return sorted.sort((a, b) => {
                        const aConnections = relationships.filter(r => r.subject === a.id || r.object === a.id).length;
                        const bConnections = relationships.filter(r => r.subject === b.id || r.object === b.id).length;
                        return aConnections - bConnections;
                    });
                default:
                    return sorted;
            }
        }

        function handleCardViewSearch(event) {
            cardViewSearchTerm = event.target.value;
            renderCardViewContent();
        }

        function handleCardViewSort(event) {
            cardViewSortOption = event.target.value;
            renderCardViewContent();
        }

        function handleCardViewGroupBy(event) {
            cardViewGroupBy = event.target.value;
            // Clear first column entity when user manually changes groupBy
            cardViewFirstColumnEntity = null;
            renderCardViewContent();
        }

        function toggleCardViewTypeFilter(type) {
            cardViewTypeFilters[type] = !cardViewTypeFilters[type];
            renderCardView();
        }

        // Open card view with a specific entity as the first column
        function openViewFromEntity(entityId, entityType) {
            const entity = entities[entityType]?.find(e => e.id === entityId);
            if (!entity) return;

            // Set the first column entity
            cardViewFirstColumnEntity = entity;

            // Set groupBy based on entity type (units, teams, and roles can be grouped by)
            if (entityType === 'unit' || entityType === 'team' || entityType === 'role') {
                cardViewGroupBy = entityType;
            }

            // Switch to flat view so grouping is visible
            cardViewHierarchical = false;

            // Close the modal and switch to card view
            closeEntityModal();
            switchView('card');
        }

        // Clear the first column entity (called when manually changing groupBy)
        function clearFirstColumnEntity() {
            cardViewFirstColumnEntity = null;
        }

        // Card View Rendering
        function renderCardView() {
            const container = document.getElementById('cardView');
            if (!container) return;

            container.innerHTML = '';

            // Create controls toolbar
            const controls = document.createElement('div');
            controls.className = 'card-view-controls';

            // Search input
            const searchContainer = document.createElement('div');
            searchContainer.className = 'card-search-container';
            searchContainer.innerHTML = `
                <i class="ph ph-magnifying-glass card-search-icon"></i>
                <input type="text"
                       class="card-search-input"
                       placeholder="Search entities..."
                       value="${cardViewSearchTerm}"
                       oninput="handleCardViewSearch(event)">
            `;
            controls.appendChild(searchContainer);

            // Sort dropdown
            const sortContainer = document.createElement('div');
            sortContainer.className = 'card-sort-container';
            sortContainer.innerHTML = `
                <span class="card-sort-label">Sort by:</span>
                <select class="card-sort-select" onchange="handleCardViewSort(event)">
                    <option value="name-asc" ${cardViewSortOption === 'name-asc' ? 'selected' : ''}>Name (A-Z)</option>
                    <option value="name-desc" ${cardViewSortOption === 'name-desc' ? 'selected' : ''}>Name (Z-A)</option>
                    <option value="connections-desc" ${cardViewSortOption === 'connections-desc' ? 'selected' : ''}>Most Connections</option>
                    <option value="connections-asc" ${cardViewSortOption === 'connections-asc' ? 'selected' : ''}>Fewest Connections</option>
                </select>
            `;
            controls.appendChild(sortContainer);

            // Group By dropdown
            const groupByContainer = document.createElement('div');
            groupByContainer.className = 'card-sort-container';
            groupByContainer.innerHTML = `
                <span class="card-sort-label">Group by:</span>
                <select class="card-sort-select" onchange="handleCardViewGroupBy(event)">
                    <option value="none" ${cardViewGroupBy === 'none' ? 'selected' : ''}>None</option>
                    <option value="unit" ${cardViewGroupBy === 'unit' ? 'selected' : ''}>Unit</option>
                    <option value="team" ${cardViewGroupBy === 'team' ? 'selected' : ''}>Team</option>
                    <option value="role" ${cardViewGroupBy === 'role' ? 'selected' : ''}>Role</option>
                </select>
            `;
            controls.appendChild(groupByContainer);

            // View mode toggle (flat vs hierarchical)
            const viewModeToggle = document.createElement('div');
            viewModeToggle.className = 'view-mode-toggle';
            viewModeToggle.innerHTML = `
                <button class="view-mode-btn ${cardViewHierarchical ? 'active' : ''}" onclick="toggleCardViewMode(true)">
                    <i class="ph ph-tree-structure"></i>
                    Nested
                </button>
                <button class="view-mode-btn ${!cardViewHierarchical ? 'active' : ''}" onclick="toggleCardViewMode(false)">
                    <i class="ph ph-squares-four"></i>
                    Flat
                </button>
            `;
            controls.appendChild(viewModeToggle);

            // Type filter buttons
            const filterButtons = document.createElement('div');
            filterButtons.className = 'card-filter-buttons';

            const typeConfigs = [
                { type: 'activity', label: 'Activities', icon: '⚡', count: relationships.length },
                { type: 'role', label: 'Roles', icon: getIcon('role'), count: entities.role.length },
                { type: 'person', label: 'People', icon: getIcon('person'), count: entities.person.length },
                { type: 'task', label: 'Tasks', icon: getIcon('task'), count: entities.task.length },
                { type: 'product', label: 'Products', icon: getIcon('product'), count: entities.product.length },
                { type: 'workflow', label: 'Workflows', icon: getIcon('workflow'), count: entities.workflow.length },
                { type: 'team', label: 'Teams', icon: getIcon('team'), count: entities.team.length },
                { type: 'unit', label: 'Units', icon: getIcon('unit'), count: entities.unit.length }
            ];

            typeConfigs.forEach(config => {
                if (config.count > 0) {
                    const btn = document.createElement('button');
                    btn.className = `card-filter-btn ${cardViewTypeFilters[config.type] ? 'active' : ''}`;
                    btn.onclick = () => toggleCardViewTypeFilter(config.type);
                    btn.innerHTML = `
                        <span class="filter-icon">${config.icon}</span>
                        <span>${config.label}</span>
                        <span class="filter-count">${config.count}</span>
                    `;
                    filterButtons.appendChild(btn);
                }
            });
            controls.appendChild(filterButtons);

            container.appendChild(controls);

            // Create content container
            const contentContainer = document.createElement('div');
            contentContainer.className = 'card-view-content';
            contentContainer.id = 'cardViewContent';
            container.appendChild(contentContainer);

            // Render the actual cards
            renderCardViewContent();
        }

        function renderCardViewContent() {
            const contentContainer = document.getElementById('cardViewContent');
            if (!contentContainer) return;

            contentContainer.innerHTML = '';

            const sidebarFilters = getActiveFilters();
            let hasContent = false;

            if (cardViewHierarchical) {
                // Hierarchical/nested view
                hasContent = renderHierarchicalCardView(contentContainer, sidebarFilters);
            } else if (cardViewGroupBy !== 'none') {
                // Grouped flat view
                hasContent = renderGroupedFlatCardView(contentContainer, sidebarFilters);
            } else {
                // Flat view (original behavior)
                hasContent = renderFlatCardView(contentContainer, sidebarFilters);
            }

            // Show no results message if nothing matches
            if (!hasContent) {
                const noResults = document.createElement('div');
                noResults.className = 'card-no-results';
                noResults.innerHTML = `
                    <i class="ph ph-magnifying-glass"></i>
                    <p>No entities match your search or filter criteria.</p>
                `;
                contentContainer.appendChild(noResults);
            }
        }

        function renderFlatCardView(contentContainer, sidebarFilters) {
            let hasContent = false;

            // Activities (tasks) - shown first as the most familiar entry point
            if (cardViewTypeFilters.activity && relationships.length > 0) {
                const activityRow = createActivityCardRowFiltered();
                if (activityRow) {
                    contentContainer.appendChild(activityRow);
                    hasContent = true;
                }
            }

            // Roles - the core organizational unit where work is assigned
            if (cardViewTypeFilters.role && sidebarFilters.entities.role && entities.role.length > 0) {
                let filteredRoles = filterEntitiesBySearch(entities.role, cardViewSearchTerm);
                filteredRoles = sortEntities(filteredRoles, cardViewSortOption);
                if (filteredRoles.length > 0) {
                    contentContainer.appendChild(createCardRow('Roles', filteredRoles, getIcon('role')));
                    hasContent = true;
                }
            }

            // People - tagged to roles
            if (cardViewTypeFilters.person && sidebarFilters.entities.person && entities.person.length > 0) {
                let filteredPeople = filterEntitiesBySearch(entities.person, cardViewSearchTerm);
                filteredPeople = sortEntities(filteredPeople, cardViewSortOption);
                if (filteredPeople.length > 0) {
                    contentContainer.appendChild(createCardRow('People', filteredPeople, getIcon('person')));
                    hasContent = true;
                }
            }

            // Tasks
            if (cardViewTypeFilters.task && sidebarFilters.entities.task && entities.task.length > 0) {
                let filteredTasks = filterEntitiesBySearch(entities.task, cardViewSearchTerm);
                filteredTasks = sortEntities(filteredTasks, cardViewSortOption);
                if (filteredTasks.length > 0) {
                    contentContainer.appendChild(createCardRow('Tasks', filteredTasks, getIcon('task')));
                    hasContent = true;
                }
            }

            // Work Products
            if (cardViewTypeFilters.product && sidebarFilters.entities.product && entities.product.length > 0) {
                let filteredProducts = filterEntitiesBySearch(entities.product, cardViewSearchTerm);
                filteredProducts = sortEntities(filteredProducts, cardViewSortOption);
                if (filteredProducts.length > 0) {
                    contentContainer.appendChild(createCardRow('Work Products', filteredProducts, getIcon('product')));
                    hasContent = true;
                }
            }

            // Workflows
            if (cardViewTypeFilters.workflow && sidebarFilters.entities.workflow && entities.workflow.length > 0) {
                let filteredWorkflows = filterEntitiesBySearch(entities.workflow, cardViewSearchTerm);
                filteredWorkflows = sortEntities(filteredWorkflows, cardViewSortOption);
                if (filteredWorkflows.length > 0) {
                    contentContainer.appendChild(createCardRow('Workflows', filteredWorkflows, getIcon('workflow')));
                    hasContent = true;
                }
            }

            // Teams - emergent structure
            if (cardViewTypeFilters.team && sidebarFilters.entities.team && entities.team.length > 0) {
                let filteredTeams = filterEntitiesBySearch(entities.team, cardViewSearchTerm);
                filteredTeams = sortEntities(filteredTeams, cardViewSortOption);
                if (filteredTeams.length > 0) {
                    contentContainer.appendChild(createCardRow('Teams', filteredTeams, getIcon('team')));
                    hasContent = true;
                }
            }

            // Units - deeper structure
            if (cardViewTypeFilters.unit && sidebarFilters.entities.unit && entities.unit.length > 0) {
                let filteredUnits = filterEntitiesBySearch(entities.unit, cardViewSearchTerm);
                filteredUnits = sortEntities(filteredUnits, cardViewSortOption);
                if (filteredUnits.length > 0) {
                    contentContainer.appendChild(createCardRow('Units', filteredUnits, getIcon('unit')));
                    hasContent = true;
                }
            }

            return hasContent;
        }

        // Get the parent team or unit that a role belongs to (for disambiguation)
        function getRoleParentTeam(roleId) {
            // Find DES relationship where role is the object (child)
            const desRelationship = relationships.find(r =>
                r.predicate === 'DES' && r.object === roleId
            );
            if (!desRelationship) return null;

            const parentEntity = findEntity(desRelationship.subject);
            // Return the parent if it's a team or unit
            if (parentEntity && (parentEntity.type === 'team' || parentEntity.type === 'unit')) {
                return parentEntity;
            }
            return null;
        }

        // Get the parent entity of an entity based on the groupBy type
        function getParentEntity(entity, groupByType) {
            // Find DES relationship where entity is the object (child)
            const desRelationship = relationships.find(r =>
                r.predicate === 'DES' && r.object === entity.id
            );

            if (!desRelationship) return null;

            const parentEntity = findEntity(desRelationship.subject);
            if (!parentEntity) return null;

            // If groupByType matches parent type, return it
            if (parentEntity.type === groupByType) {
                return parentEntity;
            }

            // Otherwise, recursively look up the chain
            // e.g., if we want to group roles by unit, but role's parent is team,
            // we need to find team's parent unit
            if (groupByType === 'unit' && parentEntity.type === 'team') {
                return getParentEntity(parentEntity, 'unit');
            }

            // For other cases, no parent found
            return null;
        }

        // People cannot have activities tied to them - they have no parent
        function getPersonParent(person, groupByType) {
            return null;
        }

        function renderGroupedFlatCardView(contentContainer, sidebarFilters) {
            let hasContent = false;
            const groupByType = cardViewGroupBy;

            // Helper to get parent for any entity
            function getParentForEntity(entity) {
                if (entity.type === 'person') {
                    return getPersonParent(entity, groupByType);
                }
                return getParentEntity(entity, groupByType);
            }

            // Helper to render a grouped section
            function renderGroupedSection(entityType, typeLabel, icon, allEntities) {
                if (!allEntities || allEntities.length === 0) return false;

                let filteredEntities = filterEntitiesBySearch(allEntities, cardViewSearchTerm);
                filteredEntities = sortEntities(filteredEntities, cardViewSortOption);

                if (filteredEntities.length === 0) return false;

                // Group entities by their parent
                const groups = new Map();
                const ungrouped = [];

                filteredEntities.forEach(entity => {
                    const parent = getParentForEntity(entity);
                    if (parent) {
                        if (!groups.has(parent.id)) {
                            groups.set(parent.id, { parent, entities: [] });
                        }
                        groups.get(parent.id).entities.push(entity);
                    } else {
                        ungrouped.push(entity);
                    }
                });

                // Get groupBy type label and icon
                const groupByLabel = groupByType === 'unit' ? 'Unit' :
                                     groupByType === 'team' ? 'Team' : 'Role';
                const groupByIcon = getIcon(groupByType);

                // Create section for this entity type
                const section = document.createElement('div');
                section.className = 'card-row grouped-section';

                const header = document.createElement('div');
                header.className = 'card-row-header';
                header.innerHTML = `
                    <div class="card-row-title">
                        ${icon} ${typeLabel}
                        <span class="card-row-count">${filteredEntities.length}</span>
                        <span class="grouped-by-label">grouped by ${groupByLabel}</span>
                    </div>
                `;
                section.appendChild(header);

                // Sort groups by parent name, but put first column entity first
                const sortedGroups = Array.from(groups.values())
                    .sort((a, b) => {
                        // If cardViewFirstColumnEntity is set, put it first
                        if (cardViewFirstColumnEntity) {
                            if (a.parent.id === cardViewFirstColumnEntity.id) return -1;
                            if (b.parent.id === cardViewFirstColumnEntity.id) return 1;
                        }
                        return a.parent.name.localeCompare(b.parent.name);
                    });

                // Render each group
                sortedGroups.forEach(group => {
                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'entity-group';

                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'entity-group-header';
                    groupHeader.innerHTML = `
                        <span class="entity-group-icon">${groupByIcon}</span>
                        <span class="entity-group-name">${group.parent.name}</span>
                        <span class="entity-group-count">${group.entities.length}</span>
                    `;
                    groupContainer.appendChild(groupHeader);

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    group.entities.forEach(entity => {
                        grid.appendChild(createSimpleEntityCard(entity));
                    });
                    groupContainer.appendChild(grid);

                    section.appendChild(groupContainer);
                });

                // Render ungrouped entities
                if (ungrouped.length > 0) {
                    const ungroupedContainer = document.createElement('div');
                    ungroupedContainer.className = 'entity-group ungrouped';

                    const ungroupedHeader = document.createElement('div');
                    ungroupedHeader.className = 'entity-group-header';
                    ungroupedHeader.innerHTML = `
                        <span class="entity-group-icon">○</span>
                        <span class="entity-group-name">No ${groupByLabel}</span>
                        <span class="entity-group-count">${ungrouped.length}</span>
                    `;
                    ungroupedContainer.appendChild(ungroupedHeader);

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    ungrouped.forEach(entity => {
                        grid.appendChild(createSimpleEntityCard(entity));
                    });
                    ungroupedContainer.appendChild(grid);

                    section.appendChild(ungroupedContainer);
                }

                contentContainer.appendChild(section);
                return true;
            }

            // Can't group units (they're top-level) - render normally
            if (cardViewTypeFilters.unit && sidebarFilters.entities.unit && entities.unit.length > 0) {
                let filteredUnits = filterEntitiesBySearch(entities.unit, cardViewSearchTerm);
                filteredUnits = sortEntities(filteredUnits, cardViewSortOption);
                if (filteredUnits.length > 0) {
                    contentContainer.appendChild(createCardRow('Units', filteredUnits, getIcon('unit')));
                    hasContent = true;
                }
            }

            // Teams - can be grouped by unit
            if (cardViewTypeFilters.team && sidebarFilters.entities.team && entities.team.length > 0) {
                if (groupByType === 'unit') {
                    if (renderGroupedSection('team', 'Teams', getIcon('team'), entities.team)) {
                        hasContent = true;
                    }
                } else {
                    let filteredTeams = filterEntitiesBySearch(entities.team, cardViewSearchTerm);
                    filteredTeams = sortEntities(filteredTeams, cardViewSortOption);
                    if (filteredTeams.length > 0) {
                        contentContainer.appendChild(createCardRow('Teams', filteredTeams, getIcon('team')));
                        hasContent = true;
                    }
                }
            }

            // Roles - can be grouped by unit or team
            if (cardViewTypeFilters.role && sidebarFilters.entities.role && entities.role.length > 0) {
                if (groupByType === 'unit' || groupByType === 'team') {
                    if (renderGroupedSection('role', 'Roles', getIcon('role'), entities.role)) {
                        hasContent = true;
                    }
                } else {
                    let filteredRoles = filterEntitiesBySearch(entities.role, cardViewSearchTerm);
                    filteredRoles = sortEntities(filteredRoles, cardViewSortOption);
                    if (filteredRoles.length > 0) {
                        contentContainer.appendChild(createCardRow('Roles', filteredRoles, getIcon('role')));
                        hasContent = true;
                    }
                }
            }

            // People - can be grouped by unit, team, or role
            if (cardViewTypeFilters.person && sidebarFilters.entities.person && entities.person.length > 0) {
                if (groupByType === 'unit' || groupByType === 'team' || groupByType === 'role') {
                    if (renderGroupedSection('person', 'People', getIcon('person'), entities.person)) {
                        hasContent = true;
                    }
                } else {
                    let filteredPeople = filterEntitiesBySearch(entities.person, cardViewSearchTerm);
                    filteredPeople = sortEntities(filteredPeople, cardViewSortOption);
                    if (filteredPeople.length > 0) {
                        contentContainer.appendChild(createCardRow('People', filteredPeople, getIcon('person')));
                        hasContent = true;
                    }
                }
            }

            // Tasks
            if (cardViewTypeFilters.task && sidebarFilters.entities.task && entities.task.length > 0) {
                let filteredTasks = filterEntitiesBySearch(entities.task, cardViewSearchTerm);
                filteredTasks = sortEntities(filteredTasks, cardViewSortOption);
                if (filteredTasks.length > 0) {
                    contentContainer.appendChild(createCardRow('Tasks', filteredTasks, getIcon('task')));
                    hasContent = true;
                }
            }

            // Work Products
            if (cardViewTypeFilters.product && sidebarFilters.entities.product && entities.product.length > 0) {
                let filteredProducts = filterEntitiesBySearch(entities.product, cardViewSearchTerm);
                filteredProducts = sortEntities(filteredProducts, cardViewSortOption);
                if (filteredProducts.length > 0) {
                    contentContainer.appendChild(createCardRow('Work Products', filteredProducts, getIcon('product')));
                    hasContent = true;
                }
            }

            // Workflows
            if (cardViewTypeFilters.workflow && sidebarFilters.entities.workflow && entities.workflow.length > 0) {
                let filteredWorkflows = filterEntitiesBySearch(entities.workflow, cardViewSearchTerm);
                filteredWorkflows = sortEntities(filteredWorkflows, cardViewSortOption);
                if (filteredWorkflows.length > 0) {
                    contentContainer.appendChild(createCardRow('Workflows', filteredWorkflows, getIcon('workflow')));
                    hasContent = true;
                }
            }

            // Activities
            if (cardViewTypeFilters.activity && relationships.length > 0) {
                const activityRow = createActivityCardRowFiltered();
                if (activityRow) {
                    contentContainer.appendChild(activityRow);
                    hasContent = true;
                }
            }

            return hasContent;
        }

        function renderHierarchicalCardView(contentContainer, sidebarFilters) {
            const hierarchy = buildHierarchyTree();
            let hasContent = false;

            // Helper to check if entity passes search filter
            function passesSearch(entity) {
                if (!cardViewSearchTerm) return true;
                const term = cardViewSearchTerm.toLowerCase();
                return entity.name.toLowerCase().includes(term) ||
                       (entity.description && entity.description.toLowerCase().includes(term));
            }

            // Helper to check if any child entities pass the search
            function hasMatchingDescendants(unitNode) {
                // Check nested units (recursive)
                if (unitNode.units) {
                    for (const childUnitNode of unitNode.units) {
                        if (passesSearch(childUnitNode.entity)) return true;
                        if (hasMatchingDescendants(childUnitNode)) return true;
                    }
                }
                // Check teams
                for (const teamNode of unitNode.teams) {
                    if (passesSearch(teamNode.entity)) return true;
                    for (const roleNode of teamNode.roles) {
                        if (passesSearch(roleNode.entity)) return true;
                        for (const person of roleNode.people) {
                            if (passesSearch(person)) return true;
                        }
                    }
                }
                // Check direct roles
                for (const roleNode of unitNode.roles) {
                    if (passesSearch(roleNode.entity)) return true;
                    for (const person of roleNode.people) {
                        if (passesSearch(person)) return true;
                    }
                }
                return false;
            }

            // Render unit hierarchy section
            if (cardViewTypeFilters.unit && sidebarFilters.entities.unit && hierarchy.units.length > 0) {
                const hierarchySection = document.createElement('div');
                hierarchySection.className = 'card-row';

                const header = document.createElement('div');
                header.className = 'card-row-header';
                header.innerHTML = `<div class="card-row-title">${getIcon('unit')} Organizational Hierarchy</div>`;
                hierarchySection.appendChild(header);

                const grid = document.createElement('div');
                grid.className = 'hierarchy-grid';

                hierarchy.units.forEach(unitNode => {
                    // Check if this unit or any descendants match the search
                    if (!passesSearch(unitNode.entity) && !hasMatchingDescendants(unitNode)) {
                        return;
                    }

                    const unitCard = createHierarchyUnitCard(unitNode, sidebarFilters);
                    if (unitCard) {
                        grid.appendChild(unitCard);
                        hasContent = true;
                    }
                });

                if (grid.children.length > 0) {
                    hierarchySection.appendChild(grid);
                    contentContainer.appendChild(hierarchySection);
                }
            }

            // Fallback: Render units that have circular parent relationships (no top-level units found)
            // This handles cases where units form cycles (e.g., Unit A defines Unit B and Unit B defines Unit A)
            if (cardViewTypeFilters.unit && sidebarFilters.entities.unit && hierarchy.units.length === 0 && entities.unit.length > 0) {
                const filteredUnits = entities.unit.filter(passesSearch);
                if (filteredUnits.length > 0) {
                    const unitsSection = document.createElement('div');
                    unitsSection.className = 'card-row';

                    const header = document.createElement('div');
                    header.className = 'card-row-header';
                    header.innerHTML = `<div class="card-row-title">${getIcon('unit')} Units</div>`;
                    unitsSection.appendChild(header);

                    const grid = document.createElement('div');
                    grid.className = 'hierarchy-grid';

                    // Build unit nodes for all units and render them
                    filteredUnits.forEach(unit => {
                        // Build a unit node for this unit
                        const desRelationships = relationships.filter(r => r.predicate === 'DES');
                        function getChildren(parentId) {
                            return desRelationships
                                .filter(r => r.subject === parentId)
                                .map(r => findEntity(r.object))
                                .filter(e => e !== null);
                        }
                        function getPeopleInRole(roleId) {
                            return relationships
                                .filter(r => r.predicate === 'INS' && r.object === roleId)
                                .map(r => findEntity(r.subject))
                                .filter(e => e !== null && e.type === 'person');
                        }

                        const directTeams = getChildren(unit.id).filter(e => e.type === 'team');
                        const directRoles = getChildren(unit.id).filter(e => e.type === 'role');

                        const unitNode = {
                            entity: unit,
                            units: [], // Don't recursively include child units to avoid infinite loops
                            teams: directTeams.map(team => {
                                const teamRoles = getChildren(team.id).filter(e => e.type === 'role');
                                return {
                                    entity: team,
                                    roles: teamRoles.map(role => ({
                                        entity: role,
                                        people: getPeopleInRole(role.id)
                                    }))
                                };
                            }),
                            roles: directRoles.map(role => ({
                                entity: role,
                                people: getPeopleInRole(role.id)
                            }))
                        };

                        const unitCard = createHierarchyUnitCard(unitNode, sidebarFilters);
                        if (unitCard) {
                            grid.appendChild(unitCard);
                            hasContent = true;
                        }
                    });

                    if (grid.children.length > 0) {
                        unitsSection.appendChild(grid);
                        contentContainer.appendChild(unitsSection);
                    }
                }
            }

            // Render orphan teams (teams without a parent unit)
            if (cardViewTypeFilters.team && sidebarFilters.entities.team && hierarchy.orphanTeams.length > 0) {
                const filteredOrphanTeams = hierarchy.orphanTeams.filter(passesSearch);
                if (filteredOrphanTeams.length > 0) {
                    const orphanSection = document.createElement('div');
                    orphanSection.className = 'orphan-entities-section';
                    orphanSection.innerHTML = `<div class="orphan-section-title">${getIcon('team')} Teams (unassigned)</div>`;

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    filteredOrphanTeams.forEach(team => {
                        grid.appendChild(createSimpleEntityCard(team));
                    });
                    orphanSection.appendChild(grid);
                    contentContainer.appendChild(orphanSection);
                    hasContent = true;
                }
            }

            // Render orphan roles (roles without a parent)
            if (cardViewTypeFilters.role && sidebarFilters.entities.role && hierarchy.orphanRoles.length > 0) {
                const filteredOrphanRoles = hierarchy.orphanRoles.filter(passesSearch);
                if (filteredOrphanRoles.length > 0) {
                    const orphanSection = document.createElement('div');
                    orphanSection.className = 'orphan-entities-section';
                    orphanSection.innerHTML = `<div class="orphan-section-title">${getIcon('role')} Roles (unassigned)</div>`;

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    filteredOrphanRoles.forEach(role => {
                        grid.appendChild(createSimpleEntityCard(role));
                    });
                    orphanSection.appendChild(grid);
                    contentContainer.appendChild(orphanSection);
                    hasContent = true;
                }
            }

            // Render orphan people (people not filling any role)
            if (cardViewTypeFilters.person && sidebarFilters.entities.person && hierarchy.orphanPeople.length > 0) {
                const filteredOrphanPeople = hierarchy.orphanPeople.filter(passesSearch);
                if (filteredOrphanPeople.length > 0) {
                    const orphanSection = document.createElement('div');
                    orphanSection.className = 'orphan-entities-section';
                    orphanSection.innerHTML = `<div class="orphan-section-title">${getIcon('person')} People (unassigned)</div>`;

                    const grid = document.createElement('div');
                    grid.className = 'card-grid';
                    filteredOrphanPeople.forEach(person => {
                        grid.appendChild(createSimpleEntityCard(person));
                    });
                    orphanSection.appendChild(grid);
                    contentContainer.appendChild(orphanSection);
                    hasContent = true;
                }
            }

            // Render tasks (always flat, not part of hierarchy)
            if (cardViewTypeFilters.task && sidebarFilters.entities.task && hierarchy.orphanTasks.length > 0) {
                let filteredTasks = filterEntitiesBySearch(hierarchy.orphanTasks, cardViewSearchTerm);
                filteredTasks = sortEntities(filteredTasks, cardViewSortOption);
                if (filteredTasks.length > 0) {
                    contentContainer.appendChild(createCardRow('Tasks', filteredTasks, getIcon('task')));
                    hasContent = true;
                }
            }

            // Render work products (always flat, not part of hierarchy)
            if (cardViewTypeFilters.product && sidebarFilters.entities.product && hierarchy.orphanProducts.length > 0) {
                let filteredProducts = filterEntitiesBySearch(hierarchy.orphanProducts, cardViewSearchTerm);
                filteredProducts = sortEntities(filteredProducts, cardViewSortOption);
                if (filteredProducts.length > 0) {
                    contentContainer.appendChild(createCardRow('Work Products', filteredProducts, getIcon('product')));
                    hasContent = true;
                }
            }

            // Render workflows (always flat, not part of hierarchy)
            if (cardViewTypeFilters.workflow && sidebarFilters.entities.workflow && hierarchy.orphanWorkflows.length > 0) {
                let filteredWorkflows = filterEntitiesBySearch(hierarchy.orphanWorkflows, cardViewSearchTerm);
                filteredWorkflows = sortEntities(filteredWorkflows, cardViewSortOption);
                if (filteredWorkflows.length > 0) {
                    contentContainer.appendChild(createCardRow('Workflows', filteredWorkflows, getIcon('workflow')));
                    hasContent = true;
                }
            }

            // Activities
            if (cardViewTypeFilters.activity && relationships.length > 0) {
                const activityRow = createActivityCardRowFiltered();
                if (activityRow) {
                    contentContainer.appendChild(activityRow);
                    hasContent = true;
                }
            }

            return hasContent;
        }

        function createHierarchyUnitCard(unitNode, sidebarFilters) {
            const unit = unitNode.entity;
            const showUnits = cardViewTypeFilters.unit && sidebarFilters.entities.unit;
            const showTeams = cardViewTypeFilters.team && sidebarFilters.entities.team;
            const showRoles = cardViewTypeFilters.role && sidebarFilters.entities.role;
            const showPeople = cardViewTypeFilters.person && sidebarFilters.entities.person;

            const card = document.createElement('div');
            card.className = 'hierarchy-card-container unit';

            // Make entire card clickable, stop propagation to prevent parent cards from firing
            card.onclick = (e) => {
                e.stopPropagation();
                openEntityModal(unit.id, 'unit');
            };

            // Unit header
            const headerHTML = `
                <div class="hierarchy-card-header">
                    <div class="hierarchy-card-icon">${getIcon('unit')}</div>
                    <div class="hierarchy-card-title">${unit.name}</div>
                </div>
            `;

            // Unit description
            const descHTML = unit.description ?
                `<div class="hierarchy-card-description">${unit.description.length > 100 ? unit.description.substring(0, 100) + '...' : unit.description}</div>` : '';

            // Unit activities
            const unitActivities = getEntityActivities(unit.id);
            let activitiesHTML = '';
            if (unitActivities.length > 0) {
                activitiesHTML = '<div class="hierarchy-card-activities">';
                unitActivities.slice(0, 2).forEach(rel => {
                    const operator = eoOperators[rel.predicate];
                    const isSubject = rel.subject === unit.id;
                    const otherEntity = findEntity(isSubject ? rel.object : rel.subject);
                    activitiesHTML += `
                        <span class="connection-badge" style="background: ${operator.color}; color: white; border-color: ${operator.color};">
                            ${isSubject ? '→' : '←'} ${operator.label} ${otherEntity?.name || ''}
                        </span>
                    `;
                });
                if (unitActivities.length > 2) {
                    activitiesHTML += `<span class="connection-badge">+${unitActivities.length - 2} more</span>`;
                }
                activitiesHTML += '</div>';
            }

            card.innerHTML = headerHTML + descHTML + activitiesHTML;

            // Nested units section (sub-units within this unit)
            if (showUnits && unitNode.units && unitNode.units.length > 0) {
                const unitsSection = document.createElement('div');
                unitsSection.className = 'nested-cards-section';
                unitsSection.innerHTML = `<div class="nested-cards-label">${getIcon('unit')} Sub-Units (${unitNode.units.length})</div>`;

                const unitsGrid = document.createElement('div');
                unitsGrid.className = 'nested-cards-grid';

                unitNode.units.forEach(childUnitNode => {
                    const childUnitCard = createHierarchyUnitCard(childUnitNode, sidebarFilters);
                    if (childUnitCard) {
                        childUnitCard.classList.add('nested-unit-card');
                        unitsGrid.appendChild(childUnitCard);
                    }
                });

                unitsSection.appendChild(unitsGrid);
                card.appendChild(unitsSection);
            }

            // Nested teams section
            if (showTeams && unitNode.teams.length > 0) {
                const teamsSection = document.createElement('div');
                teamsSection.className = 'nested-cards-section';
                teamsSection.innerHTML = `<div class="nested-cards-label">${getIcon('team')} Teams (${unitNode.teams.length})</div>`;

                const teamsGrid = document.createElement('div');
                teamsGrid.className = 'nested-cards-grid';

                unitNode.teams.forEach(teamNode => {
                    const teamCard = createNestedTeamCard(teamNode, showRoles, showPeople);
                    teamsGrid.appendChild(teamCard);
                });

                teamsSection.appendChild(teamsGrid);
                card.appendChild(teamsSection);
            }

            // Direct roles (roles that belong to unit, not to a team)
            if (showRoles && unitNode.roles.length > 0) {
                const rolesSection = document.createElement('div');
                rolesSection.className = 'nested-cards-section';
                rolesSection.innerHTML = `<div class="nested-cards-label">${getIcon('role')} Direct Roles (${unitNode.roles.length})</div>`;

                const rolesGrid = document.createElement('div');
                rolesGrid.className = 'nested-cards-grid';

                unitNode.roles.forEach(roleNode => {
                    const roleCard = createNestedRoleCard(roleNode, showPeople);
                    rolesGrid.appendChild(roleCard);
                });

                rolesSection.appendChild(rolesGrid);
                card.appendChild(rolesSection);
            }

            return card;
        }

        function createNestedTeamCard(teamNode, showRoles, showPeople) {
            const team = teamNode.entity;
            const card = document.createElement('div');
            card.className = 'nested-entity-card team';
            card.onclick = (e) => {
                e.stopPropagation();
                openEntityModal(team.id, 'team');
            };

            // Team header
            let cardHTML = `
                <div class="nested-card-header">
                    <div class="nested-card-icon">${getIcon('team')}</div>
                    <div class="nested-card-title">${team.name}</div>
                </div>
            `;

            // Team description
            if (team.description) {
                cardHTML += `<div class="nested-card-description">${team.description.length > 60 ? team.description.substring(0, 60) + '...' : team.description}</div>`;
            }

            // Team activities
            const teamActivities = getEntityActivities(team.id);
            if (teamActivities.length > 0) {
                cardHTML += '<div class="nested-card-connections">';
                teamActivities.slice(0, 2).forEach(rel => {
                    const operator = eoOperators[rel.predicate];
                    const isSubject = rel.subject === team.id;
                    const otherEntity = findEntity(isSubject ? rel.object : rel.subject);
                    cardHTML += `
                        <span class="connection-badge" style="background: ${operator.color}; color: white; font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                            ${isSubject ? '→' : '←'} ${operator.label}
                        </span>
                    `;
                });
                cardHTML += '</div>';
            }

            card.innerHTML = cardHTML;

            // Nested roles within team
            if (showRoles && teamNode.roles.length > 0) {
                const rolesSection = document.createElement('div');
                rolesSection.className = 'deep-nested-section';
                rolesSection.innerHTML = `<div class="deep-nested-label">${getIcon('role')} Roles (${teamNode.roles.length})</div>`;

                const rolesItems = document.createElement('div');
                rolesItems.className = 'deep-nested-items';

                teamNode.roles.forEach(roleNode => {
                    const roleItem = document.createElement('div');
                    roleItem.className = 'deep-nested-item';
                    roleItem.onclick = (e) => {
                        e.stopPropagation();
                        openEntityModal(roleNode.entity.id, 'role');
                    };

                    let roleHTML = `
                        <span class="item-icon">${getIcon('role')}</span>
                        <span class="item-name">${roleNode.entity.name}</span>
                    `;

                    // Show people filling this role
                    if (showPeople && roleNode.people.length > 0) {
                        roleHTML += `<span style="margin-left: auto; color: #8B6F47; font-size: 0.75rem;">${getIcon('person')} ${roleNode.people.length}</span>`;
                    }

                    roleItem.innerHTML = roleHTML;
                    rolesItems.appendChild(roleItem);
                });

                rolesSection.appendChild(rolesItems);
                card.appendChild(rolesSection);
            }

            return card;
        }

        function createNestedRoleCard(roleNode, showPeople) {
            const role = roleNode.entity;
            const card = document.createElement('div');
            card.className = 'nested-entity-card role';
            card.onclick = (e) => {
                e.stopPropagation();
                openEntityModal(role.id, 'role');
            };

            // Role header
            let cardHTML = `
                <div class="nested-card-header">
                    <div class="nested-card-icon">${getIcon('role')}</div>
                    <div class="nested-card-title">${role.name}</div>
                </div>
            `;

            // Role description
            if (role.description) {
                cardHTML += `<div class="nested-card-description">${role.description.length > 60 ? role.description.substring(0, 60) + '...' : role.description}</div>`;
            }

            // Role activities
            const roleActivities = getEntityActivities(role.id);
            if (roleActivities.length > 0) {
                cardHTML += '<div class="nested-card-connections">';
                roleActivities.slice(0, 2).forEach(rel => {
                    const operator = eoOperators[rel.predicate];
                    const isSubject = rel.subject === role.id;
                    cardHTML += `
                        <span class="connection-badge" style="background: ${operator.color}; color: white; font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                            ${isSubject ? '→' : '←'} ${operator.label}
                        </span>
                    `;
                });
                cardHTML += '</div>';
            }

            card.innerHTML = cardHTML;

            // People filling this role
            if (showPeople && roleNode.people.length > 0) {
                const peopleSection = document.createElement('div');
                peopleSection.className = 'deep-nested-section';
                peopleSection.innerHTML = `<div class="deep-nested-label">${getIcon('person')} Filled by (${roleNode.people.length})</div>`;

                const peopleItems = document.createElement('div');
                peopleItems.className = 'deep-nested-items';

                roleNode.people.forEach(person => {
                    const personItem = document.createElement('div');
                    personItem.className = 'deep-nested-item';
                    personItem.onclick = (e) => {
                        e.stopPropagation();
                        openEntityModal(person.id, 'person');
                    };
                    personItem.innerHTML = `
                        <span class="item-icon">${getIcon('person')}</span>
                        <span class="item-name">${person.name}</span>
                    `;
                    peopleItems.appendChild(personItem);
                });

                peopleSection.appendChild(peopleItems);
                card.appendChild(peopleSection);
            }

            return card;
        }

        function createSimpleEntityCard(entity) {
            const card = document.createElement('div');
            card.className = `entity-card ${entity.type}`;
            card.onclick = () => openEntityModal(entity.id, entity.type);

            const entityActivities = getEntityActivities(entity.id);

            let activitiesHTML = '';
            if (entityActivities.length > 0) {
                activitiesHTML = '<div class="card-connections">';
                entityActivities.slice(0, 3).forEach(rel => {
                    const operator = eoOperators[rel.predicate];
                    const isSubject = rel.subject === entity.id;
                    const otherEntity = findEntity(isSubject ? rel.object : rel.subject);
                    activitiesHTML += `
                        <span class="connection-badge" style="background: ${operator.color}; color: white; border-color: ${operator.color};">
                            ${isSubject ? '→' : '←'} ${operator.label} ${otherEntity?.name || ''}
                        </span>
                    `;
                });
                if (entityActivities.length > 3) {
                    activitiesHTML += `<span class="connection-badge">+${entityActivities.length - 3} more</span>`;
                }
                activitiesHTML += '</div>';
            }

            let descriptionHTML = '';
            if (entity.description && entity.description.trim()) {
                const truncatedDesc = entity.description.length > 80
                    ? entity.description.substring(0, 80) + '...'
                    : entity.description;
                descriptionHTML = `<div class="card-description">${truncatedDesc}</div>`;
            }

            // For roles, show team context for disambiguation
            let teamContextHTML = '';
            if (entity.type === 'role') {
                const parentTeam = getRoleParentTeam(entity.id);
                if (parentTeam) {
                    teamContextHTML = `
                        <div class="card-nested-under">
                            <span class="nested-label">In:</span>
                            <span class="nested-parent-badge">
                                <span class="parent-icon">${getIcon(parentTeam.type)}</span>
                                ${parentTeam.name}
                            </span>
                        </div>
                    `;
                }
            }

            card.innerHTML = `
                <div class="card-header">
                    <div class="card-icon">${getIcon(entity.type)}</div>
                    <div class="card-title">${entity.name}</div>
                </div>
                ${teamContextHTML}
                ${descriptionHTML}
                ${activitiesHTML}
            `;

            return card;
        }

        function createActivityCardRowFiltered() {
            const sidebarFilters = getActiveFilters();
            let filteredActivities = relationships.filter(r => sidebarFilters.relationships[r.predicate]);

            // Apply search filter to activities
            if (cardViewSearchTerm) {
                const term = cardViewSearchTerm.toLowerCase();
                filteredActivities = filteredActivities.filter(rel => {
                    const subj = findEntity(rel.subject);
                    const obj = findEntity(rel.object);
                    const operator = eoOperators[rel.predicate];
                    return (
                        (subj && subj.name.toLowerCase().includes(term)) ||
                        (obj && obj.name.toLowerCase().includes(term)) ||
                        operator.label.toLowerCase().includes(term) ||
                        (rel.description && rel.description.toLowerCase().includes(term))
                    );
                });
            }

            if (filteredActivities.length === 0) return null;

            const row = document.createElement('div');
            row.className = 'card-row';

            const header = document.createElement('div');
            header.className = 'card-row-header';
            header.innerHTML = `
                <div class="card-row-title">⚡ Activities (${filteredActivities.length})</div>
            `;
            row.appendChild(header);

            const grid = document.createElement('div');
            grid.className = 'card-grid';

            filteredActivities.forEach(rel => {
                const subj = findEntity(rel.subject);
                const obj = findEntity(rel.object);
                const operator = eoOperators[rel.predicate];

                const card = document.createElement('div');
                card.className = `entity-card activity`;
                card.onclick = () => openRelationshipModal(rel);

                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-icon" style="background: ${operator.color}; color: white; padding: 0.5rem; border-radius: 8px; font-size: 1.25rem;">⚡</div>
                        <div class="card-title">${operator.label}</div>
                    </div>
                    <div class="card-meta">
                        <strong>${subj?.name || rel.subject}</strong> → <strong>${obj?.name || rel.object}</strong>
                    </div>
                    ${rel.description ? `<div class="card-description">${rel.description}</div>` : ''}
                    <div class="card-connections">
                        <span class="connection-badge" style="cursor: pointer;" onclick="event.stopPropagation(); openEntityModal('${rel.subject}', '${subj?.type}')">${getIcon(subj?.type)} ${subj?.name}</span>
                        <span class="connection-badge" style="cursor: pointer;" onclick="event.stopPropagation(); openEntityModal('${rel.object}', '${obj?.type}')">${getIcon(obj?.type)} ${obj?.name}</span>
                    </div>
                `;

                grid.appendChild(card);
            });

            row.appendChild(grid);
            return row;
        }

        function createCardRow(title, entities, icon) {
            const row = document.createElement('div');
            row.className = 'card-row';

            const header = document.createElement('div');
            header.className = 'card-row-header';
            header.innerHTML = `
                <div class="card-row-title">${icon} ${title} (${entities.length})</div>
            `;
            row.appendChild(header);

            const grid = document.createElement('div');
            grid.className = 'card-grid';

            entities.forEach(entity => {
                const card = document.createElement('div');
                card.className = `entity-card ${entity.type}`;
                card.onclick = () => openEntityModal(entity.id, entity.type);

                // For units, teams and roles, find what they're nested under (DES relationships where entity is the object)
                let nestedUnderHTML = '';
                if (entity.type === 'unit' || entity.type === 'team' || entity.type === 'role') {
                    const parentRelationships = relationships.filter(r =>
                        r.predicate === 'DES' && r.object === entity.id
                    );
                    if (parentRelationships.length > 0) {
                        nestedUnderHTML = '<div class="card-nested-under"><span class="nested-label">In:</span>';
                        parentRelationships.forEach(rel => {
                            const parentEntity = findEntity(rel.subject);
                            if (parentEntity) {
                                const parentIcon = getIcon(parentEntity.type);
                                nestedUnderHTML += `
                                    <span class="nested-parent-badge">
                                        <span class="parent-icon">${parentIcon}</span>
                                        ${parentEntity.name}
                                    </span>
                                `;
                            }
                        });
                        nestedUnderHTML += '</div>';
                    }
                }

                // Get all activities this entity is involved in (excluding DES relationships for display)
                const entityActivities = relationships.filter(r =>
                    (r.subject === entity.id || r.object === entity.id) && r.predicate !== 'DES'
                );

                // Build activities HTML
                let activitiesHTML = '';
                if (entityActivities.length > 0) {
                    activitiesHTML = '<div class="card-connections">';
                    entityActivities.slice(0, 3).forEach(rel => {
                        const operator = eoOperators[rel.predicate];
                        const isSubject = rel.subject === entity.id;
                        const otherEntity = findEntity(isSubject ? rel.object : rel.subject);
                        activitiesHTML += `
                            <span class="connection-badge" style="background: ${operator.color}; color: white; border-color: ${operator.color};">
                                ${isSubject ? '→' : '←'} ${operator.label} ${otherEntity?.name || ''}
                            </span>
                        `;
                    });
                    if (entityActivities.length > 3) {
                        activitiesHTML += `<span class="connection-badge">+${entityActivities.length - 3} more</span>`;
                    }
                    activitiesHTML += '</div>';
                }

                // Build description HTML (truncate if too long)
                let descriptionHTML = '';
                if (entity.description && entity.description.trim()) {
                    const truncatedDesc = entity.description.length > 80
                        ? entity.description.substring(0, 80) + '...'
                        : entity.description;
                    descriptionHTML = `<div class="card-description">${truncatedDesc}</div>`;
                }

                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-icon">${icon}</div>
                        <div class="card-title">${entity.name}</div>
                    </div>
                    ${nestedUnderHTML}
                    ${descriptionHTML}
                    ${activitiesHTML}
                `;

                grid.appendChild(card);
            });

            row.appendChild(grid);
            return row;
        }

        // Tree View Rendering
        function toggleRelationships(relId) {
            const relsDiv = document.getElementById(relId);
            const header = event.target.closest('.tree-relationships-header');
            const icon = header?.querySelector('.tree-expand-icon');

            if (relsDiv && icon) {
                const isHidden = relsDiv.style.display === 'none';
                relsDiv.style.display = isHidden ? 'block' : 'none';
                icon.classList.toggle('expanded', isHidden);
            }
        }

        function handleTreeDrop(draggedData, targetEntity) {
            // Validate drop - can drop unit onto unit, team onto unit, or role onto team/unit
            const validDrops = {
                'unit': ['unit'],           // units can be dropped on units (nesting)
                'team': ['unit'],           // teams can be dropped on units
                'role': ['unit', 'team']    // roles can be dropped on units or teams
            };

            const allowedTargets = validDrops[draggedData.type];
            if (!allowedTargets || !allowedTargets.includes(targetEntity.type)) {
                showNotification(`Cannot move ${draggedData.type} to ${targetEntity.type}`, 'error');
                return;
            }

            // Don't drop on self
            if (draggedData.id === targetEntity.id) {
                return;
            }

            // Prevent circular references when nesting units
            if (draggedData.type === 'unit' && targetEntity.type === 'unit') {
                // Check if target is a descendant of dragged unit
                function isDescendant(parentId, childId) {
                    const children = relationships
                        .filter(r => r.predicate === 'DES' && r.subject === parentId)
                        .map(r => r.object);
                    if (children.includes(childId)) return true;
                    return children.some(cId => isDescendant(cId, childId));
                }
                if (isDescendant(draggedData.id, targetEntity.id)) {
                    showNotification(`Cannot nest ${draggedData.name} inside its own child unit`, 'error');
                    return;
                }
            }

            // Check if already connected to target
            const alreadyConnected = relationships.some(r =>
                r.predicate === 'DES' &&
                ((r.subject === draggedData.id && r.object === targetEntity.id) ||
                 (r.subject === targetEntity.id && r.object === draggedData.id))
            );

            if (alreadyConnected) {
                showNotification(`${draggedData.name} is already in ${targetEntity.name}`, 'info');
                return;
            }

            // Remove existing DES parent relationships for the dragged entity
            // (teams should only be in one unit, roles in one team/unit at hierarchy level)
            const parentTypes = targetEntity.type === 'unit' ? ['unit'] : ['unit', 'team'];
            relationships = relationships.filter(r => {
                if (r.predicate !== 'DES') return true;
                // Check if this relationship connects dragged entity to a parent of same type
                const isParentRel = (r.subject === draggedData.id || r.object === draggedData.id);
                if (!isParentRel) return true;
                const otherId = r.subject === draggedData.id ? r.object : r.subject;
                const otherEntity = findEntity(otherId);
                // Keep relationships that aren't to parent types we're replacing
                return !otherEntity || !parentTypes.includes(otherEntity.type);
            });

            // Create new DES relationship (target contains dragged)
            relationships.push({
                id: 'rel-' + Date.now(),
                subject: targetEntity.id,
                predicate: 'DES',
                object: draggedData.id
            });

            saveState();
            updateViews();
            showNotification(`Moved ${draggedData.name} to ${targetEntity.name}`, 'success');
        }

        function renderTreeView() {
            const container = document.getElementById('treeView');
            if (!container) return; // Safety check
            
            container.innerHTML = '';

            const filters = getActiveFilters();

            if (entities.unit.length === 0 && entities.team.length === 0 && entities.role.length === 0 && entities.person.length === 0 && entities.task.length === 0 && entities.product.length === 0 && entities.workflow.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 3rem; color: #8B6F47;">No entities created yet. Add entities to get started.</div>';
                return;
            }

            // Render each unit (if unit filter is on)
            if (filters.entities.unit) {
                entities.unit.forEach(unit => {
                    const unitEl = createTreeNodeDetailed(unit, filters);
                    container.appendChild(unitEl);
                });
            }

            // Show unassigned teams
            const unassignedTeams = entities.team.filter(team => {
                const isAssigned = relationships.some(r => 
                    (r.subject === team.id || r.object === team.id) &&
                    entities.unit.some(u => u.id === r.subject || u.id === r.object)
                );
                return !isAssigned;
            });

            if (unassignedTeams.length > 0 && filters.entities.team) {
                const section = document.createElement('div');
                section.className = 'tree-section';

                const header = document.createElement('div');
                header.className = 'tree-section-header';
                header.innerHTML = `
                    <span class="tree-expand-icon ${treeViewState.sectionsExpanded.unassignedTeams ? 'expanded' : ''}">▶</span>
                    <span style="font-size: 1.2rem;">📁</span>
                    <span class="tree-section-title">Unassigned Teams</span>
                    <span class="tree-section-count">${unassignedTeams.length}</span>
                `;
                section.appendChild(header);

                const content = document.createElement('div');
                content.className = `tree-section-content ${treeViewState.sectionsExpanded.unassignedTeams ? 'expanded' : ''}`;

                unassignedTeams.forEach(team => {
                    const teamEl = createTreeNodeDetailed(team, filters);
                    content.appendChild(teamEl);
                });

                section.appendChild(content);

                header.onclick = () => {
                    treeViewState.sectionsExpanded.unassignedTeams = !treeViewState.sectionsExpanded.unassignedTeams;
                    content.classList.toggle('expanded');
                    header.querySelector('.tree-expand-icon').classList.toggle('expanded');
                };

                container.appendChild(section);
            }

            // Show unassigned roles
            const unassignedRoles = entities.role.filter(role => {
                const isAssigned = relationships.some(r => 
                    (r.subject === role.id || r.object === role.id) &&
                    (entities.team.some(t => t.id === r.subject || t.id === r.object) ||
                     entities.unit.some(u => u.id === r.subject || u.id === r.object))
                );
                return !isAssigned;
            });

            if (unassignedRoles.length > 0 && filters.entities.role) {
                const section = document.createElement('div');
                section.className = 'tree-section';

                const header = document.createElement('div');
                header.className = 'tree-section-header';
                header.innerHTML = `
                    <span class="tree-expand-icon ${treeViewState.sectionsExpanded.unassignedRoles ? 'expanded' : ''}">▶</span>
                    <span style="font-size: 1.2rem;">📁</span>
                    <span class="tree-section-title">Unassigned Roles</span>
                    <span class="tree-section-count">${unassignedRoles.length}</span>
                `;
                section.appendChild(header);

                const content = document.createElement('div');
                content.className = `tree-section-content ${treeViewState.sectionsExpanded.unassignedRoles ? 'expanded' : ''}`;

                unassignedRoles.forEach(role => {
                    const roleEl = createTreeNodeDetailed(role, filters);
                    content.appendChild(roleEl);
                });

                section.appendChild(content);

                header.onclick = () => {
                    treeViewState.sectionsExpanded.unassignedRoles = !treeViewState.sectionsExpanded.unassignedRoles;
                    content.classList.toggle('expanded');
                    header.querySelector('.tree-expand-icon').classList.toggle('expanded');
                };

                container.appendChild(section);
            }

            // Show all people with collapsible grouping
            if (entities.person.length > 0 && filters.entities.person) {
                const section = document.createElement('div');
                section.className = 'tree-section';

                // Create collapsible header with grouping controls
                const header = document.createElement('div');
                header.className = 'tree-section-header';
                header.innerHTML = `
                    <span class="tree-expand-icon ${treeViewState.sectionsExpanded.people ? 'expanded' : ''}">▶</span>
                    <span style="font-size: 1.2rem;">👥</span>
                    <span class="tree-section-title">People</span>
                    <div class="tree-group-controls" onclick="event.stopPropagation();">
                        <span class="tree-group-label">Group by:</span>
                        <select class="tree-group-select" id="peopleGroupSelect" onchange="changePeopleGrouping(this.value)">
                            <option value="role" ${treeViewState.peopleGroupBy === 'role' ? 'selected' : ''}>Role</option>
                            <option value="alphabetical" ${treeViewState.peopleGroupBy === 'alphabetical' ? 'selected' : ''}>A-Z</option>
                            <option value="none" ${treeViewState.peopleGroupBy === 'none' ? 'selected' : ''}>None</option>
                        </select>
                    </div>
                    <span class="tree-section-count">${entities.person.length}</span>
                `;
                section.appendChild(header);

                // Create content container
                const content = document.createElement('div');
                content.className = `tree-section-content ${treeViewState.sectionsExpanded.people ? 'expanded' : ''}`;
                content.id = 'peopleTreeContent';

                // Render people based on grouping
                renderPeopleGrouped(content, filters);

                section.appendChild(content);

                // Add click handler for collapse/expand
                header.onclick = (e) => {
                    if (e.target.closest('.tree-group-controls')) return;
                    treeViewState.sectionsExpanded.people = !treeViewState.sectionsExpanded.people;
                    content.classList.toggle('expanded');
                    header.querySelector('.tree-expand-icon').classList.toggle('expanded');
                };

                container.appendChild(section);
            }

            // Show all tasks with collapsible section
            if (entities.task.length > 0 && filters.entities.task) {
                const section = document.createElement('div');
                section.className = 'tree-section';

                const header = document.createElement('div');
                header.className = 'tree-section-header';
                header.innerHTML = `
                    <span class="tree-expand-icon ${treeViewState.sectionsExpanded.tasks ? 'expanded' : ''}">▶</span>
                    ${getIcon('task')}
                    <span class="tree-section-title">Tasks</span>
                    <span class="tree-section-count">${entities.task.length}</span>
                `;
                section.appendChild(header);

                const content = document.createElement('div');
                content.className = `tree-section-content ${treeViewState.sectionsExpanded.tasks ? 'expanded' : ''}`;

                entities.task.forEach(task => {
                    const taskEl = createTreeNodeDetailed(task, filters);
                    content.appendChild(taskEl);
                });

                section.appendChild(content);

                header.onclick = () => {
                    treeViewState.sectionsExpanded.tasks = !treeViewState.sectionsExpanded.tasks;
                    content.classList.toggle('expanded');
                    header.querySelector('.tree-expand-icon').classList.toggle('expanded');
                };

                container.appendChild(section);
            }

            // Show all products with collapsible section
            if (entities.product.length > 0 && filters.entities.product) {
                const section = document.createElement('div');
                section.className = 'tree-section';

                const header = document.createElement('div');
                header.className = 'tree-section-header';
                header.innerHTML = `
                    <span class="tree-expand-icon ${treeViewState.sectionsExpanded.products ? 'expanded' : ''}">▶</span>
                    ${getIcon('product')}
                    <span class="tree-section-title">Work Products</span>
                    <span class="tree-section-count">${entities.product.length}</span>
                `;
                section.appendChild(header);

                const content = document.createElement('div');
                content.className = `tree-section-content ${treeViewState.sectionsExpanded.products ? 'expanded' : ''}`;

                entities.product.forEach(product => {
                    const productEl = createTreeNodeDetailed(product, filters);
                    content.appendChild(productEl);
                });

                section.appendChild(content);

                header.onclick = () => {
                    treeViewState.sectionsExpanded.products = !treeViewState.sectionsExpanded.products;
                    content.classList.toggle('expanded');
                    header.querySelector('.tree-expand-icon').classList.toggle('expanded');
                };

                container.appendChild(section);
            }

            // Show all workflows with collapsible section
            if (entities.workflow.length > 0 && filters.entities.workflow) {
                const section = document.createElement('div');
                section.className = 'tree-section';

                const header = document.createElement('div');
                header.className = 'tree-section-header';
                header.innerHTML = `
                    <span class="tree-expand-icon ${treeViewState.sectionsExpanded.workflows ? 'expanded' : ''}">▶</span>
                    ${getIcon('workflow')}
                    <span class="tree-section-title">Workflows</span>
                    <span class="tree-section-count">${entities.workflow.length}</span>
                `;
                section.appendChild(header);

                const content = document.createElement('div');
                content.className = `tree-section-content ${treeViewState.sectionsExpanded.workflows ? 'expanded' : ''}`;

                entities.workflow.forEach(workflow => {
                    const workflowEl = createTreeNodeDetailed(workflow, filters);
                    content.appendChild(workflowEl);
                });

                section.appendChild(content);

                header.onclick = () => {
                    treeViewState.sectionsExpanded.workflows = !treeViewState.sectionsExpanded.workflows;
                    content.classList.toggle('expanded');
                    header.querySelector('.tree-expand-icon').classList.toggle('expanded');
                };

                container.appendChild(section);
            }
        }

        // Helper function to get roles assigned to a person
        function getPersonRoles(personId) {
            const roles = [];
            relationships.forEach(r => {
                let roleId = null;
                if (r.subject === personId) {
                    roleId = r.object;
                } else if (r.object === personId) {
                    roleId = r.subject;
                }
                if (roleId) {
                    const role = entities.role.find(ro => ro.id === roleId);
                    if (role) {
                        roles.push(role);
                    }
                }
            });
            return roles;
        }

        // Render people grouped by the selected grouping option
        function renderPeopleGrouped(container, filters) {
            container.innerHTML = '';
            const groupBy = treeViewState.peopleGroupBy;

            if (groupBy === 'none') {
                // No grouping - just list all people
                entities.person.forEach(person => {
                    const personEl = createTreeNodeDetailed(person, filters);
                    container.appendChild(personEl);
                });
            } else if (groupBy === 'alphabetical') {
                // Group alphabetically by first letter
                const grouped = {};
                entities.person.forEach(person => {
                    const letter = (person.name || 'Unknown').charAt(0).toUpperCase();
                    if (!grouped[letter]) grouped[letter] = [];
                    grouped[letter].push(person);
                });

                const sortedLetters = Object.keys(grouped).sort();
                sortedLetters.forEach(letter => {
                    const subgroup = document.createElement('div');
                    subgroup.className = 'tree-subgroup';

                    const subheader = document.createElement('div');
                    subheader.className = 'tree-subgroup-header';
                    subheader.innerHTML = `
                        <span class="tree-expand-icon expanded">▶</span>
                        <span class="tree-subgroup-title">${letter}</span>
                        <span class="tree-subgroup-count">${grouped[letter].length}</span>
                    `;

                    const subcontent = document.createElement('div');
                    subcontent.className = 'tree-subgroup-content expanded';

                    grouped[letter].sort((a, b) => a.name.localeCompare(b.name)).forEach(person => {
                        const personEl = createTreeNodeDetailed(person, filters);
                        subcontent.appendChild(personEl);
                    });

                    subheader.onclick = () => {
                        subcontent.classList.toggle('expanded');
                        subheader.querySelector('.tree-expand-icon').classList.toggle('expanded');
                    };

                    subgroup.appendChild(subheader);
                    subgroup.appendChild(subcontent);
                    container.appendChild(subgroup);
                });
            } else if (groupBy === 'role') {
                // Group by role
                const roleGroups = {};
                const unassigned = [];

                entities.person.forEach(person => {
                    const roles = getPersonRoles(person.id);
                    if (roles.length === 0) {
                        unassigned.push(person);
                    } else {
                        roles.forEach(role => {
                            if (!roleGroups[role.id]) {
                                roleGroups[role.id] = { role: role, people: [] };
                            }
                            roleGroups[role.id].people.push(person);
                        });
                    }
                });

                // Render role groups
                Object.values(roleGroups).sort((a, b) => a.role.name.localeCompare(b.role.name)).forEach(group => {
                    const subgroup = document.createElement('div');
                    subgroup.className = 'tree-subgroup';

                    const subheader = document.createElement('div');
                    subheader.className = 'tree-subgroup-header';
                    subheader.innerHTML = `
                        <span class="tree-expand-icon expanded">▶</span>
                        <span style="font-size: 1rem;">🎭</span>
                        <span class="tree-subgroup-title">${group.role.name}</span>
                        <span class="tree-subgroup-count">${group.people.length}</span>
                    `;

                    const subcontent = document.createElement('div');
                    subcontent.className = 'tree-subgroup-content expanded';

                    group.people.sort((a, b) => a.name.localeCompare(b.name)).forEach(person => {
                        const personEl = createTreeNodeDetailed(person, filters);
                        subcontent.appendChild(personEl);
                    });

                    subheader.onclick = () => {
                        subcontent.classList.toggle('expanded');
                        subheader.querySelector('.tree-expand-icon').classList.toggle('expanded');
                    };

                    subgroup.appendChild(subheader);
                    subgroup.appendChild(subcontent);
                    container.appendChild(subgroup);
                });

                // Render unassigned people
                if (unassigned.length > 0) {
                    const subgroup = document.createElement('div');
                    subgroup.className = 'tree-subgroup';

                    const subheader = document.createElement('div');
                    subheader.className = 'tree-subgroup-header';
                    subheader.innerHTML = `
                        <span class="tree-expand-icon expanded">▶</span>
                        <span style="font-size: 1rem; opacity: 0.6;">👤</span>
                        <span class="tree-subgroup-title" style="color: #999;">Unassigned</span>
                        <span class="tree-subgroup-count">${unassigned.length}</span>
                    `;

                    const subcontent = document.createElement('div');
                    subcontent.className = 'tree-subgroup-content expanded';

                    unassigned.sort((a, b) => a.name.localeCompare(b.name)).forEach(person => {
                        const personEl = createTreeNodeDetailed(person, filters);
                        subcontent.appendChild(personEl);
                    });

                    subheader.onclick = () => {
                        subcontent.classList.toggle('expanded');
                        subheader.querySelector('.tree-expand-icon').classList.toggle('expanded');
                    };

                    subgroup.appendChild(subheader);
                    subgroup.appendChild(subcontent);
                    container.appendChild(subgroup);
                }
            }
        }

        // Change people grouping mode
        function changePeopleGrouping(value) {
            treeViewState.peopleGroupBy = value;
            const container = document.getElementById('peopleTreeContent');
            if (container) {
                const filters = getActiveFilters();
                renderPeopleGrouped(container, filters);
            }
        }

        function createTreeNodeDetailed(entity, filters) {
            const container = document.createElement('div');
            container.className = 'tree-node-container';

            const node = document.createElement('div');
            node.className = `tree-node-item ${entity.type}`;

            const icon = getIcon(entity.type);
            
            // Get connected entities
            const connectedTeams = entity.type === 'unit' ? getConnectedEntities(entity.id, 'team') : [];
            const connectedRoles = (entity.type === 'team' || entity.type === 'unit') ? getConnectedEntities(entity.id, 'role') : [];
            const hasChildren = (connectedTeams.length > 0 && filters.entities.team) || 
                               (connectedRoles.length > 0 && filters.entities.role);

            let expandIcon = '';
            if (hasChildren) {
                expandIcon = '<span class="tree-expand-icon expanded">▶</span>';
            }

            // Get people assigned to roles
            let peopleHTML = '';
            if (entity.type === 'role' && filters.entities.person) {
                const assignedPeople = entities.person.filter(p => 
                    relationships.some(r => 
                        filters.relationships[r.predicate] &&
                        ((r.subject === p.id && r.object === entity.id) ||
                        (r.object === p.id && r.subject === entity.id))
                    )
                );

                if (assignedPeople.length > 0) {
                    peopleHTML = '<div class="tree-people-assigned">';
                    assignedPeople.forEach(person => {
                        peopleHTML += `<span class="tree-person-badge" onclick="event.stopPropagation(); openEntityModal('${person.id}', 'person')" style="cursor: pointer;">👤 ${person.name}</span>`;
                    });
                    peopleHTML += '</div>';
                }
            }

            // Get relationships for this entity (filtered)
            const entityRels = relationships.filter(r => 
                filters.relationships[r.predicate] &&
                (r.subject === entity.id || r.object === entity.id)
            );

            let relsHTML = '';
            if (entityRels.length > 0) {
                const relId = 'rels-' + entity.id;
                const operator = eoOperators[entityRels[0].predicate];
                relsHTML = `
                    <div class="tree-relationships-header" onclick="toggleRelationships('${relId}')">
                        <span class="tree-expand-icon">▶</span>
                        <span>${entityRels.length} connection${entityRels.length > 1 ? 's' : ''}</span>
                    </div>
                    <div id="${relId}" class="tree-relationships" style="display: none;">
                `;
                entityRels.forEach(rel => {
                    const subj = findEntity(rel.subject);
                    const obj = findEntity(rel.object);
                    const op = eoOperators[rel.predicate];
                    relsHTML += `
                        <div class="tree-relationship-item" style="border-left-color: ${op.color}">
                            <strong>${subj?.name || rel.subject}</strong> 
                            <span style="color: ${op.color}; font-weight: 600;">${op.label}</span> 
                            <strong>${obj?.name || rel.object}</strong>
                        </div>
                    `;
                });
                relsHTML += '</div>';
            }

            node.innerHTML = `
                ${expandIcon}
                <span style="font-size: 1.2rem;">${icon}</span>
                <div class="tree-node-content">
                    <div class="tree-node-name" title="${entity.name}">${entity.name}</div>
                    <div class="tree-node-meta">${entity.type}</div>
                    ${peopleHTML}
                </div>
            `;

            container.appendChild(node);

            // Add click handler to open entity modal
            node.onclick = (e) => {
                if (!e.target.closest('.tree-expand-icon') && !e.target.closest('.tree-person-badge')) {
                    openEntityModal(entity.id, entity.type);
                }
            };
            node.style.cursor = 'pointer';

            // Add drag-and-drop for nesting
            node.draggable = true;
            node.dataset.entityId = entity.id;
            node.dataset.entityType = entity.type;

            node.ondragstart = (e) => {
                e.stopPropagation();
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    id: entity.id,
                    type: entity.type,
                    name: entity.name
                }));
                e.dataTransfer.effectAllowed = 'move';
                node.classList.add('dragging');
            };

            node.ondragend = (e) => {
                node.classList.remove('dragging');
                document.querySelectorAll('.tree-node-item.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });
            };

            // Allow dropping on units (for teams) and teams (for roles)
            if (entity.type === 'unit' || entity.type === 'team') {
                node.ondragover = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const dragData = e.dataTransfer.types.includes('text/plain');
                    if (dragData) {
                        node.classList.add('drag-over');
                        e.dataTransfer.dropEffect = 'move';
                    }
                };

                node.ondragleave = (e) => {
                    if (!node.contains(e.relatedTarget)) {
                        node.classList.remove('drag-over');
                    }
                };

                node.ondrop = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    node.classList.remove('drag-over');

                    try {
                        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                        handleTreeDrop(data, entity);
                    } catch (err) {
                        console.error('Drop error:', err);
                    }
                };
            }

            if (relsHTML) {
                const relsDiv = document.createElement('div');
                relsDiv.innerHTML = relsHTML;
                container.appendChild(relsDiv.firstChild);
            }

            // Add children
            if (hasChildren) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'tree-children expanded';

                if (entity.type === 'unit' && filters.entities.team) {
                    connectedTeams.forEach(team => {
                        const teamEl = createTreeNodeDetailed(team, filters);
                        childrenContainer.appendChild(teamEl);
                    });
                }

                if ((entity.type === 'team' || entity.type === 'unit') && filters.entities.role) {
                    connectedRoles.forEach(role => {
                        const roleEl = createTreeNodeDetailed(role, filters);
                        childrenContainer.appendChild(roleEl);
                    });
                }

                container.appendChild(childrenContainer);

                // Add expand/collapse functionality
                const expandBtn = node.querySelector('.tree-expand-icon');
                if (expandBtn) {
                    expandBtn.onclick = (e) => {
                        e.stopPropagation();
                        childrenContainer.classList.toggle('expanded');
                        expandBtn.classList.toggle('expanded');
                    };
                }
            }

            return container;
        }

        // Graph visualization - n8n style
        const svg = d3.select('#graph');
        const tooltip = d3.select('#tooltip');

        // Graph state
        let graphZoom = null;
        let currentZoomScale = 1;
        let graphG = null; // Main graph group for transforms

        // Node dimensions for n8n-style cards
        const NODE_WIDTH = 140;
        const NODE_HEIGHT = 56;
        const PORT_RADIUS = 6;

        // Get node accent color by type
        function getNodeAccentColor(type) {
            const colors = {
                unit: '#C88F4A',
                team: '#B87B5B',
                role: '#8B6F47',
                person: '#6B5642',
                object: '#A89984'
            };
            return colors[type] || '#8B6F47';
        }

        // Calculate auto-layout positions based on hierarchy using d3.tree()
        function calculateAutoLayout(nodes, width, height) {
            const positions = new Map();
            const nodeIds = new Set(nodes.map(n => n.id));

            // Build a lookup of ALL entities for hierarchy calculation (including person)
            const allEntities = new Map();
            ['unit', 'team', 'role', 'person', 'object'].forEach(type => {
                entities[type].forEach(e => allEntities.set(e.id, e));
            });

            // Build FULL hierarchy from DES relationships (unit -> team -> role)
            // AND INS relationships (person -> role, meaning person is child of role)
            const fullParentMap = new Map();
            const fullChildrenMap = new Map();

            // Process DES relationships (hierarchical: subject is parent of object)
            relationships.filter(r => r.predicate === 'DES').forEach(rel => {
                if (allEntities.has(rel.subject) && allEntities.has(rel.object)) {
                    fullParentMap.set(rel.object, rel.subject);
                    if (!fullChildrenMap.has(rel.subject)) {
                        fullChildrenMap.set(rel.subject, []);
                    }
                    fullChildrenMap.get(rel.subject).push(rel.object);
                }
            });

            // Process INS relationships (person assigned to role: subject=person, object=role)
            // In hierarchy terms, person is a child of the role they're assigned to
            relationships.filter(r => r.predicate === 'INS').forEach(rel => {
                if (allEntities.has(rel.subject) && allEntities.has(rel.object)) {
                    const person = allEntities.get(rel.subject);
                    const role = allEntities.get(rel.object);
                    // Only if subject is a person and object is a role
                    if (person && person.type === 'person' && role && role.type === 'role') {
                        fullParentMap.set(rel.subject, rel.object);
                        if (!fullChildrenMap.has(rel.object)) {
                            fullChildrenMap.set(rel.object, []);
                        }
                        // Avoid duplicates
                        if (!fullChildrenMap.get(rel.object).includes(rel.subject)) {
                            fullChildrenMap.get(rel.object).push(rel.subject);
                        }
                    }
                }
            });

            // Build filtered hierarchy - only include relationships where both nodes are visible
            const parentMap = new Map();
            const childrenMap = new Map();

            // For each visible node, find its nearest visible ancestor
            function findVisibleAncestor(nodeId) {
                let current = fullParentMap.get(nodeId);
                const visited = new Set();
                while (current && !visited.has(current)) {
                    visited.add(current);
                    if (nodeIds.has(current)) return current;
                    current = fullParentMap.get(current);
                }
                return null;
            }

            // Build effective parent-child relationships between visible nodes
            nodes.forEach(node => {
                const visibleParent = findVisibleAncestor(node.id);
                if (visibleParent) {
                    parentMap.set(node.id, visibleParent);
                    if (!childrenMap.has(visibleParent)) {
                        childrenMap.set(visibleParent, []);
                    }
                    childrenMap.get(visibleParent).push(node.id);
                }
            });

            // Find root nodes (no visible parent in hierarchy) - these have children
            const rootNodes = nodes.filter(n => !parentMap.has(n.id) && childrenMap.has(n.id));

            // Find orphan nodes (no parent AND no children in hierarchy)
            const orphanNodes = nodes.filter(n => !parentMap.has(n.id) && !childrenMap.has(n.id));

            // Increased spacing for better readability
            const VERTICAL_SPACING = 160;
            const HORIZONTAL_SPACING = 200;

            // Use d3.tree() for proper hierarchical layout
            if (rootNodes.length > 0) {
                // Build hierarchy data for d3
                function buildHierarchyData(nodeId) {
                    const children = (childrenMap.get(nodeId) || []).map(childId => buildHierarchyData(childId));
                    return { id: nodeId, children: children.length > 0 ? children : undefined };
                }

                // Create a virtual root that contains all actual roots
                const virtualRoot = {
                    id: '__virtual_root__',
                    children: rootNodes.map(n => buildHierarchyData(n.id))
                };

                // Create d3 hierarchy
                const root = d3.hierarchy(virtualRoot);

                // Calculate tree layout with increased separation
                const treeLayout = d3.tree()
                    .nodeSize([HORIZONTAL_SPACING, VERTICAL_SPACING])
                    .separation((a, b) => {
                        // Much more separation between different subtrees
                        // Also consider depth - deeper nodes need more space
                        if (a.parent === b.parent) {
                            return 1.2;
                        }
                        return 2.0;
                    });

                treeLayout(root);

                // Extract positions from d3 tree (skip virtual root)
                root.descendants().forEach(d => {
                    if (d.data.id !== '__virtual_root__') {
                        // d3.tree uses x for horizontal, y for vertical (depth)
                        // We want top-to-bottom layout, so y becomes our vertical position
                        positions.set(d.data.id, {
                            x: d.x + width / 2,  // Center horizontally
                            y: d.y + 80         // Offset from top
                        });
                    }
                });
            }

            // Position orphan nodes in a grid below the hierarchy
            if (orphanNodes.length > 0) {
                // Find the maximum y position used so far
                let maxY = 80;
                positions.forEach(pos => {
                    maxY = Math.max(maxY, pos.y);
                });

                // Calculate grid dimensions for orphans - prefer wider layout
                const gridColumns = Math.max(3, Math.ceil(Math.sqrt(orphanNodes.length * 2)));
                const gridRows = Math.ceil(orphanNodes.length / gridColumns);

                const orphanStartY = maxY + VERTICAL_SPACING + 60;
                const gridWidth = (gridColumns - 1) * HORIZONTAL_SPACING;
                const gridStartX = Math.max(100, (width - gridWidth) / 2);

                orphanNodes.forEach((n, i) => {
                    const col = i % gridColumns;
                    const row = Math.floor(i / gridColumns);
                    positions.set(n.id, {
                        x: gridStartX + col * HORIZONTAL_SPACING,
                        y: orphanStartY + row * VERTICAL_SPACING
                    });
                });
            }

            // Handle any nodes that still don't have positions
            const remaining = nodes.filter(n => !positions.has(n.id));
            if (remaining.length > 0) {
                let maxY = 80;
                positions.forEach(pos => {
                    maxY = Math.max(maxY, pos.y);
                });

                const startY = maxY + VERTICAL_SPACING;
                remaining.forEach((n, i) => {
                    positions.set(n.id, {
                        x: 100 + (i % 5) * HORIZONTAL_SPACING,
                        y: startY + Math.floor(i / 5) * VERTICAL_SPACING
                    });
                });
            }

            // Collision detection and resolution
            // Check for overlapping nodes and nudge them apart
            const nodeWidth = NODE_WIDTH + 20;  // Add padding
            const nodeHeight = NODE_HEIGHT + 20;
            const posArray = Array.from(positions.entries());

            for (let iteration = 0; iteration < 5; iteration++) {
                let hasCollision = false;
                for (let i = 0; i < posArray.length; i++) {
                    for (let j = i + 1; j < posArray.length; j++) {
                        const [id1, pos1] = posArray[i];
                        const [id2, pos2] = posArray[j];

                        const dx = Math.abs(pos1.x - pos2.x);
                        const dy = Math.abs(pos1.y - pos2.y);

                        // Check if nodes overlap
                        if (dx < nodeWidth && dy < nodeHeight) {
                            hasCollision = true;
                            // Nudge nodes apart horizontally
                            const nudge = (nodeWidth - dx) / 2 + 10;
                            if (pos1.x < pos2.x) {
                                pos1.x -= nudge;
                                pos2.x += nudge;
                            } else {
                                pos1.x += nudge;
                                pos2.x -= nudge;
                            }
                            // Update in map
                            positions.set(id1, pos1);
                            positions.set(id2, pos2);
                        }
                    }
                }
                if (!hasCollision) break;
            }

            return positions;
        }

        // Apply auto-layout and save positions
        function cleanGraphLayout() {
            const container = document.getElementById('graph');
            if (!container) return;

            const width = container.clientWidth;
            const height = container.clientHeight;

            // Get active filters (same as updateGraph)
            const filters = getActiveFilters();

            // Get filtered nodes (same as updateGraph)
            const nodes = [];
            ['unit', 'team', 'role', 'person', 'object'].forEach(type => {
                if (filters.entities[type]) {
                    entities[type].forEach(entity => nodes.push(entity));
                }
            });

            // Calculate new positions
            const positions = calculateAutoLayout(nodes, width, height);

            // Apply positions to entities and save
            positions.forEach((pos, nodeId) => {
                for (const type of ['unit', 'team', 'role', 'person', 'object']) {
                    const entity = entities[type].find(e => e.id === nodeId);
                    if (entity) {
                        entity.graphX = pos.x;
                        entity.graphY = pos.y;
                        break;
                    }
                }
            });

            // Save to localStorage
            saveWorkspaces();

            // Re-render graph
            updateGraph();

            // Reset zoom
            if (graphZoom && svg) {
                svg.call(graphZoom.transform, d3.zoomIdentity);
                currentZoomScale = 1;
                updateZoomDisplay();
            }
        }

        // Fit graph to view
        function fitGraphToView() {
            if (!graphG || !graphZoom) return;

            const container = document.getElementById('graph');
            if (!container) return;

            const width = container.clientWidth;
            const height = container.clientHeight;

            // Get bounds of all nodes
            const bounds = graphG.node().getBBox();
            if (bounds.width === 0 || bounds.height === 0) return;

            const padding = 40;
            const scale = Math.min(
                (width - padding * 2) / bounds.width,
                (height - padding * 2) / bounds.height,
                1.5 // Max zoom
            );

            const tx = (width - bounds.width * scale) / 2 - bounds.x * scale;
            const ty = (height - bounds.height * scale) / 2 - bounds.y * scale;

            svg.transition().duration(300).call(
                graphZoom.transform,
                d3.zoomIdentity.translate(tx, ty).scale(scale)
            );

            currentZoomScale = scale;
            updateZoomDisplay();
        }

        // Zoom controls
        function zoomGraph(factor) {
            if (!graphZoom) return;
            currentZoomScale *= factor;
            currentZoomScale = Math.max(0.3, Math.min(3, currentZoomScale));

            svg.transition().duration(200).call(
                graphZoom.scaleTo,
                currentZoomScale
            );

            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const display = document.getElementById('graphZoomLevel');
            if (display) {
                display.textContent = Math.round(currentZoomScale * 100) + '%';
            }
        }

        // Generate bezier curve path for edges
        function generateEdgePath(sourceX, sourceY, targetX, targetY) {
            // Source exits from right port, target enters from left port
            const sourcePortX = sourceX + NODE_WIDTH / 2;
            const sourcePortY = sourceY;
            const targetPortX = targetX - NODE_WIDTH / 2;
            const targetPortY = targetY;

            // Calculate control points for smooth bezier
            const dx = targetPortX - sourcePortX;
            const dy = targetPortY - sourcePortY;

            // Adjust curve based on relative positions
            let cp1x, cp1y, cp2x, cp2y;

            if (dx > 0) {
                // Normal left-to-right flow
                const curveStrength = Math.min(Math.abs(dx) * 0.5, 100);
                cp1x = sourcePortX + curveStrength;
                cp1y = sourcePortY;
                cp2x = targetPortX - curveStrength;
                cp2y = targetPortY;
            } else {
                // Backwards connection - need to curve around
                const curveStrength = Math.max(80, Math.abs(dx) * 0.3);
                const verticalOffset = Math.sign(dy) * Math.max(60, Math.abs(dy) * 0.5);
                cp1x = sourcePortX + curveStrength;
                cp1y = sourcePortY + verticalOffset;
                cp2x = targetPortX - curveStrength;
                cp2y = targetPortY - verticalOffset;
            }

            return `M ${sourcePortX} ${sourcePortY} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${targetPortX} ${targetPortY}`;
        }

        function updateGraph() {
            // Get dimensions
            const container = document.getElementById('graph');
            if (!container) return;

            width = container.clientWidth;
            height = container.clientHeight;

            svg.attr('width', width).attr('height', height);

            // Get active filters
            const filters = getActiveFilters();

            // Prepare data with filters applied
            const nodes = [];
            const types = ['unit', 'team', 'role', 'person', 'object'];
            types.forEach(type => {
                if (filters.entities[type]) {
                    entities[type].forEach(entity => {
                        nodes.push({ ...entity });
                    });
                }
            });

            const links = relationships
                .filter(rel => filters.relationships[rel.predicate])
                .filter(rel => {
                    const sourceNode = nodes.find(n => n.id === rel.subject);
                    const targetNode = nodes.find(n => n.id === rel.object);
                    return sourceNode && targetNode;
                })
                .map(rel => ({
                    source: rel.subject,
                    target: rel.object,
                    predicate: rel.predicate,
                    id: rel.id
                }));

            // Clear existing
            svg.selectAll('*').remove();

            // Create defs for markers and filters
            const defs = svg.append('defs');

            // Arrow markers for each operator type
            Object.keys(eoOperators).forEach(type => {
                const opData = eoOperators[type];
                defs.append('marker')
                    .attr('id', `arrow-${type}`)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 8)
                    .attr('refY', 0)
                    .attr('markerWidth', 8)
                    .attr('markerHeight', 8)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-4L10,0L0,4')
                    .attr('fill', opData.color);
            });

            // Create main group for zoom/pan
            graphG = svg.append('g').attr('class', 'graph-container');

            const linkGroup = graphG.append('g').attr('class', 'edges');
            const nodeGroup = graphG.append('g').attr('class', 'nodes');

            // Check if nodes need initial positions
            const needsLayout = nodes.some(n => n.graphX === undefined || n.graphY === undefined);

            if (needsLayout) {
                const positions = calculateAutoLayout(nodes, width, height);
                positions.forEach((pos, nodeId) => {
                    const node = nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.graphX = pos.x;
                        node.graphY = pos.y;
                        // Also update the source entity
                        for (const type of types) {
                            const entity = entities[type].find(e => e.id === nodeId);
                            if (entity) {
                                entity.graphX = pos.x;
                                entity.graphY = pos.y;
                                break;
                            }
                        }
                    }
                });
                saveWorkspaces();
            }

            // Create node lookup for edge rendering
            const nodeMap = new Map(nodes.map(n => [n.id, n]));

            // Create edges with bezier curves
            links.forEach(link => {
                const sourceNode = nodeMap.get(link.source);
                const targetNode = nodeMap.get(link.target);
                if (!sourceNode || !targetNode) return;

                const pathData = generateEdgePath(
                    sourceNode.graphX, sourceNode.graphY,
                    targetNode.graphX, targetNode.graphY
                );

                const opData = eoOperators[link.predicate] || {};

                // Invisible hitbox for easier clicking
                linkGroup.append('path')
                    .attr('class', 'graph-edge-hitbox')
                    .attr('d', pathData)
                    .attr('data-id', link.id)
                    .on('click', function(event) {
                        event.stopPropagation();
                        openEdgeEditModal(link.id);
                    });

                // Visible edge
                const edge = linkGroup.append('path')
                    .attr('class', 'graph-edge')
                    .attr('d', pathData)
                    .attr('stroke', opData.color || '#999')
                    .attr('stroke-dasharray', () => {
                        if (link.predicate === 'SEG' || link.predicate === 'REC') return '8,4';
                        if (link.predicate === 'ALT') return '4,2';
                        return 'none';
                    })
                    .attr('marker-end', `url(#arrow-${link.predicate})`)
                    .attr('data-id', link.id)
                    .on('click', function(event) {
                        event.stopPropagation();
                        openEdgeEditModal(link.id);
                    });

                // Edge label at midpoint
                const midX = (sourceNode.graphX + targetNode.graphX) / 2;
                const midY = (sourceNode.graphY + targetNode.graphY) / 2;

                // Label background
                linkGroup.append('rect')
                    .attr('class', 'graph-edge-label-bg')
                    .attr('x', midX - 16)
                    .attr('y', midY - 8)
                    .attr('width', 32)
                    .attr('height', 16)
                    .attr('rx', 4);

                // Label text
                linkGroup.append('text')
                    .attr('class', 'graph-edge-label')
                    .attr('x', midX)
                    .attr('y', midY + 3)
                    .attr('text-anchor', 'middle')
                    .attr('fill', opData.color || '#666')
                    .style('font-weight', '600')
                    .text(link.predicate);
            });

            // Create n8n-style card nodes
            graphNode = nodeGroup.selectAll('g.graph-node')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'graph-node')
                .attr('transform', d => `translate(${d.graphX - NODE_WIDTH/2}, ${d.graphY - NODE_HEIGHT/2})`)
                .call(d3.drag()
                    .on('start', nodeDragStarted)
                    .on('drag', nodeDragged)
                    .on('end', nodeDragEnded));

            // Node body (white rectangle with rounded corners)
            graphNode.append('rect')
                .attr('class', 'graph-node-body')
                .attr('width', NODE_WIDTH)
                .attr('height', NODE_HEIGHT)
                .attr('rx', 8)
                .attr('ry', 8);

            // Accent bar on left side
            graphNode.append('rect')
                .attr('class', 'graph-node-accent')
                .attr('width', 6)
                .attr('height', NODE_HEIGHT)
                .attr('rx', 8)
                .attr('fill', d => getNodeAccentColor(d.type));

            // Clip the accent bar to just show on left
            graphNode.append('rect')
                .attr('class', 'graph-node-accent')
                .attr('x', 3)
                .attr('width', 3)
                .attr('height', NODE_HEIGHT)
                .attr('fill', d => getNodeAccentColor(d.type));

            // Icon
            graphNode.append('foreignObject')
                .attr('class', 'graph-node-icon')
                .attr('x', 14)
                .attr('y', (NODE_HEIGHT - 24) / 2)
                .attr('width', 24)
                .attr('height', 24)
                .append('xhtml:div')
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('justify-content', 'center')
                .style('width', '100%')
                .style('height', '100%')
                .style('color', d => getNodeAccentColor(d.type))
                .style('font-size', '20px')
                .html(d => getIcon(d.type));

            // Node label (name)
            graphNode.append('text')
                .attr('class', 'graph-node-label')
                .attr('x', 44)
                .attr('y', NODE_HEIGHT / 2 - 4)
                .text(d => {
                    const maxLen = 12;
                    return d.name.length > maxLen ? d.name.substring(0, maxLen - 1) + '…' : d.name;
                });

            // Node type label
            graphNode.append('text')
                .attr('class', 'graph-node-type')
                .attr('x', 44)
                .attr('y', NODE_HEIGHT / 2 + 12)
                .text(d => d.type);

            // Input port (left side)
            graphNode.append('circle')
                .attr('class', 'graph-port input-port')
                .attr('cx', 0)
                .attr('cy', NODE_HEIGHT / 2)
                .attr('r', PORT_RADIUS);

            // Output port (right side)
            graphNode.append('circle')
                .attr('class', 'graph-port output-port')
                .attr('cx', NODE_WIDTH)
                .attr('cy', NODE_HEIGHT / 2)
                .attr('r', PORT_RADIUS);

            // Node interactions
            graphNode.on('click', function(event, d) {
                event.stopPropagation();
                // Deselect all, select this one
                graphNode.classed('selected', false);
                d3.select(this).classed('selected', true);
                openEntityModal(d.id, d.type);
            })
            .on('dblclick', function(event, d) {
                event.stopPropagation();
                focusNode(d);
            })
            .on('mouseover', function(event, d) {
                showTooltip(event, d);
            })
            .on('mouseout', function() {
                hideTooltip();
            });

            // Click background to deselect
            svg.on('click', function() {
                graphNode.classed('selected', false);
                unfocusAll();
            });

            // Setup zoom
            graphZoom = d3.zoom()
                .scaleExtent([0.3, 3])
                .on('zoom', (event) => {
                    graphG.attr('transform', event.transform);
                    currentZoomScale = event.transform.k;
                    updateZoomDisplay();
                });

            svg.call(graphZoom);

            // Store link data for updating
            graphLink = linkGroup;
        }

        // Node drag handlers - free movement with position persistence
        function nodeDragStarted(event, d) {
            d3.select(this).raise().classed('dragging', true);
        }

        function nodeDragged(event, d) {
            // Update position
            d.graphX = event.x + NODE_WIDTH / 2;
            d.graphY = event.y + NODE_HEIGHT / 2;

            // Move node
            d3.select(this).attr('transform', `translate(${event.x}, ${event.y})`);

            // Update connected edges
            updateEdgesForNode(d);
        }

        function nodeDragEnded(event, d) {
            d3.select(this).classed('dragging', false);

            // Save position to entity
            for (const type of ['unit', 'team', 'role', 'object']) {
                const entity = entities[type].find(e => e.id === d.id);
                if (entity) {
                    entity.graphX = d.graphX;
                    entity.graphY = d.graphY;
                    break;
                }
            }

            // Persist to storage
            saveWorkspaces();
        }

        // Update edges connected to a node during drag
        function updateEdgesForNode(node) {
            if (!graphLink) return;

            // Get all nodes for position lookup
            const nodePositions = new Map();
            d3.selectAll('.graph-node').each(function(d) {
                nodePositions.set(d.id, { x: d.graphX, y: d.graphY });
            });

            // Update paths that connect to this node
            relationships.forEach(rel => {
                if (rel.subject === node.id || rel.object === node.id) {
                    const sourcePos = nodePositions.get(rel.subject);
                    const targetPos = nodePositions.get(rel.object);
                    if (!sourcePos || !targetPos) return;

                    const pathData = generateEdgePath(
                        sourcePos.x, sourcePos.y,
                        targetPos.x, targetPos.y
                    );

                    // Update visible edge and hitbox
                    graphLink.selectAll(`path[data-id="${rel.id}"]`)
                        .attr('d', pathData);

                    // Update label position
                    const midX = (sourcePos.x + targetPos.x) / 2;
                    const midY = (sourcePos.y + targetPos.y) / 2;

                    // This is simplified - in production you'd need to track label elements
                }
            });
        }

        // Edge edit modal
        function openEdgeEditModal(relationshipId) {
            const rel = relationships.find(r => r.id === relationshipId);
            if (!rel) return;

            openRelationshipModal({ id: relationshipId, ...rel });
        }

        function getNodeRadius(type) {
            // Legacy function - kept for compatibility
            return NODE_WIDTH / 4;
        }

        function getNodeColor(type) {
            return getNodeAccentColor(type);
        }

        function getLinkColor(predicate) {
            return eoOperators[predicate]?.color || '#999';
        }

        function getIcon(type) {
            const icons = {
                unit: '<i class="ph ph-buildings"></i>',
                team: '<i class="ph ph-users-three"></i>',
                role: '<i class="ph ph-briefcase"></i>',
                person: '<i class="ph ph-user"></i>',
                task: '<i class="ph ph-check-square"></i>',
                product: '<i class="ph ph-package"></i>',
                workflow: '<i class="ph ph-flow-arrow"></i>',
                object: '<i class="ph ph-package"></i>' // Legacy support
            };
            return icons[type] || '<i class="ph ph-question"></i>';
        }

        function getEntityIcon(type) {
            const icons = {
                unit: 'ph-buildings',
                team: 'ph-users-three',
                role: 'ph-briefcase',
                person: 'ph-user',
                task: 'ph-check-square',
                product: 'ph-package',
                workflow: 'ph-flow-arrow',
                object: 'ph-package' // Legacy support
            };
            return icons[type] || 'ph-question';
        }

        function getInitials(name) {
            return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
        }

        function focusNode(d) {
            if (!d || !d.id) return;
            if (!graphNode || !graphLink) return;
            if (!relationships) return;

            focusedNode = d;

            // Get connected nodes
            const connectedNodes = new Set([d.id]);
            relationships.forEach(rel => {
                if (rel && rel.subject === d.id) connectedNodes.add(rel.object);
                if (rel && rel.object === d.id) connectedNodes.add(rel.subject);
            });

            // Dim unconnected nodes
            graphNode.style('opacity', n => connectedNodes.has(n.id) ? 1 : 0.2);
            graphLink.selectAll('.graph-edge').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                const rel = relationships.find(r => r.id === id);
                return rel && (rel.subject === d.id || rel.object === d.id) ? 1 : 0.1;
            });
        }

        function unfocusAll() {
            focusedNode = null;
            if (graphNode) graphNode.style('opacity', 1);
            if (graphLink) graphLink.selectAll('.graph-edge').style('opacity', 1);
        }

        function toggleNodeCollapse(d) {
            console.log('Toggle collapse for:', d.name);
        }

        function showTooltip(event, d) {
            const connections = relationships.filter(r =>
                r.subject === d.id || r.object === d.id
            );

            tooltip.html(`
                <strong>${d.name}</strong><br>
                <em>${d.type}</em><br>
                ${connections.length} connections
            `);
            tooltip.style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .style('opacity', 1);
        }

        function hideTooltip() {
            tooltip.style('opacity', 0);
        }

        // Legacy drag functions (for compatibility)
        function dragstarted(event, d) {
            nodeDragStarted(event, d);
        }

        function dragged(event, d) {
            nodeDragged(event, d);
        }

        function dragended(event, d) {
            nodeDragEnded(event, d);
        }

        function resetGraph() {
            if (currentView === 'graph') {
                unfocusAll();
                cleanGraphLayout();
            } else if (currentView === 'tree') {
                renderTreeView();
            }
        }

        function exportData() {
            const workspaceName = document.getElementById('workspaceNameText').textContent;
            const data = {
                workspaceName,
                entities,
                relationships
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${workspaceName.toLowerCase().replace(/\s+/g, '-')}-data.json`;
            a.click();
        }

        function importData() {
            // Create a file input dynamically
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    // Validate the data structure
                    if (!data.workspaceName || typeof data.workspaceName !== 'string') {
                        alert('Invalid import file: missing or invalid workspaceName');
                        return;
                    }

                    if (!data.entities || typeof data.entities !== 'object') {
                        alert('Invalid import file: missing or invalid entities');
                        return;
                    }

                    // Validate entity types
                    const requiredTypes = ['unit', 'team', 'role', 'person', 'object'];
                    for (const type of requiredTypes) {
                        if (!Array.isArray(data.entities[type])) {
                            // Initialize missing types as empty arrays
                            data.entities[type] = [];
                        }
                    }

                    if (!Array.isArray(data.relationships)) {
                        // Initialize missing relationships as empty array
                        data.relationships = [];
                    }

                    // Create a new workspace with the imported data
                    const wsId = generateWorkspaceId();
                    const importedName = data.workspaceName + ' (Imported)';

                    workspaces[wsId] = {
                        id: wsId,
                        name: importedName,
                        entities: JSON.parse(JSON.stringify(data.entities)),
                        relationships: JSON.parse(JSON.stringify(data.relationships)),
                        hasSampleData: false,
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };

                    saveWorkspaces();
                    switchWorkspace(wsId);
                    renderWorkspaceList();

                    // Calculate totals for reporting
                    const totalEntities = Object.values(data.entities).reduce((sum, arr) => sum + arr.length, 0);
                    const totalRelationships = data.relationships.length;

                    // Log workspace import to Xano API
                    logActivityToXano({
                        event_verb: 'Start Workspace (JSON Import)',
                        eo_operator: 'INS',
                        object_type: 'workspace',
                        object_id: wsId,
                        object_label: importedName,
                        data_json: {
                            original_name: data.workspaceName,
                            entity_count: totalEntities,
                            relationship_count: totalRelationships,
                            import_source: 'json_import'
                        }
                    }, false);

                    // Log each entity to Xano API (suppress individual toasts for bulk operations)
                    for (const entityType of Object.keys(data.entities)) {
                        for (const entity of data.entities[entityType]) {
                            logActivityToXano({
                                event_verb: 'Start Entity (JSON Import)',
                                eo_operator: 'INS',
                                object_type: entityType,
                                object_id: entity.id,
                                object_label: entity.name,
                                data_json: {
                                    entity_type: entityType,
                                    entity_name: entity.name,
                                    workspace_id: wsId,
                                    import_source: 'json_import'
                                }
                            }, false);
                        }
                    }

                    // Log each relationship to Xano API (suppress individual toasts for bulk operations)
                    for (const rel of data.relationships) {
                        const subjectEntity = findEntity(rel.subject);
                        const objectEntity = findEntity(rel.object);
                        logActivityToXano({
                            event_verb: 'Create Connection (JSON Import)',
                            eo_operator: rel.predicate || 'DES',
                            object_type: 'relationship',
                            object_id: rel.id,
                            object_label: `${subjectEntity?.name || rel.subject} ${rel.predicate || 'DES'} ${objectEntity?.name || rel.object}`,
                            data_json: {
                                subject_id: rel.subject,
                                object_id: rel.object,
                                predicate: rel.predicate || 'DES',
                                workspace_id: wsId,
                                import_source: 'json_import'
                            }
                        }, false);
                    }

                    // Show summary toast for the import
                    showActivityToast('success', 'JSON Import Complete', `${totalEntities} entities and ${totalRelationships} relationships synced to Xano`);

                    alert(`Successfully imported "${data.workspaceName}" as a new workspace with ${totalEntities} entities and ${totalRelationships} relationships.`);

                } catch (err) {
                    console.error('Import error:', err);
                    alert('Failed to import file: ' + err.message);
                }
            };

            input.click();
        }

        // ==========================================
        // BULK IMPORT FUNCTIONALITY
        // ==========================================

        let bulkImportState = {
            step: 1,
            entityType: 'person',
            rawData: '',
            parsedData: [],
            headers: [],
            fieldMappings: {},  // { sourceColumn: targetField }
            setAllValues: {},   // { targetField: { enabled: true, value: 'xyz' } }
            processedData: []
        };

        // Field definitions for each entity type
        const bulkImportFields = {
            unit: [
                { key: 'name', label: 'Name', required: true },
                { key: 'parent', label: 'Parent Unit', required: false, type: 'relationship', targetType: 'unit' }
            ],
            team: [
                { key: 'name', label: 'Name', required: true },
                { key: 'parent', label: 'Parent (Unit or Team)', required: false, type: 'relationship', targetTypes: ['unit', 'team'] }
            ],
            role: [
                { key: 'name', label: 'Name', required: true },
                { key: 'parent', label: 'Parent (Unit or Team)', required: false, type: 'relationship', targetTypes: ['unit', 'team'] }
            ],
            person: [
                { key: 'name', label: 'Name', required: true },
                { key: 'role', label: 'Assigned Role', required: false, type: 'relationship', targetType: 'role' }
            ],
            object: [
                { key: 'name', label: 'Name', required: true },
                { key: 'parent', label: 'Parent Role', required: false, type: 'relationship', targetType: 'role' }
            ]
        };

        function openBulkImportModal() {
            // Reset state
            bulkImportState = {
                step: 1,
                entityType: 'person',
                rawData: '',
                parsedData: [],
                headers: [],
                fieldMappings: {},
                setAllValues: {},
                processedData: []
            };

            // Reset UI
            document.getElementById('bulkImportPasteArea').value = '';
            document.getElementById('bulkImportFileInput').value = '';
            document.getElementById('bulkImportFileName').textContent = '';
            document.getElementById('bulkImportDataPreview').style.display = 'none';

            // Reset entity type buttons
            document.querySelectorAll('.bulk-import-entity-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === 'person');
            });

            // Reset tabs
            switchBulkImportTab('paste');

            // Reset steps
            updateBulkImportStep(1);

            // Show modal
            document.getElementById('bulkImportModal').classList.add('open');
        }

        function closeBulkImportModal() {
            document.getElementById('bulkImportModal').classList.remove('open');
        }

        function selectBulkImportType(type) {
            bulkImportState.entityType = type;
            document.querySelectorAll('.bulk-import-entity-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });

            // Re-validate if we have data
            if (bulkImportState.parsedData.length > 0) {
                updateBulkImportNextButton();
            }
        }

        function switchBulkImportTab(tab) {
            document.querySelectorAll('.bulk-import-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.bulk-import-tab:nth-child(${tab === 'paste' ? 1 : 2})`).classList.add('active');

            document.getElementById('bulkImportPasteTab').style.display = tab === 'paste' ? 'block' : 'none';
            document.getElementById('bulkImportFileTab').style.display = tab === 'file' ? 'block' : 'none';
        }

        function parseBulkImportData() {
            const rawData = document.getElementById('bulkImportPasteArea').value.trim();
            if (!rawData) {
                bulkImportState.parsedData = [];
                bulkImportState.headers = [];
                document.getElementById('bulkImportDataPreview').style.display = 'none';
                updateBulkImportNextButton();
                return;
            }

            bulkImportState.rawData = rawData;
            parseDataContent(rawData);
        }

        function parseDataContent(content) {
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                bulkImportState.parsedData = [];
                bulkImportState.headers = [];
                document.getElementById('bulkImportDataPreview').style.display = 'none';
                updateBulkImportNextButton();
                return;
            }

            // Detect delimiter (tab or comma)
            const firstLine = lines[0];
            const delimiter = firstLine.includes('\t') ? '\t' : ',';

            // Parse CSV/TSV with proper quote handling
            function parseLine(line, delim) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        if (inQuotes && line[i + 1] === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === delim && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            }

            // Parse headers
            bulkImportState.headers = parseLine(lines[0], delimiter);

            // Parse data rows
            bulkImportState.parsedData = [];
            for (let i = 1; i < lines.length; i++) {
                const values = parseLine(lines[i], delimiter);
                if (values.some(v => v.trim())) {  // Skip empty rows
                    const row = {};
                    bulkImportState.headers.forEach((header, idx) => {
                        row[header] = values[idx] || '';
                    });
                    bulkImportState.parsedData.push(row);
                }
            }

            // Update preview
            renderBulkImportDataPreview();
            updateBulkImportNextButton();
        }

        function handleBulkImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('bulkImportFileName').innerHTML = `
                <i class="ph ph-file-csv"></i> ${escapeHtml(file.name)}
            `;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                bulkImportState.rawData = content;
                parseDataContent(content);
            };
            reader.readAsText(file);
        }

        function renderBulkImportDataPreview() {
            const previewContainer = document.getElementById('bulkImportDataPreview');
            const table = document.getElementById('bulkImportPreviewTable');
            const rowCount = document.getElementById('bulkImportRowCount');

            if (bulkImportState.parsedData.length === 0) {
                previewContainer.style.display = 'none';
                return;
            }

            previewContainer.style.display = 'block';
            rowCount.textContent = `${bulkImportState.parsedData.length} rows`;

            // Build table
            let html = '<thead><tr>';
            html += '<th class="row-number-header"></th>';
            bulkImportState.headers.forEach(h => {
                html += `<th>${escapeHtml(h)}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Show first 10 rows
            const previewRows = bulkImportState.parsedData.slice(0, 10);
            previewRows.forEach((row, idx) => {
                html += '<tr>';
                html += `<td class="row-number">${idx + 1}</td>`;
                bulkImportState.headers.forEach(h => {
                    html += `<td>${escapeHtml(row[h] || '')}</td>`;
                });
                html += '</tr>';
            });

            if (bulkImportState.parsedData.length > 10) {
                html += `<tr><td colspan="${bulkImportState.headers.length + 1}" style="text-align: center; color: #8B6F47; font-style: italic;">... and ${bulkImportState.parsedData.length - 10} more rows</td></tr>`;
            }

            html += '</tbody>';
            table.innerHTML = html;
        }

        function updateBulkImportNextButton() {
            const nextBtn = document.getElementById('bulkImportNextBtn');
            const footerInfo = document.getElementById('bulkImportFooterInfo');

            if (bulkImportState.step === 1) {
                const hasData = bulkImportState.parsedData.length > 0;
                nextBtn.disabled = !hasData;
                footerInfo.textContent = hasData
                    ? `${bulkImportState.parsedData.length} rows detected. Click Next to map fields.`
                    : 'Select an entity type and paste or upload your data to continue.';
            } else if (bulkImportState.step === 2) {
                // Check if name field is mapped
                const nameMapping = Object.entries(bulkImportState.fieldMappings).find(([src, tgt]) => tgt === 'name');
                const hasNameMapping = !!nameMapping || (bulkImportState.setAllValues.name && bulkImportState.setAllValues.name.enabled);
                nextBtn.disabled = !hasNameMapping;
                footerInfo.textContent = hasNameMapping
                    ? 'Ready to review. Click Next to see the final preview.'
                    : 'Please map at least the Name field to continue.';
            }
        }

        function updateBulkImportStep(step) {
            bulkImportState.step = step;

            // Update step indicators
            for (let i = 1; i <= 3; i++) {
                const stepEl = document.getElementById(`bulkImportStep${i}`);
                stepEl.classList.remove('active', 'completed');
                if (i < step) stepEl.classList.add('completed');
                if (i === step) stepEl.classList.add('active');
            }

            // Show/hide content
            document.getElementById('bulkImportStepContent1').style.display = step === 1 ? 'block' : 'none';
            document.getElementById('bulkImportStepContent2').style.display = step === 2 ? 'block' : 'none';
            document.getElementById('bulkImportStepContent3').style.display = step === 3 ? 'block' : 'none';

            // Show/hide buttons
            document.getElementById('bulkImportBackBtn').style.display = step > 1 ? 'inline-flex' : 'none';
            document.getElementById('bulkImportNextBtn').style.display = step < 3 ? 'inline-flex' : 'none';
            document.getElementById('bulkImportImportBtn').style.display = step === 3 ? 'inline-flex' : 'none';
            document.getElementById('bulkImportDoneBtn').style.display = 'none';

            // Reset success content visibility
            document.getElementById('bulkImportReviewContent').style.display = 'block';
            document.getElementById('bulkImportSuccessContent').style.display = 'none';

            updateBulkImportNextButton();
        }

        function bulkImportNext() {
            if (bulkImportState.step === 1) {
                // Go to step 2: field mapping
                updateBulkImportStep(2);
                renderFieldMappingUI();
            } else if (bulkImportState.step === 2) {
                // Go to step 3: review
                updateBulkImportStep(3);
                processAndPreviewData();
            }
        }

        function bulkImportBack() {
            if (bulkImportState.step > 1) {
                updateBulkImportStep(bulkImportState.step - 1);
            }
        }

        function renderFieldMappingUI() {
            const container = document.getElementById('bulkImportMappingContainer');
            const fields = bulkImportFields[bulkImportState.entityType];

            // Auto-map fields based on header names
            bulkImportState.fieldMappings = {};
            bulkImportState.setAllValues = {};

            fields.forEach(field => {
                // Try to find a matching header
                const matchingHeader = bulkImportState.headers.find(h =>
                    h.toLowerCase().includes(field.key.toLowerCase()) ||
                    h.toLowerCase().includes(field.label.toLowerCase().split(' ')[0].toLowerCase())
                );
                if (matchingHeader) {
                    bulkImportState.fieldMappings[matchingHeader] = field.key;
                }
            });

            let html = '';

            // Field mapping rows
            fields.forEach(field => {
                const currentMapping = Object.entries(bulkImportState.fieldMappings).find(([src, tgt]) => tgt === field.key);
                const mappedColumn = currentMapping ? currentMapping[0] : '';

                html += `
                    <div class="bulk-import-mapping-row" data-field="${field.key}">
                        <div>
                            <div class="bulk-import-mapping-col">
                                ${field.label}${field.required ? ' <span style="color: #d32f2f;">*</span>' : ''}
                            </div>
                            ${field.type === 'relationship' ? `<div style="font-size: 0.7rem; color: #8B6F47; margin-top: 0.25rem;">Links to existing ${field.targetType || field.targetTypes?.join('/')}</div>` : ''}
                        </div>
                        <div class="bulk-import-mapping-arrow"><i class="ph ph-arrow-left"></i></div>
                        <div>
                            <select class="bulk-import-mapping-select" onchange="updateFieldMapping('${field.key}', this.value)">
                                <option value="">-- Select column --</option>
                                ${bulkImportState.headers.map(h => `
                                    <option value="${escapeHtml(h)}" ${mappedColumn === h ? 'selected' : ''}>${escapeHtml(h)}</option>
                                `).join('')}
                            </select>
                        </div>
                        <div class="bulk-import-set-all">
                            <button class="bulk-import-set-all-btn" onclick="toggleSetAll('${field.key}', this)" title="Set a default value for all items">
                                <i class="ph ph-pencil-simple"></i> Set for All
                            </button>
                            <input type="text"
                                class="bulk-import-set-all-input"
                                id="setAllInput_${field.key}"
                                placeholder="Default value..."
                                style="display: none;"
                                oninput="updateSetAllValue('${field.key}', this.value)"
                                ${field.type === 'relationship' ? `list="existingEntities_${field.key}"` : ''}>
                            ${field.type === 'relationship' ? renderExistingEntitiesDatalist(field) : ''}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            updateBulkImportNextButton();
            renderMappedPreview();
        }

        function renderExistingEntitiesDatalist(field) {
            const targetTypes = field.targetTypes || [field.targetType];
            let options = [];

            targetTypes.forEach(type => {
                if (entities[type]) {
                    entities[type].forEach(e => {
                        options.push(e.name);
                    });
                }
            });

            return `<datalist id="existingEntities_${field.key}">${options.map(o => `<option value="${escapeHtml(o)}">`).join('')}</datalist>`;
        }

        function updateFieldMapping(fieldKey, sourceColumn) {
            // Remove any existing mapping to this field
            Object.keys(bulkImportState.fieldMappings).forEach(key => {
                if (bulkImportState.fieldMappings[key] === fieldKey) {
                    delete bulkImportState.fieldMappings[key];
                }
            });

            // Add new mapping
            if (sourceColumn) {
                bulkImportState.fieldMappings[sourceColumn] = fieldKey;
            }

            updateBulkImportNextButton();
            renderMappedPreview();
        }

        function toggleSetAll(fieldKey, btn) {
            const input = document.getElementById(`setAllInput_${fieldKey}`);
            const isActive = btn.classList.contains('active');

            if (isActive) {
                btn.classList.remove('active');
                input.style.display = 'none';
                input.value = '';
                delete bulkImportState.setAllValues[fieldKey];
            } else {
                btn.classList.add('active');
                input.style.display = 'block';
                input.focus();
                bulkImportState.setAllValues[fieldKey] = { enabled: true, value: '' };
            }

            updateBulkImportNextButton();
            renderMappedPreview();
        }

        function updateSetAllValue(fieldKey, value) {
            if (bulkImportState.setAllValues[fieldKey]) {
                bulkImportState.setAllValues[fieldKey].value = value;
            }
            renderMappedPreview();
        }

        function renderMappedPreview() {
            const table = document.getElementById('bulkImportMappedTable');
            const countEl = document.getElementById('bulkImportMappedCount');
            const fields = bulkImportFields[bulkImportState.entityType];

            // Build header
            let html = '<thead><tr>';
            html += '<th class="row-number-header"></th>';
            fields.forEach(f => {
                html += `<th>${f.label}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Process and show preview
            const previewRows = bulkImportState.parsedData.slice(0, 10);
            previewRows.forEach((row, idx) => {
                html += '<tr>';
                html += `<td class="row-number">${idx + 1}</td>`;
                fields.forEach(f => {
                    let value = '';
                    const setAll = bulkImportState.setAllValues[f.key];

                    // Check if there's a column mapping
                    const mappedColumn = Object.entries(bulkImportState.fieldMappings)
                        .find(([src, tgt]) => tgt === f.key);

                    if (mappedColumn && row[mappedColumn[0]]) {
                        value = row[mappedColumn[0]];
                    } else if (setAll && setAll.enabled && setAll.value) {
                        value = `<span class="preview-set-all">${escapeHtml(setAll.value)}</span>`;
                    }

                    html += `<td>${value ? (value.includes('preview-set-all') ? value : escapeHtml(value)) : '<span style="color: #ccc;">—</span>'}</td>`;
                });
                html += '</tr>';
            });

            if (bulkImportState.parsedData.length > 10) {
                html += `<tr><td colspan="${fields.length + 1}" style="text-align: center; color: #8B6F47; font-style: italic;">... and ${bulkImportState.parsedData.length - 10} more rows</td></tr>`;
            }

            html += '</tbody>';
            table.innerHTML = html;
            countEl.textContent = `${bulkImportState.parsedData.length} items`;
        }

        function processAndPreviewData() {
            const fields = bulkImportFields[bulkImportState.entityType];
            bulkImportState.processedData = [];
            let validCount = 0;
            let errorCount = 0;

            bulkImportState.parsedData.forEach((row, idx) => {
                const processed = { _original: row, _errors: [], _rowIndex: idx };

                fields.forEach(field => {
                    let value = '';

                    // Check mapped column first
                    const mappedColumn = Object.entries(bulkImportState.fieldMappings)
                        .find(([src, tgt]) => tgt === field.key);

                    if (mappedColumn && row[mappedColumn[0]]) {
                        value = row[mappedColumn[0]].trim();
                    }

                    // Apply "Set for All" if no value from mapping
                    if (!value) {
                        const setAll = bulkImportState.setAllValues[field.key];
                        if (setAll && setAll.enabled && setAll.value) {
                            value = setAll.value.trim();
                            processed[`${field.key}_isSetAll`] = true;
                        }
                    }

                    processed[field.key] = value;

                    // Validate required fields
                    if (field.required && !value) {
                        processed._errors.push(`${field.label} is required`);
                    }
                });

                if (processed._errors.length === 0) {
                    validCount++;
                } else {
                    errorCount++;
                }

                bulkImportState.processedData.push(processed);
            });

            // Update counts
            document.getElementById('bulkImportTotalCount').textContent = bulkImportState.processedData.length;
            document.getElementById('bulkImportValidCount').textContent = validCount;
            document.getElementById('bulkImportErrorCount').textContent = errorCount;
            document.getElementById('bulkImportFinalCount').textContent = `${validCount} valid items`;

            // Update entity type label
            const typeLabels = {
                unit: 'Units',
                team: 'Teams',
                role: 'Roles',
                person: 'People',
                object: 'Objects'
            };
            document.getElementById('bulkImportEntityTypeLabel').innerHTML =
                `Importing as: <strong>${typeLabels[bulkImportState.entityType]}</strong>`;

            // Render final table
            renderFinalPreview();

            // Disable import if no valid items
            document.getElementById('bulkImportImportBtn').disabled = validCount === 0;
            document.getElementById('bulkImportFooterInfo').textContent = validCount > 0
                ? `${validCount} items ready to import.`
                : 'No valid items to import. Please check your data.';
        }

        function renderFinalPreview() {
            const table = document.getElementById('bulkImportFinalTable');
            const fields = bulkImportFields[bulkImportState.entityType];

            let html = '<thead><tr>';
            html += '<th class="row-number-header"></th>';
            fields.forEach(f => {
                html += `<th>${f.label}</th>`;
            });
            html += '<th>Status</th>';
            html += '</tr></thead><tbody>';

            bulkImportState.processedData.forEach((row, idx) => {
                const hasErrors = row._errors.length > 0;
                html += `<tr class="${hasErrors ? 'error' : ''}">`;
                html += `<td class="row-number">${idx + 1}</td>`;
                fields.forEach(f => {
                    const value = row[f.key];
                    const isSetAll = row[`${f.key}_isSetAll`];
                    html += `<td>${value ? `<span class="${isSetAll ? 'preview-set-all' : ''}">${escapeHtml(value)}</span>` : '<span style="color: #ccc;">—</span>'}</td>`;
                });
                html += `<td>${hasErrors
                    ? `<span class="preview-error"><i class="ph ph-warning"></i> ${row._errors.join(', ')}</span>`
                    : '<span style="color: #4CAF50;"><i class="ph ph-check"></i> Valid</span>'
                }</td>`;
                html += '</tr>';
            });

            html += '</tbody>';
            table.innerHTML = html;
        }

        function executeBulkImport() {
            const validItems = bulkImportState.processedData.filter(row => row._errors.length === 0);
            const entityType = bulkImportState.entityType;
            const fields = bulkImportFields[entityType];
            let importedCount = 0;

            validItems.forEach(item => {
                const name = item.name;
                if (!name) return;

                // Create entity
                const id = entityType[0] + Date.now() + Math.random().toString(36).substr(2, 5);
                const entity = {
                    id,
                    name,
                    type: entityType
                };

                entities[entityType].push(entity);

                // Log to Xano (suppress individual toasts for bulk operations)
                logActivityToXano({
                    event_verb: 'Start Entity (Bulk Import)',
                    eo_operator: 'INS',
                    object_type: entityType,
                    object_id: id,
                    object_label: name,
                    data_json: {
                        entity_type: entityType,
                        entity_name: name,
                        import_source: 'bulk_import'
                    }
                }, false);

                // Handle relationships
                fields.forEach(field => {
                    if (field.type === 'relationship' && item[field.key]) {
                        const targetName = item[field.key];
                        const targetTypes = field.targetTypes || [field.targetType];

                        // Find matching entity
                        let targetEntity = null;
                        for (const tt of targetTypes) {
                            targetEntity = entities[tt]?.find(e =>
                                e.name.toLowerCase() === targetName.toLowerCase()
                            );
                            if (targetEntity) break;
                        }

                        // Skip person-role relationships - people cannot have activities
                        if (field.key === 'role' && entityType === 'person') {
                            return;
                        }

                        if (targetEntity) {
                            // Create hierarchy relationship: Parent DES Child
                            const relId = 'rel' + Date.now() + Math.random().toString(36).substr(2, 5);
                            const subjectId = targetEntity.id;
                            const objectId = id;
                            const predicate = 'DES';

                            relationships.push({
                                id: relId,
                                subject: subjectId,
                                predicate: predicate,
                                object: objectId
                            });

                            // Log relationship (suppress individual toasts for bulk operations)
                            logActivityToXano({
                                event_verb: 'Create Connection (Bulk Import)',
                                eo_operator: predicate,
                                object_type: 'relationship',
                                object_id: relId,
                                object_label: `${findEntity(subjectId)?.name} ${predicate} ${findEntity(objectId)?.name}`,
                                data_json: {
                                    subject_id: subjectId,
                                    object_id: objectId,
                                    predicate: predicate,
                                    import_source: 'bulk_import'
                                }
                            }, false);
                        }
                    }
                });

                importedCount++;
            });

            // Save and refresh
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();

            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }

            // Show success
            document.getElementById('bulkImportReviewContent').style.display = 'none';
            document.getElementById('bulkImportSuccessContent').style.display = 'block';
            document.getElementById('bulkImportSuccessMessage').textContent =
                `Successfully imported ${importedCount} ${bulkImportState.entityType}${importedCount !== 1 ? 's' : ''}.`;

            // Show summary toast for bulk import
            if (importedCount > 0) {
                showActivityToast('success', 'Bulk Import Complete', `${importedCount} ${bulkImportState.entityType}${importedCount !== 1 ? 's' : ''} synced to Xano`);
            }

            // Update footer
            document.getElementById('bulkImportImportBtn').style.display = 'none';
            document.getElementById('bulkImportBackBtn').style.display = 'none';
            document.getElementById('bulkImportDoneBtn').style.display = 'inline-flex';
            document.getElementById('bulkImportFooterInfo').textContent = 'Import complete!';
        }

        function saveWorkspaceName() {
            // Now handled by workspace modal - this is a no-op for backwards compatibility
            // The workspace name is saved via the renameWorkspace function
        }

        let hasSampleData = false;

        function toggleSampleData() {
            if (hasSampleData) {
                // Clear sample data
                if (!confirm('Remove all sample data? This cannot be undone.')) return;
                
                entities.unit = [];
                entities.team = [];
                entities.role = [];
                entities.person = [];
                entities.task = [];
                entities.product = [];
                entities.workflow = [];
                relationships = [];

                hasSampleData = false;
                document.getElementById('sampleDataText').textContent = 'Load Sample Data';
                document.getElementById('sampleDataBtn').innerHTML = '<i class="ph ph-database"></i> <span id="sampleDataText">Load Sample Data</span>';
            } else {
                // Load sample data
                initSampleData();
                hasSampleData = true;
                document.getElementById('sampleDataText').textContent = 'Clear Sample Data';
                document.getElementById('sampleDataBtn').innerHTML = '<i class="ph ph-database"></i> <span id="sampleDataText">Clear Sample Data</span>';
            }
            
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function clearAllData() {
            if (!confirm('Clear ALL data including your custom entities? This cannot be undone.')) return;

            entities.unit = [];
            entities.team = [];
            entities.role = [];
            entities.person = [];
            entities.task = [];
            entities.product = [];
            entities.workflow = [];
            relationships = [];
            hasSampleData = false;
            
            document.getElementById('sampleDataText').textContent = 'Load Sample Data';
            document.getElementById('sampleDataBtn').innerHTML = '<i class="ph ph-database"></i> <span id="sampleDataText">Load Sample Data</span>';
            
            saveToLocalStorage();
            renderEntityList();
            updateSelects();
            updateParentOptions();
            renderActivityList();
            
            if (currentView === 'graph') {
                updateGraph();
            } else if (currentView === 'tree') {
                renderTreeView();
            } else if (currentView === 'card') {
                renderCardView();
            }
        }

        function saveToLocalStorage() {
            // Delegate to workspace-aware save
            saveWorkspaces();
        }

        function loadFromLocalStorage() {
            // Delegate to workspace-aware load
            const hasWorkspaces = loadWorkspaces();

            if (hasWorkspaces && currentWorkspaceId && workspaces[currentWorkspaceId]) {
                const ws = workspaces[currentWorkspaceId];

                // Load current workspace data (normalizeEntities ensures backwards compatibility)
                entities = normalizeEntities(JSON.parse(JSON.stringify(ws.entities || {})));
                relationships = JSON.parse(JSON.stringify(ws.relationships || []));
                hasSampleData = ws.hasSampleData || false;

                // Load workflow system data
                workflowTemplates = JSON.parse(JSON.stringify(ws.workflowTemplates || []));
                workflowInstances = JSON.parse(JSON.stringify(ws.workflowInstances || []));
                workflowViolations = JSON.parse(JSON.stringify(ws.workflowViolations || []));
                taskLinks = JSON.parse(JSON.stringify(ws.taskLinks || []));

                // Update UI
                const nameEl = document.getElementById('workspaceNameText');
                if (nameEl) {
                    nameEl.textContent = ws.name;
                    nameEl.title = ws.name;
                }

                const btnText = document.getElementById('sampleDataText');
                if (btnText) {
                    btnText.textContent = hasSampleData ? 'Clear Sample Data' : 'Load Sample Data';
                }

                console.log('📦 Loaded workspace:', ws.name);
                return true;
            }

            return false;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (currentView === 'graph') {
                updateGraph();
            }
        });

        // === SIMPLIFIED UX FUNCTIONS ===

        // Collapsible sections
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        // Collapsible sidebar panels
        function togglePanel(side) {
            const container = document.getElementById('mainContainer');
            const panel = document.getElementById(side === 'left' ? 'panelLeft' : 'panelRight');

            if (!container || !panel) return;

            const isCollapsed = panel.classList.toggle('collapsed');

            // Update container grid class
            if (side === 'left') {
                container.classList.toggle('left-collapsed', isCollapsed);
            } else {
                container.classList.toggle('right-collapsed', isCollapsed);
            }

            // Save state to localStorage
            localStorage.setItem(`panel${side.charAt(0).toUpperCase() + side.slice(1)}Collapsed`, isCollapsed);

            // Trigger graph resize if visible
            setTimeout(() => {
                if (currentView === 'graph') {
                    updateGraph();
                } else if (currentView === 'venn') {
                    renderVennView();
                }
            }, 350);
        }

        // Restore panel collapse states on load
        function restorePanelStates() {
            const leftCollapsed = localStorage.getItem('panelLeftCollapsed') === 'true';
            const rightCollapsed = localStorage.getItem('panelRightCollapsed') === 'true';
            const container = document.getElementById('mainContainer');
            const panelLeft = document.getElementById('panelLeft');
            const panelRight = document.getElementById('panelRight');

            if (leftCollapsed && panelLeft && container) {
                panelLeft.classList.add('collapsed');
                container.classList.add('left-collapsed');
            }

            if (rightCollapsed && panelRight && container) {
                panelRight.classList.add('collapsed');
                container.classList.add('right-collapsed');
            }
        }

        // Task Wizard State
        let wizardState = {
            taskName: '',
            selectedRole: null,
            selectedPerson: null,
            newRoleName: '',
            newPersonName: ''
        };

        // Dismiss/hide the task wizard - show compact CTA instead
        function dismissTaskWizard() {
            const wizard = document.getElementById('taskWizard');
            const quickCTA = document.getElementById('taskQuickCTA');
            if (wizard) {
                wizard.style.display = 'none';
                localStorage.setItem('taskWizardDismissed', 'true');
            }
            // Show the compact CTA so task creation is always accessible
            if (quickCTA) {
                quickCTA.style.display = 'block';
            }
        }

        function checkTaskWizard() {
            const wizard = document.getElementById('taskWizard');
            const quickCTA = document.getElementById('taskQuickCTA');
            const dismissed = localStorage.getItem('taskWizardDismissed');
            // Also hide if there are existing entities
            const hasEntities = Object.values(entities).some(arr => arr.length > 0);
            if (wizard && (dismissed === 'true' || hasEntities)) {
                wizard.style.display = 'none';
                // Show compact CTA so task creation is always the first, prominent option
                if (quickCTA) {
                    quickCTA.style.display = 'block';
                }
            }
        }

        // Show full wizard from compact CTA
        function showFullWizard() {
            const wizard = document.getElementById('taskWizard');
            const quickCTA = document.getElementById('taskQuickCTA');
            if (wizard) {
                wizard.style.display = 'block';
            }
            if (quickCTA) {
                quickCTA.style.display = 'none';
            }
        }

        // Start the wizard flow (deprecated - wizard removed, use openHeroTaskModal instead)
        function startTaskWizard() {
            // Wizard has been removed, open hero task modal instead
            openHeroTaskModal();
        }

        // Cancel wizard (deprecated - wizard removed)
        function cancelTaskWizard() {
            // Wizard has been removed, no-op
        }

        function resetWizardSteps() {
            // Wizard has been removed, no-op
        }

        // Deprecated wizard functions - wizard has been removed, use openHeroTaskModal instead
        function updateWizardProgress(currentStep) { }
        function wizardNextStep(step) { }
        function wizardPrevStep(step) { }
        function populateWizardRoles() { }
        function selectWizardRole(roleId) { }
        function showWizardCreateRole() { }
        function hideWizardCreateRole() { }
        function createWizardRole() { }
        function populateWizardPersons() { }
        function selectWizardPerson(personId) { }
        function showWizardCreatePerson() { }
        function hideWizardCreatePerson() { }
        function createWizardPerson() { }
        function updateWizardSummary() { }

        // Deprecated - wizard removed, use submitHeroTask instead
        function completeTaskWizard() { }

        // Legacy compatibility (deprecated)
        function dismissWelcomeBanner() { }

        function checkWelcomeBanner() { }

        // ============================================
        // HERO TASK MODAL FUNCTIONS
        // ============================================

        // Flatpickr instance for due date picker
        let heroDatePicker = null;

        // Open the hero task modal
        function openHeroTaskModal(preselectedRoleId = null) {
            const overlay = document.getElementById('heroTaskOverlay');
            overlay.classList.add('active');

            // Populate role and person selects
            populateHeroSelects();

            // Pre-select role if provided
            if (preselectedRoleId) {
                const roleSelect = document.getElementById('heroTaskRole');
                if (roleSelect) {
                    roleSelect.value = preselectedRoleId;
                    // Trigger change event to update person dropdown and preview
                    roleSelect.dispatchEvent(new Event('change'));
                }
            }

            // Initialize Flatpickr for better cross-browser date picking
            if (typeof flatpickr !== 'undefined' && !heroDatePicker) {
                heroDatePicker = flatpickr('#heroTaskDueDate', {
                    dateFormat: 'Y-m-d',
                    minDate: 'today',
                    allowInput: true,
                    onChange: function(selectedDates, dateStr) {
                        updateHeroTaskPreview();
                    }
                });
            }

            // Focus on task input
            setTimeout(() => {
                document.getElementById('heroTaskName').focus();
            }, 100);

            // Remove pulse animation from FAB after first use
            const fab = document.querySelector('.task-fab');
            if (fab) fab.classList.remove('task-fab-pulse');
        }

        // Close the hero task modal
        function closeHeroTaskModal() {
            const overlay = document.getElementById('heroTaskOverlay');
            overlay.classList.remove('active');

            // Reset form - basic fields
            document.getElementById('heroTaskName').value = '';
            document.getElementById('heroTaskWorkflow').value = '';
            if (document.getElementById('heroTaskRole')) document.getElementById('heroTaskRole').value = '';
            if (document.getElementById('heroTaskRoleMain')) document.getElementById('heroTaskRoleMain').value = '';
            document.getElementById('heroTaskPerson').value = '';
            document.getElementById('heroTaskDueDate').value = '';
            if (heroDatePicker) {
                heroDatePicker.clear();
            }
            document.getElementById('heroTaskPredecessor').value = '';
            document.getElementById('heroTaskPreview').style.display = 'none';
            document.getElementById('heroTaskSubmitBtn').disabled = true;
            document.getElementById('heroDependencyWarning').style.display = 'none';

            // Reset new fields
            if (document.getElementById('heroTaskDescription')) {
                document.getElementById('heroTaskDescription').value = '';
            }
            if (document.getElementById('heroTaskRecurring')) {
                document.getElementById('heroTaskRecurring').value = '';
            }

            // Reset priority to medium
            selectedPriority = 'medium';
            const priorityOptions = document.querySelectorAll('#heroPrioritySelect .priority-option');
            priorityOptions.forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.priority === 'medium') {
                    opt.classList.add('selected');
                }
            });

            // Reset tags
            heroTaskTags = [];
            const tagsContainer = document.getElementById('heroTagsContainer');
            if (tagsContainer) {
                tagsContainer.querySelectorAll('.task-tag').forEach(el => el.remove());
            }

            // Reset collaborators
            heroCollaborators = [];
            renderCollaboratorAvatars();

            // Hide role context display and required notice
            if (document.getElementById('roleContextDisplay')) {
                document.getElementById('roleContextDisplay').style.display = 'none';
            }
            if (document.getElementById('roleRequiredNotice')) {
                document.getElementById('roleRequiredNotice').style.display = 'none';
            }

            // Hide inline create forms
            document.getElementById('heroWorkflowCreate').classList.remove('active');
            if (document.getElementById('heroRoleCreate')) document.getElementById('heroRoleCreate').classList.remove('active');
            if (document.getElementById('heroRoleCreateMain')) document.getElementById('heroRoleCreateMain').classList.remove('active');
            document.getElementById('heroPersonCreate').classList.remove('active');

            // Reset advanced options to collapsed state
            document.getElementById('heroAdvancedOptions').style.display = 'none';
            document.getElementById('heroAdvancedToggle').classList.remove('expanded');
            document.getElementById('heroAdvancedToggleText').textContent = 'More options...';
        }

        // Close on backdrop click
        function closeHeroTaskModalOnBackdrop(event) {
            if (event.target === event.currentTarget) {
                closeHeroTaskModal();
            }
        }

        // Toggle advanced options visibility
        function toggleAdvancedOptions() {
            const advancedOptions = document.getElementById('heroAdvancedOptions');
            const toggleBtn = document.getElementById('heroAdvancedToggle');
            const toggleText = document.getElementById('heroAdvancedToggleText');

            if (advancedOptions.style.display === 'none') {
                advancedOptions.style.display = 'block';
                toggleBtn.classList.add('expanded');
                toggleText.textContent = 'Fewer options';
            } else {
                advancedOptions.style.display = 'none';
                toggleBtn.classList.remove('expanded');
                toggleText.textContent = 'More options...';
            }
        }

        // Populate role and person selects in hero modal
        function populateHeroSelects() {
            const roleSelect = document.getElementById('heroTaskRole');
            const roleSelectMain = document.getElementById('heroTaskRoleMain'); // Main required role selector
            const personSelect = document.getElementById('heroTaskPerson');
            const predecessorSelect = document.getElementById('heroTaskPredecessor');
            const workflowSelect = document.getElementById('heroTaskWorkflow');
            const workflowPrompt = document.getElementById('heroWorkflowPrompt');

            // Clear existing options (except first)
            if (roleSelect) roleSelect.innerHTML = '<option value="">Select a role...</option>';
            if (roleSelectMain) roleSelectMain.innerHTML = '<option value="">Select a role...</option>';
            personSelect.innerHTML = '<option value="">Select a person...</option>';
            predecessorSelect.innerHTML = '<option value="">No dependency...</option>';
            workflowSelect.innerHTML = '<option value="">Select a workflow...</option>';

            // Add workflows
            const workflows = entities.workflow || [];
            workflows.forEach(workflow => {
                const option = document.createElement('option');
                option.value = workflow.id;
                option.textContent = workflow.name;
                workflowSelect.appendChild(option);
            });

            // Show prompt if no workflows exist
            if (workflows.length === 0) {
                workflowPrompt.style.display = 'flex';
            } else {
                workflowPrompt.style.display = 'none';
            }

            // Add roles to both selectors using hierarchical structure
            const roleHierarchy = buildRoleHierarchyStructure();

            // Helper to add role options
            const addRoleOption = (selectEl, role, indent = '') => {
                const option = document.createElement('option');
                option.value = role.id;
                option.textContent = indent + role.name;
                selectEl.appendChild(option);
            };

            // Populate hierarchical role options
            const populateRoleSelect = (selectEl, showHierarchy = false) => {
                if (!selectEl) return;

                // Add units with their teams and roles
                roleHierarchy.units.forEach(unit => {
                    const unitGroup = document.createElement('optgroup');
                    unitGroup.label = `📦 ${unit.name}`;

                    unit.teams.forEach(team => {
                        // Add team as a disabled option header within unit
                        const teamOption = document.createElement('option');
                        teamOption.disabled = true;
                        teamOption.textContent = `  👥 ${team.name}`;
                        teamOption.style.fontWeight = '600';
                        teamOption.style.color = '#666';
                        unitGroup.appendChild(teamOption);

                        // Add roles under team
                        team.roles.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = `      ${role.name}`;
                            unitGroup.appendChild(option);
                        });
                    });

                    if (unitGroup.children.length > 0) {
                        selectEl.appendChild(unitGroup);
                    }
                });

                // Add orphan teams (teams not in any unit)
                roleHierarchy.orphanTeams.forEach(team => {
                    const teamGroup = document.createElement('optgroup');
                    teamGroup.label = `👥 ${team.name}`;

                    team.roles.forEach(role => {
                        const option = document.createElement('option');
                        option.value = role.id;
                        option.textContent = `  ${role.name}`;
                        teamGroup.appendChild(option);
                    });

                    selectEl.appendChild(teamGroup);
                });

                // Add orphan roles (roles not in any team)
                if (roleHierarchy.orphanRoles.length > 0) {
                    const hasHierarchy = roleHierarchy.units.length > 0 || roleHierarchy.orphanTeams.length > 0;

                    if (hasHierarchy) {
                        const otherGroup = document.createElement('optgroup');
                        otherGroup.label = 'Other Roles';
                        roleHierarchy.orphanRoles.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = role.name;
                            otherGroup.appendChild(option);
                        });
                        selectEl.appendChild(otherGroup);
                    } else {
                        // No hierarchy - just add roles directly
                        roleHierarchy.orphanRoles.forEach(role => {
                            const option = document.createElement('option');
                            option.value = role.id;
                            option.textContent = role.name;
                            selectEl.appendChild(option);
                        });
                    }
                }
            };

            // Populate both role selectors
            populateRoleSelect(roleSelect, false);
            populateRoleSelect(roleSelectMain, true);

            // Add people
            (entities.person || []).forEach(person => {
                const option = document.createElement('option');
                option.value = person.id;
                option.textContent = person.name;
                personSelect.appendChild(option);
            });

            // Add existing tasks as potential predecessors
            const tasks = entities.task || [];
            tasks.forEach(task => {
                const option = document.createElement('option');
                option.value = task.id;
                option.textContent = task.name + (task.dueDate ? ` (due: ${formatDateShort(task.dueDate)})` : '');
                predecessorSelect.appendChild(option);
            });
        }

        // Parse date string to local Date object (avoids timezone issues)
        // dateStr is expected in YYYY-MM-DD format
        function parseLocalDate(dateStr) {
            if (!dateStr) return null;
            const parts = dateStr.split('T')[0].split('-');
            const year = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // JS months are 0-indexed
            const day = parseInt(parts[2], 10);
            return new Date(year, month, day);
        }

        // Format date for display
        function formatDateShort(dateStr) {
            if (!dateStr) return '';
            const date = parseLocalDate(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // Get task due date status for styling
        function getTaskDueDateStatus(task) {
            if (!task.dueDate) return '';
            if (task.status === 'completed') return 'completed';

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const dueDate = parseLocalDate(task.dueDate);
            const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));

            if (diffDays < 0) return 'overdue';
            if (diffDays === 0) return 'due-today';
            if (diffDays <= 3) return 'due-soon';
            return '';
        }

        // Check if a date string is today
        function isToday(dateStr) {
            if (!dateStr) return false;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const date = parseLocalDate(dateStr);
            return date.getTime() === today.getTime();
        }

        // Check if a date string is tomorrow
        function isTomorrow(dateStr) {
            if (!dateStr) return false;
            const tomorrow = new Date();
            tomorrow.setHours(0, 0, 0, 0);
            tomorrow.setDate(tomorrow.getDate() + 1);
            const date = parseLocalDate(dateStr);
            return date.getTime() === tomorrow.getTime();
        }

        // Render task-specific modal info section - Simplified version
        function renderTaskModalInfo(task) {
            const dueDateStatus = getTaskDueDateStatus(task);

            // Get predecessor task
            const predecessor = task.predecessorId ? entities.task.find(t => t.id === task.predecessorId) : null;

            // Get dependent tasks (tasks that depend on this one)
            const dependents = entities.task.filter(t => t.predecessorId === task.id);

            // Get linked tasks (from emergent workflow system)
            const linkedTasksData = getTaskLinks(task.id).map(link => {
                const linkedId = link.sourceTaskId === task.id ? link.targetTaskId : link.sourceTaskId;
                const linkedTask = entities.task.find(t => t.id === linkedId);
                return linkedTask ? { task: linkedTask, link } : null;
            }).filter(Boolean);

            // Get violations for this task
            const violations = getTaskViolations(task.id);

            // Get connected roles through relationships
            const connectedRoles = relationships
                .filter(r => (r.subject === task.id || r.object === task.id) && r.predicate !== 'DES')
                .map(r => {
                    const otherId = r.subject === task.id ? r.object : r.subject;
                    return findEntity(otherId);
                })
                .filter(e => e && e.type === 'role');

            // Format due date display
            let dueDateDisplay = 'Set date';
            if (task.dueDate) {
                const date = parseLocalDate(task.dueDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const diffDays = Math.ceil((date - today) / (1000 * 60 * 60 * 24));
                dueDateDisplay = formatDateShort(task.dueDate);
                if (task.status !== 'completed') {
                    if (diffDays < 0) {
                        dueDateDisplay += ` (${Math.abs(diffDays)}d overdue)`;
                    } else if (diffDays === 0) {
                        dueDateDisplay += ' (today)';
                    } else if (diffDays <= 3) {
                        dueDateDisplay += ` (${diffDays}d)`;
                    }
                }
            }

            // Get status display info
            const statusInfo = {
                pending: { label: 'To Do', icon: 'ph-circle-dashed', class: 'status-pending' },
                in_progress: { label: 'In Progress', icon: 'ph-spinner', class: 'status-in-progress' },
                completed: { label: 'Done', icon: 'ph-check-circle', class: 'status-completed' }
            };
            const currentStatus = statusInfo[task.status] || statusInfo.pending;

            // Count subtasks
            const subtasks = entities.task.filter(t => t.parentTaskId === task.id);
            const completedSubtasks = subtasks.filter(t => t.status === 'completed').length;

            // Count dependencies
            const dependencyCount = (predecessor ? 1 : 0) + dependents.length;

            // Count comments
            const comments = (task.comments || []);

            return `
                <div class="simple-task-modal">
                    <!-- Violations Alert (only shown when needed) -->
                    ${violations.length > 0 ? `
                    <div style="background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 8px; padding: 12px; margin-bottom: 16px; display: flex; align-items: center; gap: 10px;">
                        <i class="ph ph-warning" style="color: #D97706; font-size: 18px;"></i>
                        <span style="flex: 1; font-size: 13px; color: #92400E;">${violations[0].message}</span>
                        <button onclick="showViolationReconciliation('${task.id}')" style="background: #D97706; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;">
                            Reconcile
                        </button>
                    </div>
                    ` : ''}

                    <!-- Simplified Meta Bar with Chips -->
                    <div class="simple-task-meta-bar">
                        <!-- Status Chip with Dropdown -->
                        <div style="position: relative;" id="statusChipWrapper_${task.id}">
                            <div class="simple-task-chip filled ${currentStatus.class}" onclick="toggleSimpleTaskStatusDropdown('${task.id}')">
                                <i class="ph ${currentStatus.icon}"></i>
                                <span>${currentStatus.label}</span>
                            </div>
                            <div class="simple-task-status-dropdown" id="statusDropdown_${task.id}">
                                <div class="simple-task-status-option pending" onclick="updateTaskStatus('${task.id}', 'pending'); closeSimpleTaskStatusDropdown('${task.id}');">
                                    <i class="ph ph-circle-dashed"></i> To Do
                                </div>
                                <div class="simple-task-status-option in-progress" onclick="updateTaskStatus('${task.id}', 'in_progress'); closeSimpleTaskStatusDropdown('${task.id}');">
                                    <i class="ph ph-spinner"></i> In Progress
                                </div>
                                <div class="simple-task-status-option completed" onclick="updateTaskStatus('${task.id}', 'completed'); closeSimpleTaskStatusDropdown('${task.id}');">
                                    <i class="ph ph-check-circle"></i> Done
                                </div>
                            </div>
                        </div>

                        <!-- Date Chip -->
                        <div class="simple-task-chip ${task.dueDate ? 'filled' : 'empty'}" onclick="toggleTaskDatePicker('${task.id}')" style="position: relative;" id="taskDateBtn_${task.id}">
                            <i class="ph ph-calendar"></i>
                            <span>${dueDateDisplay}</span>
                            <div class="date-picker-popup" id="taskDatePicker_${task.id}">
                                <div class="date-quick-options">
                                    <div class="date-option" onclick="event.stopPropagation(); setTaskDueDate('${task.id}', 'today')">Today</div>
                                    <div class="date-option" onclick="event.stopPropagation(); setTaskDueDate('${task.id}', 'tomorrow')">Tomorrow</div>
                                    <div class="date-option" onclick="event.stopPropagation(); setTaskDueDate('${task.id}', 'thisweek')">This Week</div>
                                    <div class="date-option" onclick="event.stopPropagation(); setTaskDueDate('${task.id}', 'nextweek')">Next Week</div>
                                    <div class="date-option" onclick="event.stopPropagation(); setTaskDueDate('${task.id}', 'nextmonth')">Next Month</div>
                                    <div class="date-option" onclick="event.stopPropagation(); setTaskDueDate('${task.id}', 'none')">No Date</div>
                                </div>
                                <div class="date-picker-custom" onclick="event.stopPropagation();">
                                    <input type="text"
                                           id="customDate_${task.id}"
                                           placeholder="Pick a specific date..."
                                           value="${task.dueDate || ''}"
                                           onfocus="initTaskDatePicker('${task.id}')"
                                           readonly>
                                </div>
                            </div>
                        </div>

                        <!-- Priority Chip -->
                        <div class="simple-task-chip filled priority-${task.priority || 'medium'}" onclick="cycleTaskPriority('${task.id}')" title="Click to change priority">
                            <i class="ph ph-flag"></i>
                            <span>${(task.priority || 'medium').charAt(0).toUpperCase() + (task.priority || 'medium').slice(1)}</span>
                        </div>

                        <!-- Role Chip -->
                        <div class="simple-task-chip ${connectedRoles.length ? 'filled' : 'empty'}" ${connectedRoles.length ? `onclick="openEntityModal('${connectedRoles[0].id}', 'role')"` : `onclick="showToast('Use Edit button to assign role', 'info')"`}>
                            <i class="ph ph-briefcase"></i>
                            <span>${connectedRoles.length ? connectedRoles[0].name : 'Assign role'}</span>
                        </div>
                    </div>

                    <!-- Quick Date Buttons -->
                    <div class="quick-date-section">
                        <span class="quick-date-label">Quick set deadline:</span>
                        <div class="quick-date-buttons">
                            <button class="quick-date-btn ${isToday(task.dueDate) ? 'active' : ''}" onclick="setTaskDueDate('${task.id}', 'today')">
                                <i class="ph ph-sun"></i> Today
                            </button>
                            <button class="quick-date-btn ${isTomorrow(task.dueDate) ? 'active' : ''}" onclick="setTaskDueDate('${task.id}', 'tomorrow')">
                                <i class="ph ph-sun-horizon"></i> Tomorrow
                            </button>
                            <button class="quick-date-btn" onclick="setTaskDueDate('${task.id}', 'nextweek')">
                                <i class="ph ph-calendar-plus"></i> +1 Week
                            </button>
                            <button class="quick-date-btn" onclick="openInlineFlatpickr('${task.id}', event)">
                                <i class="ph ph-calendar-blank"></i> Pick...
                            </button>
                            ${task.dueDate ? `
                            <button class="quick-date-btn" onclick="setTaskDueDate('${task.id}', 'none')" title="Clear date">
                                <i class="ph ph-x"></i>
                            </button>
                            ` : ''}
                        </div>
                    </div>

                    <!-- Editable Description -->
                    <div class="simple-task-description">
                        <textarea
                            class="simple-task-description-field"
                            id="simpleTaskDescription_${task.id}"
                            placeholder="Add notes or details about this task..."
                            onblur="saveSimpleTaskDescription('${task.id}')"
                        >${task.description || ''}</textarea>
                    </div>

                    <!-- Option Links for Additional Features -->
                    <div class="simple-task-options">
                        <!-- Subtasks Link -->
                        <div class="simple-task-option-link" onclick="toggleSimpleTaskSection('subtasks_${task.id}')">
                            <div class="simple-task-option-text">
                                <i class="ph ph-list-checks"></i>
                                <span>Subtasks</span>
                                ${subtasks.length > 0 ? `<span class="simple-task-option-badge">${completedSubtasks}/${subtasks.length}</span>` : ''}
                            </div>
                            <span class="simple-task-option-arrow"><i class="ph ph-caret-right"></i></span>
                        </div>
                        <div class="simple-task-expanded-section" id="subtasks_${task.id}" style="display: none;">
                            ${renderSubtasksSection(task.id)}
                        </div>

                        <!-- Dependencies Link -->
                        <div class="simple-task-option-link" onclick="toggleSimpleTaskSection('deps_${task.id}')">
                            <div class="simple-task-option-text">
                                <i class="ph ph-git-branch"></i>
                                <span>Dependencies</span>
                                ${dependencyCount > 0 ? `<span class="simple-task-option-badge">${dependencyCount}</span>` : ''}
                            </div>
                            <span class="simple-task-option-arrow"><i class="ph ph-caret-right"></i></span>
                        </div>
                        <div class="simple-task-expanded-section" id="deps_${task.id}" style="display: none;">
                            ${predecessor || dependents.length > 0 ? `
                                ${predecessor ? `
                                <div style="margin-bottom: 12px;">
                                    <div style="font-size: 11px; color: #888; text-transform: uppercase; margin-bottom: 6px;">Blocked by</div>
                                    <div class="task-dep-item ${predecessor.status === 'completed' ? 'completed' : ''}" onclick="openEntityModal('${predecessor.id}', 'task')">
                                        <div class="dep-checkbox ${predecessor.status === 'completed' ? 'completed' : ''}">
                                            ${predecessor.status === 'completed' ? '<i class="ph ph-check"></i>' : ''}
                                        </div>
                                        <span class="dep-name">${predecessor.name}</span>
                                    </div>
                                </div>
                                ` : ''}
                                ${dependents.length > 0 ? `
                                <div>
                                    <div style="font-size: 11px; color: #888; text-transform: uppercase; margin-bottom: 6px;">Blocking (${dependents.length})</div>
                                    ${dependents.map(dep => `
                                        <div class="task-dep-item ${dep.status === 'completed' ? 'completed' : ''}" onclick="openEntityModal('${dep.id}', 'task')" style="margin-bottom: 6px;">
                                            <div class="dep-checkbox ${dep.status === 'completed' ? 'completed' : ''}">
                                                ${dep.status === 'completed' ? '<i class="ph ph-check"></i>' : ''}
                                            </div>
                                            <span class="dep-name">${dep.name}</span>
                                        </div>
                                    `).join('')}
                                </div>
                                ` : ''}
                            ` : `
                            <div style="text-align: center; color: #888; font-size: 13px; padding: 8px;">
                                No dependencies set
                            </div>
                            `}
                        </div>

                        <!-- Related Tasks Link -->
                        <div class="simple-task-option-link" onclick="toggleSimpleTaskSection('related_${task.id}')">
                            <div class="simple-task-option-text">
                                <i class="ph ph-link"></i>
                                <span>Related tasks</span>
                                ${linkedTasksData.length > 0 ? `<span class="simple-task-option-badge">${linkedTasksData.length}</span>` : ''}
                            </div>
                            <span class="simple-task-option-arrow"><i class="ph ph-caret-right"></i></span>
                        </div>
                        <div class="simple-task-expanded-section" id="related_${task.id}" style="display: none;">
                            ${linkedTasksData.length > 0 ? `
                                ${linkedTasksData.map(({ task: lt, link }) => `
                                    <div class="task-dep-item ${lt.status === 'completed' ? 'completed' : ''}" onclick="openEntityModal('${lt.id}', 'task')" style="margin-bottom: 6px;">
                                        <div class="dep-checkbox ${lt.status === 'completed' ? 'completed' : ''}">
                                            ${lt.status === 'completed' ? '<i class="ph ph-check"></i>' : ''}
                                        </div>
                                        <span class="dep-name">${lt.name}</span>
                                    </div>
                                `).join('')}
                                <button onclick="event.stopPropagation(); openTaskLinkModal('${task.id}')" style="background: #f5f5f5; color: #666; border: 1px dashed #ddd; padding: 8px 12px; border-radius: 6px; font-size: 13px; cursor: pointer; width: 100%; margin-top: 8px;">
                                    <i class="ph ph-plus"></i> Link another task
                                </button>
                            ` : `
                            <div style="text-align: center; padding: 8px;">
                                <button onclick="event.stopPropagation(); openTaskLinkModal('${task.id}')" style="background: #f5f5f5; color: #666; border: 1px dashed #ddd; padding: 8px 16px; border-radius: 6px; font-size: 13px; cursor: pointer;">
                                    <i class="ph ph-plus"></i> Link a task
                                </button>
                            </div>
                            `}
                        </div>

                        <!-- Comments Link -->
                        <div class="simple-task-option-link" onclick="toggleSimpleTaskSection('comments_${task.id}')">
                            <div class="simple-task-option-text">
                                <i class="ph ph-chat-circle"></i>
                                <span>Comments</span>
                                ${comments.length > 0 ? `<span class="simple-task-option-badge">${comments.length}</span>` : ''}
                            </div>
                            <span class="simple-task-option-arrow"><i class="ph ph-caret-right"></i></span>
                        </div>
                        <div class="simple-task-expanded-section" id="comments_${task.id}" style="display: none;">
                            ${renderTaskComments(task.id)}
                        </div>
                    </div>
                </div>
            `;
        }

        // Toggle simple task section visibility
        function toggleSimpleTaskSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                const isHidden = section.style.display === 'none';
                section.style.display = isHidden ? 'block' : 'none';
                // Update arrow direction
                const link = section.previousElementSibling;
                if (link) {
                    const arrow = link.querySelector('.simple-task-option-arrow i');
                    if (arrow) {
                        arrow.className = isHidden ? 'ph ph-caret-down' : 'ph ph-caret-right';
                    }
                }
            }
        }

        // Toggle status dropdown
        function toggleSimpleTaskStatusDropdown(taskId) {
            const dropdown = document.getElementById(`statusDropdown_${taskId}`);
            if (dropdown) {
                dropdown.classList.toggle('show');
            }
        }

        // Close status dropdown
        function closeSimpleTaskStatusDropdown(taskId) {
            const dropdown = document.getElementById(`statusDropdown_${taskId}`);
            if (dropdown) {
                dropdown.classList.remove('show');
            }
        }

        // Save description from simple task modal
        function saveSimpleTaskDescription(taskId) {
            const textarea = document.getElementById(`simpleTaskDescription_${taskId}`);
            if (!textarea) return;

            const task = entities.task.find(t => t.id === taskId);
            if (!task) return;

            const newDescription = textarea.value.trim();
            const oldDescription = task.description || '';

            if (newDescription !== oldDescription) {
                // Track in undo history before making changes
                pushToUndoHistory({
                    type: 'update_entity',
                    entityType: 'task',
                    data: { id: task.id },
                    oldData: { description: oldDescription },
                    description: `Edit description: ${task.name}`
                });

                task.description = newDescription;
                saveData();

                // Log to Xano with full history tracking
                logActivityToXano({
                    event_verb: 'Update Description',
                    eo_operator: 'ALT',
                    object_type: 'task',
                    object_id: taskId,
                    object_label: task.name,
                    data_json: {
                        field: 'description',
                        old_value: oldDescription,
                        new_value: newDescription
                    }
                });

                showToast('Description saved', 'success');
            }
        }

        // Show violation reconciliation dialog
        function showViolationReconciliation(taskId) {
            const violations = getTaskViolations(taskId);
            if (violations.length === 0) return;

            const violation = violations[0];
            const template = workflowTemplates.find(t => t.id === violation.workflowTemplateId);
            const owner = getWorkflowOwner(violation.workflowTemplateId);

            const message = `This task doesn't match the workflow rules.

${violation.message}

${owner ? `Workflow created by: ${owner.name || 'Unknown'}` : ''}

Options:
• Adjust your task to fit the workflow rules
• Request an exception from the workflow owner
• Propose a change to the workflow`;

            if (confirm(message + '\n\nClick OK to grant an exception for this task.')) {
                resolveViolation(violation.id, 'exception_granted', 'Exception granted by user');
                showToast('Exception granted for this task', 'success');
                openEntityModal(taskId, 'task');
            }
        }

        // ========================================
        // Task Movement Confirmation System
        // ========================================

        let pendingTaskMove = null; // Stores pending move info: { taskId, newStatus, callback }

        function getStatusLabel(status) {
            return status === 'completed' ? 'Done' : (status === 'in_progress' ? 'In Progress' : 'To Do');
        }

        function getStatusOrder(status) {
            const order = { 'pending': 0, 'in_progress': 1, 'completed': 2 };
            return order[status] ?? 0;
        }

        // Check if task movement needs confirmation and return warning info
        function checkTaskMoveWarning(taskId, newStatus) {
            const task = entities.task.find(t => t.id === taskId);
            if (!task) return null;

            const newStatusOrder = getStatusOrder(newStatus);
            const warnings = [];

            // Check 1: Subtask moving beyond parent's status
            if (task.predecessorId) {
                const parent = entities.task.find(t => t.id === task.predecessorId);
                if (parent) {
                    const parentStatusOrder = getStatusOrder(parent.status);
                    if (newStatusOrder > parentStatusOrder) {
                        warnings.push({
                            type: 'subtask_ahead',
                            message: `Parent task "${parent.name}" is still "${getStatusLabel(parent.status)}".`
                        });
                    }
                }
            }

            // Check 2: Parent moving to Done with incomplete subtasks
            const subtasks = entities.task.filter(t => t.predecessorId === taskId);
            if (subtasks.length > 0 && newStatus === 'completed') {
                const incompleteSubtasks = subtasks.filter(t => t.status !== 'completed');
                if (incompleteSubtasks.length > 0) {
                    warnings.push({
                        type: 'incomplete_subtasks',
                        count: incompleteSubtasks.length,
                        message: `This task has ${incompleteSubtasks.length} incomplete subtask${incompleteSubtasks.length > 1 ? 's' : ''}.`
                    });
                }
            }

            return warnings.length > 0 ? warnings : null;
        }

        function showTaskConfirmModal(title, message, callback) {
            document.getElementById('taskConfirmTitle').textContent = title;
            document.getElementById('taskConfirmText').innerHTML = message;
            document.getElementById('taskConfirmModal').classList.add('active');
            pendingTaskMove = { callback };
        }

        function closeTaskConfirmModal() {
            document.getElementById('taskConfirmModal').classList.remove('active');
            pendingTaskMove = null;
        }

        function confirmTaskMove() {
            if (pendingTaskMove && pendingTaskMove.callback) {
                pendingTaskMove.callback();
            }
            closeTaskConfirmModal();
        }

        // Actually perform the task status update (no confirmation)
        function executeTaskStatusUpdate(taskId, newStatus, refreshModal = true) {
            const task = entities.task.find(t => t.id === taskId);
            if (!task) return;

            // Capture old value for history tracking
            const oldStatus = task.status || 'pending';

            // Only proceed if status actually changed
            if (oldStatus === newStatus) return;

            // Track in undo history before making changes
            pushToUndoHistory({
                type: 'update_entity',
                entityType: 'task',
                data: { id: task.id },
                oldData: { status: oldStatus },
                description: `Change status: ${task.name}`
            });

            task.status = newStatus;
            saveData();

            // Log activity with full history tracking
            logActivityToXano({
                event_verb: 'Update Status',
                eo_operator: 'ALT',
                object_type: 'task',
                object_id: taskId,
                object_label: task.name,
                data_json: {
                    field: 'status',
                    old_value: oldStatus,
                    new_value: newStatus,
                    old_display: getStatusLabel(oldStatus),
                    new_display: getStatusLabel(newStatus)
                }
            });

            // Re-render the modal to update the UI
            if (refreshModal) {
                openEntityModal(taskId, 'task');
            }

            // Update task board if visible
            if (document.getElementById('taskBoardView')?.classList.contains('active')) {
                renderTaskBoard();
            }
        }

        // Update task status (with confirmation if needed)
        function updateTaskStatus(taskId, newStatus) {
            const task = entities.task.find(t => t.id === taskId);
            if (!task) return;

            const warnings = checkTaskMoveWarning(taskId, newStatus);

            if (warnings) {
                const warningMessages = warnings.map(w => w.message).join('<br><br>');
                const title = `Move to "${getStatusLabel(newStatus)}"?`;
                showTaskConfirmModal(title, warningMessages, () => {
                    executeTaskStatusUpdate(taskId, newStatus);
                });
            } else {
                executeTaskStatusUpdate(taskId, newStatus);
            }
        }

        // Render role work dashboard content - shows people, tasks, and workflows
        function renderRoleWorkContent(roleId) {
            const role = entities.role.find(r => r.id === roleId);
            if (!role) return '';

            // Get assigned people with their relationship IDs (INS relationships where role is the object)
            const assignedPeopleWithRels = relationships
                .filter(r => r.predicate === 'INS' && r.object === roleId)
                .map(r => ({ person: findEntity(r.subject), relationshipId: r.id }))
                .filter(item => item.person && item.person.type === 'person');

            const assignedPeople = assignedPeopleWithRels.map(item => item.person);
            const assignedPersonIds = assignedPeople.map(p => p.id);

            // Get unassigned people for the dropdown
            const unassignedPeople = entities.person.filter(p => !assignedPersonIds.includes(p.id));

            // Get connected tasks (CON relationships)
            const connectedTasks = relationships
                .filter(r => r.predicate === 'CON' && (r.subject === roleId || r.object === roleId))
                .map(r => {
                    const otherId = r.subject === roleId ? r.object : r.subject;
                    return findEntity(otherId);
                })
                .filter(e => e && e.type === 'task');

            // Get connected workflows
            const connectedWorkflows = relationships
                .filter(r => r.predicate === 'CON' && (r.subject === roleId || r.object === roleId))
                .map(r => {
                    const otherId = r.subject === roleId ? r.object : r.subject;
                    return findEntity(otherId);
                })
                .filter(e => e && e.type === 'workflow');

            // Calculate task stats
            const taskStats = {
                pending: connectedTasks.filter(t => t.status === 'pending').length,
                in_progress: connectedTasks.filter(t => t.status === 'in_progress').length,
                completed: connectedTasks.filter(t => t.status === 'completed').length
            };

            // Get other roles in the same workflows
            function getWorkflowRoles(workflowId) {
                return relationships
                    .filter(r => r.predicate === 'CON' && (r.subject === workflowId || r.object === workflowId))
                    .map(r => {
                        const otherId = r.subject === workflowId ? r.object : r.subject;
                        return findEntity(otherId);
                    })
                    .filter(e => e && e.type === 'role');
            }

            return `
                <div class="role-work-dashboard">
                    <!-- Assigned People Section -->
                    <div class="role-work-section">
                        <div class="role-work-section-header">
                            <div class="role-work-section-title">
                                <i class="ph ph-users"></i> Assigned People
                            </div>
                            <span class="role-work-count">${assignedPeople.length}</span>
                        </div>
                        ${assignedPeopleWithRels.length > 0 ? `
                            <div class="role-people-list">
                                ${assignedPeopleWithRels.map(item => `
                                    <div class="role-person-chip-with-remove">
                                        <div class="role-person-chip-content" onclick="openEntityModal('${item.person.id}', 'person')">
                                            <i class="ph ph-user"></i>
                                            ${item.person.name}
                                        </div>
                                        <button class="role-person-remove-btn" onclick="removePersonFromRole('${item.relationshipId}', event)" title="Remove from role">
                                            <i class="ph ph-x"></i>
                                        </button>
                                    </div>
                                `).join('')}
                            </div>
                        ` : `
                            <div class="role-empty-state">No one assigned to this role</div>
                        `}
                        <!-- Assign Person UI -->
                        <div class="role-assign-person-section">
                            <div class="role-assign-person-row">
                                <select id="roleModalPersonSelect" class="role-assign-person-select">
                                    <option value="">Select person...</option>
                                    ${unassignedPeople.map(person => `<option value="${person.id}">${person.name}</option>`).join('')}
                                </select>
                                <button class="role-assign-person-btn" onclick="assignPersonToRoleFromRoleModal()" ${unassignedPeople.length === 0 ? 'disabled' : ''}>
                                    <i class="ph ph-plus"></i> Assign
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Tasks Section -->
                    <div class="role-work-section">
                        <div class="role-work-section-header">
                            <div class="role-work-section-title">
                                <i class="ph ph-check-square"></i> Tasks
                            </div>
                            <span class="role-work-count">${connectedTasks.length}</span>
                        </div>
                        ${connectedTasks.length > 0 ? `
                            <div class="role-task-summary">
                                <div class="role-task-stat pending">
                                    <i class="ph ph-circle-dashed"></i>
                                    <span class="role-task-stat-count">${taskStats.pending}</span> pending
                                </div>
                                <div class="role-task-stat in_progress">
                                    <i class="ph ph-spinner"></i>
                                    <span class="role-task-stat-count">${taskStats.in_progress}</span> active
                                </div>
                                <div class="role-task-stat completed">
                                    <i class="ph ph-check-circle"></i>
                                    <span class="role-task-stat-count">${taskStats.completed}</span> done
                                </div>
                            </div>
                            <div class="role-task-list">
                                ${connectedTasks.map(task => {
                                    const statusIcon = task.status === 'completed' ? 'ph-check' :
                                                       task.status === 'in_progress' ? 'ph-spinner' : '';
                                    return `
                                    <div class="role-task-item" onclick="openEntityModal('${task.id}', 'task')">
                                        <div class="role-task-status ${task.status}">
                                            ${statusIcon ? `<i class="ph ${statusIcon}"></i>` : ''}
                                        </div>
                                        <div class="role-task-info">
                                            <div class="role-task-name">${task.name}</div>
                                            <div class="role-task-meta">
                                                ${renderInlineDatePicker(task.id, task.dueDate)}
                                            </div>
                                        </div>
                                    </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : `
                            <div class="role-empty-state">No tasks assigned to this role</div>
                        `}
                    </div>

                    <!-- Workflows Section -->
                    <div class="role-work-section">
                        <div class="role-work-section-header">
                            <div class="role-work-section-title">
                                <i class="ph ph-git-branch"></i> Workflows
                            </div>
                            <span class="role-work-count">${connectedWorkflows.length}</span>
                        </div>
                        ${connectedWorkflows.length > 0 ? `
                            <div class="role-workflow-list">
                                ${connectedWorkflows.map(workflow => {
                                    const workflowRoles = getWorkflowRoles(workflow.id);
                                    return `
                                    <div class="role-workflow-item" onclick="openEntityModal('${workflow.id}', 'workflow')">
                                        <div class="role-workflow-header">
                                            <i class="ph ph-git-branch"></i>
                                            <span class="role-workflow-name">${workflow.name}</span>
                                        </div>
                                        ${workflowRoles.length > 0 ? `
                                            <div class="role-workflow-roles">
                                                ${workflowRoles.map(r => `
                                                    <span class="role-workflow-role-chip ${r.id === roleId ? 'current' : ''}">${r.name}</span>
                                                `).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : `
                            <div class="role-empty-state">No workflows connected</div>
                        `}
                    </div>
                </div>
            `;
        }

        // Render simplified quick actions for task modal
        function renderTaskQuickActions(taskId) {
            const task = entities.task.find(t => t.id === taskId);
            if (!task) return '';

            // Get connected entities
            const connectedRoles = relationships
                .filter(r => (r.subject === taskId || r.object === taskId) && r.predicate !== 'DES')
                .map(r => {
                    const otherId = r.subject === taskId ? r.object : r.subject;
                    return findEntity(otherId);
                })
                .filter(e => e && e.type === 'role');

            return `
                <div class="task-quick-actions-panel">
                    <div class="modal-section-title" style="margin-bottom: 0.75rem;">
                        <i class="ph ph-lightning"></i> Quick Actions
                    </div>

                    <!-- Assign Role -->
                    <div class="task-quick-action-section">
                        <div class="task-quick-action-label">
                            <i class="ph ph-briefcase"></i> Assign Role
                        </div>
                        <div class="task-quick-action-row">
                            <select id="taskQuickRoleSelect" class="task-quick-select">
                                <option value="">Select role...</option>
                                ${entities.role.map(role => {
                                    const isConnected = connectedRoles.some(r => r.id === role.id);
                                    return `<option value="${role.id}" ${isConnected ? 'disabled' : ''}>${role.name}${isConnected ? ' (connected)' : ''}</option>`;
                                }).join('')}
                            </select>
                            <button class="task-quick-action-btn" onclick="assignRoleToTask('${taskId}')">
                                <i class="ph ph-plus"></i>
                            </button>
                        </div>
                        ${connectedRoles.length > 0 ? `
                        <div class="task-connected-list" style="margin-top: 0.5rem;">
                            ${connectedRoles.map(role => `
                                <div class="task-connected-item">
                                    <i class="ph ph-briefcase"></i>
                                    <span style="flex: 1;" onclick="openEntityModal('${role.id}', 'role')">${role.name}</span>
                                    <button class="connection-remove-btn" onclick="removeTaskRoleConnection('${taskId}', '${role.id}')" style="margin-left: auto;">
                                        <i class="ph ph-x"></i>
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                        ` : ''}
                    </div>

                    <!-- Add Predecessor -->
                    <div class="task-quick-action-section" style="margin-top: 1rem;">
                        <div class="task-quick-action-label">
                            <i class="ph ph-arrow-bend-left-up"></i> Add Dependency (Blocked By)
                        </div>
                        ${task.predecessorId ? `
                            <div class="task-connected-list">
                                ${(() => {
                                    const pred = entities.task.find(t => t.id === task.predecessorId);
                                    return pred ? `
                                        <div class="task-connected-item">
                                            <i class="ph ph-check-square"></i>
                                            <span style="flex: 1;" onclick="openEntityModal('${pred.id}', 'task')">${pred.name}</span>
                                            <button class="connection-remove-btn" onclick="removeTaskPredecessor('${taskId}')" style="margin-left: auto;">
                                                <i class="ph ph-x"></i>
                                            </button>
                                        </div>
                                    ` : '';
                                })()}
                            </div>
                        ` : `
                            <div class="task-quick-action-row">
                                <select id="taskQuickPredecessorSelect" class="task-quick-select">
                                    <option value="">Select task to depend on...</option>
                                    ${entities.task
                                        .filter(t => t.id !== taskId)
                                        .map(t => `<option value="${t.id}">${t.name}</option>`)
                                        .join('')}
                                </select>
                                <button class="task-quick-action-btn" onclick="setTaskPredecessor('${taskId}')">
                                    <i class="ph ph-plus"></i>
                                </button>
                            </div>
                        `}
                    </div>
                </div>

                <style>
                    .task-quick-actions-panel {
                        padding: 0;
                    }
                    .task-quick-action-section {
                        background: #FAF7F5;
                        border-radius: 8px;
                        padding: 1rem;
                    }
                    .task-quick-action-label {
                        font-size: 0.8rem;
                        font-weight: 600;
                        color: #6B5642;
                        margin-bottom: 0.5rem;
                        display: flex;
                        align-items: center;
                        gap: 0.375rem;
                    }
                    .task-quick-action-row {
                        display: flex;
                        gap: 0.5rem;
                    }
                    .task-quick-select {
                        flex: 1;
                        padding: 0.5rem 0.75rem;
                        border: 1px solid #E5DDD1;
                        border-radius: 6px;
                        font-size: 0.875rem;
                        background: white;
                    }
                    .task-quick-select:focus {
                        outline: none;
                        border-color: #C88F4A;
                    }
                    .task-quick-action-btn {
                        padding: 0.5rem 0.75rem;
                        background: #C88F4A;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                    .task-quick-action-btn:hover {
                        background: #B87D3A;
                    }
                </style>
            `;
        }

        // Assign role to task
        function assignRoleToTask(taskId) {
            const select = document.getElementById('taskQuickRoleSelect');
            const roleId = select?.value;
            if (!roleId) return;

            // Create CON relationship
            const relId = 'rel' + Date.now();
            relationships.push({
                id: relId,
                subject: taskId,
                predicate: 'CON',
                object: roleId,
                description: ''
            });

            saveData();
            openEntityModal(taskId, 'task');
        }

        // Remove role connection from task
        function removeTaskRoleConnection(taskId, roleId) {
            const relIndex = relationships.findIndex(r =>
                ((r.subject === taskId && r.object === roleId) ||
                 (r.subject === roleId && r.object === taskId)) &&
                r.predicate !== 'DES'
            );
            if (relIndex > -1) {
                relationships.splice(relIndex, 1);
                saveData();
                openEntityModal(taskId, 'task');
            }
        }

        // Set task predecessor
        function setTaskPredecessor(taskId) {
            const select = document.getElementById('taskQuickPredecessorSelect');
            const predecessorId = select?.value;
            if (!predecessorId) return;

            const task = entities.task.find(t => t.id === taskId);
            if (task) {
                task.predecessorId = predecessorId;
                saveData();
                openEntityModal(taskId, 'task');
            }
        }

        // Remove task predecessor
        function removeTaskPredecessor(taskId) {
            const task = entities.task.find(t => t.id === taskId);
            if (task) {
                task.predecessorId = null;
                saveData();
                openEntityModal(taskId, 'task');
            }
        }

        // Get dependent tasks that would be affected by date change
        function getDependentTasksChain(taskId, visited = new Set()) {
            if (visited.has(taskId)) return [];
            visited.add(taskId);

            const dependents = entities.task.filter(t => t.predecessorId === taskId);
            let chain = [...dependents];

            dependents.forEach(dep => {
                chain = chain.concat(getDependentTasksChain(dep.id, visited));
            });

            return chain;
        }

        // Check for date conflicts with predecessor
        function checkPredecessorDateConflict() {
            const predecessorId = document.getElementById('heroTaskPredecessor').value;
            const dueDate = document.getElementById('heroTaskDueDate').value;
            const warningEl = document.getElementById('heroDependencyWarning');
            const warningText = document.getElementById('heroDependencyWarningText');

            if (!predecessorId || !dueDate) {
                warningEl.style.display = 'none';
                return;
            }

            const predecessor = entities.task.find(t => t.id === predecessorId);
            if (!predecessor || !predecessor.dueDate) {
                warningEl.style.display = 'none';
                return;
            }

            const predDate = parseLocalDate(predecessor.dueDate);
            const taskDate = parseLocalDate(dueDate);

            if (taskDate <= predDate) {
                warningEl.style.display = 'flex';
                warningText.textContent = `This task is due before or on the same day as "${predecessor.name}" (${formatDateShort(predecessor.dueDate)})`;
            } else {
                warningEl.style.display = 'none';
            }
        }

        // Toggle role inline create (legacy - kept for compatibility)
        function toggleHeroRoleCreate() {
            const createDiv = document.getElementById('heroRoleCreate');
            if (createDiv) {
                createDiv.classList.toggle('active');
                if (createDiv.classList.contains('active')) {
                    document.getElementById('heroNewRoleName')?.focus();
                }
            }
        }

        // Toggle main role inline create
        function toggleHeroRoleCreateMain() {
            const createDiv = document.getElementById('heroRoleCreateMain');
            createDiv.classList.toggle('active');
            if (createDiv.classList.contains('active')) {
                document.getElementById('heroNewRoleNameMain').focus();
            }
        }

        // Create new role from main section of hero modal
        function createHeroRoleMain() {
            const nameInput = document.getElementById('heroNewRoleNameMain');
            const name = nameInput.value.trim();

            if (!name) return;

            // Create role entity
            const roleId = 'role' + Date.now();
            const role = { id: roleId, name: name, type: 'role', description: '' };
            entities.role.push(role);

            logActivityToXano({
                event_verb: 'Add Entity',
                object_type: 'role',
                object_label: name
            });

            saveToLocalStorage();
            renderEntityList();

            // Refresh selects and select the new role
            populateHeroSelects();
            document.getElementById('heroTaskRoleMain').value = roleId;

            // Clear and hide inline create
            nameInput.value = '';
            document.getElementById('heroRoleCreateMain').classList.remove('active');

            updateHeroTaskPreview();
            updateRoleContext();
        }

        // ============================================
        // PRIORITY SELECTION
        // ============================================
        let selectedPriority = 'medium';

        function selectPriority(priority) {
            selectedPriority = priority;
            const options = document.querySelectorAll('#heroPrioritySelect .priority-option');
            options.forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.priority === priority) {
                    opt.classList.add('selected');
                }
            });
            updateHeroTaskPreview();
        }

        // ============================================
        // QUICK ADD BAR (Simplified Task Creation)
        // ============================================
        let quickAddPriority = 'medium';
        let quickAddSuggestionsVisible = false;

        function selectQuickAddPriority(priority) {
            quickAddPriority = priority;
            const dots = document.querySelectorAll('#quickAddPriorityDots .priority-dot');
            dots.forEach(dot => {
                dot.classList.remove('active');
                if (dot.dataset.priority === priority) {
                    dot.classList.add('active');
                }
            });
        }

        function handleQuickAddKeypress(event) {
            if (event.key === 'Enter') {
                const input = document.getElementById('quickAddInput');
                const taskName = input.value.trim();

                if (taskName) {
                    // Open modal with task name pre-filled instead of creating directly
                    openQuickAddModal(taskName);
                    input.value = '';
                    hideQuickAddSuggestions();
                }
            }
        }

        function handleQuickAddInput(event) {
            const input = event.target;
            const value = input.value;

            // Parse inline shortcuts
            parseInlineShortcuts(value);

            // Show suggestions on certain triggers
            if (value.includes('!') || value.includes('@') || value.includes('#')) {
                showQuickAddSuggestions();
            } else {
                hideQuickAddSuggestions();
            }
        }

        function parseInlineShortcuts(text) {
            // Priority shortcuts: ! = low, !! = high, !!! = urgent
            if (text.includes('!!!')) {
                selectQuickAddPriority('urgent');
            } else if (text.includes('!!')) {
                selectQuickAddPriority('high');
            } else if (text.includes('!') && !text.includes('!!')) {
                selectQuickAddPriority('low');
            }
        }

        function showQuickAddSuggestions() {
            const suggestions = document.getElementById('quickAddSuggestions');
            if (suggestions && !quickAddSuggestionsVisible) {
                suggestions.classList.add('show');
                quickAddSuggestionsVisible = true;
            }
        }

        function hideQuickAddSuggestions() {
            const suggestions = document.getElementById('quickAddSuggestions');
            if (suggestions) {
                suggestions.classList.remove('show');
                quickAddSuggestionsVisible = false;
            }
        }

        // ============================================
        // QUICK ADD MODAL FUNCTIONS
        // ============================================

        // State for the quick add modal
        let quickAddModalState = {
            taskName: '',
            dueDate: null,
            priority: 'medium',
            roleId: null,
            description: '',
            tags: []
        };

        function openQuickAddModal(rawTaskName) {
            // Parse shortcuts from the raw task name
            let taskName = rawTaskName;
            let dueDate = null;
            let tags = [];
            let priority = quickAddPriority; // Use priority from dots if selected

            // Extract and remove priority markers
            if (taskName.includes('!!!')) {
                priority = 'urgent';
            } else if (taskName.includes('!!')) {
                priority = 'high';
            } else if (taskName.includes('!') && !taskName.includes('!!')) {
                priority = 'low';
            }
            taskName = taskName.replace(/!!!/g, '').replace(/!!/g, '').replace(/!/g, '');

            // Extract @date shortcuts
            const dateMatch = taskName.match(/@(today|tomorrow|monday|tuesday|wednesday|thursday|friday|saturday|sunday|next\s*week)/i);
            if (dateMatch) {
                const dateStr = dateMatch[1].toLowerCase();
                dueDate = parseDateShortcut(dateStr);
                taskName = taskName.replace(/@\w+/gi, '');
            }

            // Extract #tags
            const tagMatches = taskName.match(/#(\w+)/g);
            if (tagMatches) {
                tags = tagMatches.map(t => t.replace('#', ''));
                taskName = taskName.replace(/#\w+/g, '');
            }

            taskName = taskName.trim();

            if (!taskName) {
                showToast('Task name is required', 'error');
                return;
            }

            // Initialize modal state - don't auto-assign role, require explicit selection
            quickAddModalState = {
                taskName: taskName,
                dueDate: dueDate,
                priority: priority,
                roleId: null,
                description: '',
                tags: tags
            };

            // Show the modal
            const overlay = document.getElementById('quickAddModalOverlay');
            overlay.classList.add('active');

            // Pre-fill the form
            document.getElementById('quickAddModalTitle').value = taskName;
            document.getElementById('quickAddModalDescription').value = '';

            // Update chips to reflect current state
            updateQuickAddModalChips();

            // Populate role dropdown
            populateQuickAddRoleOptions();

            // Focus on description field (task name is already filled)
            setTimeout(() => {
                document.getElementById('quickAddModalDescription').focus();
            }, 100);

            // Show a toast to guide the user
            showToast('Select a role to assign this task', 'info');
        }

        function closeQuickAddModal() {
            const overlay = document.getElementById('quickAddModalOverlay');
            overlay.classList.remove('active');

            // Close any open dropdowns
            hideAllQuickAddDropdowns();

            // Reset quick add priority dots to medium
            selectQuickAddPriority('medium');
        }

        function closeQuickAddModalOnBackdrop(event) {
            if (event.target === event.currentTarget) {
                saveQuickAddModal();
            }
        }

        function saveQuickAddModal() {
            // Get values from form
            const taskName = document.getElementById('quickAddModalTitle').value.trim();
            const description = document.getElementById('quickAddModalDescription').value.trim();

            if (!taskName) {
                showToast('Task name is required', 'error');
                return;
            }

            // Check if any roles exist for task assignment
            const roles = entities.role || [];
            if (roles.length === 0) {
                // Close modal and redirect to hero modal for role creation
                closeQuickAddModal();
                showToast('Create a role first to assign this task', 'info');
                document.getElementById('heroTaskName').value = taskName;
                openHeroTaskModal();
                return;
            }

            // Require explicit role selection
            if (!quickAddModalState.roleId) {
                showToast('Please select a role to assign this task', 'error');
                // Highlight the role chip to draw attention
                const roleChip = document.getElementById('quickAddRoleChip');
                roleChip.classList.add('error');
                setTimeout(() => roleChip.classList.remove('error'), 2000);
                toggleQuickAddRolePicker();
                return;
            }

            const roleId = quickAddModalState.roleId;

            // Create the task
            const taskId = 'task' + Date.now();
            const taskObject = {
                id: taskId,
                name: taskName,
                type: 'task',
                description: description,
                dueDate: quickAddModalState.dueDate,
                predecessorId: null,
                status: 'pending',
                priority: quickAddModalState.priority,
                tags: quickAddModalState.tags,
                collaborators: [],
                recurring: null,
                producesProductId: null,
                followsWorkflowId: null,
                createdAt: new Date().toISOString()
            };
            entities.task.push(taskObject);

            // Connect role to task (Role CON Task)
            const roleTaskRelId = 'rel' + (Date.now() + 1);
            const roleTaskRel = {
                id: roleTaskRelId,
                subject: roleId,
                predicate: 'CON',
                object: taskId,
                description: ''
            };
            relationships.push(roleTaskRel);

            // Log task creation activity
            logActivityToXano({
                event_verb: 'Add Entity',
                eo_operator: 'INS',
                object_type: 'task',
                object_id: taskId,
                object_label: taskName,
                data_json: {
                    entity_name: taskName,
                    description: description,
                    dueDate: quickAddModalState.dueDate,
                    status: 'pending',
                    priority: quickAddModalState.priority,
                    tags: quickAddModalState.tags
                }
            });

            // Log role-task relationship
            const role = entities.role.find(r => r.id === roleId);
            logActivityToXano({
                event_verb: 'Link Connection',
                eo_operator: 'CON',
                object_type: 'relationship',
                object_id: roleTaskRelId,
                object_label: `${role?.name || 'Role'} → ${taskName}`,
                data_json: {
                    subject_id: roleId,
                    predicate: 'CON',
                    target_id: taskId
                }
            });

            // Save to local storage
            saveToLocalStorage();

            // Close modal
            closeQuickAddModal();

            // Update the task board with animation
            if (document.getElementById('taskBoardView')?.classList.contains('active')) {
                renderTaskBoard();
                // Also refresh the current view (kanban, table, timeline, etc.)
                if (currentView === 'kanban') {
                    renderKanbanBoard();
                } else if (currentView === 'table') {
                    renderTaskTable();
                } else if (currentView === 'timeline') {
                    renderTimeline();
                } else if (currentView === 'gantt') {
                    renderGanttView();
                } else if (currentView === 'calendar') {
                    renderCalendarView();
                }

                // Add animation to the new card
                setTimeout(() => {
                    const newCard = document.querySelector(`.kanban-card[data-id="${taskId}"]`);
                    if (newCard) {
                        newCard.classList.add('new-task');
                        setTimeout(() => newCard.classList.remove('new-task'), 300);
                    }
                }, 50);
            }

            showToast('✓ Task saved!', 'success');
        }

        function updateQuickAddModalChips() {
            // Update date chip
            const dateChip = document.getElementById('quickAddDateChip');
            const dateLabel = document.getElementById('quickAddDateLabel');
            if (quickAddModalState.dueDate) {
                dateChip.classList.add('filled');
                dateLabel.textContent = formatDateForDisplay(quickAddModalState.dueDate);
            } else {
                dateChip.classList.remove('filled');
                dateLabel.textContent = 'Add due date';
            }

            // Update priority chip
            const priorityChip = document.getElementById('quickAddPriorityChip');
            const priorityLabel = document.getElementById('quickAddPriorityLabel');
            const priorityLabels = {
                low: 'Low',
                medium: 'Medium',
                high: 'High',
                urgent: 'Urgent'
            };
            if (quickAddModalState.priority && quickAddModalState.priority !== 'medium') {
                priorityChip.classList.add('filled');
                priorityLabel.textContent = priorityLabels[quickAddModalState.priority];
            } else {
                priorityChip.classList.remove('filled');
                priorityLabel.textContent = 'Set priority';
            }

            // Update role chip
            const roleChip = document.getElementById('quickAddRoleChip');
            const roleLabel = document.getElementById('quickAddRoleLabel');
            if (quickAddModalState.roleId) {
                const role = (entities.role || []).find(r => r.id === quickAddModalState.roleId);
                if (role) {
                    roleChip.classList.add('filled');
                    roleLabel.textContent = role.name;
                } else {
                    roleChip.classList.remove('filled');
                    roleLabel.textContent = 'Assign role';
                }
            } else {
                roleChip.classList.remove('filled');
                roleLabel.textContent = 'Assign role';
            }
        }

        function formatDateForDisplay(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            if (date.toDateString() === today.toDateString()) {
                return 'Today';
            } else if (date.toDateString() === tomorrow.toDateString()) {
                return 'Tomorrow';
            } else {
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            }
        }

        function hideAllQuickAddDropdowns() {
            document.getElementById('quickAddDateDropdown')?.classList.remove('show');
            document.getElementById('quickAddRoleDropdown')?.classList.remove('show');
        }

        function toggleQuickAddDatePicker() {
            const dropdown = document.getElementById('quickAddDateDropdown');
            const wasOpen = dropdown.classList.contains('show');
            hideAllQuickAddDropdowns();
            if (!wasOpen) {
                dropdown.classList.add('show');
            }
        }

        function setQuickAddDate(preset) {
            let dateStr = null;
            switch (preset) {
                case 'today':
                    dateStr = parseDateShortcut('today');
                    break;
                case 'tomorrow':
                    dateStr = parseDateShortcut('tomorrow');
                    break;
                case 'nextWeek':
                    dateStr = parseDateShortcut('next week');
                    break;
                case 'custom':
                    // Show the date input
                    const dateInput = document.getElementById('quickAddDateInput');
                    dateInput.style.display = 'block';
                    dateInput.focus();
                    dateInput.click();
                    return;
            }
            quickAddModalState.dueDate = dateStr;
            hideAllQuickAddDropdowns();
            updateQuickAddModalChips();
        }

        function setQuickAddCustomDate(dateValue) {
            if (dateValue) {
                quickAddModalState.dueDate = dateValue;
            }
            document.getElementById('quickAddDateInput').style.display = 'none';
            hideAllQuickAddDropdowns();
            updateQuickAddModalChips();
        }

        function cycleQuickAddPriority() {
            const priorities = ['medium', 'high', 'urgent', 'low'];
            const currentIndex = priorities.indexOf(quickAddModalState.priority);
            const nextIndex = (currentIndex + 1) % priorities.length;
            quickAddModalState.priority = priorities[nextIndex];
            updateQuickAddModalChips();
        }

        function toggleQuickAddRolePicker() {
            const dropdown = document.getElementById('quickAddRoleDropdown');
            const wasOpen = dropdown.classList.contains('show');
            hideAllQuickAddDropdowns();
            if (!wasOpen) {
                populateQuickAddRoleOptions();
                dropdown.classList.add('show');
            }
        }

        function populateQuickAddRoleOptions() {
            const container = document.getElementById('quickAddRoleOptions');
            const roles = entities.role || [];

            if (roles.length === 0) {
                container.innerHTML = `
                    <div class="quick-add-dropdown-item" style="color: #888; cursor: default;">
                        <i class="ph ph-info"></i> No roles yet
                    </div>
                `;
                return;
            }

            const hierarchy = buildRoleHierarchyStructure();
            const mostUsedTeamId = getMostUsedTeam();
            const mostUsedUnitId = mostUsedTeamId ? getUnitForTeam(mostUsedTeamId) : null;

            let html = '';

            // Render units with their teams and roles
            hierarchy.units.forEach(unit => {
                const isUnitExpanded = mostUsedUnitId === unit.id;
                html += `
                    <div class="role-hierarchy-section">
                        <div class="role-hierarchy-header ${isUnitExpanded ? 'expanded' : ''}"
                             data-section-id="${unit.id}" data-section-type="unit"
                             onclick="toggleRoleHierarchySection('${unit.id}', 'unit')">
                            <i class="ph ph-caret-right toggle-icon"></i>
                            <i class="ph ph-buildings header-icon"></i>
                            <span>${unit.name}</span>
                        </div>
                        <div class="role-hierarchy-content ${isUnitExpanded ? 'expanded' : ''}"
                             id="role-hierarchy-content-unit-${unit.id}">
                `;

                unit.teams.forEach(team => {
                    const isTeamExpanded = mostUsedTeamId === team.id;
                    html += `
                        <div class="role-hierarchy-team">
                            <div class="role-hierarchy-team-header ${isTeamExpanded ? 'expanded' : ''}"
                                 data-section-id="${team.id}" data-section-type="team"
                                 onclick="toggleRoleHierarchySection('${team.id}', 'team')">
                                <i class="ph ph-caret-right toggle-icon"></i>
                                <i class="ph ph-users-three header-icon"></i>
                                <span>${team.name}</span>
                            </div>
                            <div class="role-hierarchy-team-content ${isTeamExpanded ? 'expanded' : ''}"
                                 id="role-hierarchy-content-team-${team.id}">
                                <div class="role-hierarchy-roles">
                    `;

                    team.roles.forEach(role => {
                        html += `
                            <div class="quick-add-dropdown-item ${quickAddModalState.roleId === role.id ? 'selected' : ''}"
                                 onclick="selectQuickAddRole('${role.id}')">
                                <i class="ph ph-briefcase"></i> ${role.name}
                            </div>
                        `;
                    });

                    html += `
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            // Render orphan teams (teams not in any unit)
            hierarchy.orphanTeams.forEach(team => {
                const isTeamExpanded = mostUsedTeamId === team.id;
                html += `
                    <div class="role-hierarchy-section">
                        <div class="role-hierarchy-header ${isTeamExpanded ? 'expanded' : ''}"
                             data-section-id="${team.id}" data-section-type="team"
                             onclick="toggleRoleHierarchySection('${team.id}', 'team')">
                            <i class="ph ph-caret-right toggle-icon"></i>
                            <i class="ph ph-users-three header-icon"></i>
                            <span>${team.name}</span>
                        </div>
                        <div class="role-hierarchy-content ${isTeamExpanded ? 'expanded' : ''}"
                             id="role-hierarchy-content-team-${team.id}">
                            <div class="role-hierarchy-roles">
                `;

                team.roles.forEach(role => {
                    html += `
                        <div class="quick-add-dropdown-item ${quickAddModalState.roleId === role.id ? 'selected' : ''}"
                             onclick="selectQuickAddRole('${role.id}')">
                            <i class="ph ph-briefcase"></i> ${role.name}
                        </div>
                    `;
                });

                html += `
                            </div>
                        </div>
                    </div>
                `;
            });

            // Render orphan roles (roles not in any team) - always expanded
            if (hierarchy.orphanRoles.length > 0) {
                // If there's any hierarchy structure, add a header for orphan roles
                if (hierarchy.units.length > 0 || hierarchy.orphanTeams.length > 0) {
                    html += `<div class="role-hierarchy-orphan-header">Other Roles</div>`;
                }
                hierarchy.orphanRoles.forEach(role => {
                    html += `
                        <div class="quick-add-dropdown-item ${quickAddModalState.roleId === role.id ? 'selected' : ''}"
                             onclick="selectQuickAddRole('${role.id}')">
                            <i class="ph ph-briefcase"></i> ${role.name}
                        </div>
                    `;
                });
            }

            container.innerHTML = html;
        }

        function selectQuickAddRole(roleId) {
            quickAddModalState.roleId = roleId;
            hideAllQuickAddDropdowns();
            updateQuickAddModalChips();

            // Track team usage for "most used team" feature
            const teamId = getTeamForRole(roleId);
            if (teamId) {
                trackTeamUsage(teamId);
            }
        }

        // Add Escape key handler for quick add modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const quickAddOverlay = document.getElementById('quickAddModalOverlay');
                if (quickAddOverlay && quickAddOverlay.classList.contains('active')) {
                    e.preventDefault();
                    e.stopPropagation();
                    saveQuickAddModal();
                }
            }
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            const quickAddOverlay = document.getElementById('quickAddModalOverlay');
            if (quickAddOverlay && quickAddOverlay.classList.contains('active')) {
                // Check if click is outside any dropdown
                if (!e.target.closest('.quick-add-dropdown') && !e.target.closest('.quick-add-meta-chip')) {
                    hideAllQuickAddDropdowns();
                }
            }
        });

        function createQuickTask(rawTaskName) {
            // Parse out shortcuts from task name
            let taskName = rawTaskName;
            let dueDate = null;
            let tags = [];

            // Extract and remove priority markers
            taskName = taskName.replace(/!!!/g, '').replace(/!!/g, '').replace(/!/g, '');

            // Extract @date shortcuts
            const dateMatch = taskName.match(/@(today|tomorrow|monday|tuesday|wednesday|thursday|friday|saturday|sunday|next\s*week)/i);
            if (dateMatch) {
                const dateStr = dateMatch[1].toLowerCase();
                dueDate = parseDateShortcut(dateStr);
                taskName = taskName.replace(/@\w+/gi, '');
            }

            // Extract #tags
            const tagMatches = taskName.match(/#(\w+)/g);
            if (tagMatches) {
                tags = tagMatches.map(t => t.replace('#', ''));
                taskName = taskName.replace(/#\w+/g, '');
            }

            taskName = taskName.trim();

            if (!taskName) {
                showToast('Task name is required', 'error');
                return;
            }

            // Check if any roles exist
            const roles = entities.role || [];
            if (roles.length === 0) {
                // No roles exist - prompt to use full modal
                showToast('Create a role first to assign this task', 'info');
                document.getElementById('heroTaskName').value = taskName;
                openHeroTaskModal();
                return;
            }

            // Use the first role as default (for quick add)
            // In a production app, you might want to let users set a default role
            const defaultRole = roles[0];

            // Create the task
            const taskId = 'task' + Date.now();
            const taskObject = {
                id: taskId,
                name: taskName,
                type: 'task',
                description: '',
                dueDate: dueDate,
                predecessorId: null,
                status: 'pending',
                priority: quickAddPriority,
                tags: tags,
                collaborators: [],
                recurring: null,
                producesProductId: null,
                followsWorkflowId: null,
                createdAt: new Date().toISOString()
            };
            entities.task.push(taskObject);

            // Connect role to task (Role CON Task)
            const roleTaskRel = {
                id: 'rel' + (Date.now() + 1),
                subject: defaultRole.id,
                predicate: 'CON',
                object: taskId,
                description: ''
            };
            relationships.push(roleTaskRel);

            // Log activity
            logActivityToXano({
                event_verb: 'Add Entity',
                object_type: 'task',
                object_label: taskName
            });

            // Save to local storage
            saveToLocalStorage();

            // Reset quick add priority to medium
            selectQuickAddPriority('medium');

            // Update the task board with animation
            if (document.getElementById('taskBoardView')?.classList.contains('active')) {
                renderTaskBoard();
                // Also refresh the current view (kanban, table, timeline, etc.)
                if (currentView === 'kanban') {
                    renderKanbanBoard();
                } else if (currentView === 'table') {
                    renderTaskTable();
                } else if (currentView === 'timeline') {
                    renderTimeline();
                } else if (currentView === 'gantt') {
                    renderGanttView();
                } else if (currentView === 'calendar') {
                    renderCalendarView();
                }

                // Add animation to the new card
                setTimeout(() => {
                    const newCard = document.querySelector(`.kanban-card[data-id="${taskId}"]`);
                    if (newCard) {
                        newCard.classList.add('new-task');
                        setTimeout(() => newCard.classList.remove('new-task'), 300);
                    }
                }, 50);
            }

            showToast('✓ Task created', 'success');
        }

        function parseDateShortcut(shortcut) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            switch (shortcut.toLowerCase()) {
                case 'today':
                    return formatDateForInput(today);
                case 'tomorrow':
                    const tomorrow = new Date(today);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    return formatDateForInput(tomorrow);
                case 'next week':
                case 'nextweek':
                    const nextWeek = new Date(today);
                    nextWeek.setDate(nextWeek.getDate() + 7);
                    return formatDateForInput(nextWeek);
                case 'monday':
                case 'tuesday':
                case 'wednesday':
                case 'thursday':
                case 'friday':
                case 'saturday':
                case 'sunday':
                    return formatDateForInput(getNextDayOfWeek(shortcut));
                default:
                    return null;
            }
        }

        function getNextDayOfWeek(dayName) {
            const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            const targetDay = days.indexOf(dayName.toLowerCase());
            const today = new Date();
            const currentDay = today.getDay();

            let daysUntilTarget = targetDay - currentDay;
            if (daysUntilTarget <= 0) {
                daysUntilTarget += 7;
            }

            const targetDate = new Date(today);
            targetDate.setDate(today.getDate() + daysUntilTarget);
            return targetDate;
        }

        function formatDateForInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Close suggestions when clicking outside
        document.addEventListener('click', function(event) {
            const quickAddBar = document.getElementById('quickAddBar');
            if (quickAddBar && !quickAddBar.contains(event.target)) {
                hideQuickAddSuggestions();
            }
        });

        // ============================================
        // TASK MODAL QUICK ACTIONS
        // ============================================

        function toggleTaskDatePicker(taskId) {
            const picker = document.getElementById(`taskDatePicker_${taskId}`);
            if (picker) {
                picker.classList.toggle('show');
            }
        }

        // Inline date picker for task list items
        let activeInlineDatePicker = null;

        function showInlineDatePicker(taskId, event) {
            event.stopPropagation();

            // Close any existing picker
            closeAllInlineDatePickers();

            const picker = document.getElementById(`inlineDatePicker_${taskId}`);
            if (picker) {
                picker.classList.add('show');
                activeInlineDatePicker = taskId;

                // Close when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeInlineDatePickerOnOutsideClick);
                }, 10);
            }
        }

        function closeAllInlineDatePickers() {
            document.querySelectorAll('.inline-date-popup.show').forEach(p => p.classList.remove('show'));
            document.removeEventListener('click', closeInlineDatePickerOnOutsideClick);
            activeInlineDatePicker = null;
        }

        function closeInlineDatePickerOnOutsideClick(event) {
            if (!event.target.closest('.inline-date-popup') && !event.target.closest('.inline-date-trigger')) {
                closeAllInlineDatePickers();
            }
        }

        function setInlineTaskDate(taskId, dateOption, event) {
            if (event) event.stopPropagation();
            closeAllInlineDatePickers();
            setTaskDueDate(taskId, dateOption);

            // Refresh any open modals or views
            const entityModal = document.getElementById('entityModal');
            if (entityModal && entityModal.classList.contains('active')) {
                const modalTaskId = entityModal.dataset.entityId;
                const modalType = entityModal.dataset.entityType;
                if (modalType === 'task' || modalType === 'role') {
                    openEntityModal(modalTaskId, modalType);
                }
            }
        }

        function openInlineFlatpickr(taskId, event) {
            if (event) event.stopPropagation();
            closeAllInlineDatePickers();

            const task = entities.task.find(t => t.id === taskId);

            // Create a temporary input for flatpickr
            const tempInput = document.createElement('input');
            tempInput.style.position = 'absolute';
            tempInput.style.opacity = '0';
            tempInput.style.pointerEvents = 'none';
            document.body.appendChild(tempInput);

            const fp = flatpickr(tempInput, {
                dateFormat: 'Y-m-d',
                defaultDate: task?.dueDate || null,
                allowInput: false,
                onChange: function(selectedDates, dateStr) {
                    if (dateStr) {
                        setTaskDueDate(taskId, dateStr);
                        // Refresh any open modals
                        const entityModal = document.getElementById('entityModal');
                        if (entityModal && entityModal.classList.contains('active')) {
                            const modalTaskId = entityModal.dataset.entityId;
                            const modalType = entityModal.dataset.entityType;
                            if (modalType === 'task' || modalType === 'role') {
                                openEntityModal(modalTaskId, modalType);
                            }
                        }
                    }
                },
                onClose: function() {
                    setTimeout(() => {
                        fp.destroy();
                        tempInput.remove();
                    }, 100);
                }
            });

            fp.open();
        }

        // Generate inline date picker HTML for use in task lists
        function renderInlineDatePicker(taskId, currentDate) {
            const displayDate = currentDate ? formatDateShort(currentDate) : 'Set date';
            const dueDateStatus = currentDate ? getTaskDueDateStatus({ dueDate: currentDate, status: 'pending' }) : '';

            return `
                <div class="inline-date-trigger ${currentDate ? dueDateStatus : 'empty'}" onclick="showInlineDatePicker('${taskId}', event)">
                    <i class="ph ph-calendar"></i>
                    <span>${displayDate}</span>
                    <div class="inline-date-popup" id="inlineDatePicker_${taskId}">
                        <div class="inline-date-options">
                            <div class="inline-date-option" onclick="setInlineTaskDate('${taskId}', 'today', event)">
                                <i class="ph ph-sun"></i> Today
                            </div>
                            <div class="inline-date-option" onclick="setInlineTaskDate('${taskId}', 'tomorrow', event)">
                                <i class="ph ph-sun-horizon"></i> Tomorrow
                            </div>
                            <div class="inline-date-option" onclick="setInlineTaskDate('${taskId}', 'nextweek', event)">
                                <i class="ph ph-calendar-plus"></i> Next week
                            </div>
                            <div class="inline-date-option calendar" onclick="openInlineFlatpickr('${taskId}', event)">
                                <i class="ph ph-calendar-blank"></i> Pick date...
                            </div>
                            ${currentDate ? `
                            <div class="inline-date-option clear" onclick="setInlineTaskDate('${taskId}', 'none', event)">
                                <i class="ph ph-x"></i> Clear date
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        // Store flatpickr instances to avoid multiple initializations
        const taskDatePickers = {};

        function initTaskDatePicker(taskId) {
            const inputEl = document.getElementById(`customDate_${taskId}`);
            if (!inputEl || taskDatePickers[taskId]) return;

            const task = entities.task.find(t => t.id === taskId);

            taskDatePickers[taskId] = flatpickr(inputEl, {
                dateFormat: 'Y-m-d',
                defaultDate: task?.dueDate || null,
                allowInput: false,
                onChange: function(selectedDates, dateStr) {
                    if (dateStr) {
                        setTaskDueDate(taskId, dateStr);
                    }
                },
                onClose: function() {
                    // Clean up picker instance after closing
                    setTimeout(() => {
                        if (taskDatePickers[taskId]) {
                            taskDatePickers[taskId].destroy();
                            delete taskDatePickers[taskId];
                        }
                    }, 100);
                }
            });

            // Open the picker immediately
            taskDatePickers[taskId].open();
        }

        function setTaskDueDate(taskId, dateOption) {
            const task = entities.task.find(t => t.id === taskId);
            if (!task) return;

            // Capture old value for history tracking
            const oldDate = task.dueDate || null;

            let newDate = null;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            switch (dateOption) {
                case 'today':
                    newDate = formatDateForInput(today);
                    break;
                case 'tomorrow':
                    const tomorrow = new Date(today);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    newDate = formatDateForInput(tomorrow);
                    break;
                case 'thisweek':
                    // Next Friday or end of this week
                    const thisFriday = new Date(today);
                    const daysUntilFriday = (5 - today.getDay() + 7) % 7 || 7;
                    thisFriday.setDate(today.getDate() + daysUntilFriday);
                    newDate = formatDateForInput(thisFriday);
                    break;
                case 'nextweek':
                    const nextWeek = new Date(today);
                    nextWeek.setDate(nextWeek.getDate() + 7);
                    newDate = formatDateForInput(nextWeek);
                    break;
                case 'nextmonth':
                    const nextMonth = new Date(today);
                    nextMonth.setMonth(nextMonth.getMonth() + 1);
                    newDate = formatDateForInput(nextMonth);
                    break;
                case 'none':
                    newDate = null;
                    break;
                default:
                    // Handle custom date string (YYYY-MM-DD format)
                    if (dateOption && /^\d{4}-\d{2}-\d{2}$/.test(dateOption)) {
                        newDate = dateOption;
                    }
                    break;
            }

            // Only proceed if date actually changed
            if (oldDate === newDate) {
                const picker = document.getElementById(`taskDatePicker_${taskId}`);
                if (picker) picker.classList.remove('show');
                return;
            }

            // Track in undo history before making changes
            pushToUndoHistory({
                type: 'update_entity',
                entityType: 'task',
                data: { id: task.id },
                oldData: { dueDate: oldDate },
                description: `Change due date: ${task.name}`
            });

            task.dueDate = newDate;
            saveToLocalStorage();

            // Log to Xano with full history tracking
            logActivityToXano({
                event_verb: 'Update Due Date',
                eo_operator: 'ALT',
                object_type: 'task',
                object_id: taskId,
                object_label: task.name,
                data_json: {
                    field: 'dueDate',
                    old_value: oldDate,
                    new_value: newDate,
                    old_display: oldDate ? formatDateShort(oldDate) : 'No date',
                    new_display: newDate ? formatDateShort(newDate) : 'No date'
                }
            });

            // Close the picker
            const picker = document.getElementById(`taskDatePicker_${taskId}`);
            if (picker) picker.classList.remove('show');

            // Refresh the modal
            openEntityModal(taskId, 'task');

            // Update task board if visible
            if (document.getElementById('taskBoardView')?.classList.contains('active')) {
                renderTaskBoard();
            }

            showToast(newDate ? `Due date: ${formatDateShort(newDate)}` : 'Due date cleared', 'success');
        }

        function cycleTaskPriority(taskId) {
            const task = entities.task.find(t => t.id === taskId);
            if (!task) return;

            // Capture old value for history tracking
            const oldPriority = task.priority || 'medium';

            const priorities = ['low', 'medium', 'high', 'urgent'];
            const currentIndex = priorities.indexOf(oldPriority);
            const nextIndex = (currentIndex + 1) % priorities.length;
            const newPriority = priorities[nextIndex];

            // Track in undo history before making changes
            pushToUndoHistory({
                type: 'update_entity',
                entityType: 'task',
                data: { id: task.id },
                oldData: { priority: oldPriority },
                description: `Change priority: ${task.name}`
            });

            task.priority = newPriority;
            saveToLocalStorage();

            // Log to Xano with full history tracking
            logActivityToXano({
                event_verb: 'Update Priority',
                eo_operator: 'ALT',
                object_type: 'task',
                object_id: taskId,
                object_label: task.name,
                data_json: {
                    field: 'priority',
                    old_value: oldPriority,
                    new_value: newPriority
                }
            });

            // Refresh the modal
            openEntityModal(taskId, 'task');

            // Update task board if visible
            if (document.getElementById('taskBoardView')?.classList.contains('active')) {
                renderTaskBoard();
            }

            showToast(`Priority: ${newPriority.charAt(0).toUpperCase() + newPriority.slice(1)}`, 'success');
        }

        // Close date picker when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.quick-action-btn')) {
                document.querySelectorAll('.date-picker-popup.show').forEach(picker => {
                    picker.classList.remove('show');
                });
            }
        });

        // ============================================
        // TAGS SYSTEM
        // ============================================
        let heroTaskTags = [];
        const tagColors = ['blue', 'green', 'yellow', 'red', 'purple', 'pink', 'orange'];

        function handleTagInput(event) {
            if (event.key === 'Enter' || event.key === ',') {
                event.preventDefault();
                const input = event.target;
                const tag = input.value.trim().replace(',', '');

                if (tag && !heroTaskTags.includes(tag)) {
                    heroTaskTags.push(tag);
                    renderHeroTags();
                }
                input.value = '';
            } else if (event.key === 'Backspace' && event.target.value === '' && heroTaskTags.length > 0) {
                heroTaskTags.pop();
                renderHeroTags();
            }
        }

        function renderHeroTags() {
            const container = document.getElementById('heroTagsContainer');
            const input = document.getElementById('heroTagsInput');

            // Remove existing tags
            container.querySelectorAll('.task-tag').forEach(el => el.remove());

            // Add tags before the input
            heroTaskTags.forEach((tag, index) => {
                const tagEl = document.createElement('span');
                tagEl.className = 'task-tag';
                tagEl.dataset.color = tagColors[index % tagColors.length];
                tagEl.innerHTML = `${tag} <i class="ph ph-x tag-remove" onclick="removeHeroTag('${tag}')"></i>`;
                container.insertBefore(tagEl, input);
            });
        }

        function removeHeroTag(tag) {
            heroTaskTags = heroTaskTags.filter(t => t !== tag);
            renderHeroTags();
        }

        // ============================================
        // ROLE CONTEXT (Holonic Hierarchy Display)
        // ============================================
        function updateRoleContext() {
            const roleSelect = document.getElementById('heroTaskRoleMain');
            const contextDisplay = document.getElementById('roleContextDisplay');
            const breadcrumb = document.getElementById('roleContextBreadcrumb');
            const roleRequiredNotice = document.getElementById('roleRequiredNotice');

            const roleId = roleSelect?.value;

            if (!roleId) {
                if (contextDisplay) contextDisplay.style.display = 'none';
                if (roleRequiredNotice) roleRequiredNotice.style.display = 'flex';
                return;
            }

            if (roleRequiredNotice) roleRequiredNotice.style.display = 'none';

            // Build hierarchy: Unit > Team > Role
            const hierarchy = getRoleHierarchy(roleId);

            if (hierarchy.length > 0 && contextDisplay) {
                contextDisplay.style.display = 'flex';

                let html = '';
                hierarchy.forEach((item, index) => {
                    if (index > 0) {
                        html += '<i class="ph ph-caret-right"></i>';
                    }
                    const icon = item.type === 'unit' ? 'ph-buildings' :
                                 item.type === 'team' ? 'ph-users-three' : 'ph-briefcase';
                    html += `<span class="role-context-item ${item.type}" onclick="openEntityModal('${item.id}', '${item.type}')">
                        <i class="ph ${icon}"></i>
                        ${item.name}
                    </span>`;
                });
                breadcrumb.innerHTML = html;
            } else if (contextDisplay) {
                contextDisplay.style.display = 'none';
            }
        }

        function getRoleHierarchy(roleId) {
            const hierarchy = [];
            let currentId = roleId;

            // Start with the role
            const role = entities.role?.find(r => r.id === roleId);
            if (role) {
                hierarchy.unshift({ id: role.id, name: role.name, type: 'role' });
            }

            // Find parent team/unit
            while (currentId) {
                const parentRel = relationships.find(r =>
                    r.predicate === 'DES' && r.object === currentId
                );

                if (parentRel) {
                    const parent = findEntity(parentRel.subject);
                    if (parent && (parent.type === 'team' || parent.type === 'unit')) {
                        hierarchy.unshift({ id: parent.id, name: parent.name, type: parent.type });
                        currentId = parent.id;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }

            return hierarchy;
        }

        // ============================================
        // HIERARCHICAL ROLE SELECTOR SYSTEM
        // ============================================

        // Build a hierarchical structure of roles grouped by Unit > Team
        function buildRoleHierarchyStructure() {
            const roles = entities.role || [];
            const teams = entities.team || [];
            const units = entities.unit || [];

            // Track which roles/teams are already placed in hierarchy
            const placedRoles = new Set();
            const placedTeams = new Set();

            // Build unit -> team -> role structure
            const unitHierarchy = [];

            units.forEach(unit => {
                const unitData = {
                    id: unit.id,
                    name: unit.name,
                    type: 'unit',
                    teams: []
                };

                // Find teams that belong to this unit (Unit DES Team)
                const unitTeams = teams.filter(team => {
                    return relationships.some(r =>
                        r.predicate === 'DES' &&
                        r.subject === unit.id &&
                        r.object === team.id
                    );
                });

                unitTeams.forEach(team => {
                    placedTeams.add(team.id);
                    const teamData = {
                        id: team.id,
                        name: team.name,
                        type: 'team',
                        roles: []
                    };

                    // Find roles that belong to this team (Team DES Role)
                    const teamRoles = roles.filter(role => {
                        return relationships.some(r =>
                            r.predicate === 'DES' &&
                            r.subject === team.id &&
                            r.object === role.id
                        );
                    });

                    teamRoles.forEach(role => {
                        placedRoles.add(role.id);
                        teamData.roles.push(role);
                    });

                    // Sort roles alphabetically
                    teamData.roles.sort((a, b) => a.name.localeCompare(b.name));

                    if (teamData.roles.length > 0) {
                        unitData.teams.push(teamData);
                    }
                });

                // Sort teams alphabetically
                unitData.teams.sort((a, b) => a.name.localeCompare(b.name));

                if (unitData.teams.length > 0) {
                    unitHierarchy.push(unitData);
                }
            });

            // Sort units alphabetically
            unitHierarchy.sort((a, b) => a.name.localeCompare(b.name));

            // Find orphan teams (teams not in any unit but have roles)
            const orphanTeams = [];
            teams.filter(team => !placedTeams.has(team.id)).forEach(team => {
                const teamRoles = roles.filter(role => {
                    return relationships.some(r =>
                        r.predicate === 'DES' &&
                        r.subject === team.id &&
                        r.object === role.id
                    );
                });

                if (teamRoles.length > 0) {
                    teamRoles.forEach(role => placedRoles.add(role.id));
                    orphanTeams.push({
                        id: team.id,
                        name: team.name,
                        type: 'team',
                        roles: teamRoles.sort((a, b) => a.name.localeCompare(b.name))
                    });
                }
            });

            orphanTeams.sort((a, b) => a.name.localeCompare(b.name));

            // Find orphan roles (roles not in any team)
            const orphanRoles = roles
                .filter(role => !placedRoles.has(role.id))
                .sort((a, b) => a.name.localeCompare(b.name));

            return {
                units: unitHierarchy,
                orphanTeams: orphanTeams,
                orphanRoles: orphanRoles
            };
        }

        // Get the team ID for a role (if it has one)
        function getTeamForRole(roleId) {
            const teamRel = relationships.find(r =>
                r.predicate === 'DES' &&
                r.object === roleId &&
                entities.team?.some(t => t.id === r.subject)
            );
            return teamRel ? teamRel.subject : null;
        }

        // Track team usage for "most used team" feature
        function trackTeamUsage(teamId) {
            if (!teamId || !currentWorkspaceId) return;

            const storageKey = `teamUsage_${currentWorkspaceId}`;
            let usage = {};

            try {
                usage = JSON.parse(localStorage.getItem(storageKey)) || {};
            } catch (e) {
                usage = {};
            }

            usage[teamId] = (usage[teamId] || 0) + 1;
            localStorage.setItem(storageKey, JSON.stringify(usage));
        }

        // Get the most used team for the current workspace
        function getMostUsedTeam() {
            if (!currentWorkspaceId) return null;

            const storageKey = `teamUsage_${currentWorkspaceId}`;
            let usage = {};

            try {
                usage = JSON.parse(localStorage.getItem(storageKey)) || {};
            } catch (e) {
                return null;
            }

            let maxCount = 0;
            let mostUsedTeamId = null;

            for (const [teamId, count] of Object.entries(usage)) {
                // Verify team still exists
                if (count > maxCount && entities.team?.some(t => t.id === teamId)) {
                    maxCount = count;
                    mostUsedTeamId = teamId;
                }
            }

            return mostUsedTeamId;
        }

        // Get the unit that contains a team
        function getUnitForTeam(teamId) {
            const unitRel = relationships.find(r =>
                r.predicate === 'DES' &&
                r.object === teamId &&
                entities.unit?.some(u => u.id === r.subject)
            );
            return unitRel ? unitRel.subject : null;
        }

        // Toggle hierarchy section expansion
        function toggleRoleHierarchySection(sectionId, type) {
            const header = document.querySelector(`[data-section-id="${sectionId}"][data-section-type="${type}"]`);
            const content = document.getElementById(`role-hierarchy-content-${type}-${sectionId}`);

            if (header && content) {
                header.classList.toggle('expanded');
                content.classList.toggle('expanded');
            }
        }

        // ============================================
        // COLLABORATORS SYSTEM
        // ============================================
        let heroCollaborators = [];

        function openCollaboratorPicker() {
            // Get all people not already added as collaborators
            const available = (entities.person || []).filter(p => !heroCollaborators.includes(p.id));

            if (available.length === 0) {
                showToast('All people have been added as collaborators', 'info');
                return;
            }

            // Simple prompt-based picker for now (can be enhanced with modal)
            const names = available.map(p => p.name).join(', ');
            const selected = prompt(`Available collaborators: ${names}\n\nEnter name to add:`);

            if (selected) {
                const person = available.find(p => p.name.toLowerCase() === selected.toLowerCase());
                if (person) {
                    heroCollaborators.push(person.id);
                    renderCollaboratorAvatars();
                } else {
                    showToast('Person not found', 'error');
                }
            }
        }

        function renderCollaboratorAvatars() {
            const container = document.getElementById('heroCollaboratorAvatars');
            if (!container) return;

            container.innerHTML = '';

            heroCollaborators.forEach(personId => {
                const person = entities.person?.find(p => p.id === personId);
                if (person) {
                    const initials = person.name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                    const avatar = document.createElement('div');
                    avatar.className = 'collaborator-avatar';
                    avatar.title = person.name;
                    avatar.textContent = initials;
                    avatar.onclick = () => removeCollaborator(personId);
                    container.appendChild(avatar);
                }
            });
        }

        function removeCollaborator(personId) {
            heroCollaborators = heroCollaborators.filter(id => id !== personId);
            renderCollaboratorAvatars();
        }

        // ============================================
        // TASK COMMENTS SYSTEM
        // ============================================
        let taskComments = {}; // { taskId: [{ id, author, authorType, text, createdAt, mentions }] }

        function addTaskComment(taskId, text, authorName = 'You') {
            if (!taskComments[taskId]) {
                taskComments[taskId] = [];
            }

            // Parse mentions from text
            const mentionRegex = /@(\w+(?:\s+\w+)?)/g;
            const mentions = [];
            let match;
            while ((match = mentionRegex.exec(text)) !== null) {
                mentions.push(match[1]);
            }

            const comment = {
                id: 'comment' + Date.now(),
                author: authorName,
                authorType: 'person',
                text: text,
                createdAt: new Date().toISOString(),
                mentions: mentions,
                reactions: {}, // { emoji: ['You', 'person2', ...] }
                resolved: false,
                resolvedBy: null,
                resolvedAt: null
            };

            taskComments[taskId].push(comment);
            saveTaskComments();

            // Trigger notifications for mentions
            if (mentions.length > 0) {
                addMentionNotifications(taskId, comment, mentions);
            }

            return comment;
        }

        function getTaskComments(taskId) {
            return taskComments[taskId] || [];
        }

        function renderTaskComments(taskId) {
            const comments = getTaskComments(taskId);
            const commonEmojis = ['👍', '❤️', '🎉', '👀', '🚀', '💯', '✅', '🤔', '👏', '🔥', '💡', '⭐'];

            const renderReactions = (comment) => {
                const reactions = comment.reactions || {};
                const reactionKeys = Object.keys(reactions).filter(emoji => reactions[emoji] && reactions[emoji].length > 0);

                if (reactionKeys.length === 0) {
                    return `
                        <div class="comment-reactions">
                            <button class="add-reaction-btn" onclick="showEmojiPicker(event, '${taskId}', '${comment.id}')" title="Add reaction">
                                <i class="ph ph-smiley"></i>
                            </button>
                        </div>
                    `;
                }

                return `
                    <div class="comment-reactions">
                        ${reactionKeys.map(emoji => {
                            const users = reactions[emoji];
                            const isActive = users.includes('You');
                            return `
                                <button class="comment-reaction ${isActive ? 'active' : ''}"
                                        onclick="toggleReaction('${taskId}', '${comment.id}', '${emoji}')"
                                        title="${users.join(', ')}">
                                    <span class="comment-reaction-emoji">${emoji}</span>
                                    <span class="comment-reaction-count">${users.length}</span>
                                </button>
                            `;
                        }).join('')}
                        <button class="add-reaction-btn" onclick="showEmojiPicker(event, '${taskId}', '${comment.id}')" title="Add reaction">
                            <i class="ph ph-plus"></i>
                        </button>
                    </div>
                `;
            };

            const renderCommentItem = (comment) => {
                const initials = comment.author.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                const formattedText = comment.text.replace(/@(\w+(?:\s+\w+)?)/g, '<span class="mention" onclick="handleMentionClick(\'$1\')">@$1</span>');
                const timeAgo = formatTimeAgo(new Date(comment.createdAt).getTime());
                const isResolved = comment.resolved;

                return `
                    <div class="comment-item ${isResolved ? 'resolved' : ''}" data-comment-id="${comment.id}">
                        <div class="comment-avatar">${initials}</div>
                        <div class="comment-content">
                            <div class="comment-header">
                                <span class="comment-author">${comment.author}</span>
                                <span class="comment-time">${timeAgo}</span>
                                ${isResolved ? `<span class="comment-resolved-badge"><i class="ph ph-check-circle"></i> Resolved</span>` : ''}
                            </div>
                            <div class="comment-text">${formattedText}</div>
                            ${renderReactions(comment)}
                            <div class="comment-actions">
                                ${!isResolved ? `
                                    <button class="comment-action-btn resolve" onclick="resolveComment('${taskId}', '${comment.id}')" title="Mark as resolved">
                                        <i class="ph ph-check-circle"></i> Resolve
                                    </button>
                                ` : `
                                    <button class="comment-action-btn" onclick="unresolveComment('${taskId}', '${comment.id}')" title="Unresolve">
                                        <i class="ph ph-arrow-counter-clockwise"></i> Unresolve
                                    </button>
                                `}
                                <button class="comment-action-btn" onclick="editComment('${taskId}', '${comment.id}')" title="Edit comment">
                                    <i class="ph ph-pencil-simple"></i> Edit
                                </button>
                                <button class="comment-action-btn delete" onclick="deleteComment('${taskId}', '${comment.id}')" title="Delete comment">
                                    <i class="ph ph-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            };

            const commentsHtml = comments.length > 0
                ? comments.map(renderCommentItem).join('')
                : `<div style="padding: 0.75rem; background: #FAF7F5; border-radius: 6px; text-align: center; color: #8B6F47; font-size: 0.875rem;">
                       <em>No comments yet. Start the discussion!</em>
                   </div>`;

            return `
                <div class="task-comments">
                    <div class="task-comments-header">
                        <span class="task-comments-title">
                            <i class="ph ph-chat-circle"></i> Activity & Comments
                            ${comments.length > 0 ? `<span class="task-comments-count">${comments.length}</span>` : ''}
                        </span>
                    </div>
                    <div class="comments-list">
                        ${commentsHtml}
                    </div>
                    <div class="comment-input-container" style="margin-top: 0.75rem;">
                        <div class="comment-input-wrapper">
                            <textarea class="comment-input"
                                      id="commentInput_${taskId}"
                                      placeholder="Add a comment... (use @ to mention people or roles)"
                                      oninput="handleCommentInput(event, '${taskId}')"
                                      onkeydown="handleCommentKeydown(event, '${taskId}')"></textarea>
                            <div class="mention-autocomplete" id="mentionDropdown_${taskId}"></div>
                        </div>
                        <button class="comment-submit-btn" onclick="submitComment('${taskId}')">
                            <i class="ph ph-paper-plane-tilt"></i>
                        </button>
                    </div>
                </div>

                <!-- Emoji Picker (hidden by default) -->
                <div class="emoji-picker" id="emojiPicker">
                    <div class="emoji-picker-grid">
                        ${commonEmojis.map(emoji => `
                            <button class="emoji-picker-item" onclick="selectEmoji('${emoji}')">${emoji}</button>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // @Mention autocomplete state
        let mentionState = {
            active: false,
            taskId: null,
            startPosition: 0,
            highlightedIndex: 0,
            matches: []
        };

        function handleCommentInput(event, taskId) {
            const input = event.target;
            const text = input.value;
            const cursorPosition = input.selectionStart;

            // Find if we're in a mention context (after @)
            const textBeforeCursor = text.substring(0, cursorPosition);
            const atIndex = textBeforeCursor.lastIndexOf('@');

            if (atIndex !== -1) {
                const textAfterAt = textBeforeCursor.substring(atIndex + 1);
                // Check if it's a valid mention context (no spaces after typing)
                if (!/\s/.test(textAfterAt) || textAfterAt.split(' ').length <= 2) {
                    showMentionDropdown(taskId, textAfterAt, atIndex);
                    return;
                }
            }

            hideMentionDropdown(taskId);
        }

        function showMentionDropdown(taskId, query, startPosition) {
            const dropdown = document.getElementById(`mentionDropdown_${taskId}`);
            if (!dropdown) return;

            // Get all mentionable entities (people and roles)
            const people = (entities.person || []).map(p => ({ ...p, entityType: 'person' }));
            const roles = (entities.role || []).map(r => ({ ...r, entityType: 'role' }));
            const allMentionables = [...people, ...roles];

            // Filter by query
            const queryLower = query.toLowerCase();
            const matches = allMentionables.filter(entity =>
                entity.name.toLowerCase().includes(queryLower)
            ).slice(0, 8); // Limit to 8 results

            if (matches.length === 0) {
                hideMentionDropdown(taskId);
                return;
            }

            mentionState = {
                active: true,
                taskId: taskId,
                startPosition: startPosition,
                highlightedIndex: 0,
                matches: matches
            };

            dropdown.innerHTML = matches.map((entity, index) => {
                const initials = entity.name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                const iconClass = entity.entityType === 'person' ? 'person' : 'role';
                const typeLabel = entity.entityType === 'person' ? 'Person' : 'Role';

                return `
                    <div class="mention-option ${index === 0 ? 'highlighted' : ''}"
                         data-index="${index}"
                         data-name="${entity.name}"
                         onmouseenter="highlightMentionOption(${index})"
                         onclick="selectMention('${taskId}', '${entity.name.replace(/'/g, "\\'")}')">
                        <div class="mention-option-icon ${iconClass}">${initials}</div>
                        <span class="mention-option-name">${entity.name}</span>
                        <span class="mention-option-type">${typeLabel}</span>
                    </div>
                `;
            }).join('');

            dropdown.classList.add('active');
        }

        function hideMentionDropdown(taskId) {
            const dropdown = document.getElementById(`mentionDropdown_${taskId}`);
            if (dropdown) {
                dropdown.classList.remove('active');
                dropdown.innerHTML = '';
            }
            mentionState.active = false;
        }

        function highlightMentionOption(index) {
            mentionState.highlightedIndex = index;
            const dropdown = document.getElementById(`mentionDropdown_${mentionState.taskId}`);
            if (!dropdown) return;

            const options = dropdown.querySelectorAll('.mention-option');
            options.forEach((opt, i) => {
                opt.classList.toggle('highlighted', i === index);
            });
        }

        function selectMention(taskId, name) {
            const input = document.getElementById(`commentInput_${taskId}`);
            if (!input) return;

            const text = input.value;
            const beforeMention = text.substring(0, mentionState.startPosition);
            const afterCursor = text.substring(input.selectionStart);

            // Insert the mention
            input.value = beforeMention + '@' + name + ' ' + afterCursor;

            // Set cursor position after the mention
            const newPosition = beforeMention.length + name.length + 2;
            input.setSelectionRange(newPosition, newPosition);
            input.focus();

            hideMentionDropdown(taskId);
        }

        function handleCommentKeydown(event, taskId) {
            // Handle mention dropdown navigation
            if (mentionState.active && mentionState.taskId === taskId) {
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    const newIndex = Math.min(mentionState.highlightedIndex + 1, mentionState.matches.length - 1);
                    highlightMentionOption(newIndex);
                    return;
                }
                if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    const newIndex = Math.max(mentionState.highlightedIndex - 1, 0);
                    highlightMentionOption(newIndex);
                    return;
                }
                if (event.key === 'Enter' || event.key === 'Tab') {
                    event.preventDefault();
                    const selected = mentionState.matches[mentionState.highlightedIndex];
                    if (selected) {
                        selectMention(taskId, selected.name);
                    }
                    return;
                }
                if (event.key === 'Escape') {
                    event.preventDefault();
                    hideMentionDropdown(taskId);
                    return;
                }
            }

            // Default: Enter to submit (Shift+Enter for newline)
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                submitComment(taskId);
            }
        }

        function submitComment(taskId) {
            const input = document.getElementById(`commentInput_${taskId}`);
            const text = input?.value.trim();

            if (!text) return;

            hideMentionDropdown(taskId);
            addTaskComment(taskId, text);
            input.value = '';

            // Re-render the task modal to show new comment
            openEntityModal(taskId, 'task');
            showToast('Comment added', 'success');
        }

        // Emoji picker state
        let emojiPickerState = {
            taskId: null,
            commentId: null
        };

        function showEmojiPicker(event, taskId, commentId) {
            event.stopPropagation();
            const picker = document.getElementById('emojiPicker');
            if (!picker) return;

            emojiPickerState = { taskId, commentId };

            // Position the picker near the button
            const rect = event.target.getBoundingClientRect();
            const modal = document.querySelector('.modal-dialog');
            const modalRect = modal ? modal.getBoundingClientRect() : { left: 0, top: 0 };

            picker.style.left = (rect.left - modalRect.left) + 'px';
            picker.style.top = (rect.bottom - modalRect.top + 5) + 'px';
            picker.classList.add('active');

            // Close picker when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeEmojiPickerOnOutsideClick);
            }, 10);
        }

        function closeEmojiPickerOnOutsideClick(event) {
            const picker = document.getElementById('emojiPicker');
            if (picker && !picker.contains(event.target)) {
                picker.classList.remove('active');
                document.removeEventListener('click', closeEmojiPickerOnOutsideClick);
            }
        }

        function selectEmoji(emoji) {
            const { taskId, commentId } = emojiPickerState;
            if (!taskId || !commentId) return;

            toggleReaction(taskId, commentId, emoji);

            const picker = document.getElementById('emojiPicker');
            if (picker) picker.classList.remove('active');
            document.removeEventListener('click', closeEmojiPickerOnOutsideClick);
        }

        function toggleReaction(taskId, commentId, emoji) {
            const comments = taskComments[taskId];
            if (!comments) return;

            const comment = comments.find(c => c.id === commentId);
            if (!comment) return;

            // Initialize reactions if needed
            if (!comment.reactions) {
                comment.reactions = {};
            }

            // Initialize this emoji's array if needed
            if (!comment.reactions[emoji]) {
                comment.reactions[emoji] = [];
            }

            // Toggle user's reaction
            const userIndex = comment.reactions[emoji].indexOf('You');
            if (userIndex === -1) {
                comment.reactions[emoji].push('You');
            } else {
                comment.reactions[emoji].splice(userIndex, 1);
            }

            // Clean up empty reaction arrays
            if (comment.reactions[emoji].length === 0) {
                delete comment.reactions[emoji];
            }

            saveTaskComments();
            openEntityModal(taskId, 'task');
        }

        function resolveComment(taskId, commentId) {
            const comments = taskComments[taskId];
            if (!comments) return;

            const comment = comments.find(c => c.id === commentId);
            if (!comment) return;

            comment.resolved = true;
            comment.resolvedBy = 'You';
            comment.resolvedAt = new Date().toISOString();

            saveTaskComments();
            openEntityModal(taskId, 'task');
            showToast('Comment marked as resolved', 'success');
        }

        function unresolveComment(taskId, commentId) {
            const comments = taskComments[taskId];
            if (!comments) return;

            const comment = comments.find(c => c.id === commentId);
            if (!comment) return;

            comment.resolved = false;
            comment.resolvedBy = null;
            comment.resolvedAt = null;

            saveTaskComments();
            openEntityModal(taskId, 'task');
        }

        function editComment(taskId, commentId) {
            const comments = taskComments[taskId];
            if (!comments) return;

            const comment = comments.find(c => c.id === commentId);
            if (!comment) return;

            const newText = prompt('Edit your comment:', comment.text);
            if (newText !== null && newText.trim() !== '') {
                comment.text = newText.trim();
                comment.editedAt = new Date().toISOString();

                // Re-parse mentions
                const mentionRegex = /@(\w+(?:\s+\w+)?)/g;
                const mentions = [];
                let match;
                while ((match = mentionRegex.exec(newText)) !== null) {
                    mentions.push(match[1]);
                }
                comment.mentions = mentions;

                saveTaskComments();
                openEntityModal(taskId, 'task');
                showToast('Comment updated', 'success');
            }
        }

        function deleteComment(taskId, commentId) {
            if (!confirm('Are you sure you want to delete this comment?')) return;

            const comments = taskComments[taskId];
            if (!comments) return;

            const index = comments.findIndex(c => c.id === commentId);
            if (index === -1) return;

            comments.splice(index, 1);
            saveTaskComments();
            openEntityModal(taskId, 'task');
            showToast('Comment deleted', 'info');
        }

        function handleMentionClick(mentionName) {
            // Try to find matching person or role and open their modal
            const person = entities.person?.find(p =>
                p.name.toLowerCase().includes(mentionName.toLowerCase())
            );
            if (person) {
                openEntityModal(person.id, 'person');
                return;
            }

            const role = entities.role?.find(r =>
                r.name.toLowerCase().includes(mentionName.toLowerCase())
            );
            if (role) {
                openEntityModal(role.id, 'role');
                return;
            }

            showToast(`Could not find "${mentionName}"`, 'info');
        }

        function saveTaskComments() {
            if (currentWorkspaceId) {
                localStorage.setItem(`taskComments_${currentWorkspaceId}`, JSON.stringify(taskComments));
            }
        }

        function loadTaskComments() {
            if (currentWorkspaceId) {
                const saved = localStorage.getItem(`taskComments_${currentWorkspaceId}`);
                if (saved) {
                    taskComments = JSON.parse(saved);
                }
            }
        }

        // ============================================
        // NOTIFICATION SYSTEM
        // ============================================
        let notifications = []; // [{ id, type, text, taskId, read, createdAt }]
        let notificationSettings = {
            taskAssignment: true,
            taskUpdate: true,
            mentions: true,
            comments: true,
            dueDateReminder: true
        };

        function addNotification(type, text, taskId = null) {
            const notification = {
                id: 'notif' + Date.now(),
                type: type,
                text: text,
                taskId: taskId,
                read: false,
                createdAt: new Date().toISOString()
            };

            notifications.unshift(notification);

            // Keep only last 50 notifications
            if (notifications.length > 50) {
                notifications = notifications.slice(0, 50);
            }

            saveNotifications();
            updateNotificationBadge();

            return notification;
        }

        function addMentionNotifications(taskId, comment, mentions) {
            const task = entities.task?.find(t => t.id === taskId);
            if (!task) return;

            mentions.forEach(mention => {
                // Check if mention matches a person or role
                const person = entities.person?.find(p => p.name.toLowerCase().includes(mention.toLowerCase()));
                const role = entities.role?.find(r => r.name.toLowerCase().includes(mention.toLowerCase()));

                if (person || role) {
                    addNotification(
                        'mention',
                        `${comment.author} mentioned ${mention} in "${task.name}"`,
                        taskId
                    );
                }
            });
        }

        function markNotificationRead(notificationId) {
            const notification = notifications.find(n => n.id === notificationId);
            if (notification) {
                notification.read = true;
                saveNotifications();
                updateNotificationBadge();
            }
        }

        function markAllNotificationsRead() {
            notifications.forEach(n => n.read = true);
            saveNotifications();
            updateNotificationBadge();
        }

        function getUnreadCount() {
            return notifications.filter(n => !n.read).length;
        }

        function updateNotificationBadge() {
            const badge = document.getElementById('notificationBadge');
            const count = getUnreadCount();

            if (badge) {
                if (count > 0) {
                    badge.textContent = count > 9 ? '9+' : count;
                    badge.style.display = 'flex';
                } else {
                    badge.style.display = 'none';
                }
            }
        }

        function saveNotifications() {
            if (currentWorkspaceId) {
                localStorage.setItem(`notifications_${currentWorkspaceId}`, JSON.stringify(notifications));
            }
        }

        function loadNotifications() {
            if (currentWorkspaceId) {
                const saved = localStorage.getItem(`notifications_${currentWorkspaceId}`);
                if (saved) {
                    notifications = JSON.parse(saved);
                }
            }
        }

        function toggleNotificationsPanel() {
            const panel = document.getElementById('notificationsPanel');
            if (panel) {
                panel.classList.toggle('open');
                if (panel.classList.contains('open')) {
                    renderNotificationsPanel();
                }
            }
        }

        function renderNotificationsPanel() {
            const list = document.getElementById('notificationsList');
            if (!list) return;

            if (notifications.length === 0) {
                list.innerHTML = `
                    <div style="padding: 2rem; text-align: center; color: #8B6F47;">
                        <i class="ph ph-bell-slash" style="font-size: 2rem; margin-bottom: 0.5rem; display: block;"></i>
                        No notifications yet
                    </div>
                `;
                return;
            }

            list.innerHTML = notifications.map(notif => {
                const iconClass = notif.type === 'task' ? 'task' :
                                  notif.type === 'comment' ? 'comment' :
                                  notif.type === 'mention' ? 'mention' : 'assignment';
                const icon = notif.type === 'task' ? 'ph-check-square' :
                             notif.type === 'comment' ? 'ph-chat-circle' :
                             notif.type === 'mention' ? 'ph-at' : 'ph-user-plus';
                const timeAgo = formatTimeAgo(new Date(notif.createdAt).getTime());

                return `
                    <div class="notification-item ${notif.read ? '' : 'unread'}"
                         onclick="handleNotificationClick('${notif.id}', '${notif.taskId || ''}')">
                        <div class="notification-icon ${iconClass}">
                            <i class="ph ${icon}"></i>
                        </div>
                        <div class="notification-content">
                            <div class="notification-text">${notif.text}</div>
                            <div class="notification-time">${timeAgo}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function handleNotificationClick(notificationId, taskId) {
            markNotificationRead(notificationId);
            renderNotificationsPanel();

            if (taskId) {
                toggleNotificationsPanel();
                openEntityModal(taskId, 'task');
            }
        }

        // ============================================
        // AUTOMATION RULES ENGINE
        // ============================================
        let automationRules = [
            {
                id: 'rule_auto_complete_parent',
                name: 'Auto-complete parent tasks',
                description: 'When all subtasks are completed, mark parent task as complete',
                trigger: 'subtask_completed',
                action: 'complete_parent_if_all_done',
                enabled: true
            },
            {
                id: 'rule_notify_role',
                name: 'Notify on assignment',
                description: 'Send notification when a task is assigned to a role',
                trigger: 'task_assigned',
                action: 'notify_role_members',
                enabled: true
            },
            {
                id: 'rule_due_date_reminder',
                name: 'Due date reminders',
                description: 'Notify when tasks are due soon or overdue',
                trigger: 'due_date_approaching',
                action: 'send_reminder',
                enabled: true
            },
            {
                id: 'rule_cascade_dates',
                name: 'Cascade date changes',
                description: 'When a predecessor task date changes, adjust dependent task dates',
                trigger: 'due_date_changed',
                action: 'cascade_to_dependents',
                enabled: false
            }
        ];

        function toggleAutomationRule(ruleId) {
            const rule = automationRules.find(r => r.id === ruleId);
            if (rule) {
                rule.enabled = !rule.enabled;
                saveAutomationRules();
                showToast(`Rule "${rule.name}" ${rule.enabled ? 'enabled' : 'disabled'}`, 'info');
            }
        }

        function executeAutomationRules(trigger, context) {
            const activeRules = automationRules.filter(r => r.enabled && r.trigger === trigger);

            activeRules.forEach(rule => {
                switch (rule.action) {
                    case 'complete_parent_if_all_done':
                        if (context.parentTaskId) {
                            checkAndCompleteParent(context.parentTaskId);
                        }
                        break;
                    case 'notify_role_members':
                        if (context.roleId && context.taskId) {
                            notifyRoleMembers(context.roleId, context.taskId);
                        }
                        break;
                    case 'send_reminder':
                        // Handled by periodic check
                        break;
                    case 'cascade_to_dependents':
                        if (context.taskId && context.daysDelta) {
                            propagateDateChange(context.taskId, context.newDate, context.daysDelta);
                        }
                        break;
                }
            });
        }

        function checkAndCompleteParent(parentTaskId) {
            const subtasks = getSubtasks(parentTaskId);
            if (subtasks.length > 0 && subtasks.every(t => t.status === 'completed')) {
                const parent = entities.task?.find(t => t.id === parentTaskId);
                if (parent && parent.status !== 'completed') {
                    parent.status = 'completed';
                    saveToLocalStorage();
                    showToast('Parent task auto-completed', 'success');
                    addNotification('task', `"${parent.name}" was automatically completed`, parentTaskId);
                }
            }
        }

        function notifyRoleMembers(roleId, taskId) {
            const role = entities.role?.find(r => r.id === roleId);
            const task = entities.task?.find(t => t.id === taskId);
            if (role && task) {
                addNotification('assignment', `Task "${task.name}" assigned to ${role.name}`, taskId);
            }
        }

        function saveAutomationRules() {
            if (currentWorkspaceId) {
                localStorage.setItem(`automationRules_${currentWorkspaceId}`, JSON.stringify(automationRules));
            }
        }

        function loadAutomationRules() {
            if (currentWorkspaceId) {
                const saved = localStorage.getItem(`automationRules_${currentWorkspaceId}`);
                if (saved) {
                    automationRules = JSON.parse(saved);
                }
            }
        }

        // ============================================
        // SUBTASKS WITH ROLE ASSIGNMENTS
        // ============================================
        function addSubtask(parentTaskId, subtaskName, roleId = null, dueDate = null) {
            const subtaskId = 'task' + Date.now();

            // Calculate orderIndex - new subtasks go to the end (last to complete)
            const existingSubtasks = getSubtasks(parentTaskId);
            const maxOrderIndex = existingSubtasks.reduce((max, s) => {
                const idx = s.orderIndex ?? 0;
                return idx > max ? idx : max;
            }, 0);

            const subtask = {
                id: subtaskId,
                name: subtaskName,
                type: 'task',
                status: 'pending',
                dueDate: dueDate,
                predecessorId: parentTaskId, // Using predecessorId to link to parent
                parentTaskId: parentTaskId,
                priority: 'medium',
                tags: [],
                description: '',
                createdAt: new Date().toISOString(),
                orderIndex: maxOrderIndex + 1 // Lower orderIndex = first to complete (top of list)
            };

            entities.task.push(subtask);

            // Connect to role if provided
            if (roleId) {
                const roleTaskRel = {
                    id: 'rel' + Date.now(),
                    subject: roleId,
                    predicate: 'CON',
                    object: subtaskId,
                    description: ''
                };
                relationships.push(roleTaskRel);
            }

            saveToLocalStorage();

            logActivityToXano({
                event_verb: 'Add Subtask',
                object_type: 'task',
                object_label: subtaskName,
                details: `Parent: ${parentTaskId}`
            });

            return subtask;
        }

        function renderSubtasksSection(taskId) {
            const subtasks = getSubtasks(taskId);
            const completedCount = subtasks.filter(t => t.status === 'completed').length;
            const totalCount = subtasks.length;
            const progress = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;
            const sectionId = `subtasks_${taskId}`;

            return `
                <div class="collapsible-section" id="${sectionId}">
                    <div class="collapsible-header" onclick="toggleCollapsibleSection('${sectionId}')">
                        <span class="collapsible-title">
                            <i class="ph ph-list-checks"></i> Subtasks
                            <span class="subtask-prereq-label">(complete these first)</span>
                            <span class="section-help-tooltip" title="Subtasks are prerequisites that block this task. You must complete all subtasks before this main task can be marked as done.">
                                <i class="ph ph-question"></i>
                            </span>
                            ${totalCount > 0 ? `<span class="collapsible-badge">${completedCount}/${totalCount}</span>` : ''}
                        </span>
                        <div class="collapsible-toggle">
                            ${totalCount > 0 ? `
                            <div class="subtask-progress-bar" style="width: 60px;">
                                <div class="subtask-progress-fill" style="width: ${progress}%"></div>
                            </div>
                            ` : ''}
                            <i class="ph ph-caret-down"></i>
                        </div>
                    </div>
                    <div class="collapsible-content">
                        ${subtasks.map(subtask => {
                            const roleRel = relationships.find(r => r.object === subtask.id && r.predicate === 'CON');
                            const role = roleRel ? entities.role?.find(r => r.id === roleRel.subject) : null;

                            return `
                                <div class="subtask-item ${subtask.status === 'completed' ? 'completed' : ''}" onclick="openEntityModal('${subtask.id}', 'task')">
                                    <div class="subtask-checkbox ${subtask.status === 'completed' ? 'checked' : ''}"
                                         onclick="event.stopPropagation(); toggleSubtaskStatus('${subtask.id}', '${taskId}')">
                                        ${subtask.status === 'completed' ? '<i class="ph ph-check" style="font-size: 12px;"></i>' : ''}
                                    </div>
                                    <div class="subtask-content">
                                        <div class="subtask-name">${subtask.name}</div>
                                        <div class="subtask-meta">
                                            ${role ? `<span class="subtask-role"><i class="ph ph-briefcase"></i> ${role.name}</span>` : ''}
                                            ${renderInlineDatePicker(subtask.id, subtask.dueDate)}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        <div class="subtask-input-row" onclick="this.querySelector('input').focus()">
                            <i class="ph ph-plus input-icon"></i>
                            <input type="text"
                                   id="subtask-input-${taskId}"
                                   placeholder="Add a subtask…"
                                   onkeydown="handleSubtaskInputKeydown(event, '${taskId}')"
                                   onblur="handleSubtaskInputBlur(event, '${taskId}')" />
                            <span class="subtask-input-hint">Press Enter</span>
                            <div class="subtask-input-actions">
                                <button type="button" class="subtask-input-btn submit"
                                        onclick="event.stopPropagation(); submitSubtaskInput('${taskId}')">
                                    Add
                                </button>
                            </div>
                        </div>
                        ${totalCount > 0 && completedCount < totalCount ? `
                        <div class="subtask-blocking-notice">
                            <i class="ph ph-warning-circle"></i>
                            This task is blocked until all ${totalCount - completedCount} remaining subtask${totalCount - completedCount === 1 ? ' is' : 's are'} completed
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function toggleCollapsibleSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        function toggleSubtaskStatus(subtaskId, parentTaskId) {
            const subtask = entities.task?.find(t => t.id === subtaskId);
            if (!subtask) return;

            const newStatus = subtask.status === 'completed' ? 'pending' : 'completed';
            const warnings = checkTaskMoveWarning(subtaskId, newStatus);

            const executeToggle = () => {
                subtask.status = newStatus;
                saveToLocalStorage();

                // Execute automation rules
                if (subtask.status === 'completed') {
                    executeAutomationRules('subtask_completed', { parentTaskId: parentTaskId });
                }

                // Refresh the task modal
                openEntityModal(parentTaskId, 'task');
            };

            if (warnings) {
                const warningMessages = warnings.map(w => w.message).join('<br><br>');
                const title = `Mark as "${getStatusLabel(newStatus)}"?`;
                showTaskConfirmModal(title, warningMessages, executeToggle);
            } else {
                executeToggle();
            }
        }

        // Inline subtask input handlers
        function handleSubtaskInputKeydown(event, parentTaskId) {
            if (event.key === 'Enter') {
                event.preventDefault();
                submitSubtaskInput(parentTaskId);
            } else if (event.key === 'Escape') {
                event.target.value = '';
                event.target.blur();
            }
        }

        function handleSubtaskInputBlur(event, parentTaskId) {
            // Small delay to allow click on Add button to register
            setTimeout(() => {
                const input = event.target;
                const value = input.value.trim();
                // Only submit if there's content and focus moved outside the input row
                if (value && !input.closest('.subtask-input-row').contains(document.activeElement)) {
                    submitSubtaskInput(parentTaskId);
                }
            }, 150);
        }

        function submitSubtaskInput(parentTaskId) {
            const input = document.getElementById(`subtask-input-${parentTaskId}`);
            if (!input) return;

            const name = input.value.trim();
            if (!name) return;

            // Create the subtask
            const subtask = addSubtask(parentTaskId, name);

            // Clear input for next entry
            input.value = '';

            // Re-render the subtasks section to show the new subtask
            const subtasksContainer = input.closest('.subtasks-section');
            if (subtasksContainer) {
                const newHtml = renderSubtasksSection(parentTaskId);
                subtasksContainer.outerHTML = newHtml;

                // Focus the new input for quick consecutive additions
                setTimeout(() => {
                    const newInput = document.getElementById(`subtask-input-${parentTaskId}`);
                    if (newInput) newInput.focus();
                }, 50);
            }

            showToast('Subtask added', 'success');
        }

        // Legacy function kept for compatibility (e.g., Kanban board calls)
        function openAddSubtaskModal(parentTaskId) {
            // Try to find and focus the inline input first
            const input = document.getElementById(`subtask-input-${parentTaskId}`);
            if (input) {
                input.focus();
                return;
            }
            // Fallback: open modal if inline input not available
            openEntityModal(parentTaskId, 'task');
            setTimeout(() => {
                const modalInput = document.getElementById(`subtask-input-${parentTaskId}`);
                if (modalInput) modalInput.focus();
            }, 100);
        }

        // Toggle person inline create
        function toggleHeroPersonCreate() {
            const createDiv = document.getElementById('heroPersonCreate');
            createDiv.classList.toggle('active');
            if (createDiv.classList.contains('active')) {
                document.getElementById('heroNewPersonName').focus();
            }
        }

        // Create new role from hero modal
        function createHeroRole() {
            const nameInput = document.getElementById('heroNewRoleName');
            const name = nameInput.value.trim();

            if (!name) return;

            // Create role entity
            const roleId = 'role' + Date.now();
            const role = { id: roleId, name: name, type: 'role' };
            entities.role.push(role);

            logActivityToXano({
                event_verb: 'Add Entity',
                object_type: 'role',
                object_label: name
            });

            saveToLocalStorage();
            renderEntityList();

            // Refresh selects and select the new role
            populateHeroSelects();
            document.getElementById('heroTaskRole').value = roleId;

            // Clear and hide inline create
            nameInput.value = '';
            document.getElementById('heroRoleCreate').classList.remove('active');

            updateHeroTaskPreview();
        }

        // Create new person from hero modal
        function createHeroPerson() {
            const nameInput = document.getElementById('heroNewPersonName');
            const name = nameInput.value.trim();

            if (!name) return;

            // Create person entity
            const personId = 'person' + Date.now();
            const person = { id: personId, name: name, type: 'person' };
            entities.person.push(person);

            logActivityToXano({
                event_verb: 'Add Entity',
                object_type: 'person',
                object_label: name
            });

            saveToLocalStorage();
            renderEntityList();

            // Refresh selects and select the new person
            populateHeroSelects();
            document.getElementById('heroTaskPerson').value = personId;

            // Clear and hide inline create
            nameInput.value = '';
            document.getElementById('heroPersonCreate').classList.remove('active');

            updateHeroTaskPreview();
        }

        // Toggle workflow inline create
        function toggleHeroWorkflowCreate() {
            const createDiv = document.getElementById('heroWorkflowCreate');
            createDiv.classList.toggle('active');
            if (createDiv.classList.contains('active')) {
                document.getElementById('heroNewWorkflowName').focus();
            }
        }

        // Create new workflow from hero modal
        function createHeroWorkflow() {
            const nameInput = document.getElementById('heroNewWorkflowName');
            const name = nameInput.value.trim();

            if (!name) return;

            // Create workflow entity
            const workflowId = 'workflow' + Date.now();
            const workflow = { id: workflowId, name: name, type: 'workflow', description: '' };
            entities.workflow.push(workflow);

            logActivityToXano({
                event_verb: 'Add Entity',
                object_type: 'workflow',
                object_label: name
            });

            saveToLocalStorage();
            renderEntityList();

            // Refresh selects and select the new workflow
            populateHeroSelects();
            document.getElementById('heroTaskWorkflow').value = workflowId;

            // Clear and hide inline create
            nameInput.value = '';
            document.getElementById('heroWorkflowCreate').classList.remove('active');

            updateHeroTaskPreview();
        }

        // Update preview as user fills in form
        function updateHeroTaskPreview() {
            const taskName = document.getElementById('heroTaskName').value.trim();
            const roleId = document.getElementById('heroTaskRole').value;
            const personId = document.getElementById('heroTaskPerson').value;
            const dueDate = document.getElementById('heroTaskDueDate').value;
            const predecessorId = document.getElementById('heroTaskPredecessor').value;
            const workflowId = document.getElementById('heroTaskWorkflow').value;

            const previewDiv = document.getElementById('heroTaskPreview');
            const previewContent = document.getElementById('heroTaskPreviewContent');
            const submitBtn = document.getElementById('heroTaskSubmitBtn');

            // Enable/disable submit based on required fields (only task name is required, workflow is optional)
            submitBtn.disabled = !taskName;

            // Check for date conflicts
            checkPredecessorDateConflict();

            if (!taskName) {
                previewDiv.style.display = 'none';
                return;
            }

            previewDiv.style.display = 'block';

            const role = entities.role.find(r => r.id === roleId);
            const person = entities.person.find(p => p.id === personId);
            const predecessor = entities.task.find(t => t.id === predecessorId);
            const workflow = entities.workflow.find(w => w.id === workflowId);

            // Build preview starting with the task
            let html = `
                <span class="hero-task-preview-item task">
                    <i class="ph ph-file-text"></i>
                    ${taskName}
                </span>
            `;

            // Add role before task if selected
            if (role) {
                html = `
                    <span class="hero-task-preview-item role">
                        <i class="ph ph-briefcase"></i>
                        ${role.name}
                    </span>
                    <span class="hero-task-preview-arrow">→</span>
                ` + html;
            }

            // Add person before role/task if selected
            if (person) {
                html = `
                    <span class="hero-task-preview-item person">
                        <i class="ph ph-user"></i>
                        ${person.name}
                    </span>
                    <span class="hero-task-preview-arrow">→</span>
                ` + html;
            }

            // Add workflow at the beginning if selected
            if (workflow) {
                html = `
                    <span class="hero-task-preview-item workflow">
                        <i class="ph ph-flow-arrow"></i>
                        ${workflow.name}
                    </span>
                    <span class="hero-task-preview-arrow">→</span>
                ` + html;
            }

            // Add due date if set
            if (dueDate) {
                html += `
                    <span class="hero-task-preview-item due-date">
                        <i class="ph ph-calendar"></i>
                        ${formatDateShort(dueDate)}
                    </span>
                `;
            }

            // Add dependency indicator if set
            if (predecessor) {
                html += `
                    <span class="hero-task-preview-item dependency">
                        <i class="ph ph-link-simple"></i>
                        After: ${predecessor.name}
                    </span>
                `;
            }

            previewContent.innerHTML = html;
        }

        // Submit hero task
        function submitHeroTask() {
            const taskName = document.getElementById('heroTaskName').value.trim();
            const description = document.getElementById('heroTaskDescription')?.value.trim() || '';
            // Use main role selector (required), fall back to legacy selector
            const roleIdMain = document.getElementById('heroTaskRoleMain')?.value;
            const roleIdLegacy = document.getElementById('heroTaskRole')?.value;
            const roleId = roleIdMain || roleIdLegacy;
            const personId = document.getElementById('heroTaskPerson')?.value;
            const dueDate = document.getElementById('heroTaskDueDate')?.value;
            const predecessorId = document.getElementById('heroTaskPredecessor')?.value;
            const workflowId = document.getElementById('heroTaskWorkflow')?.value;
            const recurringValue = document.getElementById('heroTaskRecurring')?.value || '';

            // Task name is required
            if (!taskName) {
                showToast('Task name is required', 'error');
                return;
            }

            // Role is required (EO holonic model - tasks must be assigned to roles)
            if (!roleId) {
                showToast('Please assign this task to a role', 'error');
                document.getElementById('roleRequiredNotice').style.display = 'flex';
                return;
            }

            let taskId = null;

            try {
                const role = entities.role.find(r => r.id === roleId);
                const person = personId ? entities.person.find(p => p.id === personId) : null;
                const workflow = workflowId ? entities.workflow.find(w => w.id === workflowId) : null;

                // 1. Create task entity with enhanced fields
                taskId = 'task' + Date.now();
                const taskObject = {
                    id: taskId,
                    name: taskName,
                    type: 'task',
                    description: description,
                    dueDate: dueDate || null,
                    predecessorId: predecessorId || null,
                    status: 'pending',
                    priority: selectedPriority || 'medium',
                    tags: [...heroTaskTags], // Copy tags array
                    collaborators: [...heroCollaborators], // Copy collaborators array
                    recurring: recurringValue || null,
                    producesProductId: null,
                    followsWorkflowId: workflowId || null,
                    createdAt: new Date().toISOString()
                };
                entities.task.push(taskObject);

                logActivityToXano({
                    event_verb: 'Add Entity',
                    eo_operator: 'INS',
                    object_type: 'task',
                    object_id: taskId,
                    object_label: taskName,
                    data_json: {
                        entity_name: taskName,
                        description: description,
                        dueDate: dueDate || null,
                        status: 'pending',
                        priority: selectedPriority || 'medium',
                        predecessorId: predecessorId || null,
                        tags: [...heroTaskTags],
                        collaborators: [...heroCollaborators],
                        recurring: recurringValue || null,
                        followsWorkflowId: workflowId || null
                    }
                });

                // 2. Connect workflow to task (Workflow CON Task) - only if workflow is selected
                if (workflow) {
                    const workflowTaskRelId = 'rel' + Date.now();
                    const workflowTaskRel = {
                        id: workflowTaskRelId,
                        subject: workflowId,
                        predicate: 'CON',
                        object: taskId,
                        description: ''
                    };
                    relationships.push(workflowTaskRel);

                    logActivityToXano({
                        event_verb: 'Link Connection',
                        eo_operator: 'CON',
                        object_type: 'relationship',
                        object_id: workflowTaskRelId,
                        object_label: `${workflow.name} → ${taskName}`,
                        data_json: {
                            subject_id: workflowId,
                            predicate: 'CON',
                            target_id: taskId
                        }
                    });
                }

                // 3. Connect role to task (Role CON Task) - only if role is selected
                if (role) {
                    const roleTaskRelId = 'rel' + (Date.now() + 1);
                    const roleTaskRel = {
                        id: roleTaskRelId,
                        subject: role.id,
                        predicate: 'CON',
                        object: taskId,
                        description: ''
                    };
                    relationships.push(roleTaskRel);

                    logActivityToXano({
                        event_verb: 'Link Connection',
                        eo_operator: 'CON',
                        object_type: 'relationship',
                        object_id: roleTaskRelId,
                        object_label: `${role.name} → ${taskName}`,
                        data_json: {
                            subject_id: role.id,
                            predicate: 'CON',
                            target_id: taskId
                        }
                    });

                    // Track team usage for "most used team" feature
                    const teamId = getTeamForRole(role.id);
                    if (teamId) {
                        trackTeamUsage(teamId);
                    }
                }

                // 4. If person selected and role selected, assign person to role (Person INS Role)
                if (person && role) {
                    const existingAssignment = relationships.find(r =>
                        r.subject === person.id &&
                        r.predicate === 'INS' &&
                        r.object === role.id
                    );

                    if (!existingAssignment) {
                        const personRoleRelId = 'rel' + (Date.now() + 2);
                        const personRoleRel = {
                            id: personRoleRelId,
                            subject: person.id,
                            predicate: 'INS',
                            object: role.id,
                            description: ''
                        };
                        relationships.push(personRoleRel);

                        logActivityToXano({
                            event_verb: 'Start Assignment',
                            eo_operator: 'INS',
                            object_type: 'relationship',
                            object_id: personRoleRelId,
                            object_label: `${person.name} → ${role.name}`,
                            data_json: {
                                subject_id: person.id,
                                predicate: 'INS',
                                target_id: role.id
                            }
                        });
                    }
                }

                // Save to local storage first (most important)
                saveToLocalStorage();

                // Trigger automation rules for task assignment
                if (role) {
                    executeAutomationRules('task_assigned', { roleId: roleId, taskId: taskId });
                }

                console.log('Task created via hero modal:', taskName);
            } catch (error) {
                console.error('Error creating task:', error);
            }

            // Always close modal, even if there was an error
            closeHeroTaskModal();

            // Refresh UI in a try-catch to prevent errors from blocking
            try {
                renderEntityList();
                renderActivityList();
                populateSelects();
                updateTaskCountBadge();
                renderTaskBoardView();
                // Also refresh the current view (kanban, table, timeline, etc.)
                if (currentView === 'kanban') {
                    renderKanbanBoard();
                } else if (currentView === 'table') {
                    renderTaskTable();
                } else if (currentView === 'timeline') {
                    renderTimeline();
                } else if (currentView === 'gantt') {
                    renderGanttView();
                } else if (currentView === 'calendar') {
                    renderCalendarView();
                }
            } catch (renderError) {
                console.error('Error refreshing UI after task creation:', renderError);
            }

            // Check for pattern emergence (similar tasks or linked chains)
            // Use setTimeout to allow UI to update first
            if (taskId) {
                setTimeout(() => {
                    try {
                        checkForPatternEmergence(taskId);
                    } catch (patternError) {
                        console.error('Error checking pattern emergence:', patternError);
                    }
                }, 500);
            }
        }

        // ============================================
        // TASK SEQUENCE (COLLAPSIBLE LINKED TASKS) FUNCTIONS
        // ============================================

        // Track collapsed state of task sequences (persisted in session)
        const collapsedSequences = new Set();

        // Toggle a task sequence collapsed/expanded state
        function toggleTaskSequence(rootTaskId, event) {
            if (event) {
                event.stopPropagation();
            }

            if (collapsedSequences.has(rootTaskId)) {
                collapsedSequences.delete(rootTaskId);
            } else {
                collapsedSequences.add(rootTaskId);
            }

            // Re-render the current view
            const currentView = document.querySelector('.view-toggle-btn.active')?.dataset?.view;
            if (currentView === 'kanban') {
                renderKanbanBoard();
            } else if (currentView === 'table') {
                renderTaskTable();
            } else {
                renderTaskBoardView();
            }
        }

        // Get all tasks in a sequence starting from a root task
        // Returns array of tasks in order: [root, child1, child2, ...]
        function getTaskSequence(rootTaskId) {
            const sequence = [];
            const root = (entities.task || []).find(t => t.id === rootTaskId);
            if (!root) return sequence;

            sequence.push(root);

            // Recursively get all descendants
            function addDescendants(parentId) {
                const children = (entities.task || [])
                    .filter(t => t.predecessorId === parentId)
                    .sort((a, b) => {
                        // Sort by orderIndex descending (higher = first to do = top of list)
                        const orderA = a.orderIndex ?? new Date(a.createdAt).getTime();
                        const orderB = b.orderIndex ?? new Date(b.createdAt).getTime();
                        return orderB - orderA;
                    });

                children.forEach(child => {
                    sequence.push(child);
                    addDescendants(child.id);
                });
            }

            addDescendants(rootTaskId);
            return sequence;
        }

        // Find the root task of a sequence (the task with no predecessor, or the top-level ancestor)
        function findSequenceRoot(taskId) {
            const task = (entities.task || []).find(t => t.id === taskId);
            if (!task) return null;

            if (!task.predecessorId) return task;

            // Walk up the chain to find the root
            let current = task;
            while (current.predecessorId) {
                const parent = (entities.task || []).find(t => t.id === current.predecessorId);
                if (!parent) break;
                current = parent;
            }
            return current;
        }

        // Get all root tasks (tasks that have dependents but no predecessor themselves)
        function getRootTasks() {
            const tasks = entities.task || [];
            const tasksWithDependents = new Set();

            tasks.forEach(t => {
                if (t.predecessorId) {
                    tasksWithDependents.add(t.predecessorId);
                }
            });

            // Root tasks are those that have dependents but no predecessor
            return tasks.filter(t => !t.predecessorId && tasksWithDependents.has(t.id));
        }

        // Check if a task is part of a sequence (has predecessor or has dependents)
        function isPartOfSequence(taskId) {
            const task = (entities.task || []).find(t => t.id === taskId);
            if (!task) return false;

            // Has a predecessor?
            if (task.predecessorId) return true;

            // Has dependents?
            const hasDependents = (entities.task || []).some(t => t.predecessorId === taskId);
            return hasDependents;
        }

        // ============================================
        // TASK BOARD VIEW FUNCTIONS
        // ============================================

        // Render a single task card for board view
        function renderBoardTaskCard(task, isInSequence = false) {
            // Find connected role
            const roleRel = relationships.find(r =>
                r.object === task.id && r.predicate === 'CON'
            );
            const role = roleRel ? entities.role.find(r => r.id === roleRel.subject) : null;

            // Find person assigned to role
            let person = null;
            let roleParent = null;
            if (role) {
                const personRel = relationships.find(r =>
                    r.object === role.id && r.predicate === 'INS'
                );
                person = personRel ? entities.person.find(p => p.id === personRel.subject) : null;

                // Find role's parent team/unit for structural context
                const parentRel = relationships.find(r =>
                    r.predicate === 'DES' && r.object === role.id
                );
                if (parentRel) {
                    roleParent = findEntity(parentRel.subject);
                }
            }

            // Check date status
            const dueDateStatus = getTaskDueDateStatus(task);

            return `
                <div class="task-board-card ${dueDateStatus}" onclick="showEntityDetails('${task.id}')">
                    <div class="task-board-card-header">
                        <div class="task-board-card-title">
                            <i class="ph ph-file-text"></i>
                            ${task.name}
                        </div>
                        <button class="task-board-card-menu" onclick="event.stopPropagation(); showTaskCardMenu('${task.id}')">
                            <i class="ph ph-dots-three-vertical"></i>
                        </button>
                    </div>
                    <div class="task-board-card-meta">
                        ${role ? `
                            <span class="task-board-card-tag role">
                                <i class="ph ph-briefcase"></i>
                                ${role.name}${person ? ` <i class="ph ph-arrow-right" style="font-size: 0.7rem; opacity: 0.5; margin: 0 0.15rem;"></i> ${person.name}` : ''}
                            </span>
                        ` : ''}
                        ${task.dueDate ? `
                            <span class="task-board-card-tag due-date ${dueDateStatus}">
                                <i class="ph ph-calendar"></i>
                                ${formatDateShort(task.dueDate)}
                            </span>
                        ` : ''}
                    </div>
                    ${roleParent ? `
                        <div class="task-board-card-structure">
                            <i class="ph ph-${roleParent.type === 'unit' ? 'buildings' : 'users-three'}"></i>
                            ${roleParent.name}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Render the task board view
        function renderTaskBoardView() {
            const content = document.getElementById('taskBoardContent');
            const tasks = entities.task || [];

            // Update total count
            document.getElementById('taskBoardTotal').textContent = tasks.length;
            updateTaskCountBadge();

            // Get the FAB element
            const fab = document.querySelector('.task-fab');

            if (tasks.length === 0) {
                // Hide FAB when empty state is shown (empty state has its own Create Task button)
                if (fab) fab.style.display = 'none';

                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-clipboard-text"></i>
                        <h3>No tasks yet</h3>
                        <p>Start by creating a task. As you assign roles and people,<br>your organizational structure will emerge.</p>
                        <button class="hero-task-btn hero-task-btn-primary" onclick="openHeroTaskModal()" style="padding: 0.75rem 1.25rem;">
                            <i class="ph ph-plus"></i> Create Task
                        </button>
                        <div class="empty-state-hint">
                            <kbd>T</kbd> to create task · <kbd>Cmd+K</kbd> for commands
                        </div>
                    </div>
                `;
                return;
            }

            // Show FAB when there are tasks
            if (fab) fab.style.display = 'flex';

            // Get search/filter values
            const searchTerm = (document.getElementById('taskBoardSearch').value || '').toLowerCase();
            const filterValue = document.getElementById('taskBoardFilter').value;

            // Filter tasks
            let filteredTasks = tasks.filter(task => {
                // Search filter
                if (searchTerm && !task.name.toLowerCase().includes(searchTerm)) {
                    return false;
                }

                // Role filter
                if (filterValue === 'unassigned') {
                    const hasRole = relationships.some(r =>
                        r.object === task.id && r.predicate === 'CON'
                    );
                    if (hasRole) return false;
                }

                return true;
            });

            if (filteredTasks.length === 0) {
                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-magnifying-glass"></i>
                        <h3>No matching tasks</h3>
                        <p>Try adjusting your search or filters</p>
                    </div>
                `;
                return;
            }

            // Build task cards - group linked tasks into collapsible sequences
            let html = '<div class="task-board-list">';

            // Track which tasks have been rendered (to avoid duplicates)
            const renderedTasks = new Set();

            // First, identify root tasks (tasks with dependents but no predecessor)
            const rootTasks = filteredTasks.filter(t => {
                const hasDependents = filteredTasks.some(d => d.predecessorId === t.id);
                return !t.predecessorId && hasDependents;
            });

            // Render root tasks with their sequences
            rootTasks.forEach(rootTask => {
                const sequence = getTaskSequence(rootTask.id).filter(t =>
                    filteredTasks.some(ft => ft.id === t.id)
                );

                if (sequence.length === 0) return;

                // Mark all tasks in this sequence as rendered
                sequence.forEach(t => renderedTasks.add(t.id));

                const isCollapsed = collapsedSequences.has(rootTask.id);
                const dependentCount = sequence.length - 1;

                html += `
                    <div class="board-task-sequence ${isCollapsed ? 'collapsed' : ''}" data-root-id="${rootTask.id}">
                        <div class="board-sequence-header">
                            <div class="board-sequence-toggle" onclick="toggleTaskSequence('${rootTask.id}', event)" title="${isCollapsed ? 'Expand' : 'Collapse'} sequence">
                                <i class="ph ph-caret-down"></i>
                            </div>
                            ${renderBoardTaskCard(rootTask, true)}
                        </div>
                        <div class="board-sequence-content">
                `;

                // Render dependent tasks in the sequence (skip the root)
                sequence.slice(1).forEach(task => {
                    html += renderBoardTaskCard(task, true);
                });

                html += `
                        </div>
                    </div>
                `;
            });

            // Render standalone tasks (no predecessor and no dependents in filtered set)
            filteredTasks.forEach(task => {
                if (renderedTasks.has(task.id)) return;

                // Check if this task is part of a sequence that wasn't fully in the filtered set
                if (task.predecessorId) {
                    // This is a dependent task whose root wasn't in the filtered set
                    // Find its root or the highest ancestor in filtered set
                    let rootId = task.predecessorId;
                    let root = filteredTasks.find(t => t.id === rootId);

                    // If root is in filtered and not rendered, render it as a sequence
                    if (root && !renderedTasks.has(root.id)) {
                        const sequence = getTaskSequence(root.id).filter(t =>
                            filteredTasks.some(ft => ft.id === t.id)
                        );

                        if (sequence.length > 1) {
                            sequence.forEach(t => renderedTasks.add(t.id));

                            const isCollapsed = collapsedSequences.has(root.id);

                            html += `
                                <div class="board-task-sequence ${isCollapsed ? 'collapsed' : ''}" data-root-id="${root.id}">
                                    <div class="board-sequence-header">
                                        <div class="board-sequence-toggle" onclick="toggleTaskSequence('${root.id}', event)" title="${isCollapsed ? 'Expand' : 'Collapse'} sequence">
                                            <i class="ph ph-caret-down"></i>
                                        </div>
                                        ${renderBoardTaskCard(root, true)}
                                    </div>
                                    <div class="board-sequence-content">
                            `;

                            sequence.slice(1).forEach(seqTask => {
                                html += renderBoardTaskCard(seqTask, true);
                            });

                            html += `
                                    </div>
                                </div>
                            `;
                            return;
                        }
                    }
                }

                // Skip if already rendered
                if (renderedTasks.has(task.id)) return;

                // Render as standalone task
                renderedTasks.add(task.id);
                html += renderBoardTaskCard(task, false);
            });

            html += '</div>';
            content.innerHTML = html;
        }

        // Filter task board
        function filterTaskBoard() {
            renderTaskBoardView();
        }

        // Update task count badge
        function updateTaskCountBadge() {
            const badge = document.getElementById('taskCountBadge');
            if (!badge) return; // Badge element may not exist

            const count = (entities.task || []).length;

            if (count > 0) {
                badge.textContent = count;
                badge.style.display = 'block';
            } else {
                badge.style.display = 'none';
            }
        }

        // Show task card menu (placeholder for future enhancement)
        function showTaskCardMenu(taskId) {
            // For now, show entity details
            showEntityDetails(taskId);
        }

        // ============================================
        // KANBAN BOARD VIEW
        // ============================================

        let draggedTaskId = null;

        // Get all subtasks (children) of a parent task, sorted by orderIndex (first to complete at top)
        function getSubtasks(parentTaskId) {
            return (entities.task || [])
                .filter(t => t.predecessorId === parentTaskId)
                .sort((a, b) => {
                    // Sort by orderIndex descending (higher = first to do = top of list)
                    // This matches workflow where tasks added first (lower orderIndex) are done last
                    // Fallback to createdAt for backward compatibility
                    const orderA = a.orderIndex ?? new Date(a.createdAt).getTime();
                    const orderB = b.orderIndex ?? new Date(b.createdAt).getTime();
                    return orderB - orderA;
                });
        }

        // Get all related task IDs (parent and all its subtasks)
        function getRelatedTaskIds(taskId) {
            const task = entities.task.find(t => t.id === taskId);
            if (!task) return [taskId];

            // Get subtasks of this task
            const subtasks = getSubtasks(taskId);

            // If this task has a predecessor, include sibling subtasks
            if (task.predecessorId) {
                const siblings = getSubtasks(task.predecessorId);
                return [task.predecessorId, taskId, ...siblings.map(s => s.id)];
            }

            // This is a parent task with subtasks
            if (subtasks.length > 0) {
                return [taskId, ...subtasks.map(s => s.id)];
            }

            return [taskId];
        }

        // Render a single kanban card
        function renderKanbanCard(task) {
            // Get role and person info
            const roleRel = relationships.find(r => r.object === task.id && r.predicate === 'CON');
            const role = roleRel ? entities.role.find(r => r.id === roleRel.subject) : null;
            let person = null;
            if (role) {
                const personRel = relationships.find(r => r.object === role.id && r.predicate === 'INS');
                person = personRel ? entities.person.find(p => p.id === personRel.subject) : null;
            }

            const dueDateStatus = getTaskDueDateStatus(task);

            // Check if this is a parent (has subtasks) or a subtask
            const subtasks = getSubtasks(task.id);
            const hasSubtasks = subtasks.length > 0;

            // Build card classes (no subtask-specific classes since we're grouping them)
            let cardClasses = `kanban-card ${dueDateStatus}`;

            // Build subtask progress info for parent tasks
            const completedSubtasks = subtasks.filter(s => s.status === 'completed').length;

            // Determine movement restrictions for parent tasks
            let movementNote = '';
            if (hasSubtasks) {
                const pendingSubtasks = subtasks.filter(s => s.status === 'pending').length;
                if (completedSubtasks < subtasks.length) {
                    movementNote = `Cannot move to "Done" until all ${subtasks.length} subtasks are complete`;
                }
                if (pendingSubtasks > 0) {
                    movementNote = `Cannot move to "In Progress" or "Done" - ${pendingSubtasks} subtask(s) still in "To Do"`;
                }
            }

            return `
                <div class="${cardClasses}"
                     draggable="true"
                     data-id="${task.id}"
                     data-predecessor-id="${task.predecessorId || ''}"
                     ondragstart="handleKanbanDragStart(event)"
                     ondragend="handleKanbanDragEnd(event)"
                     onclick="showEntityDetails('${task.id}')">
                    <div class="kanban-card-title" style="display: flex; align-items: center; gap: 0.5rem;">
                        ${task.name}
                        ${hasSubtasks ? `<span class="kanban-card-subtask-badge" title="${completedSubtasks} of ${subtasks.length} subtasks complete${movementNote ? ' - ' + movementNote : ''}"><i class="ph ph-list-checks"></i> ${completedSubtasks}/${subtasks.length}</span>` : ''}
                    </div>
                    <div class="kanban-card-meta">
                        ${person ? `<span class="kanban-card-assignee" ${role ? `title="Role: ${role.name}"` : ''}><i class="ph ph-user-circle"></i> ${person.name}</span>` :
                          (role ? `<span class="kanban-card-assignee kanban-card-role-only" title="No person assigned to this role"><i class="ph ph-briefcase"></i> ${role.name}</span>` : '')}
                        ${task.dueDate ? `<span class="kanban-card-due ${dueDateStatus}"><i class="ph ph-calendar"></i> ${formatDateShort(task.dueDate)}</span>` : ''}
                    </div>
                </div>
            `;
        }

        function renderKanbanBoard() {
            const content = document.getElementById('taskBoardContent');
            const allTasks = entities.task || [];
            const tasks = getAdvancedFilteredTasks(); // Apply advanced filters

            // Update total count (show filtered/total)
            const totalEl = document.getElementById('taskBoardTotal');
            if (tasks.length !== allTasks.length) {
                totalEl.textContent = `${tasks.length}/${allTasks.length}`;
            } else {
                totalEl.textContent = tasks.length;
            }
            updateTaskCountBadge();

            const fab = document.querySelector('.task-fab');

            if (allTasks.length === 0) {
                if (fab) fab.style.display = 'none';
                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-columns"></i>
                        <h3>No tasks yet</h3>
                        <p>Create tasks to see them organized by status on this Kanban board.</p>
                        <button class="hero-task-btn hero-task-btn-primary" onclick="openHeroTaskModal()" style="padding: 0.75rem 1.25rem;">
                            <i class="ph ph-plus"></i> Create Task
                        </button>
                    </div>
                `;
                return;
            }

            if (tasks.length === 0 && allTasks.length > 0) {
                if (fab) fab.style.display = 'flex';
                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-funnel"></i>
                        <h3>No matching tasks</h3>
                        <p>No tasks match your current filters. Try adjusting the filter criteria.</p>
                        <button class="hero-task-btn hero-task-btn-secondary" onclick="openAdvancedFilterPanel()" style="padding: 0.75rem 1.25rem;">
                            <i class="ph ph-funnel"></i> Adjust Filters
                        </button>
                    </div>
                `;
                return;
            }

            if (fab) fab.style.display = 'flex';

            const statuses = [
                { key: 'pending', label: 'To Do', icon: 'ph-circle-dashed' },
                { key: 'in_progress', label: 'In Progress', icon: 'ph-spinner' },
                { key: 'completed', label: 'Done', icon: 'ph-check-circle' }
            ];

            // Build content-level filter bar
            const hasAdvancedFilters = advancedFilters.priority.length !== 3 ||
                advancedFilters.dateFrom || advancedFilters.dateTo || advancedFilters.datePreset ||
                advancedFilters.assignees.length > 0 || advancedFilters.tags.length > 0;
            const activeFilterCount = getActiveAdvancedFilterCount();

            let html = `
                <div class="content-filter-bar">
                    <div class="content-filter-left">
                        <div class="content-filter-group">
                            <button class="content-filter-chip ${advancedFilters.status.includes('pending') ? 'active' : ''}"
                                    onclick="toggleInlineStatusFilter('pending')" title="To Do tasks">
                                <i class="ph ph-circle-dashed"></i>
                                <span>To Do</span>
                                <span class="content-filter-count">${tasks.filter(t => t.status === 'pending').length}</span>
                            </button>
                            <button class="content-filter-chip ${advancedFilters.status.includes('in_progress') ? 'active' : ''}"
                                    onclick="toggleInlineStatusFilter('in_progress')" title="In Progress tasks">
                                <i class="ph ph-spinner"></i>
                                <span>In Progress</span>
                                <span class="content-filter-count">${tasks.filter(t => t.status === 'in_progress').length}</span>
                            </button>
                            <button class="content-filter-chip ${advancedFilters.status.includes('completed') ? 'active' : ''}"
                                    onclick="toggleInlineStatusFilter('completed')" title="Done tasks">
                                <i class="ph ph-check-circle"></i>
                                <span>Done</span>
                                <span class="content-filter-count">${tasks.filter(t => t.status === 'completed').length}</span>
                            </button>
                        </div>
                    </div>
                    <div class="content-filter-right">
                        <button class="content-filter-more ${hasAdvancedFilters ? 'has-filters' : ''}" onclick="openAdvancedFilterPanel()">
                            <i class="ph ph-funnel"></i>
                            <span>Filter</span>
                            ${activeFilterCount > 0 ? `<span class="content-filter-badge">${activeFilterCount}</span>` : ''}
                        </button>
                    </div>
                </div>
            `;

            html += '<div class="kanban-board">';

            statuses.forEach(status => {
                // Get tasks for this column
                const columnTasks = tasks.filter(t => t.status === status.key);

                // Group tasks by their sequence root
                const tasksByRoot = new Map(); // rootId -> [tasks in sequence in this column]
                const standaloneTasks = [];
                const processedTasks = new Set();

                columnTasks.forEach(task => {
                    if (processedTasks.has(task.id)) return;

                    // Find the root of this task's sequence
                    const root = findSequenceRoot(task.id);

                    if (root) {
                        // Get all tasks in this sequence that are in this column
                        const fullSequence = getTaskSequence(root.id);
                        const sequenceInColumn = fullSequence.filter(t => t.status === status.key);

                        if (sequenceInColumn.length > 1) {
                            // This is a multi-task sequence in this column
                            tasksByRoot.set(root.id, sequenceInColumn);
                            sequenceInColumn.forEach(t => processedTasks.add(t.id));
                        } else if (sequenceInColumn.length === 1) {
                            // Only one task from this sequence in this column
                            standaloneTasks.push(task);
                            processedTasks.add(task.id);
                        }
                    } else {
                        standaloneTasks.push(task);
                        processedTasks.add(task.id);
                    }
                });

                html += `
                    <div class="kanban-column" data-status="${status.key}">
                        <div class="kanban-column-header">
                            <i class="ph ${status.icon}"></i>
                            <span>${status.label}</span>
                            <span class="kanban-column-count">${columnTasks.length}</span>
                        </div>
                        <div class="kanban-column-content"
                             ondrop="handleKanbanDrop(event)"
                             ondragover="handleKanbanDragOver(event)"
                             ondragleave="handleKanbanDragLeave(event)">
                `;

                // Render sequences first
                tasksByRoot.forEach((sequenceTasks, rootId) => {
                    const isCollapsed = collapsedSequences.has(rootId);
                    const firstTask = sequenceTasks[0];
                    const restTasks = sequenceTasks.slice(1);

                    html += `
                        <div class="kanban-task-sequence ${isCollapsed ? 'collapsed' : ''}" data-root-id="${rootId}">
                            <div class="kanban-sequence-header">
                                <div class="kanban-sequence-toggle" onclick="toggleTaskSequence('${rootId}', event)" title="${isCollapsed ? 'Expand' : 'Collapse'} sequence (${sequenceTasks.length} tasks)">
                                    <i class="ph ph-caret-down"></i>
                                </div>
                                ${renderKanbanCard(firstTask)}
                            </div>
                            <div class="kanban-sequence-content">
                    `;

                    restTasks.forEach(task => {
                        html += renderKanbanCard(task);
                    });

                    html += `
                            </div>
                        </div>
                    `;
                });

                // Render standalone tasks
                standaloneTasks.forEach(task => {
                    html += renderKanbanCard(task);
                });

                html += `
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            content.innerHTML = html;
        }

        function handleKanbanDragStart(event) {
            // Use currentTarget to get the card element even if drag started from a child
            draggedTaskId = event.currentTarget.dataset.id;
            event.currentTarget.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', draggedTaskId);

            // Get related tasks (parent, siblings, or subtasks)
            const relatedIds = getRelatedTaskIds(draggedTaskId);
            const hasSubtasks = getSubtasks(draggedTaskId).length > 0;

            // Highlight related tasks and fade unrelated ones
            document.querySelectorAll('.kanban-card').forEach(card => {
                const cardId = card.dataset.id;
                if (relatedIds.includes(cardId)) {
                    if (cardId !== draggedTaskId) {
                        card.classList.add('subtask-related');
                    }
                } else {
                    card.classList.add('subtask-faded');
                }
            });

            // Draw connection lines if there are related tasks
            if (relatedIds.length > 1) {
                drawSubtaskConnections(draggedTaskId, relatedIds);
            }

            // Show warning hint on columns where movement will need confirmation
            const task = entities.task.find(t => t.id === draggedTaskId);
            if (task && task.predecessorId) {
                const predecessor = entities.task.find(t => t.id === task.predecessorId);
                if (predecessor) {
                    const predecessorStatusOrder = getStatusOrder(predecessor.status);

                    document.querySelectorAll('.kanban-column').forEach(column => {
                        const targetStatus = column.dataset.status;
                        const targetOrder = getStatusOrder(targetStatus);
                        const columnContent = column.querySelector('.kanban-column-content');

                        // Show warning hint if subtask would move beyond predecessor's status
                        if (targetOrder > predecessorStatusOrder) {
                            columnContent.classList.add('drop-warning');
                            const targetStatusLabel = targetStatus === 'completed' ? 'Done' : (targetStatus === 'in_progress' ? 'In Progress' : 'To Do');
                            columnContent.dataset.warningReason = `⚠ "${predecessor.name}" is not "${targetStatusLabel}" yet`;
                        }
                    });
                }
            }
        }

        function handleKanbanDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
            draggedTaskId = null;

            // Remove all visual states
            document.querySelectorAll('.kanban-column-content').forEach(col => {
                col.classList.remove('drag-over');
                col.classList.remove('drop-warning');
                delete col.dataset.warningReason;
            });

            // Remove highlight/fade from all cards
            document.querySelectorAll('.kanban-card').forEach(card => {
                card.classList.remove('subtask-related');
                card.classList.remove('subtask-faded');
            });

            // Remove connection lines
            removeSubtaskConnections();
        }

        function handleKanbanDragOver(event) {
            event.preventDefault();
            const columnContent = event.currentTarget;
            columnContent.classList.add('drag-over');
        }

        function handleKanbanDragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }

        function handleKanbanDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');

            if (!draggedTaskId) return;

            const newStatus = event.currentTarget.parentElement.dataset.status;
            const task = entities.task.find(t => t.id === draggedTaskId);
            const taskId = draggedTaskId; // Capture for closure

            if (!task || task.status === newStatus) return;

            const warnings = checkTaskMoveWarning(taskId, newStatus);

            const executeMove = () => {
                const t = entities.task.find(t => t.id === taskId);
                if (!t) return;

                t.status = newStatus;
                saveToLocalStorage();

                logActivityToXano({
                    event_verb: 'Update Status',
                    object_type: 'task',
                    object_label: `${t.name} → ${newStatus}`
                });

                renderKanbanBoard();
            };

            if (warnings) {
                const warningMessages = warnings.map(w => w.message).join('<br><br>');
                const title = `Move to "${getStatusLabel(newStatus)}"?`;
                showTaskConfirmModal(title, warningMessages, executeMove);
            } else {
                executeMove();
            }
        }

        // Draw SVG lines connecting parent to subtasks
        function drawSubtaskConnections(draggedId, relatedIds) {
            // Remove any existing connector
            removeSubtaskConnections();

            const draggedCard = document.querySelector(`.kanban-card[data-id="${draggedId}"]`);
            if (!draggedCard) return;

            // Create SVG overlay
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('kanban-subtask-connector');
            svg.style.position = 'fixed';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '1000';

            const draggedRect = draggedCard.getBoundingClientRect();
            const draggedCenterX = draggedRect.left + draggedRect.width / 2;
            const draggedCenterY = draggedRect.top + draggedRect.height / 2;

            // Draw lines to each related card (except the dragged one)
            relatedIds.forEach(id => {
                if (id === draggedId) return;

                const relatedCard = document.querySelector(`.kanban-card[data-id="${id}"]`);
                if (!relatedCard) return;

                const relatedRect = relatedCard.getBoundingClientRect();
                const relatedCenterX = relatedRect.left + relatedRect.width / 2;
                const relatedCenterY = relatedRect.top + relatedRect.height / 2;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', draggedCenterX);
                line.setAttribute('y1', draggedCenterY);
                line.setAttribute('x2', relatedCenterX);
                line.setAttribute('y2', relatedCenterY);

                svg.appendChild(line);
            });

            document.body.appendChild(svg);
        }

        // Remove connection lines
        function removeSubtaskConnections() {
            const existing = document.querySelector('.kanban-subtask-connector');
            if (existing) {
                existing.remove();
            }
        }

        // ============================================
        // TABLE VIEW
        // ============================================

        let tableSortColumn = 'name';
        let tableSortDirection = 'asc';

        function renderTaskTable() {
            const content = document.getElementById('taskBoardContent');
            const allTasks = entities.task || [];
            const tasks = getAdvancedFilteredTasks(); // Apply advanced filters

            // Update total count (show filtered/total)
            const totalEl = document.getElementById('taskBoardTotal');
            if (tasks.length !== allTasks.length) {
                totalEl.textContent = `${tasks.length}/${allTasks.length}`;
            } else {
                totalEl.textContent = tasks.length;
            }
            updateTaskCountBadge();

            const fab = document.querySelector('.task-fab');

            if (allTasks.length === 0) {
                if (fab) fab.style.display = 'none';
                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-table"></i>
                        <h3>No tasks yet</h3>
                        <p>Create tasks to see them in a table format.</p>
                        <button class="hero-task-btn hero-task-btn-primary" onclick="openHeroTaskModal()" style="padding: 0.75rem 1.25rem;">
                            <i class="ph ph-plus"></i> Create Task
                        </button>
                    </div>
                `;
                return;
            }

            if (tasks.length === 0 && allTasks.length > 0) {
                if (fab) fab.style.display = 'flex';
                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-funnel"></i>
                        <h3>No matching tasks</h3>
                        <p>No tasks match your current filters. Try adjusting the filter criteria.</p>
                        <button class="hero-task-btn hero-task-btn-secondary" onclick="openAdvancedFilterPanel()" style="padding: 0.75rem 1.25rem;">
                            <i class="ph ph-funnel"></i> Adjust Filters
                        </button>
                    </div>
                `;
                return;
            }

            if (fab) fab.style.display = 'flex';

            // Sort tasks
            const sortedTasks = [...tasks].sort((a, b) => {
                let aVal, bVal;
                switch(tableSortColumn) {
                    case 'name':
                        aVal = a.name.toLowerCase();
                        bVal = b.name.toLowerCase();
                        break;
                    case 'status':
                        aVal = a.status;
                        bVal = b.status;
                        break;
                    case 'dueDate':
                        aVal = a.dueDate || '9999-12-31';
                        bVal = b.dueDate || '9999-12-31';
                        break;
                    case 'role':
                        const roleRelA = relationships.find(r => r.object === a.id && r.predicate === 'CON');
                        const roleA = roleRelA ? entities.role.find(r => r.id === roleRelA.subject) : null;
                        const roleRelB = relationships.find(r => r.object === b.id && r.predicate === 'CON');
                        const roleB = roleRelB ? entities.role.find(r => r.id === roleRelB.subject) : null;
                        aVal = roleA ? roleA.name.toLowerCase() : 'zzz';
                        bVal = roleB ? roleB.name.toLowerCase() : 'zzz';
                        break;
                    default:
                        aVal = a.name.toLowerCase();
                        bVal = b.name.toLowerCase();
                }
                if (tableSortDirection === 'asc') {
                    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                } else {
                    return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                }
            });

            const getSortIcon = (column) => {
                if (tableSortColumn === column) {
                    return tableSortDirection === 'asc' ? 'ph-caret-up' : 'ph-caret-down';
                }
                return 'ph-caret-up-down';
            };

            let html = `
                <div class="task-table-container">
                    <table class="task-table">
                        <thead>
                            <tr>
                                <th onclick="sortTaskTable('name')" class="sortable">
                                    Name <i class="ph ${getSortIcon('name')}"></i>
                                </th>
                                <th onclick="sortTaskTable('status')" class="sortable">
                                    Status <i class="ph ${getSortIcon('status')}"></i>
                                </th>
                                <th onclick="sortTaskTable('role')" class="sortable">
                                    Role <i class="ph ${getSortIcon('role')}"></i>
                                </th>
                                <th>Person</th>
                                <th>Workflow</th>
                                <th onclick="sortTaskTable('dueDate')" class="sortable">
                                    Due Date <i class="ph ${getSortIcon('dueDate')}"></i>
                                </th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            sortedTasks.forEach(task => {
                const roleRel = relationships.find(r => r.object === task.id && r.predicate === 'CON');
                const role = roleRel ? entities.role.find(r => r.id === roleRel.subject) : null;
                let person = null;
                if (role) {
                    const personRel = relationships.find(r => r.object === role.id && r.predicate === 'INS');
                    person = personRel ? entities.person.find(p => p.id === personRel.subject) : null;
                }
                const workflow = task.followsWorkflowId ? entities.workflow?.find(w => w.id === task.followsWorkflowId) : null;
                const dueDateStatus = getTaskDueDateStatus(task);

                const statusLabels = {
                    'pending': 'To Do',
                    'in_progress': 'In Progress',
                    'completed': 'Done'
                };

                html += `
                    <tr onclick="showEntityDetails('${task.id}')" style="cursor: pointer;">
                        <td class="task-table-name">
                            <i class="ph ph-file-text"></i> ${task.name}
                        </td>
                        <td>
                            <span class="task-table-status ${task.status}">${statusLabels[task.status] || task.status}</span>
                        </td>
                        <td>${role ? role.name : '<span class="task-table-empty">Unassigned</span>'}</td>
                        <td>${person ? person.name : '<span class="task-table-empty">-</span>'}</td>
                        <td>${workflow ? workflow.name : '<span class="task-table-empty">-</span>'}</td>
                        <td class="${dueDateStatus}">
                            ${task.dueDate ? formatDateShort(task.dueDate) : '<span class="task-table-empty">-</span>'}
                        </td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            content.innerHTML = html;
        }

        function sortTaskTable(column) {
            if (tableSortColumn === column) {
                tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                tableSortColumn = column;
                tableSortDirection = 'asc';
            }
            renderTaskTable();
        }

        // ============================================
        // TIMELINE VIEW
        // ============================================

        function renderTimeline() {
            const content = document.getElementById('taskBoardContent');
            const allTasks = entities.task || [];
            const tasks = getAdvancedFilteredTasks(); // Apply advanced filters

            // Update total count (show filtered/total)
            const totalEl = document.getElementById('taskBoardTotal');
            if (tasks.length !== allTasks.length) {
                totalEl.textContent = `${tasks.length}/${allTasks.length}`;
            } else {
                totalEl.textContent = tasks.length;
            }
            updateTaskCountBadge();

            const fab = document.querySelector('.task-fab');

            // Filter tasks with due dates
            const tasksWithDates = tasks.filter(t => t.dueDate);

            if (allTasks.length === 0) {
                if (fab) fab.style.display = 'none';
                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-calendar-blank"></i>
                        <h3>No tasks yet</h3>
                        <p>Create tasks with due dates to see them on the timeline.</p>
                        <button class="hero-task-btn hero-task-btn-primary" onclick="openHeroTaskModal()" style="padding: 0.75rem 1.25rem;">
                            <i class="ph ph-plus"></i> Create Task
                        </button>
                    </div>
                `;
                return;
            }

            if (fab) fab.style.display = 'flex';

            if (tasks.length === 0 && allTasks.length > 0) {
                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-funnel"></i>
                        <h3>No matching tasks</h3>
                        <p>No tasks match your current filters. Try adjusting the filter criteria.</p>
                        <button class="hero-task-btn hero-task-btn-secondary" onclick="openAdvancedFilterPanel()" style="padding: 0.75rem 1.25rem;">
                            <i class="ph ph-funnel"></i> Adjust Filters
                        </button>
                    </div>
                `;
                return;
            }

            if (tasksWithDates.length === 0) {
                content.innerHTML = `
                    <div class="task-board-empty">
                        <i class="ph ph-calendar-blank"></i>
                        <h3>No tasks with due dates</h3>
                        <p>Add due dates to your tasks to see them on the timeline.</p>
                        <button class="hero-task-btn hero-task-btn-secondary" onclick="switchView('tasks')" style="padding: 0.75rem 1.25rem;">
                            <i class="ph ph-arrow-left"></i> Back to Work View
                        </button>
                    </div>
                `;
                return;
            }

            // Calculate date range
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const dates = tasksWithDates.map(t => parseLocalDate(t.dueDate));
            const minDate = new Date(Math.min(today.getTime(), ...dates.map(d => d.getTime())));
            const maxDate = new Date(Math.max(...dates.map(d => d.getTime())));

            // Add padding to range
            minDate.setDate(minDate.getDate() - 2);
            maxDate.setDate(maxDate.getDate() + 7);

            // Generate days array
            const days = [];
            const currentDate = new Date(minDate);
            while (currentDate <= maxDate) {
                days.push(new Date(currentDate));
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Group tasks by due date
            const tasksByDate = {};
            tasksWithDates.forEach(task => {
                const dateKey = task.dueDate;
                if (!tasksByDate[dateKey]) {
                    tasksByDate[dateKey] = [];
                }
                tasksByDate[dateKey].push(task);
            });

            let html = `
                <div class="timeline-container">
                    <div class="timeline-header">
                        <div class="timeline-legend">
                            <span class="timeline-legend-item pending"><i class="ph ph-circle-dashed"></i> To Do</span>
                            <span class="timeline-legend-item in-progress"><i class="ph ph-spinner"></i> In Progress</span>
                            <span class="timeline-legend-item completed"><i class="ph ph-check-circle"></i> Done</span>
                        </div>
                    </div>
                    <div class="timeline-scroll">
                        <div class="timeline-track">
            `;

            days.forEach((day, index) => {
                const dateKey = day.toISOString().split('T')[0];
                const dayTasks = tasksByDate[dateKey] || [];
                const isToday = day.toDateString() === today.toDateString();
                const isPast = day < today;
                const isWeekend = day.getDay() === 0 || day.getDay() === 6;

                html += `
                    <div class="timeline-day ${isToday ? 'today' : ''} ${isPast ? 'past' : ''} ${isWeekend ? 'weekend' : ''}">
                        <div class="timeline-day-header">
                            <span class="timeline-day-name">${day.toLocaleDateString('en-US', { weekday: 'short' })}</span>
                            <span class="timeline-day-date">${day.getDate()}</span>
                            ${isToday ? '<span class="timeline-today-badge">Today</span>' : ''}
                        </div>
                        <div class="timeline-day-tasks">
                `;

                dayTasks.forEach(task => {
                    const roleRel = relationships.find(r => r.object === task.id && r.predicate === 'CON');
                    const role = roleRel ? entities.role.find(r => r.id === roleRel.subject) : null;

                    html += `
                        <div class="timeline-task ${task.status}" onclick="showEntityDetails('${task.id}')">
                            <div class="timeline-task-name">${task.name}</div>
                            ${role ? `<div class="timeline-task-role">${role.name}</div>` : ''}
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            html += `
                        </div>
                    </div>
                </div>
            `;

            content.innerHTML = html;

            // Scroll to today
            setTimeout(() => {
                const todayEl = document.querySelector('.timeline-day.today');
                if (todayEl) {
                    todayEl.scrollIntoView({ behavior: 'smooth', inline: 'center' });
                }
            }, 100);
        }

        // ============================================
        // NATURAL LANGUAGE → OPERATOR MAPPING
        // ============================================

        // Maps natural language verbs to EO operators
        // Users search for verbs, system maps to operators internally
        const verbToOperatorMap = {
            // CON (Link/Connect) - most common for workflows
            'involves': 'CON',
            'uses': 'CON',
            'requires': 'CON',
            'includes': 'CON',
            'connects': 'CON',
            'links': 'CON',
            'relates': 'CON',
            'associates': 'CON',
            'participates': 'CON',
            'engages': 'CON',
            'works with': 'CON',
            'collaborates': 'CON',
            'produces': 'CON',
            'creates': 'CON',
            'generates': 'CON',
            'outputs': 'CON',
            'delivers': 'CON',

            // SUP (Balance/Oversee)
            'oversees': 'SUP',
            'manages': 'SUP',
            'supervises': 'SUP',
            'leads': 'SUP',
            'directs': 'SUP',
            'coordinates': 'SUP',
            'balances': 'SUP',
            'governs': 'SUP',
            'controls': 'SUP',

            // SYN (Merge/Combine)
            'combines': 'SYN',
            'merges': 'SYN',
            'integrates': 'SYN',
            'synthesizes': 'SYN',
            'unifies': 'SYN',
            'consolidates': 'SYN',
            'brings together': 'SYN',

            // SEG (Divide/Segment)
            'divides': 'SEG',
            'splits': 'SEG',
            'breaks down': 'SEG',
            'segments': 'SEG',
            'separates': 'SEG',
            'partitions': 'SEG',

            // ALT (Shift/Alternate)
            'alternates': 'ALT',
            'switches': 'ALT',
            'modifies': 'ALT',
            'changes': 'ALT',
            'shifts': 'ALT',
            'transforms': 'ALT',
            'adapts': 'ALT',

            // REC (Loop/Reconfigure)
            'loops': 'REC',
            'iterates': 'REC',
            'reconfigures': 'REC',
            'repeats': 'REC',
            'cycles': 'REC',
            'recurses': 'REC',
            'restructures': 'REC',

            // DES (Define/Designate) - for structure
            'defines': 'DES',
            'designates': 'DES',
            'describes': 'DES',
            'assigns': 'DES',
            'contains': 'DES',
            'nests': 'DES',
            'belongs to': 'DES',

            // NUL (Notice/Remove)
            'removes': 'NUL',
            'deletes': 'NUL',
            'nullifies': 'NUL',
            'cancels': 'NUL',
            'voids': 'NUL'
        };

        // Search verbs and return matching operators with descriptions
        function searchRelationshipVerbs(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            if (!term) return [];

            const matches = [];
            for (const [verb, operatorCode] of Object.entries(verbToOperatorMap)) {
                if (verb.includes(term)) {
                    const operator = eoOperators[operatorCode];
                    if (operator && !operator.deprecated) {
                        matches.push({
                            verb: verb,
                            operator: operatorCode,
                            label: operator.label,
                            description: operator.description,
                            color: operator.color
                        });
                    }
                }
            }

            // Remove duplicates (same operator, keep first verb match)
            const seen = new Set();
            return matches.filter(m => {
                if (seen.has(m.operator)) return false;
                seen.add(m.operator);
                return true;
            }).slice(0, 6); // Limit results
        }

        // ============================================
        // FLOW VIEW FUNCTIONS (Emergent Patterns)
        // ============================================

        // Discover patterns from tasks - roles with multiple similar tasks
        function discoverWorkPatterns() {
            const tasks = entities.task || [];
            const patterns = [];

            // Pattern 1: Roles with multiple tasks
            const roleTaskMap = {};
            tasks.forEach(task => {
                // Find role connected to this task
                const roleRel = relationships.find(r =>
                    (r.subject === task.id || r.object === task.id) &&
                    r.predicate === 'CON'
                );
                if (roleRel) {
                    const roleId = roleRel.subject === task.id ? roleRel.object : roleRel.subject;
                    const role = entities.role?.find(r => r.id === roleId);
                    if (role) {
                        if (!roleTaskMap[roleId]) {
                            roleTaskMap[roleId] = { role, tasks: [] };
                        }
                        roleTaskMap[roleId].tasks.push(task);
                    }
                }
            });

            // Create patterns for roles with 2+ tasks
            Object.values(roleTaskMap).forEach(({ role, tasks: roleTasks }) => {
                if (roleTasks.length >= 2) {
                    // Check if already has a named workflow
                    const hasNamedWorkflow = roleTasks.some(t => t.followsWorkflowId);
                    if (!hasNamedWorkflow) {
                        patterns.push({
                            type: 'role-tasks',
                            role,
                            tasks: roleTasks,
                            suggestedName: `${role.name} work`,
                            description: `${roleTasks.length} tasks assigned to ${role.name}`
                        });
                    }
                }
            });

            return patterns;
        }

        function renderFlowView() {
            const content = document.getElementById('flowViewContent');
            const workflows = entities.workflow || [];
            const tasks = entities.task || [];
            const searchTerm = (document.getElementById('flowViewSearch')?.value || '').toLowerCase();

            // Discover emergent patterns
            const discoveredPatterns = discoverWorkPatterns();

            // Filter workflows by search
            const filteredWorkflows = workflows.filter(wf =>
                !searchTerm || wf.name.toLowerCase().includes(searchTerm)
            );

            // Filter discovered patterns by search
            const filteredPatterns = discoveredPatterns.filter(p =>
                !searchTerm ||
                p.suggestedName.toLowerCase().includes(searchTerm) ||
                p.role.name.toLowerCase().includes(searchTerm)
            );

            const hasContent = filteredWorkflows.length > 0 || filteredPatterns.length > 0;

            if (!hasContent && tasks.length === 0) {
                content.innerHTML = `
                    <div class="flow-view-empty">
                        <i class="ph ph-flow-arrow"></i>
                        <h3>Patterns emerge from work</h3>
                        <p>As you create tasks and assign them to roles, this view will show you the patterns that naturally emerge - who does what, and how work flows through your organization.</p>
                        <button class="hero-task-btn hero-task-btn-secondary" onclick="switchView('tasks')">
                            <i class="ph ph-kanban"></i> Start with Work
                        </button>
                    </div>
                `;
                return;
            }

            if (!hasContent && tasks.length > 0) {
                content.innerHTML = `
                    <div class="flow-view-empty">
                        <i class="ph ph-flow-arrow"></i>
                        <h3>No patterns yet</h3>
                        <p>Keep adding tasks and assigning them to roles. When a role has multiple tasks, patterns will appear here automatically.</p>
                        <div style="margin-top: 1rem; font-size: 0.875rem; color: #8B6F47;">
                            <strong>${tasks.length}</strong> task${tasks.length !== 1 ? 's' : ''} created so far
                        </div>
                    </div>
                `;
                return;
            }

            let html = '';

            // Section: Discovered Patterns (emergent)
            if (filteredPatterns.length > 0) {
                html += `
                    <div class="flow-section">
                        <div class="flow-section-header">
                            <i class="ph ph-lightbulb"></i>
                            <span>Emerging Patterns</span>
                            <span class="flow-section-count">${filteredPatterns.length} discovered</span>
                        </div>
                        <div class="flow-section-hint">These patterns emerged from your work. Name them to track them.</div>
                        <div class="flow-view-list">
                `;

                filteredPatterns.forEach(pattern => {
                    html += `
                        <div class="workflow-card discovered" data-pattern-role="${pattern.role.id}">
                            <div class="workflow-card-header">
                                <div class="workflow-card-title">
                                    <i class="ph ph-sparkle"></i>
                                    ${pattern.suggestedName}
                                </div>
                                <div class="workflow-card-badge">Discovered</div>
                            </div>
                            <div class="workflow-card-body">
                                <div class="workflow-section">
                                    <div class="workflow-section-label">Role</div>
                                    <div class="workflow-chips">
                                        <span class="workflow-chip" onclick="showEntityDetails('${pattern.role.id}')">
                                            <i class="ph ph-briefcase"></i>
                                            ${pattern.role.name}
                                        </span>
                                    </div>
                                </div>
                                <div class="workflow-section">
                                    <div class="workflow-section-label">Tasks in this pattern</div>
                                    <div class="workflow-task-list">
                                        ${pattern.tasks.slice(0, 3).map(task => `
                                            <div class="workflow-task-item" onclick="showEntityDetails('${task.id}')">
                                                <i class="ph ph-check-square"></i>
                                                ${task.name}
                                            </div>
                                        `).join('')}
                                        ${pattern.tasks.length > 3 ? `
                                            <div class="workflow-task-more">+${pattern.tasks.length - 3} more</div>
                                        ` : ''}
                                    </div>
                                </div>
                                <button class="workflow-name-btn" onclick="nameDiscoveredPattern('${pattern.role.id}')">
                                    <i class="ph ph-tag"></i> Name this pattern
                                </button>
                            </div>
                        </div>
                    `;
                });

                html += '</div></div>';
            }

            // Section: Named Workflows (formalized patterns)
            if (filteredWorkflows.length > 0) {
                html += `
                    <div class="flow-section">
                        <div class="flow-section-header">
                            <i class="ph ph-flow-arrow"></i>
                            <span>Named Patterns</span>
                            <span class="flow-section-count">${filteredWorkflows.length}</span>
                        </div>
                        <div class="flow-view-list">
                `;

                filteredWorkflows.forEach(workflow => {
                    // Find connected roles
                    const connectedRoles = relationships
                        .filter(r => (r.subject === workflow.id || r.object === workflow.id) && r.predicate === 'CON')
                        .map(r => {
                            const otherId = r.subject === workflow.id ? r.object : r.subject;
                            return entities.role?.find(role => role.id === otherId);
                        })
                        .filter(Boolean);

                    // Find connected products
                    const connectedProducts = relationships
                        .filter(r => r.subject === workflow.id && r.predicate === 'CON')
                        .map(r => entities.product?.find(prod => prod.id === r.object))
                        .filter(Boolean);

                    // Find tasks that follow this workflow
                    const workflowTasks = (entities.task || []).filter(t => t.followsWorkflowId === workflow.id);

                    html += `
                        <div class="workflow-card" data-workflow-id="${workflow.id}">
                            <div class="workflow-card-header" onclick="showEntityDetails('${workflow.id}')">
                                <div class="workflow-card-title">
                                    <i class="ph ph-flow-arrow"></i>
                                    ${workflow.name}
                                </div>
                                <div class="workflow-card-meta">
                                    ${connectedRoles.length > 0 ? `<span><i class="ph ph-user-circle"></i> ${connectedRoles.length}</span>` : ''}
                                    ${workflowTasks.length > 0 ? `<span><i class="ph ph-check-square"></i> ${workflowTasks.length}</span>` : ''}
                                </div>
                            </div>
                            <div class="workflow-card-body">
                                ${connectedRoles.length > 0 ? `
                                    <div class="workflow-section">
                                        <div class="workflow-section-label">Roles involved</div>
                                        <div class="workflow-chips">
                                            ${connectedRoles.map(role => `
                                                <span class="workflow-chip" onclick="event.stopPropagation(); showEntityDetails('${role.id}')">
                                                    <i class="ph ph-briefcase"></i>
                                                    ${role.name}
                                                </span>
                                            `).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                ${workflowTasks.length > 0 ? `
                                    <div class="workflow-section">
                                        <div class="workflow-section-label">Tasks</div>
                                        <div class="workflow-task-list">
                                            ${workflowTasks.slice(0, 3).map(task => `
                                                <div class="workflow-task-item" onclick="event.stopPropagation(); showEntityDetails('${task.id}')">
                                                    <i class="ph ph-check-square"></i>
                                                    ${task.name}
                                                </div>
                                            `).join('')}
                                            ${workflowTasks.length > 3 ? `
                                                <div class="workflow-task-more">+${workflowTasks.length - 3} more</div>
                                            ` : ''}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });

                html += '</div></div>';
            }

            content.innerHTML = html;
        }

        function filterFlowView() {
            renderFlowView();
        }

        // Name a discovered pattern - creates a workflow from the pattern
        function nameDiscoveredPattern(roleId) {
            const role = entities.role?.find(r => r.id === roleId);
            if (!role) return;

            const name = prompt(`Name this work pattern:`, `${role.name} process`);
            if (name && name.trim()) {
                // Create the workflow
                const workflow = {
                    id: 'workflow' + Date.now(),
                    name: name.trim(),
                    type: 'workflow',
                    description: `Work pattern for ${role.name}`
                };
                entities.workflow.push(workflow);

                // Connect workflow to the role
                relationships.push({
                    id: 'rel' + Date.now(),
                    subject: workflow.id,
                    predicate: 'CON',
                    object: roleId
                });

                // Associate tasks with this workflow
                const roleTasks = (entities.task || []).filter(task => {
                    const rel = relationships.find(r =>
                        (r.subject === task.id || r.object === task.id) &&
                        r.predicate === 'CON' &&
                        (r.subject === roleId || r.object === roleId)
                    );
                    return rel && !task.followsWorkflowId;
                });

                roleTasks.forEach(task => {
                    task.followsWorkflowId = workflow.id;
                });

                saveToLocalStorage();
                renderFlowView();
                showToast(`Pattern named: ${name.trim()}`);
            }
        }

        // Open modal to add role/product to workflow
        function openAddToWorkflow(workflowId, entityType) {
            openEntityModal(workflowId, 'workflow');
            setTimeout(() => {
                switchModalTab('connect');
            }, 100);
        }

        // ============================================
        // SHAPE VIEW FUNCTIONS (Structure from Work)
        // ============================================

        // Helper: Get task count for a role
        function getRoleTaskCount(roleId) {
            return relationships.filter(r =>
                (r.subject === roleId || r.object === roleId) &&
                r.predicate === 'CON'
            ).filter(r => {
                const otherId = r.subject === roleId ? r.object : r.subject;
                return entities.task?.some(t => t.id === otherId);
            }).length;
        }

        // Helper: Get assigned people for a role
        function getRoleAssignedPeople(roleId) {
            return relationships.filter(r =>
                r.object === roleId && r.predicate === 'INS'
            ).map(r => entities.person?.find(p => p.id === r.subject)).filter(Boolean);
        }

        function renderShapeView() {
            const content = document.getElementById('shapeViewContent');

            // Calculate work insights first (work-focused)
            const taskCount = (entities.task || []).length;
            const roleCount = (entities.role || []).length;
            const personCount = (entities.person || []).length;
            const unitCount = (entities.unit || []).length;
            const teamCount = (entities.team || []).length;

            // Calculate active roles (roles with tasks assigned)
            const activeRoles = (entities.role || []).filter(role => getRoleTaskCount(role.id) > 0);
            const idleRoles = (entities.role || []).filter(role => getRoleTaskCount(role.id) === 0);

            const hasRoles = roleCount > 0;
            const hasStructure = unitCount > 0 || teamCount > 0;

            if (!hasRoles && taskCount === 0) {
                content.innerHTML = `
                    <div class="shape-view-empty">
                        <i class="ph ph-tree-structure"></i>
                        <h3>Structure emerges from work</h3>
                        <p>Create tasks and assign them to roles. As you do, the natural shape of how work gets done will emerge here.</p>
                        <button class="hero-task-btn hero-task-btn-secondary" onclick="switchView('tasks')">
                            <i class="ph ph-kanban"></i> Start with Work
                        </button>
                    </div>
                `;
                return;
            }

            if (!hasRoles && taskCount > 0) {
                content.innerHTML = `
                    <div class="shape-view-empty">
                        <i class="ph ph-tree-structure"></i>
                        <h3>You have work, but who does it?</h3>
                        <p>You have ${taskCount} task${taskCount !== 1 ? 's' : ''}, but no roles yet. When you assign tasks to roles, structure will emerge.</p>
                        <button class="hero-task-btn hero-task-btn-secondary" onclick="switchView('tasks')">
                            <i class="ph ph-kanban"></i> View Work
                        </button>
                    </div>
                `;
                return;
            }

            let html = '';

            // Work-first insights
            html += `
                <div class="shape-insights">
                    <div class="shape-insights-title">
                        <i class="ph ph-pulse"></i>
                        Work activity
                    </div>
                    <div class="shape-insight-item">
                        <i class="ph ph-check-square"></i>
                        <span class="shape-insight-value">${taskCount}</span> task${taskCount !== 1 ? 's' : ''}
                    </div>
                    <div class="shape-insight-item ${activeRoles.length > 0 ? 'active' : ''}">
                        <i class="ph ph-briefcase"></i>
                        <span class="shape-insight-value">${activeRoles.length}</span> active role${activeRoles.length !== 1 ? 's' : ''}
                    </div>
                    ${idleRoles.length > 0 ? `
                        <div class="shape-insight-item idle">
                            <i class="ph ph-pause-circle"></i>
                            <span class="shape-insight-value">${idleRoles.length}</span> idle role${idleRoles.length !== 1 ? 's' : ''}
                        </div>
                    ` : ''}
                    <div class="shape-insight-item">
                        <i class="ph ph-user"></i>
                        <span class="shape-insight-value">${personCount}</span> ${personCount === 1 ? 'person' : 'people'}
                    </div>
                </div>
            `;

            // If there are roles but no structure, suggest grouping
            if (roleCount >= 2 && !hasStructure) {
                html += `
                    <div class="shape-suggestion">
                        <i class="ph ph-lightbulb"></i>
                        <div class="shape-suggestion-content">
                            <strong>Ready to organize?</strong>
                            <p>You have ${roleCount} roles doing work. If they collaborate, consider grouping them into a team.</p>
                        </div>
                    </div>
                `;
            }

            // Roles section - the heart of structure emerging from work
            html += '<div class="shape-section">';
            html += '<div class="shape-section-title"><i class="ph ph-briefcase"></i> Roles (who does the work)</div>';
            html += '<div class="shape-roles-grid">';

            (entities.role || []).forEach(role => {
                const taskCount = getRoleTaskCount(role.id);
                const people = getRoleAssignedPeople(role.id);
                const isActive = taskCount > 0;

                html += `
                    <div class="shape-role-card ${isActive ? 'active' : 'idle'}" onclick="showEntityDetails('${role.id}')">
                        <div class="shape-role-header">
                            <span class="shape-role-name">${role.name}</span>
                            ${isActive ? `
                                <span class="shape-role-badge active">${taskCount} task${taskCount !== 1 ? 's' : ''}</span>
                            ` : `
                                <span class="shape-role-badge idle">no tasks</span>
                            `}
                        </div>
                        ${people.length > 0 ? `
                            <div class="shape-role-people">
                                ${people.map(p => `<span class="shape-person-chip"><i class="ph ph-user"></i> ${p.name}</span>`).join('')}
                            </div>
                        ` : `
                            <div class="shape-role-empty">No one assigned</div>
                        `}
                    </div>
                `;
            });

            html += '</div></div>';

            // Structure section (if any exists) - shown as optional organization
            if (hasStructure) {
                html += '<div class="shape-section">';
                html += '<div class="shape-section-title"><i class="ph ph-tree-structure"></i> Organization (how roles are grouped)</div>';
                html += '<div class="shape-tree">';

                // Render units with their nested content
                (entities.unit || []).forEach(unit => {
                    html += renderShapeNode(unit, 'unit');
                });

                // Orphan teams
                const orphanTeams = (entities.team || []).filter(team => {
                    return !relationships.some(r => r.subject === team.id && r.predicate === 'DES');
                });
                orphanTeams.forEach(team => {
                    html += renderShapeNode(team, 'team');
                });

                html += '</div></div>';
            }

            content.innerHTML = html;
        }

        function renderShapeNode(entity, type) {
            // Find children (entities that DES this entity - meaning this is their parent)
            const children = relationships
                .filter(r => r.object === entity.id && r.predicate === 'DES')
                .map(r => {
                    for (const entityType of ['team', 'role', 'unit']) {
                        const found = entities[entityType]?.find(e => e.id === r.subject);
                        if (found) return { entity: found, type: entityType };
                    }
                    return null;
                })
                .filter(Boolean);

            const hasChildren = children.length > 0;
            const icon = type === 'unit' ? 'ph-buildings' : type === 'team' ? 'ph-users-three' : 'ph-briefcase';

            // For roles, show task count
            let taskBadge = '';
            if (type === 'role') {
                const taskCount = getRoleTaskCount(entity.id);
                taskBadge = taskCount > 0
                    ? `<span class="shape-node-badge active">${taskCount}</span>`
                    : `<span class="shape-node-badge idle">0</span>`;
            }

            let html = `
                <div class="shape-node ${hasChildren ? '' : 'no-children'}" data-entity-id="${entity.id}">
                    <div class="shape-node-header" onclick="${hasChildren ? `toggleShapeNode('${entity.id}')` : `showEntityDetails('${entity.id}')`}">
                        ${hasChildren ? `
                            <div class="shape-node-toggle">
                                <i class="ph ph-caret-right"></i>
                            </div>
                        ` : '<div style="width: 20px;"></div>'}
                        <div class="shape-node-icon ${type}">
                            <i class="ph ${icon}"></i>
                        </div>
                        <span class="shape-node-name">${entity.name}</span>
                        ${hasChildren ? `<span class="shape-node-count">${children.length}</span>` : ''}
                    </div>
                    ${hasChildren ? `
                        <div class="shape-node-children">
                            ${children.map(child => renderShapeNode(child.entity, child.type)).join('')}
                        </div>
                    ` : ''}
                </div>
            `;

            return html;
        }

        function toggleShapeNode(entityId) {
            const node = document.querySelector(`.shape-node[data-entity-id="${entityId}"]`);
            if (node) {
                node.classList.toggle('expanded');
            }
        }

        // ============================================
        // GANTT VIEW
        // ============================================

        let ganttStartDate = new Date();
        ganttStartDate.setDate(ganttStartDate.getDate() - 7); // Start a week ago

        function renderGanttView() {
            const content = document.getElementById('ganttViewContent');
            const filteredTasks = getAdvancedFilteredTasks();

            if (filteredTasks.length === 0) {
                content.innerHTML = `
                    <div class="gantt-empty">
                        <i class="ph ph-chart-bar-horizontal"></i>
                        <h3>No tasks to display</h3>
                        <p>Create some tasks with due dates to see them on the Gantt chart.</p>
                    </div>
                `;
                return;
            }

            // Get date range - 4 weeks from start date
            const daysToShow = 28;
            const dates = [];
            for (let i = 0; i < daysToShow; i++) {
                const date = new Date(ganttStartDate);
                date.setDate(ganttStartDate.getDate() + i);
                dates.push(date);
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Build header
            let headerHtml = `
                <div class="gantt-header">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <h3 style="margin: 0; color: #3D2E1F;"><i class="ph ph-chart-bar-horizontal" style="color: #C88F4A;"></i> Gantt Chart</h3>
                    </div>
                    <div class="gantt-controls">
                        <button class="btn btn-small btn-outline" onclick="ganttNavigate(-7)">
                            <i class="ph ph-caret-left"></i> Week
                        </button>
                        <button class="btn btn-small" onclick="ganttGoToToday()">Today</button>
                        <button class="btn btn-small btn-outline" onclick="ganttNavigate(7)">
                            Week <i class="ph ph-caret-right"></i>
                        </button>
                    </div>
                </div>
                <div class="gantt-container">
                    <div class="gantt-timeline-header">
                        <div class="gantt-task-column">Task</div>
                        <div class="gantt-timeline-dates">
            `;

            dates.forEach(date => {
                const isWeekend = date.getDay() === 0 || date.getDay() === 6;
                const isToday = date.toDateString() === today.toDateString();
                const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                headerHtml += `
                    <div class="gantt-date-cell ${isWeekend ? 'weekend' : ''} ${isToday ? 'today' : ''}">
                        <div>${dayNames[date.getDay()]}</div>
                        <div>${date.getDate()}</div>
                    </div>
                `;
            });

            headerHtml += '</div></div>';

            // Build task rows
            let rowsHtml = '';
            filteredTasks.forEach(task => {
                const statusClass = task.status === 'completed' ? 'completed' :
                                   task.status === 'in_progress' ? 'in-progress' : 'pending';

                // Calculate bar position
                let barHtml = '';
                if (task.dueDate) {
                    const dueDate = parseLocalDate(task.dueDate);
                    const startOfTask = task.startDate ? parseLocalDate(task.startDate) : new Date(dueDate);
                    if (!task.startDate) {
                        startOfTask.setDate(startOfTask.getDate() - 3); // Default 3 days duration if no start
                    }

                    const dayWidth = 40; // matches min-width of gantt-date-cell
                    const startOffset = Math.floor((startOfTask - ganttStartDate) / (1000 * 60 * 60 * 24));
                    const endOffset = Math.floor((dueDate - ganttStartDate) / (1000 * 60 * 60 * 24));
                    const duration = Math.max(1, endOffset - startOffset + 1);

                    const left = startOffset * dayWidth;
                    const width = duration * dayWidth - 4;

                    const isOverdue = dueDate < today && task.status !== 'completed';
                    const barClass = isOverdue ? 'overdue' : statusClass;

                    if (startOffset < daysToShow && endOffset >= 0) {
                        barHtml = `
                            <div class="gantt-bar ${barClass}"
                                 style="left: ${Math.max(0, left)}px; width: ${Math.min(width, (daysToShow - Math.max(0, startOffset)) * dayWidth)}px;"
                                 onclick="openTaskModal('${task.id}')"
                                 title="${task.name}">
                                ${task.name}
                            </div>
                        `;
                    }
                }

                rowsHtml += `
                    <div class="gantt-row">
                        <div class="gantt-task-cell" onclick="openTaskModal('${task.id}')" style="cursor: pointer;">
                            <div class="gantt-task-status ${statusClass}"></div>
                            <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${task.name}</span>
                        </div>
                        <div class="gantt-bar-area">
                            ${barHtml}
                        </div>
                    </div>
                `;
            });

            content.innerHTML = headerHtml + rowsHtml + '</div>';
        }

        function ganttNavigate(days) {
            ganttStartDate.setDate(ganttStartDate.getDate() + days);
            renderGanttView();
        }

        function ganttGoToToday() {
            ganttStartDate = new Date();
            ganttStartDate.setDate(ganttStartDate.getDate() - 7);
            renderGanttView();
        }

        // ============================================
        // CALENDAR VIEW
        // ============================================

        let calendarCurrentMonth = new Date();

        function renderCalendarView() {
            const content = document.getElementById('calendarViewContent');
            const filteredTasks = getAdvancedFilteredTasks();

            const year = calendarCurrentMonth.getFullYear();
            const month = calendarCurrentMonth.getMonth();
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startDayOfWeek = firstDay.getDay();

            // Group tasks by due date
            const tasksByDate = {};
            filteredTasks.forEach(task => {
                if (task.dueDate) {
                    const dateKey = task.dueDate.split('T')[0];
                    if (!tasksByDate[dateKey]) tasksByDate[dateKey] = [];
                    tasksByDate[dateKey].push(task);
                }
            });

            let html = `
                <div class="calendar-header">
                    <div class="calendar-nav">
                        <button class="calendar-nav-btn" onclick="calendarNavigate(-1)">
                            <i class="ph ph-caret-left"></i>
                        </button>
                        <div class="calendar-month-title">${monthNames[month]} ${year}</div>
                        <button class="calendar-nav-btn" onclick="calendarNavigate(1)">
                            <i class="ph ph-caret-right"></i>
                        </button>
                    </div>
                    <button class="calendar-today-btn" onclick="calendarGoToToday()">Today</button>
                </div>
                <div class="calendar-grid">
                    <div class="calendar-weekdays">
                        <div class="calendar-weekday">Sun</div>
                        <div class="calendar-weekday">Mon</div>
                        <div class="calendar-weekday">Tue</div>
                        <div class="calendar-weekday">Wed</div>
                        <div class="calendar-weekday">Thu</div>
                        <div class="calendar-weekday">Fri</div>
                        <div class="calendar-weekday">Sat</div>
                    </div>
                    <div class="calendar-days">
            `;

            // Add empty cells for days before first of month
            for (let i = 0; i < startDayOfWeek; i++) {
                const prevMonthDay = new Date(year, month, -startDayOfWeek + i + 1);
                html += `<div class="calendar-day other-month"><div class="calendar-day-number">${prevMonthDay.getDate()}</div></div>`;
            }

            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const currentDate = new Date(year, month, day);
                const dateKey = currentDate.toISOString().split('T')[0];
                const isToday = currentDate.toDateString() === today.toDateString();
                const dayTasks = tasksByDate[dateKey] || [];

                let tasksHtml = '';
                dayTasks.slice(0, 3).forEach(task => {
                    const isOverdue = parseLocalDate(task.dueDate) < today && task.status !== 'completed';
                    const statusClass = isOverdue ? 'overdue' :
                                       task.status === 'completed' ? 'completed' :
                                       task.status === 'in_progress' ? 'in-progress' : 'pending';
                    tasksHtml += `
                        <div class="calendar-task ${statusClass}" onclick="event.stopPropagation(); openTaskModal('${task.id}')" title="${task.name}">
                            ${task.name}
                        </div>
                    `;
                });

                if (dayTasks.length > 3) {
                    tasksHtml += `<div class="calendar-task" style="background: #F5F2ED; color: #6B5642;">+${dayTasks.length - 3} more</div>`;
                }

                html += `
                    <div class="calendar-day ${isToday ? 'today' : ''}" onclick="showDayTasks('${dateKey}')">
                        <div class="calendar-day-number">${day}</div>
                        <div class="calendar-day-tasks">${tasksHtml}</div>
                    </div>
                `;
            }

            // Add empty cells for days after last of month
            const cellsUsed = startDayOfWeek + daysInMonth;
            const cellsNeeded = Math.ceil(cellsUsed / 7) * 7;
            for (let i = cellsUsed; i < cellsNeeded; i++) {
                const nextMonthDay = i - cellsUsed + 1;
                html += `<div class="calendar-day other-month"><div class="calendar-day-number">${nextMonthDay}</div></div>`;
            }

            html += '</div></div>';
            content.innerHTML = html;
        }

        function calendarNavigate(direction) {
            calendarCurrentMonth.setMonth(calendarCurrentMonth.getMonth() + direction);
            renderCalendarView();
        }

        function calendarGoToToday() {
            calendarCurrentMonth = new Date();
            renderCalendarView();
        }

        function showDayTasks(dateKey) {
            // Could open a modal showing all tasks for that day
            console.log('Show tasks for:', dateKey);
        }

        // Keyboard shortcut for hero task modal
        document.addEventListener('keydown', function(event) {
            const overlay = document.getElementById('heroTaskOverlay');
            const modalActive = overlay && overlay.classList.contains('active');

            // Handle Enter key to submit task when modal is active
            if (event.key === 'Enter' && modalActive) {
                // Check if we're in an inline create input (these have their own Enter handlers)
                const inlineCreateInputs = ['heroNewWorkflowName', 'heroNewRoleName', 'heroNewPersonName'];
                if (inlineCreateInputs.includes(event.target.id)) {
                    return; // Let the inline input's own handler deal with it
                }

                // For main task input, selects, and date input - submit the form
                const formElements = ['heroTaskName', 'heroTaskWorkflow', 'heroTaskRole', 'heroTaskPerson', 'heroTaskDueDate', 'heroTaskPredecessor'];
                if (formElements.includes(event.target.id)) {
                    event.preventDefault();
                    submitHeroTask();
                    return;
                }
            }

            // Don't trigger T shortcut if in an input field
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                return;
            }

            // 'T' key opens hero task modal
            if (event.key === 't' || event.key === 'T') {
                event.preventDefault();
                openHeroTaskModal();
            }

            // Escape closes modal
            if (event.key === 'Escape') {
                if (modalActive) {
                    closeHeroTaskModal();
                }
            }
        });

        // Advanced entity options toggle
        function toggleAdvancedEntityOptions() {
            const options = document.getElementById('advancedEntityOptions');
            const toggleBtn = document.getElementById('advancedEntityToggle');
            if (options && toggleBtn) {
                const isVisible = options.style.display !== 'none';
                options.style.display = isVisible ? 'none' : 'block';
                toggleBtn.classList.toggle('expanded', !isVisible);
                toggleBtn.innerHTML = isVisible
                    ? '<i class="ph ph-plus"></i> Structure options'
                    : '<i class="ph ph-minus"></i> Hide structure options';
            }
        }

        // Advanced operators toggle
        function toggleAdvancedOperators() {
            const operators = document.getElementById('advancedOperators');
            const toggleBtn = document.getElementById('moreOperatorsBtn');
            if (operators && toggleBtn) {
                const isVisible = operators.classList.contains('visible');
                operators.classList.toggle('visible', !isVisible);
                toggleBtn.classList.toggle('expanded', !isVisible);
                toggleBtn.innerHTML = isVisible
                    ? '<i class="ph ph-plus"></i> More operators (6)'
                    : '<i class="ph ph-minus"></i> Hide operators';
            }
        }

        // Activity details toggle
        function toggleActivityDetails() {
            const details = document.getElementById('activityDetailsSection');
            const toggleBtn = document.getElementById('activityDetailsToggle');
            if (details && toggleBtn) {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
                toggleBtn.classList.toggle('expanded', !isVisible);
                toggleBtn.innerHTML = isVisible
                    ? '<i class="ph ph-plus"></i> Add notes or details'
                    : '<i class="ph ph-minus"></i> Hide notes';
            }
        }

        // Simplified predicate selection (for 3 main operators)
        function selectSimplifiedPredicate(predicateCode, btn) {
            // Remove active from all quick operator buttons
            document.querySelectorAll('.quick-operator-selector .operator-btn').forEach(b => {
                b.classList.remove('active');
            });
            // Remove active from advanced operators too
            document.querySelectorAll('.advanced-operators .predicate-btn').forEach(b => {
                b.classList.remove('active');
            });
            // Add active to clicked button
            btn.classList.add('active');
            // Set the predicate and update preview (don't call selectPredicate to avoid clearing active state)
            selectedPredicate = predicateCode;
            updateSentencePreview();
        }

        // Simplified filters (dropdown-based)
        function applySimplifiedFilters() {
            const connectionFilter = document.getElementById('connectionFilterDropdown').value;
            const entityFilter = document.getElementById('entityFilterDropdown').value;

            // Map simplified filters to advanced filter checkboxes
            const operatorFilters = {
                'all': ['NUL', 'DES', 'SEG', 'CON', 'ALT', 'SYN', 'SUP', 'REC'],
                'nesting': ['DES'],  // DES for nesting/hierarchy
                'activities': ['NUL', 'SEG', 'CON', 'ALT', 'SYN', 'SUP', 'REC']  // All non-DES operators for activities
            };

            const entityFilters = {
                'all': ['Unit', 'Team', 'Role', 'Person', 'Object'],
                'structure': ['Unit', 'Team'],
                'roles': ['Role'],
                'people': ['Person']
            };

            // Set operator checkboxes
            const selectedOps = operatorFilters[connectionFilter] || operatorFilters['all'];
            ['NUL', 'DES', 'SEG', 'CON', 'ALT', 'SYN', 'SUP', 'REC'].forEach(op => {
                const checkbox = document.getElementById(`filter${op}`);
                if (checkbox) {
                    checkbox.checked = selectedOps.includes(op);
                }
            });

            // Set entity checkboxes
            const selectedEntities = entityFilters[entityFilter] || entityFilters['all'];
            ['Unit', 'Team', 'Role', 'Person', 'Object'].forEach(ent => {
                const checkbox = document.getElementById(`filter${ent}`);
                if (checkbox) {
                    checkbox.checked = selectedEntities.includes(ent);
                }
            });

            // Apply the filters
            applyFilters();
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const loadingStatus = document.getElementById('loadingStatus');

            function updateStatus(message, success = true) {
                if (loadingStatus) {
                    loadingStatus.innerHTML = success
                        ? `<i class="ph ph-check-circle"></i> ${message}`
                        : `<i class="ph ph-warning-circle"></i> ${message}`;
                    loadingStatus.style.background = success ? 'rgba(76, 175, 80, 0.3)' : 'rgba(244, 67, 54, 0.3)';
                }
                console.log(success ? '✅' : '❌', message);
            }

            console.log('🔧 Initializing Taskflow...');
            console.log('📍 Loading from:', window.location.protocol);
            console.log('🌐 D3.js loaded:', typeof d3 !== 'undefined');

            // Initialize Authentication Manager - this gates access to the app
            console.log('🔐 Checking authentication...');
            AuthManager.init();

            // Detect iframe/embed context
            const isInIframe = window.parent !== window;
            const isSoftrEmbed = isInIframe || window.location.hostname.includes('softr');
            console.log('🖼️ Running in iframe:', isInIframe);
            console.log('🔗 Softr embed detected:', isSoftrEmbed);

            // Initialize Softr user identity detection
            SoftrIdentity.init();

            // Initialize Xano connection status check
            initXanoConnectionCheck();

            // Check if essential libraries loaded
            if (typeof d3 === 'undefined') {
                updateStatus('D3.js failed to load - Internet required', false);
                alert('⚠️ D3.js failed to load from CDN. Graph view will not work.\n\nPlease ensure you have an internet connection.');
            } else {
                updateStatus('Libraries loaded');
            }

            // Close modal on outside click
            document.getElementById('entityModal').addEventListener('click', (e) => {
                if (e.target.id === 'entityModal') {
                    closeEntityModal();
                }
            });

            // Check localStorage availability (may be blocked in cross-origin iframes)
            let localStorageAvailable = true;
            try {
                const testKey = '__storage_test__';
                localStorage.setItem(testKey, testKey);
                localStorage.removeItem(testKey);
                console.log('💾 localStorage available: true');
            } catch (e) {
                localStorageAvailable = false;
                console.warn('⚠️ localStorage not available (possibly blocked in iframe):', e.message);
                if (isInIframe) {
                    updateStatus('Storage limited in embed mode', false);
                }
            }

            // Try to load from localStorage first
            updateStatus('Checking saved data...');
            let hasStoredData = false;
            if (localStorageAvailable) {
                try {
                    hasStoredData = loadFromLocalStorage();
                    console.log('📦 Has stored data:', hasStoredData);
                } catch (e) {
                    console.error('❌ localStorage error:', e);
                    if (window.location.protocol === 'file:') {
                        updateStatus('localStorage restricted (file:// URL)', false);
                        console.warn('⚠️ Note: Some browsers restrict localStorage for file:// URLs');
                    }
                }
            }

            // Function to load sample data as fallback
            function loadSampleDataFallback() {
                updateStatus('Loading sample data...');
                console.log('📝 Creating default workspace with sample data...');
                try {
                    // Create default workspace
                    const wsId = generateWorkspaceId();
                    workspaces[wsId] = {
                        id: wsId,
                        name: 'Acme Marketing Agency',
                        entities: { unit: [], team: [], role: [], person: [], task: [], product: [], workflow: [] },
                        relationships: [],
                        hasSampleData: true,
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };
                    currentWorkspaceId = wsId;

                    initSampleData();
                    hasSampleData = true;

                    // Update workspace with loaded sample data
                    workspaces[wsId].entities = JSON.parse(JSON.stringify(entities));
                    workspaces[wsId].relationships = JSON.parse(JSON.stringify(relationships));
                    saveWorkspaces();

                    const btnText = document.getElementById('sampleDataText');
                    if (btnText) {
                        btnText.textContent = 'Clear Sample Data';
                    }
                    console.log('✅ Sample data loaded. Entities:', {
                        units: entities.unit.length,
                        teams: entities.team.length,
                        roles: entities.role.length,
                        people: entities.person.length,
                        tasks: entities.task.length,
                        products: entities.product.length,
                        workflows: entities.workflow.length
                    });
                    console.log('✅ Relationships:', relationships.length);
                    updateStatus('Sample data loaded');
                } catch (e) {
                    console.error('❌ Error loading sample data:', e);
                    updateStatus('Error loading sample data', false);
                    alert('Error loading sample data. Check console for details.');
                }
            }

            // Function to complete initialization after data is loaded
            function completeInitialization() {
                // Load undo history and recycle bin for current workspace
                loadUndoHistory();

                // Load enhanced task management data
                loadTaskComments();
                loadNotifications();
                loadAutomationRules();

                // Render everything
                try {
                    updateStatus('Rendering interface...');
                    console.log('🎨 Rendering UI...');
                    renderEntityList();
                    updateSelects();
                    updateParentOptions();
                    renderActivityList();
                    updateFilterStatus();
                    updateTaskCountBadge();
                    updateNotificationBadge();
                    console.log('✅ UI rendered');
                    updateStatus('Ready');

                    // Initialize simplified UX
                    checkWelcomeBanner();
                    restorePanelStates();
                    updateStructureSectionVisibility();
                    initSidebar();
                } catch (e) {
                    console.error('❌ Error rendering UI:', e);
                    updateStatus('Error rendering UI', false);
                    alert('Error rendering interface. Check console for details.');
                }

                // Character counter for description
                const descriptionField = document.getElementById('activityDescription');
                const charCount = document.getElementById('charCount');
                if (descriptionField && charCount) {
                    descriptionField.addEventListener('input', () => {
                        charCount.textContent = descriptionField.value.length;
                    });
                }

                // Show kanban view by default
                try {
                    switchView('kanban');
                    console.log('✅ Kanban view activated');
                } catch (e) {
                    console.error('❌ Error switching to kanban view:', e);
                    updateStatus('Error loading view', false);
                }

                // Initialize auto-refresh system
                initAutoRefresh();
                console.log('🔄 Auto-refresh system initialized');

                // Initialize update polling system
                initUpdatePolling();
                console.log('🔄 Update polling system initialized');

                console.log('🎉 Initialization complete!');
                console.log('📊 Current state:', {
                    entities: {
                        units: entities.unit.length,
                        teams: entities.team.length,
                        roles: entities.role.length,
                        people: entities.person.length,
                        tasks: entities.task.length,
                        products: entities.product.length,
                        workflows: entities.workflow.length
                    },
                    relationships: relationships.length,
                    hasSampleData: hasSampleData
                });

                // Hide loading status after 3 seconds if successful
                setTimeout(() => {
                    if (loadingStatus && loadingStatus.textContent.includes('Ready')) {
                        loadingStatus.style.display = 'none';
                    }
                }, 3000);
            }

            // If no stored data, try to restore from Xano first
            if (!hasStoredData) {
                updateStatus('Checking Xano for existing data...');
                console.log('📡 No localStorage data - checking Xano for existing data...');

                getActivitiesFromXano().then(xanoActivities => {
                    if (xanoActivities && xanoActivities.length > 0) {
                        console.log('✅ Found', xanoActivities.length, 'activities in Xano');
                        updateStatus('Restoring data from Xano...');

                        // Try to reconstruct entities from activities
                        const reconstructed = reconstructEntitiesFromActivities(xanoActivities);
                        const totalEntities = Object.values(reconstructed.entities).reduce(
                            (sum, arr) => sum + arr.length, 0
                        );

                        if (totalEntities > 0) {
                            // Create workspace with reconstructed data
                            const wsId = generateWorkspaceId();
                            workspaces[wsId] = {
                                id: wsId,
                                name: 'Restored Data',
                                entities: reconstructed.entities,
                                relationships: reconstructed.relationships,
                                hasSampleData: false,
                                createdAt: Date.now(),
                                updatedAt: Date.now()
                            };
                            currentWorkspaceId = wsId;
                            entities = normalizeEntities(JSON.parse(JSON.stringify(reconstructed.entities)));
                            relationships = JSON.parse(JSON.stringify(reconstructed.relationships));
                            hasSampleData = false;
                            saveWorkspaces();

                            console.log('✅ Restored', totalEntities, 'entities from Xano');
                            updateStatus(`Restored ${totalEntities} entities from Xano`);

                            // Update UI
                            const nameEl = document.getElementById('workspaceNameText');
                            if (nameEl) {
                                nameEl.textContent = workspaces[wsId].name;
                                nameEl.title = workspaces[wsId].name;
                            }

                            completeInitialization();
                        } else {
                            // Activities exist but no entities could be reconstructed
                            console.log('⚠️ Activities found but no entities to restore - loading sample data');
                            loadSampleDataFallback();
                            completeInitialization();
                        }
                    } else {
                        // No Xano data - load sample data
                        console.log('ℹ️ No existing data in Xano - loading sample data');
                        loadSampleDataFallback();
                        completeInitialization();
                    }
                }).catch(err => {
                    console.error('❌ Xano connection failed:', err);
                    updateStatus('Xano unavailable - loading sample data', false);
                    loadSampleDataFallback();
                    completeInitialization();
                });
            } else {
                updateStatus('Loaded from storage');
                console.log('✅ Loaded data from localStorage');

                // Still connect to Xano for activity logging
                getActivitiesFromXano().then(xanoActivities => {
                    if (xanoActivities && xanoActivities.length > 0) {
                        console.log('✅ Connected to Xano. Found', xanoActivities.length, 'activities');
                    } else {
                        console.log('ℹ️ Xano connected but no activities found for this app');
                    }
                }).catch(err => {
                    console.error('⚠️ Xano connection failed (data loaded from localStorage):', err);
                });

                completeInitialization();
            }
        });
    </script>

    <!-- Toast Notification -->
    <div class="toast-notification" id="toastNotification"></div>

    <!-- Hero Task Creation FAB -->
    <button class="task-fab task-fab-pulse" onclick="openHeroTaskModal()" title="Create a new task (Press T)">
        <span class="task-fab-label">Create Task</span>
        <i class="ph ph-plus"></i>
    </button>

    <!-- Hero Task Modal -->
    <div class="hero-task-overlay" id="heroTaskOverlay" onclick="closeHeroTaskModalOnBackdrop(event)">
        <div class="hero-task-modal" onclick="event.stopPropagation()">
            <div class="hero-task-header">
                <h2><i class="ph ph-lightning"></i> Create a Task</h2>
                <button class="hero-task-close" onclick="closeHeroTaskModal()">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="hero-task-body">
                <div class="hero-task-input-group">
                    <label class="hero-task-label">What needs to get done?</label>
                    <input type="text"
                           id="heroTaskName"
                           class="hero-task-main-input"
                           placeholder="e.g., Review contracts, Prepare report, Draft proposal..."
                           onkeypress="if(event.key==='Enter') submitHeroTask()"
                           oninput="updateHeroTaskPreview()">
                </div>

                <!-- Description Field -->
                <div class="hero-task-input-group hero-task-description-group">
                    <label class="hero-task-label"><i class="ph ph-text-aa"></i> Description (Optional)</label>
                    <textarea id="heroTaskDescription"
                              class="task-description-field"
                              placeholder="Add more details about this task..."
                              oninput="updateHeroTaskPreview()"></textarea>
                </div>

                <div class="hero-task-row hero-task-essential-options">
                    <div class="hero-task-input-group" style="flex: 1;">
                        <label class="hero-task-label"><i class="ph ph-calendar"></i> Due Date</label>
                        <input type="date"
                               id="heroTaskDueDate"
                               class="hero-task-date-input"
                               onchange="updateHeroTaskPreview()">
                    </div>
                    <div class="hero-task-input-group" style="flex: 1;">
                        <label class="hero-task-label"><i class="ph ph-flag"></i> Priority</label>
                        <div class="priority-select" id="heroPrioritySelect">
                            <div class="priority-option low" onclick="selectPriority('low')" data-priority="low">
                                <span>Low</span>
                            </div>
                            <div class="priority-option medium selected" onclick="selectPriority('medium')" data-priority="medium">
                                <span>Medium</span>
                            </div>
                            <div class="priority-option high" onclick="selectPriority('high')" data-priority="high">
                                <span>High</span>
                            </div>
                            <div class="priority-option urgent" onclick="selectPriority('urgent')" data-priority="urgent">
                                <span>Urgent</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tags Input -->
                <div class="hero-task-input-group" style="margin-top: 1rem;">
                    <label class="hero-task-label"><i class="ph ph-tag"></i> Tags (Optional)</label>
                    <div class="tags-input-container" id="heroTagsContainer" onclick="document.getElementById('heroTagsInput').focus()">
                        <input type="text"
                               id="heroTagsInput"
                               placeholder="Type and press Enter to add tags..."
                               onkeydown="handleTagInput(event)">
                    </div>
                </div>

                <!-- Role Assignment (Required for EO integration) -->
                <div class="hero-task-input-group" style="margin-top: 1rem;">
                    <label class="hero-task-label">
                        <i class="ph ph-briefcase"></i> Assign to Role<span class="required-indicator">*</span>
                    </label>
                    <div class="hero-task-select-wrapper">
                        <select id="heroTaskRoleMain" class="hero-task-select" onchange="updateHeroTaskPreview(); updateRoleContext()">
                            <option value="">Select a role...</option>
                        </select>
                    </div>
                    <div class="hero-task-or-create">
                        or <a onclick="toggleHeroRoleCreateMain()">create new role</a>
                    </div>
                    <div class="hero-task-inline-create" id="heroRoleCreateMain">
                        <div class="hero-task-inline-row">
                            <input type="text"
                                   id="heroNewRoleNameMain"
                                   class="hero-task-inline-input"
                                   placeholder="Role name..."
                                   onkeypress="if(event.key==='Enter') createHeroRoleMain()">
                            <button class="hero-task-inline-btn" onclick="createHeroRoleMain()">
                                <i class="ph ph-plus"></i>
                            </button>
                        </div>
                    </div>
                    <div class="role-required-notice" id="roleRequiredNotice" style="display: none;">
                        <i class="ph ph-info"></i>
                        <span>In EO, tasks must be assigned to roles. This ensures work is tied to organizational structure.</span>
                    </div>
                    <!-- Role Context Display -->
                    <div class="role-context-display" id="roleContextDisplay" style="display: none; margin-top: 0.75rem;">
                        <div class="role-context-breadcrumb" id="roleContextBreadcrumb">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                </div>

                <button type="button" class="hero-task-advanced-toggle" id="heroAdvancedToggle" onclick="toggleAdvancedOptions()">
                    <i class="ph ph-caret-down" id="heroAdvancedToggleIcon"></i>
                    <span id="heroAdvancedToggleText">More options...</span>
                </button>

                <div class="hero-task-advanced-options" id="heroAdvancedOptions" style="display: none;">
                    <!-- Collaborators/Followers -->
                    <div class="hero-task-input-group">
                        <label class="hero-task-label"><i class="ph ph-users"></i> Collaborators (Optional)</label>
                        <div class="task-collaborators" id="heroCollaboratorsContainer">
                            <div class="collaborator-avatars" id="heroCollaboratorAvatars">
                                <!-- Populated dynamically -->
                            </div>
                            <div class="collaborator-add" onclick="openCollaboratorPicker()" title="Add collaborator">
                                <i class="ph ph-plus" style="font-size: 0.8rem;"></i>
                            </div>
                        </div>
                        <div class="hero-task-or-create" style="margin-top: 0.5rem;">
                            <small style="color: #8B6F47;">Collaborators will be notified of task updates</small>
                        </div>
                    </div>

                    <!-- Workflow -->
                    <div class="hero-task-input-group">
                        <label class="hero-task-label"><i class="ph ph-flow-arrow"></i> Part of Workflow (Optional)</label>
                        <div class="hero-task-select-wrapper">
                            <select id="heroTaskWorkflow" class="hero-task-select" onchange="updateHeroTaskPreview()">
                                <option value="">Select a workflow...</option>
                            </select>
                        </div>
                        <div class="hero-task-or-create">
                            or <a onclick="toggleHeroWorkflowCreate()">create new workflow</a>
                        </div>
                        <div class="hero-task-inline-create" id="heroWorkflowCreate">
                            <div class="hero-task-inline-row">
                                <input type="text"
                                       id="heroNewWorkflowName"
                                       class="hero-task-inline-input"
                                       placeholder="Workflow name..."
                                       onkeypress="if(event.key==='Enter') createHeroWorkflow()">
                                <button class="hero-task-inline-btn" onclick="createHeroWorkflow()">
                                    <i class="ph ph-plus"></i>
                                </button>
                            </div>
                        </div>
                        <div class="hero-task-workflow-prompt" id="heroWorkflowPrompt" style="display: none;">
                            <i class="ph ph-info"></i>
                            <span>No workflows yet. Create one to organize related tasks.</span>
                        </div>
                    </div>

                    <!-- Person Assignment (within selected role) -->
                    <div class="hero-task-input-group">
                        <label class="hero-task-label"><i class="ph ph-user"></i> Assign to Person (Optional)</label>
                        <div class="hero-task-select-wrapper">
                            <select id="heroTaskPerson" class="hero-task-select" onchange="updateHeroTaskPreview()">
                                <option value="">Select a person...</option>
                            </select>
                        </div>
                        <div class="hero-task-or-create">
                            or <a onclick="toggleHeroPersonCreate()">add new person</a>
                        </div>
                        <div class="hero-task-inline-create" id="heroPersonCreate">
                            <div class="hero-task-inline-row">
                                <input type="text"
                                       id="heroNewPersonName"
                                       class="hero-task-inline-input"
                                       placeholder="Person's name..."
                                       onkeypress="if(event.key==='Enter') createHeroPerson()">
                                <button class="hero-task-inline-btn" onclick="createHeroPerson()">
                                    <i class="ph ph-plus"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Dependencies -->
                    <div class="hero-task-input-group">
                        <label class="hero-task-label"><i class="ph ph-link-simple"></i> Depends On (Optional)</label>
                        <div class="hero-task-select-wrapper">
                            <select id="heroTaskPredecessor" class="hero-task-select" onchange="updateHeroTaskPreview(); checkPredecessorDateConflict()">
                                <option value="">No dependency...</option>
                            </select>
                        </div>
                        <div class="hero-task-dependency-warning" id="heroDependencyWarning" style="display: none;">
                            <i class="ph ph-warning"></i>
                            <span id="heroDependencyWarningText"></span>
                        </div>
                    </div>

                    <!-- Recurring Task -->
                    <div class="hero-task-input-group">
                        <label class="hero-task-label"><i class="ph ph-repeat"></i> Recurring (Optional)</label>
                        <div class="hero-task-select-wrapper">
                            <select id="heroTaskRecurring" class="hero-task-select">
                                <option value="">Does not repeat</option>
                                <option value="daily">Daily</option>
                                <option value="weekly">Weekly</option>
                                <option value="biweekly">Every 2 weeks</option>
                                <option value="monthly">Monthly</option>
                                <option value="quarterly">Quarterly</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="hero-task-preview" id="heroTaskPreview" style="display: none;">
                    <div class="hero-task-preview-title">Preview</div>
                    <div class="hero-task-preview-content" id="heroTaskPreviewContent">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
            <div class="hero-task-footer">
                <div class="hero-task-shortcut-hint">
                    <kbd>T</kbd> to open &middot; <kbd>Esc</kbd> to close &middot; <kbd>Enter</kbd> to create
                </div>
                <div class="hero-task-actions">
                    <button class="hero-task-btn hero-task-btn-secondary" onclick="closeHeroTaskModal()">
                        Cancel
                    </button>
                    <button class="hero-task-btn hero-task-btn-primary" id="heroTaskSubmitBtn" onclick="submitHeroTask()" disabled>
                        <i class="ph ph-check"></i> Create Task
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Quick Add Modal (Lightweight task creation from quick-add bar) -->
    <div class="quick-add-modal-overlay" id="quickAddModalOverlay" onclick="closeQuickAddModalOnBackdrop(event)">
        <div class="quick-add-modal" onclick="event.stopPropagation()">
            <div class="quick-add-modal-header">
                <input type="text"
                       id="quickAddModalTitle"
                       class="quick-add-modal-title-input"
                       placeholder="Task name..."
                       onkeypress="if(event.key==='Enter') saveQuickAddModal()">
                <div class="quick-add-modal-prompt">
                    <i class="ph ph-sparkle"></i>
                    <span>Add more details or press <strong>Escape</strong> to save quickly</span>
                </div>
            </div>

            <div class="quick-add-modal-meta">
                <div class="quick-add-meta-chip" id="quickAddDateChip" onclick="toggleQuickAddDatePicker()">
                    <i class="ph ph-calendar"></i>
                    <span id="quickAddDateLabel">Add due date</span>
                </div>
                <div class="quick-add-meta-chip" id="quickAddPriorityChip" onclick="cycleQuickAddPriority()">
                    <i class="ph ph-flag"></i>
                    <span id="quickAddPriorityLabel">Set priority</span>
                </div>
                <div class="quick-add-meta-chip" id="quickAddRoleChip" onclick="toggleQuickAddRolePicker()">
                    <i class="ph ph-briefcase"></i>
                    <span id="quickAddRoleLabel">Assign role</span>
                </div>
            </div>

            <!-- Date Picker Dropdown -->
            <div class="quick-add-dropdown" id="quickAddDateDropdown">
                <div class="quick-add-dropdown-item" onclick="setQuickAddDate('today')">
                    <i class="ph ph-calendar-check"></i> Today
                </div>
                <div class="quick-add-dropdown-item" onclick="setQuickAddDate('tomorrow')">
                    <i class="ph ph-sun"></i> Tomorrow
                </div>
                <div class="quick-add-dropdown-item" onclick="setQuickAddDate('nextWeek')">
                    <i class="ph ph-calendar-plus"></i> Next week
                </div>
                <div class="quick-add-dropdown-item" onclick="setQuickAddDate('custom')">
                    <i class="ph ph-calendar-blank"></i> Pick a date...
                </div>
                <input type="date" id="quickAddDateInput" style="display: none;" onchange="setQuickAddCustomDate(this.value)">
            </div>

            <!-- Role Picker Dropdown -->
            <div class="quick-add-dropdown" id="quickAddRoleDropdown">
                <div id="quickAddRoleOptions">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <div class="quick-add-modal-description">
                <label class="quick-add-description-label">
                    <i class="ph ph-text-aa"></i> Description (Optional)
                </label>
                <textarea id="quickAddModalDescription"
                          class="quick-add-description-textarea"
                          placeholder="Add any details, context, or notes about this task..."></textarea>
            </div>

            <div class="quick-add-modal-footer">
                <span class="quick-add-footer-hint">
                    Press <strong>Esc</strong> to save and close
                </span>
                <div class="quick-add-footer-actions">
                    <button class="quick-add-btn quick-add-btn-ghost" onclick="closeQuickAddModal()">
                        Cancel
                    </button>
                    <button class="quick-add-btn quick-add-btn-primary" onclick="saveQuickAddModal()">
                        <i class="ph ph-check"></i> Save & Close
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- How It Works Modal -->
    <div class="how-it-works-overlay" id="howItWorksOverlay" onclick="if(event.target === this) closeHowItWorks()">
        <div class="how-it-works-modal">
            <button class="how-it-works-close" onclick="closeHowItWorks()">
                <i class="ph ph-x"></i>
            </button>
            <h2><i class="ph ph-lightbulb"></i> How Taskflow Works</h2>
            <p class="how-it-works-tagline">Start with tasks. Structure emerges.</p>

            <div class="how-it-works-steps">
                <div class="how-it-works-step">
                    <div class="step-icon"><i class="ph ph-check-square"></i></div>
                    <div class="step-content">
                        <h3>1. Create Tasks</h3>
                        <p>Start with what needs to get done. Tasks are work items, deliverables, or goals.</p>
                    </div>
                </div>
                <div class="how-it-works-step">
                    <div class="step-icon"><i class="ph ph-briefcase"></i></div>
                    <div class="step-content">
                        <h3>2. Assign to Roles</h3>
                        <p>Every task belongs to a role. Roles represent functions - not specific people.</p>
                    </div>
                </div>
                <div class="how-it-works-step">
                    <div class="step-icon"><i class="ph ph-user"></i></div>
                    <div class="step-content">
                        <h3>3. Tag People (Optional)</h3>
                        <p>Attach real people to roles. One person can fill many roles; one role can have many people.</p>
                    </div>
                </div>
                <div class="how-it-works-step">
                    <div class="step-icon"><i class="ph ph-tree-structure"></i></div>
                    <div class="step-content">
                        <h3>4. Structure Emerges</h3>
                        <p>As you add tasks and roles, your organization's shape reveals itself. Use Cards, Tree, or Org Chart views to explore.</p>
                    </div>
                </div>
            </div>

            <div class="how-it-works-insight">
                <strong>The insight:</strong> Traditional org charts start with structure. Taskflow starts with work, and structure follows naturally.
            </div>

            <button class="btn" onclick="closeHowItWorks(); openHeroTaskModal();">
                <i class="ph ph-rocket"></i> Get Started
            </button>
        </div>
    </div>

    <!-- Workflow Suggestion Modal -->
    <div class="workflow-suggestion-overlay" id="workflowSuggestionOverlay" onclick="if(event.target === this) dismissWorkflowSuggestion()">
        <div class="workflow-suggestion-modal" onclick="event.stopPropagation()">
            <div class="workflow-suggestion-header">
                <h3><i class="ph ph-sparkle"></i> Pattern Detected</h3>
                <button class="workflow-suggestion-close" onclick="dismissWorkflowSuggestion()">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="workflow-suggestion-body">
                <p class="workflow-suggestion-message" id="workflowSuggestionMessage">
                    These tasks look like a repeating pattern. Would you like to make this a workflow?
                </p>
                <div class="workflow-suggestion-tasks" id="workflowSuggestionTasks">
                    <!-- Populated dynamically -->
                </div>
                <input type="text"
                       class="workflow-suggestion-input"
                       id="workflowSuggestionName"
                       placeholder="Name this workflow...">
                <div class="workflow-suggestion-footer">
                    <button class="workflow-suggestion-btn workflow-suggestion-btn-secondary" onclick="dismissWorkflowSuggestion()">
                        Not Now
                    </button>
                    <button class="workflow-suggestion-btn workflow-suggestion-btn-primary" onclick="acceptWorkflowSuggestion()">
                        <i class="ph ph-git-branch"></i> Create Workflow
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Link Modal -->
    <div class="task-link-overlay" id="taskLinkOverlay" onclick="if(event.target === this) closeTaskLinkModal()">
        <div class="task-link-modal" onclick="event.stopPropagation()">
            <div class="task-link-header">
                <h3><i class="ph ph-link"></i> Link Tasks</h3>
                <button class="task-link-close" onclick="closeTaskLinkModal()">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="task-link-body">
                <div class="task-link-select-group">
                    <label class="task-link-label">Link to Task</label>
                    <select class="task-link-select" id="taskLinkTargetSelect">
                        <option value="">Select a task...</option>
                    </select>
                </div>

                <div class="task-link-option-group">
                    <label class="task-link-label">Should dates be linked?</label>
                    <div class="task-link-option" onclick="selectLinkType('soft')">
                        <input type="radio" name="linkType" value="soft" id="linkTypeSoft" checked>
                        <div class="task-link-option-content">
                            <div class="task-link-option-title">Soft Link (Sequence Only)</div>
                            <div class="task-link-option-desc">Tasks are related but dates are independent. "B happens after A" without date coupling.</div>
                        </div>
                    </div>
                    <div class="task-link-option" onclick="selectLinkType('hard')">
                        <input type="radio" name="linkType" value="hard" id="linkTypeHard">
                        <div class="task-link-option-content">
                            <div class="task-link-option-title">Hard Link (Dates Coupled)</div>
                            <div class="task-link-option-desc">If one task's date changes, linked tasks adjust automatically.</div>
                        </div>
                    </div>
                </div>

                <div class="task-link-footer">
                    <button class="task-link-btn task-link-btn-secondary" onclick="closeTaskLinkModal()">
                        Cancel
                    </button>
                    <button class="task-link-btn task-link-btn-primary" onclick="submitTaskLink()">
                        <i class="ph ph-link"></i> Create Link
                    </button>
                </div>
            </div>
        </div>
    </div>
